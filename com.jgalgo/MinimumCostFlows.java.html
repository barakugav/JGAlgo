<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MinimumCostFlows.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo</a> &gt; <span class="el_source">MinimumCostFlows.java</span></div><h1>MinimumCostFlows.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo;

import java.util.BitSet;
import com.jgalgo.graph.Graph;
import com.jgalgo.graph.IndexGraph;
import com.jgalgo.graph.IndexGraphBuilder;
import com.jgalgo.graph.IndexIdMap;
import com.jgalgo.graph.IndexIdMaps;
import com.jgalgo.graph.WeightFunction;
import com.jgalgo.graph.Weights;
import com.jgalgo.internal.util.Assertions;
import it.unimi.dsi.fastutil.doubles.DoubleArrayList;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntList;

<span class="nc" id="L31">class MinimumCostFlows {</span>

	private static abstract class AbstractImplBase implements MinimumCostFlow {

		@Override
		public void computeMinCostMaxFlow(Graph g, FlowNetwork net, WeightFunction cost, int source, int sink) {
<span class="pc bpc" id="L37" title="1 of 2 branches missed.">			if (g instanceof IndexGraph) {</span>
<span class="nc" id="L38">				computeMinCostMaxFlow((IndexGraph) g, net, cost, source, sink);</span>
<span class="nc" id="L39">				return;</span>
			}

<span class="fc" id="L42">			IndexGraph iGraph = g.indexGraph();</span>
<span class="fc" id="L43">			IndexIdMap viMap = g.indexGraphVerticesMap();</span>
<span class="fc" id="L44">			IndexIdMap eiMap = g.indexGraphEdgesMap();</span>
<span class="fc" id="L45">			FlowNetwork iNet = FlowNetworks.indexNetFromNet(net, eiMap);</span>
<span class="fc" id="L46">			WeightFunction iCost = IndexIdMaps.idToIndexWeightFunc(cost, eiMap);</span>
<span class="fc" id="L47">			int iSource = viMap.idToIndex(source);</span>
<span class="fc" id="L48">			int iSink = viMap.idToIndex(sink);</span>

<span class="fc" id="L50">			computeMinCostMaxFlow(iGraph, iNet, iCost, iSource, iSink);</span>
<span class="fc" id="L51">		}</span>

		@Override
		public void computeMinCostMaxFlow(Graph g, FlowNetwork net, WeightFunction cost, WeightFunction lowerBound,
				int source, int sink) {
<span class="nc bnc" id="L56" title="All 2 branches missed.">			if (g instanceof IndexGraph) {</span>
<span class="nc" id="L57">				computeMinCostMaxFlow((IndexGraph) g, net, cost, lowerBound, source, sink);</span>
<span class="nc" id="L58">				return;</span>
			}

<span class="nc" id="L61">			IndexGraph iGraph = g.indexGraph();</span>
<span class="nc" id="L62">			IndexIdMap viMap = g.indexGraphVerticesMap();</span>
<span class="nc" id="L63">			IndexIdMap eiMap = g.indexGraphEdgesMap();</span>
<span class="nc" id="L64">			FlowNetwork iNet = FlowNetworks.indexNetFromNet(net, eiMap);</span>
<span class="nc" id="L65">			WeightFunction iCost = IndexIdMaps.idToIndexWeightFunc(cost, eiMap);</span>
<span class="nc" id="L66">			WeightFunction iLowerBound = IndexIdMaps.idToIndexWeightFunc(lowerBound, eiMap);</span>
<span class="nc" id="L67">			int iSource = viMap.idToIndex(source);</span>
<span class="nc" id="L68">			int iSink = viMap.idToIndex(sink);</span>

<span class="nc" id="L70">			computeMinCostMaxFlow(iGraph, iNet, iCost, iLowerBound, iSource, iSink);</span>
<span class="nc" id="L71">		}</span>

		@Override
		public void computeMinCostMaxFlow(Graph g, FlowNetwork net, WeightFunction cost, IntCollection sources,
				IntCollection sinks) {
<span class="nc bnc" id="L76" title="All 2 branches missed.">			if (g instanceof IndexGraph) {</span>
<span class="nc" id="L77">				computeMinCostMaxFlow((IndexGraph) g, net, cost, sources, sinks);</span>
<span class="nc" id="L78">				return;</span>
			}

<span class="nc" id="L81">			IndexGraph iGraph = g.indexGraph();</span>
<span class="nc" id="L82">			IndexIdMap viMap = g.indexGraphVerticesMap();</span>
<span class="nc" id="L83">			IndexIdMap eiMap = g.indexGraphEdgesMap();</span>
<span class="nc" id="L84">			FlowNetwork iNet = FlowNetworks.indexNetFromNet(net, eiMap);</span>
<span class="nc" id="L85">			WeightFunction iCost = IndexIdMaps.idToIndexWeightFunc(cost, eiMap);</span>
<span class="nc" id="L86">			IntCollection iSources = IndexIdMaps.idToIndexCollection(sources, viMap);</span>
<span class="nc" id="L87">			IntCollection iSinks = IndexIdMaps.idToIndexCollection(sinks, viMap);</span>

<span class="nc" id="L89">			computeMinCostMaxFlow(iGraph, iNet, iCost, iSources, iSinks);</span>
<span class="nc" id="L90">		}</span>

		@Override
		public void computeMinCostMaxFlow(Graph g, FlowNetwork net, WeightFunction cost, WeightFunction lowerBound,
				IntCollection sources, IntCollection sinks) {
<span class="nc bnc" id="L95" title="All 2 branches missed.">			if (g instanceof IndexGraph) {</span>
<span class="nc" id="L96">				computeMinCostMaxFlow((IndexGraph) g, net, cost, lowerBound, sources, sinks);</span>
<span class="nc" id="L97">				return;</span>
			}

<span class="nc" id="L100">			IndexGraph iGraph = g.indexGraph();</span>
<span class="nc" id="L101">			IndexIdMap viMap = g.indexGraphVerticesMap();</span>
<span class="nc" id="L102">			IndexIdMap eiMap = g.indexGraphEdgesMap();</span>
<span class="nc" id="L103">			FlowNetwork iNet = FlowNetworks.indexNetFromNet(net, eiMap);</span>
<span class="nc" id="L104">			WeightFunction iCost = IndexIdMaps.idToIndexWeightFunc(cost, eiMap);</span>
<span class="nc" id="L105">			WeightFunction iLowerBound = IndexIdMaps.idToIndexWeightFunc(lowerBound, eiMap);</span>
<span class="nc" id="L106">			IntCollection iSources = IndexIdMaps.idToIndexCollection(sources, viMap);</span>
<span class="nc" id="L107">			IntCollection iSinks = IndexIdMaps.idToIndexCollection(sinks, viMap);</span>

<span class="nc" id="L109">			computeMinCostMaxFlow(iGraph, iNet, iCost, iLowerBound, iSources, iSinks);</span>
<span class="nc" id="L110">		}</span>

		@Override
		public void computeMinCostFlow(Graph g, FlowNetwork net, WeightFunction cost, WeightFunction demand) {
<span class="nc bnc" id="L114" title="All 2 branches missed.">			if (g instanceof IndexGraph) {</span>
<span class="nc" id="L115">				computeMinCostFlow((IndexGraph) g, net, cost, demand);</span>
<span class="nc" id="L116">				return;</span>
			}

<span class="nc" id="L119">			IndexGraph iGraph = g.indexGraph();</span>
<span class="nc" id="L120">			IndexIdMap viMap = g.indexGraphVerticesMap();</span>
<span class="nc" id="L121">			IndexIdMap eiMap = g.indexGraphEdgesMap();</span>
<span class="nc" id="L122">			FlowNetwork iNet = FlowNetworks.indexNetFromNet(net, eiMap);</span>
<span class="nc" id="L123">			WeightFunction iCost = IndexIdMaps.idToIndexWeightFunc(cost, eiMap);</span>
<span class="nc" id="L124">			WeightFunction iDemand = IndexIdMaps.idToIndexWeightFunc(demand, viMap);</span>

<span class="nc" id="L126">			computeMinCostFlow(iGraph, iNet, iCost, iDemand);</span>
<span class="nc" id="L127">		}</span>

		@Override
		public void computeMinCostFlow(Graph g, FlowNetwork net, WeightFunction cost, WeightFunction lowerBound,
				WeightFunction demand) {
<span class="nc bnc" id="L132" title="All 2 branches missed.">			if (g instanceof IndexGraph) {</span>
<span class="nc" id="L133">				computeMinCostFlow((IndexGraph) g, net, cost, lowerBound, demand);</span>
<span class="nc" id="L134">				return;</span>
			}

<span class="nc" id="L137">			IndexGraph iGraph = g.indexGraph();</span>
<span class="nc" id="L138">			IndexIdMap viMap = g.indexGraphVerticesMap();</span>
<span class="nc" id="L139">			IndexIdMap eiMap = g.indexGraphEdgesMap();</span>
<span class="nc" id="L140">			FlowNetwork iNet = FlowNetworks.indexNetFromNet(net, eiMap);</span>
<span class="nc" id="L141">			WeightFunction iCost = IndexIdMaps.idToIndexWeightFunc(cost, eiMap);</span>
<span class="nc" id="L142">			WeightFunction iLowerBound = IndexIdMaps.idToIndexWeightFunc(lowerBound, eiMap);</span>
<span class="nc" id="L143">			WeightFunction iDemand = IndexIdMaps.idToIndexWeightFunc(demand, viMap);</span>

<span class="nc" id="L145">			computeMinCostFlow(iGraph, iNet, iCost, iLowerBound, iDemand);</span>
<span class="nc" id="L146">		}</span>

		abstract void computeMinCostMaxFlow(IndexGraph g, FlowNetwork net, WeightFunction cost, int source, int sink);

		abstract void computeMinCostMaxFlow(IndexGraph g, FlowNetwork net, WeightFunction cost,
				WeightFunction lowerBound, int source, int sink);

		abstract void computeMinCostMaxFlow(IndexGraph g, FlowNetwork net, WeightFunction cost, IntCollection sources,
				IntCollection sinks);

		abstract void computeMinCostMaxFlow(IndexGraph g, FlowNetwork net, WeightFunction cost,
				WeightFunction lowerBound, IntCollection sources, IntCollection sinks);

		abstract void computeMinCostFlow(IndexGraph g, FlowNetwork net, WeightFunction cost, WeightFunction demand);

		abstract void computeMinCostFlow(IndexGraph g, FlowNetwork net, WeightFunction cost, WeightFunction lowerBound,
				WeightFunction demand);

	}

<span class="fc" id="L166">	static abstract class AbstractImpl extends AbstractImplBase {</span>

		@Override
		void computeMinCostMaxFlow(IndexGraph g, FlowNetwork net, WeightFunction cost, WeightFunction lowerBound,
				int source, int sink) {
<span class="nc" id="L171">			computeMinCostMaxFlow(g, net, cost, lowerBound, IntList.of(source), IntList.of(sink));</span>
<span class="nc" id="L172">		}</span>

		@Override
		void computeMinCostMaxFlow(IndexGraph gOrig, FlowNetwork netOrig, WeightFunction costOrig,
				WeightFunction lowerBound, IntCollection sources, IntCollection sinks) {
<span class="nc" id="L177">			Assertions.Graphs.onlyDirected(gOrig);</span>
<span class="nc" id="L178">			checkLowerBound(gOrig, netOrig, lowerBound);</span>

			/*
			 * To solve the problem of minimum-cost maximum-flow between a set of sources and sinks, with a flow lower
			 * bound for each edge, we perform a reduction to min-cost max-flow between a single source and a sink sink
			 * without lower bounds. To get rid of the lower bound, remove from each edge capacity its lower bound, and
			 * add/remove demand from the edge endpoints. This reduction is slightly more complicated than the others,
			 * as some vertices (the sources/sinks) require 'infinite' demand, while others (other vertices with demand)
			 * require finite demand. We create a new graph with all the vertices and edges of the original graph, with
			 * addition of a new source and sink, and connect the source to the sources with high capacity edges, the
			 * source to vertices with a positive demand with capacity equal to the demand, the sinks to the sink with
			 * high capacity edges and lastly the vertices with negative demand to the sink with capacity equal to the
			 * demand.
			 */

			/* For each edge with lower bound add/remove demand to the edge endpoints */
<span class="nc" id="L194">			WeightFunction demand = computeDemand(gOrig, netOrig, lowerBound, null);</span>

			/* Add all original vertices and edges */
<span class="nc" id="L197">			IndexGraphBuilder builder = IndexGraphBuilder.newDirected();</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">			for (int n = gOrig.vertices().size(), v = 0; v &lt; n; v++)</span>
<span class="nc" id="L199">				builder.addVertex();</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">			for (int m = gOrig.edges().size(), e = 0; e &lt; m; e++)</span>
<span class="nc" id="L201">				builder.addEdge(gOrig.edgeSource(e), gOrig.edgeTarget(e));</span>
			/* any edge with index smaller than this threshold is an original edge of the graph */
<span class="nc" id="L203">			final int origEdgesThreshold = builder.edges().size();</span>

			/* determine a great enough capacity ('infinite') for edges to sources (from sinks) */
<span class="nc" id="L206">			double maxCap = 0;</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">			for (int m = gOrig.edges().size(), e = 0; e &lt; m; e++)</span>
<span class="nc" id="L208">				maxCap = Math.max(maxCap, netOrig.getCapacity(e) - lowerBound.weight(e));</span>
<span class="nc" id="L209">			final double sourceSinkEdgeCapacity = maxCap * gOrig.vertices().size();</span>

			/* Add two artificial terminal vertices, a source and a sink */
<span class="nc" id="L212">			final int source = builder.addVertex();</span>
<span class="nc" id="L213">			final int sink = builder.addVertex();</span>

<span class="nc" id="L215">			DoubleArrayList capacities = new DoubleArrayList();</span>
<span class="nc" id="L216">			BitSet origSourcesSinksSet = new BitSet(gOrig.vertices().size());</span>
			/* Connect the source to the sources with high capacity edges */
<span class="nc bnc" id="L218" title="All 2 branches missed.">			for (int s : sources) {</span>
<span class="nc" id="L219">				builder.addEdge(source, s);</span>
<span class="nc" id="L220">				capacities.add(sourceSinkEdgeCapacity);</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">				assert !origSourcesSinksSet.get(s);</span>
<span class="nc" id="L222">				origSourcesSinksSet.set(s);</span>
<span class="nc" id="L223">			}</span>
			/* Connect the sinks to the sink with high capacity edges */
<span class="nc bnc" id="L225" title="All 2 branches missed.">			for (int t : sinks) {</span>
<span class="nc" id="L226">				builder.addEdge(t, sink);</span>
<span class="nc" id="L227">				capacities.add(sourceSinkEdgeCapacity);</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">				assert !origSourcesSinksSet.get(t);</span>
<span class="nc" id="L229">				origSourcesSinksSet.set(t);</span>
<span class="nc" id="L230">			}</span>
			/*
			 * Any edge with index smaller than this threshold and equal or greater than origEdgesThreshold is an edge
			 * connect source-sources or sinks-sink. Any edge with index greater or equal to this threshold is an edge
			 * connecting a source to a vertex with positive demand or a vertex with negative demand to a sink.
			 */
<span class="nc" id="L236">			final int sourcesSinksThreshold = builder.edges().size();</span>

			/*
			 * Connect the source to all vertices with positive demand and the vertices with negative demand to the sink
			 */
<span class="nc bnc" id="L241" title="All 2 branches missed.">			for (int n = gOrig.vertices().size(), v = 0; v &lt; n; v++) {</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">				if (origSourcesSinksSet.get(v))</span>
<span class="nc" id="L243">					continue;</span>
<span class="nc" id="L244">				double d = demand.weight(v);</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">				if (d &gt; 0) {</span>
<span class="nc" id="L246">					builder.addEdge(source, v);</span>
<span class="nc" id="L247">					capacities.add(d);</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">				} else if (d &lt; 0) {</span>
<span class="nc" id="L249">					builder.addEdge(v, sink);</span>
<span class="nc" id="L250">					capacities.add(-d);</span>
				}
			}

<span class="nc" id="L254">			IndexGraph g = builder.build();</span>

			/*
			 * Create a network for the new graph by storing capacities and flows of the artificial edges and by
			 * reducing the capacities of edges by their lower bound
			 */
<span class="nc" id="L260">			FlowNetwork net = new FlowNetwork() {</span>
<span class="nc" id="L261">				double[] caps = capacities.elements();</span>
<span class="nc" id="L262">				double[] flows = new double[capacities.size()];</span>

				@Override
				public double getCapacity(int edge) {
<span class="nc bnc" id="L266" title="All 2 branches missed.">					if (edge &lt; origEdgesThreshold)</span>
<span class="nc" id="L267">						return netOrig.getCapacity(edge) - lowerBound.weight(edge);</span>
<span class="nc" id="L268">					return caps[edge - origEdgesThreshold];</span>
				}

				@Override
				public void setCapacity(int edge, double capacity) {
<span class="nc" id="L273">					throw new UnsupportedOperationException();</span>
				}

				@Override
				public double getFlow(int edge) {
<span class="nc bnc" id="L278" title="All 2 branches missed.">					if (edge &lt; origEdgesThreshold)</span>
<span class="nc" id="L279">						return netOrig.getFlow(edge) - lowerBound.weight(edge);</span>
<span class="nc" id="L280">					return flows[edge - origEdgesThreshold];</span>
				}

				@Override
				public void setFlow(int edge, double flow) {
<span class="nc bnc" id="L285" title="All 2 branches missed.">					if (edge &lt; origEdgesThreshold) {</span>
<span class="nc" id="L286">						netOrig.setFlow(edge, flow + lowerBound.weight(edge));</span>
					} else {
<span class="nc" id="L288">						flows[edge - origEdgesThreshold] = flow;</span>
					}
<span class="nc" id="L290">				}</span>
			};

			/*
			 * Create a cost function for the new graph: original edges have their original costs, big negative cost for
			 * edges that connect vertices with demand as we must satisfy them, and zero cost for edges connecting
			 * source-sources or sinks-sink
			 */
<span class="nc" id="L298">			double maxCost = 0;</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">			for (int m = gOrig.edges().size(), e = 0; e &lt; m; e++)</span>
<span class="nc" id="L300">				maxCost = Math.max(maxCost, Math.abs(costOrig.weight(e)));</span>
<span class="nc" id="L301">			final double demandEdgeCost = -maxCost * gOrig.vertices().size();</span>
<span class="nc" id="L302">			WeightFunction cost = e -&gt; {</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">				if (e &lt; origEdgesThreshold)</span>
<span class="nc" id="L304">					return costOrig.weight(e); /* original edge */</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">				if (e &lt; sourcesSinksThreshold)</span>
<span class="nc" id="L306">					return 0; /* edge to source/sink */</span>
<span class="nc" id="L307">				return demandEdgeCost; /* edge to a non source/sink vertex with demand */</span>
			};

			/* Compute a min-cost max-flow in the new graph and network */
<span class="nc" id="L311">			computeMinCostMaxFlow(g, net, cost, source, sink);</span>
<span class="nc" id="L312">		}</span>

		@Override
		void computeMinCostFlow(IndexGraph gOrig, FlowNetwork netOrig, WeightFunction costOrig, WeightFunction demand) {
<span class="nc" id="L316">			Assertions.Graphs.onlyDirected(gOrig);</span>
<span class="nc" id="L317">			checkDemand(gOrig, demand);</span>

			/*
			 * To solve the minimum cost flow of given demand we use a reduction to minimum-cost maximum-flow between
			 * two terminal vertices, source and sink. We add an edge from the source to each vertex with positive
			 * demand with capacity equal to the demand, and an edge from each vertex with negative demand to the sink
			 * with capacity equal to the demand.
			 */

			/* Add all original vertices and edges */
<span class="nc" id="L327">			IndexGraphBuilder builder = IndexGraphBuilder.newDirected();</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">			for (int n = gOrig.vertices().size(), v = 0; v &lt; n; v++)</span>
<span class="nc" id="L329">				builder.addVertex();</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">			for (int m = gOrig.edges().size(), e = 0; e &lt; m; e++)</span>
<span class="nc" id="L331">				builder.addEdge(gOrig.edgeSource(e), gOrig.edgeTarget(e));</span>
			/* any edge with index greater than this threshold is not an original edge of the graph */
<span class="nc" id="L333">			final int origEdgesThreshold = builder.edges().size();</span>

			/* Add two artificial vertices, source and sink */
<span class="nc" id="L336">			final int source = builder.addVertex();</span>
<span class="nc" id="L337">			final int sink = builder.addVertex();</span>

			/* Connect the source to vertices with positive demand and vertices with negative demand to the sink */
<span class="nc" id="L340">			DoubleArrayList capacities = new DoubleArrayList();</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">			for (int n = gOrig.vertices().size(), v = 0; v &lt; n; v++) {</span>
<span class="nc" id="L342">				double d = demand.weight(v);</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">				if (d &gt; 0) {</span>
<span class="nc" id="L344">					builder.addEdge(source, v);</span>
<span class="nc" id="L345">					capacities.add(d);</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">				} else if (d &lt; 0) {</span>
<span class="nc" id="L347">					builder.addEdge(v, sink);</span>
<span class="nc" id="L348">					capacities.add(-d);</span>
				}
			}

<span class="nc" id="L352">			IndexGraph g = builder.build();</span>

			/*
			 * Create a network for the new graph by using two new arrays for the artificial edges capacities and flows
			 */
<span class="nc" id="L357">			FlowNetwork net = new FlowNetwork() {</span>
<span class="nc" id="L358">				double[] caps = capacities.elements();</span>
<span class="nc" id="L359">				double[] flows = new double[capacities.size()];</span>

				@Override
				public double getCapacity(int edge) {
<span class="nc bnc" id="L363" title="All 2 branches missed.">					return edge &lt; origEdgesThreshold ? netOrig.getCapacity(edge) : caps[edge - origEdgesThreshold];</span>
				}

				@Override
				public void setCapacity(int edge, double capacity) {
<span class="nc" id="L368">					throw new UnsupportedOperationException();</span>
				}

				@Override
				public double getFlow(int edge) {
<span class="nc bnc" id="L373" title="All 2 branches missed.">					return edge &lt; origEdgesThreshold ? netOrig.getFlow(edge) : flows[edge - origEdgesThreshold];</span>
				}

				@Override
				public void setFlow(int edge, double flow) {
<span class="nc bnc" id="L378" title="All 2 branches missed.">					if (edge &lt; origEdgesThreshold) {</span>
<span class="nc" id="L379">						netOrig.setFlow(edge, flow);</span>
					} else {
<span class="nc" id="L381">						flows[edge - origEdgesThreshold] = flow;</span>
					}
<span class="nc" id="L383">				}</span>
			};
			/*
			 * All the artificial edges should not have a cost, if its possible to satisfy the demand they will be
			 * saturated anyway
			 */
<span class="nc bnc" id="L389" title="All 2 branches missed.">			WeightFunction cost = e -&gt; e &lt; origEdgesThreshold ? costOrig.weight(e) : 0;</span>

			/* Compute a minimum-cost maximum-flow between the two artificial vertices */
<span class="nc" id="L392">			computeMinCostMaxFlow(g, net, cost, source, sink);</span>
<span class="nc" id="L393">		}</span>

		@Override
		void computeMinCostFlow(IndexGraph g, FlowNetwork netOrig, WeightFunction cost, WeightFunction lowerBound,
				WeightFunction demand) {
<span class="nc" id="L398">			Assertions.Graphs.onlyDirected(g);</span>
<span class="nc" id="L399">			checkLowerBound(g, netOrig, lowerBound);</span>
<span class="nc" id="L400">			checkDemand(g, demand);</span>

			/*
			 * To solve the minimum cost flow for a given demand and edges lower bounds, we perform a reduction to the
			 * problem with given demand without any edges flow lower bounds. For each edge with lower bound we subtract
			 * the lower bound from the capacity of the edge, and add/remove demand to the edge endpoints.
			 */

			/* Create a network by subtracting the lower bound from each edge capacity */
<span class="nc" id="L409">			FlowNetwork net = new FlowNetwork() {</span>
				@Override
				public double getCapacity(int edge) {
<span class="nc" id="L412">					return netOrig.getCapacity(edge) - lowerBound.weight(edge);</span>
				}

				@Override
				public void setCapacity(int edge, double capacity) {
<span class="nc" id="L417">					throw new UnsupportedOperationException();</span>
				}

				@Override
				public double getFlow(int edge) {
<span class="nc" id="L422">					return netOrig.getFlow(edge) - lowerBound.weight(edge);</span>
				}

				@Override
				public void setFlow(int edge, double flow) {
<span class="nc" id="L427">					netOrig.setFlow(edge, flow + lowerBound.weight(edge));</span>
<span class="nc" id="L428">				}</span>
			};

			/* For each edge with lower bound we add/remove demand from the end endpoints */
<span class="nc" id="L432">			WeightFunction demand2 = computeDemand(g, netOrig, lowerBound, demand);</span>

			/* Solve the reduction problem with only demand without edges lower bounds */
<span class="nc" id="L435">			computeMinCostFlow(g, net, cost, demand2);</span>
<span class="nc" id="L436">		}</span>

		private static WeightFunction computeDemand(IndexGraph g, FlowNetwork netOrig, WeightFunction lowerBound,
				WeightFunction demand) {
<span class="nc" id="L440">			Weights.Double demand2 = Weights.createExternalVerticesWeights(g, double.class);</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">			if (demand != null) {</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">				for (int n = g.vertices().size(), v = 0; v &lt; n; v++)</span>
<span class="nc" id="L443">					demand2.set(v, demand.weight(v));</span>
			}
<span class="nc bnc" id="L445" title="All 2 branches missed.">			if (lowerBound != null) {</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">				for (int m = g.edges().size(), e = 0; e &lt; m; e++) {</span>
<span class="nc" id="L447">					double l = lowerBound.weight(e);</span>
<span class="nc" id="L448">					netOrig.setFlow(e, l);</span>
<span class="nc" id="L449">					int u = g.edgeSource(e), v = g.edgeTarget(e);</span>
<span class="nc" id="L450">					demand2.set(u, demand2.getDouble(u) + l);</span>
<span class="nc" id="L451">					demand2.set(v, demand2.getDouble(v) - l);</span>
				}
			}
<span class="nc" id="L454">			return demand2;</span>
		}

		static void checkLowerBound(IndexGraph g, FlowNetwork net, WeightFunction lowerBound) {
<span class="nc bnc" id="L458" title="All 2 branches missed.">			for (int m = g.edges().size(), e = 0; e &lt; m; e++) {</span>
<span class="nc" id="L459">				double l = lowerBound.weight(e);</span>
<span class="nc bnc" id="L460" title="All 4 branches missed.">				if (!(0 &lt;= l &amp;&amp; l &lt;= net.getCapacity(e)))</span>
<span class="nc" id="L461">					throw new IllegalArgumentException(&quot;Lower bound must be in [0, capacity] for edge &quot; + e);</span>
			}
<span class="nc" id="L463">		}</span>

		static void checkDemand(IndexGraph g, WeightFunction demand) {
<span class="nc" id="L466">			double sum = 0;</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">			for (int n = g.vertices().size(), v = 0; v &lt; n; v++) {</span>
<span class="nc" id="L468">				double d = demand.weight(v);</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">				if (!Double.isFinite(d))</span>
<span class="nc" id="L470">					throw new IllegalArgumentException(&quot;Demand must be non-negative for vertex &quot; + v);</span>
<span class="nc" id="L471">				sum += d;</span>
			}
<span class="nc bnc" id="L473" title="All 2 branches missed.">			if (sum != 0)</span>
<span class="nc" id="L474">				throw new IllegalArgumentException(&quot;Sum of demand must be zero&quot;);</span>
<span class="nc" id="L475">		}</span>

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>