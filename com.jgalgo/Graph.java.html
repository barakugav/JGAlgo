<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Graph.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jgalgo</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo</a> &gt; <span class="el_source">Graph.java</span></div><h1>Graph.java</h1><pre class="source lang-java linenums">package com.jgalgo;

import java.util.Collection;
import java.util.Set;

import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntSet;

/**
 * A discrete graph with vertices and edges.
 * &lt;p&gt;
 * A graph consist of a finite set of vertices {@code V} and edges {@code E}.
 * Vertices are some objects, and edges are connections between the vertices,
 * for example vertices can be cities and edges could be the roads between them.
 * Edges could be directed or undirected. Weights may be assigned to vertices
 * or edges, for example the length of a road might be a weight of an edge.
 * Than, questions such as &quot;what is the shortest path between two cities?&quot; might
 * be answered using graph algorithms.
 * &lt;p&gt;
 * Each edge {@code e=(u, v)} in the graph has a &lt;i&gt;source&lt;/i&gt;, {@code u}, and a
 * &lt;i&gt;target&lt;/i&gt; {@code v}. In undirected graphs the 'source' and 'target' can
 * be switched, as the edge is not directed, and we treat the source and target
 * as interchangeable &lt;i&gt;end points&lt;/i&gt;. If an edge {@code (u, v)} exist in the
 * graph, we say the vertices {@code u} and {@code v} and &lt;i&gt;neighbors&lt;/i&gt;, or
 * &lt;i&gt;adjacent&lt;/i&gt;. The edges are usually stored in some list for each vertex,
 * allowing efficient iteration of its edges. The &lt;i&gt;degree&lt;/i&gt; of an edges is
 * the number of its edges. In directed graph, we have both &lt;i&gt;in-degree&lt;/i&gt; and
 * &lt;i&gt;out-degree&lt;/i&gt;, which are the number of edges going in and out the vertex,
 * respectively.
 * &lt;p&gt;
 * Vertices can be added or removed. When a vertex {@code v} is removed, all the
 * edges with {@code v} as one of their end points are removed as well. Edge can
 * be added as connection to existing vertices, or removed.
 * &lt;p&gt;
 * Each vertex in the graph is identified by a unique non negative int ID. The
 * set of vertices in the graph is always {@code (0,1,2, ...,verticesNum-1)}.
 * To maintain this, the graph implementation may rename existing vertices when
 * the user remove a vertex, see {@link #getVerticesIDStrategy()}. Similar to
 * vertices, each edge in the graph is identified by a unique non negative int
 * ID. In contrast to the vertices IDs, it's not specified how the graph
 * implementation assign new IDs to added edges, or if it rename some of them
 * when the user remove an edge, see {@link #getEdgesIDStrategy()}.
 * &lt;p&gt;
 * The number of vertices, {@code |V|}, is usually denoted as {@code n} in
 * algorithms time and space complexities. And similarly, the number of edges,
 * {@code |E|}, is usually denoted as {@code m}.
 *
 * &lt;pre&gt; {@code
 * // Create a directed graph with three vertices and edges between them
 * DiGraph g = new GraphArrayDirected();
 * int v1 = g.addVertex();
 * int v2 = g.addVertex();
 * int v3 = g.addVertex();
 * int e1 = g.addEdge(v1, v2);
 * int e2 = g.addEdge(v2, v3);
 * int e3 = g.addEdge(v1, v3);
 *
 * // Assign some weights to the edges
 * Weights.Double w = g.addEdgesWeights(&quot;weightsKey&quot;, double.class);
 * w.set(e1, 1.2);
 * w.set(e2, 3.1);
 * w.set(e3, 15.1);
 *
 * // Calculate the shortest paths from v1 to all other vertices
 * SSSP ssspAlgo = new SSSPDijkstra();
 * SSSP.Result ssspRes = ssspAlgo.calcDistances(g, w, v1);
 *
 * // Print the shortest path from v1 to v3
 * assert ssspRes.distance(v3) == 4.3;
 * assert ssspRes.getPathTo(v3).equals(IntList.of(e1, e2));
 * System.out.println(&quot;Distance from v1 to v3 is: &quot; + ssspRes.distance(v3));
 * System.out.println(&quot;The shortest path from v1 to v3 is:&quot;);
 * for (IntIterator it = ssspRes.getPathTo(v3).iterator(); it.hasNext();) {
 * 	int e = it.nextInt();
 * 	int u = g.edgeSource(e), v = g.edgeTarget(e);
 * 	System.out.println(&quot; &quot; + e + &quot;(&quot; + u + &quot;, &quot; + v + &quot;)&quot;);
 * }
 * }&lt;/pre&gt;
 *
 * @see DiGraph
 * @see UGraph
 * @author Barak Ugav
 */
public interface Graph {

	/**
	 * Get the set of all vertices of the graph.
	 *
	 * &lt;p&gt;
	 * Each vertex in the graph is identified by a unique non negative int ID,
	 * determined by {@link #getVerticesIDStrategy()}. The returned set is a set of
	 * all these identifiers, and its size is equivalent to the number of vertices
	 * in the graph.
	 *
	 * @return a set containing all IDs of the graph vertices
	 */
	IntSet vertices();

	/**
	 * Get the set of all edges of the graph.
	 *
	 * &lt;p&gt;
	 * Each edge in the graph is identified by a unique non negative int ID,
	 * determined by {@link #getEdgesIDStrategy()}. The returned set is a set of all
	 * these identifiers, and its size is equivalent to the number of edges in the
	 * graph.
	 *
	 * @return a set containing all IDs of the graph edges
	 */
	IntSet edges();

	/**
	 * Add a new vertex to the graph.
	 *
	 * @return the new vertex identifier
	 */
	int addVertex();

	/**
	 * Remove a vertex and all its edges from the graph.
	 *
	 * &lt;p&gt;
	 * After removing a vertex, the vertices ID strategy may rename other vertices
	 * identifiers to maintain its invariants, see {@link #getVerticesIDStrategy()}.
	 * Theses renames can be subscribed using {@link IDStrategy#addIDSwapListener}.
	 * It may be more convenient to remove all edges of a vertex and ignore it,
	 * instead of actually removing it and dealing with IDs renames, but that
	 * depends on the specific use case.
	 *
	 * @see IDStrategy
	 *
	 * @param v the vertex identifier to remove
	 * @throws IndexOutOfBoundsException if {@code v} is not a valid vertex
	 *                                   identifier
	 */
	void removeVertex(int v);

	/**
	 * Remove multiple vertices.
	 * &lt;p&gt;
	 * After removing a vertex, the vertices ID strategy may rename other vertices
	 * identifiers to maintain its invariants, see {@link #getVerticesIDStrategy()}.
	 * Theses renames can be subscribed using {@link IDStrategy#addIDSwapListener}.
	 * &lt;p&gt;
	 * This function may be useful in case a user want to remove a collection of
	 * vertices, and does not want to update IDs within the collection due to IDs
	 * renames.
	 *
	 * @param vs a collection of vertices to remove
	 * @throws IndexOutOfBoundsException if one of the edges is not a valid edge
	 *                                   identifier
	 * @throws IllegalArgumentException  if the vertices collection to remove
	 *                                   contains duplications
	 */
	void removeVertices(IntCollection vs);

	/**
	 * Get the edges whose source is {@code u}.
	 *
	 * &lt;p&gt;
	 * Get an edge iterator that iterate over all edges whose source is {@code u}.
	 * In case the graph is undirected, the iterator will iterate over edges whose
	 * {@code u} is one of their end points.
	 *
	 * @param u a source vertex
	 * @return an iterator of all the edges whose source is u
	 * @throws IndexOutOfBoundsException if {@code u} is not a valid vertex
	 *                                   identifier
	 */
	EdgeIter edgesOut(int u);

	/**
	 * Get the edges whose target is {@code v}.
	 *
	 * &lt;p&gt;
	 * Get an edge iterator that iterate over all edges whose target is {@code v}.
	 * In case the graph is undirected, the iterator will iterate over edges whose
	 * {@code v} is one of their end points.
	 *
	 * @param v a target vertex
	 * @return an iterator of all the edges whose target is {@code v}
	 * @throws IndexOutOfBoundsException if {@code v} is not a valid vertex
	 *                                   identifier
	 */
	EdgeIter edgesIn(int v);

	/**
	 * Get the edge whose source is {@code u} and target is {@code v}.
	 *
	 * &lt;p&gt;
	 * If the graph is not directed, the return edge is an edge that its end-points
	 * are {@code u} and {@code v}.
	 *
	 * &lt;p&gt;
	 * In case there are multiple (parallel) edges between {@code u} and {@code v},
	 * a single arbitrary one is returned.
	 *
	 * @param u a source vertex
	 * @param v a target vertex
	 * @return id of the edge or {@code -1} if no such edge exists
	 * @throws IndexOutOfBoundsException if {@code u} or {@code v} are not valid
	 *                                   vertices identifiers
	 */
	default int getEdge(int u, int v) {
<span class="fc bfc" id="L205" title="All 2 branches covered.">		for (EdgeIter it = edgesOut(u); it.hasNext();) {</span>
<span class="fc" id="L206">			int e = it.nextInt();</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">			if (it.v() == v)</span>
<span class="fc" id="L208">				return e;</span>
<span class="fc" id="L209">		}</span>
<span class="fc" id="L210">		return -1;</span>
	}

	/**
	 * Get the edges whose source is {@code u} and target is {@code v}.
	 *
	 * @param u a source vertex
	 * @param v a target vertex
	 * @return an iterator of all the edges whose source is {@code u} and target is
	 *         {@code v}
	 * @throws IndexOutOfBoundsException if {@code u} or {@code v} are not valid
	 *                                   vertices identifiers
	 */
	EdgeIter getEdges(int u, int v);

	/**
	 * Add a new edge to the graph.
	 *
	 * @param u a source vertex
	 * @param v a target vertex
	 * @return the new edge identifier
	 * @throws IndexOutOfBoundsException if {@code u} or {@code v} are not valid
	 *                                   vertices identifiers
	 */
	int addEdge(int u, int v);

	/**
	 * Remove an edge from the graph.
	 *
	 * &lt;p&gt;
	 * After removing an edge, the edges ID strategy may rename other edges
	 * identifiers to maintain its invariants, see {@link #getEdgesIDStrategy()}.
	 * Theses renames can be subscribed using {@link IDStrategy#addIDSwapListener}.
	 *
	 * @param edge the edge identifier
	 * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge
	 *                                   identifier
	 */
	void removeEdge(int edge);

	/**
	 * Remove multiple edges.
	 * &lt;p&gt;
	 * After removing an edge, the edges ID strategy may rename other edges
	 * identifiers to maintain its invariants, see {@link #getEdgesIDStrategy()}.
	 * Theses renames can be subscribed using {@link IDStrategy#addIDSwapListener}.
	 * &lt;p&gt;
	 * This function may be useful in case a user want to remove a collection of
	 * edges, and does not want to update IDs within the collection due to IDs
	 * renames.
	 *
	 * @param edges a collection of edges to remove
	 * @throws IndexOutOfBoundsException if one of the edges is not a valid edge
	 *                                   identifier
	 * @throws IllegalArgumentException  if the edges collection to remove contains
	 *                                   duplications
	 */
	void removeEdges(IntCollection edges);

	/**
	 * Remove all the edges of a vertex.
	 *
	 * &lt;p&gt;
	 * After removing an edge, the edges ID strategy may rename other edges
	 * identifiers to maintain its invariants, see {@link #getEdgesIDStrategy()}.
	 * Theses renames can be subscribed using {@link IDStrategy#addIDSwapListener}.
	 *
	 * @param u a vertex in the graph
	 * @throws IndexOutOfBoundsException if {@code u} is not a valid vertex
	 *                                   identifier
	 */
	default void removeEdges(int u) {
<span class="fc" id="L282">		removeEdgesOut(u);</span>
<span class="fc" id="L283">		removeEdgesIn(u);</span>
<span class="fc" id="L284">	}</span>

	/**
	 * Remove all edges whose source is {@code u}.
	 * &lt;p&gt;
	 * After removing an edge, the edges ID strategy may rename other edges
	 * identifiers to maintain its invariants, see {@link #getEdgesIDStrategy()}.
	 * Theses renames can be subscribed using {@link IDStrategy#addIDSwapListener}.
	 *
	 * @param u a vertex in the graph
	 * @throws IndexOutOfBoundsException if {@code u} is not a valid vertex
	 *                                   identifier
	 */
	default void removeEdgesOut(int u) {
<span class="fc bfc" id="L298" title="All 2 branches covered.">		for (EdgeIter eit = edgesOut(u); eit.hasNext();) {</span>
<span class="fc" id="L299">			eit.nextInt();</span>
<span class="fc" id="L300">			eit.remove();</span>
		}
<span class="fc" id="L302">	}</span>

	/**
	 * Remove all edges whose target is {@code v}.
	 * &lt;p&gt;
	 * After removing an edge, the edges ID strategy may rename other edges
	 * identifiers to maintain its invariants, see {@link #getEdgesIDStrategy()}.
	 * Theses renames can be subscribed using {@link IDStrategy#addIDSwapListener}.
	 *
	 * @param v a vertex in the graph
	 * @throws IndexOutOfBoundsException if {@code v} is not a valid vertex
	 *                                   identifier
	 */
	default void removeEdgesIn(int v) {
<span class="fc bfc" id="L316" title="All 2 branches covered.">		for (EdgeIter eit = edgesIn(v); eit.hasNext();) {</span>
<span class="fc" id="L317">			eit.nextInt();</span>
<span class="fc" id="L318">			eit.remove();</span>
		}
<span class="fc" id="L320">	}</span>

	/**
	 * Get the source vertex of an edge.
	 *
	 * &lt;p&gt;
	 * If the graph is undirected, this function return an arbitrary end-point of
	 * the edge, but always other end-point than {@link #edgeTarget(int)} returns.
	 *
	 * @param edge the edge identifier
	 * @return the edge source vertex
	 * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge
	 *                                   identifier
	 */
	public int edgeSource(int edge);

	/**
	 * Get the target vertex of an edge.
	 *
	 * &lt;p&gt;
	 * If the graph is undirected, this function return an arbitrary end-point of
	 * the edge, but always the other end-point than {@link #edgeSource(int)}
	 * returns.
	 *
	 * @param edge the edge identifier
	 * @return the edge target vertex
	 * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge
	 *                                   identifier
	 */
	public int edgeTarget(int edge);

	/**
	 * Get the other end-point of an edge.
	 *
	 * @param edge     an edge identifier
	 * @param endpoint one of the edge end-point
	 * @return the other end-point of the edge
	 * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge
	 *                                   identifier
	 * @throws IllegalArgumentException  if {@code endpoint} is not an endpoint of
	 *                                   the edge
	 */
	default int edgeEndpoint(int edge, int endpoint) {
<span class="nc" id="L363">		int u = edgeSource(edge);</span>
<span class="nc" id="L364">		int v = edgeTarget(edge);</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">		if (endpoint == u) {</span>
<span class="nc" id="L366">			return v;</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">		} else if (endpoint == v) {</span>
<span class="nc" id="L368">			return u;</span>
		} else {
<span class="nc" id="L370">			throw new IllegalArgumentException(&quot;Given vertex is not an endpoint of the edge&quot;);</span>
		}
	}

	/**
	 * Get the out degree of a source vertex.
	 *
	 * @param u a source vertex
	 * @return the number of edges whose source is u
	 * @throws IndexOutOfBoundsException if {@code u} is not a valid vertex
	 *                                   identifier
	 */
	default int degreeOut(int u) {
<span class="fc" id="L383">		int count = 0;</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">		for (EdgeIter it = edgesOut(u); it.hasNext();) {</span>
<span class="fc" id="L385">			it.nextInt();</span>
<span class="fc" id="L386">			count++;</span>
		}
<span class="fc" id="L388">		return count;</span>
	}

	/**
	 * Get the in degree of a target vertex.
	 *
	 * @param v a target vertex
	 * @return the number of edges whose target is v
	 * @throws IndexOutOfBoundsException if {@code v} is not a valid vertex
	 *                                   identifier
	 */
	default int degreeIn(int v) {
<span class="fc" id="L400">		int count = 0;</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">		for (EdgeIter it = edgesIn(v); it.hasNext();) {</span>
<span class="fc" id="L402">			it.nextInt();</span>
<span class="fc" id="L403">			count++;</span>
		}
<span class="fc" id="L405">		return count;</span>
	}

	/**
	 * Clear the graph completely by removing all vertices and edges.
	 *
	 * &lt;p&gt;
	 * This function might be used to reuse an already allocated graph object.
	 * &lt;p&gt;
	 * Note that this function also clears any weights associated with the vertices
	 * or edges.
	 */
	public void clear();

	/**
	 * Remove all the edges from the graph.
	 *
	 * &lt;p&gt;
	 * Note that this function also clears any weights associated with the edges.
	 */
	public void clearEdges();

	/**
	 * Get the vertices weights of some key.
	 * &lt;p&gt;
	 * See {@link Weights} for a complete documentation of the weights containers.
	 *
	 * @param key some key of the weights, could be anything
	 * @return vertices weights of the key, or null if no container found with the
	 *         specified key
	 * @param &lt;V&gt;        The weight data type
	 * @param &lt;WeightsT&gt; the weights container, used to avoid casts of containers of
	 *                   primitive types
	 */
	public &lt;V, WeightsT extends Weights&lt;V&gt;&gt; WeightsT verticesWeight(Object key);

	/**
	 * Add a new weights container associated with the vertices of this graph.
	 *
	 * &lt;pre&gt; {@code
	 * Graph g = ...;
	 * int v1 = g.newVertex();
	 * int v2 = g.newVertex();
	 *
	 * Weights&lt;String&gt; names = g.addVerticesWeights(&quot;name&quot;, String.class);
	 * names.set(v1, &quot;Alice&quot;);
	 * names.set(v2, &quot;Bob&quot;);
	 *
	 * Weights.Int ages = g.addVerticesWeights(&quot;age&quot;, int.class);
	 * ages.set(v1, 42);
	 * ages.set(v2, 35);
	 * }&lt;/pre&gt;
	 *
	 * &lt;p&gt;
	 * See {@link Weights} for a complete documentation of the weights containers.
	 *
	 * @param key  some key of the weights, could be anything
	 * @param type the type of the weights, used for primitive types weights
	 * @return a new weights container
	 * @throws IllegalArgumentException if a vertices weights container with the
	 *                                  same key already exists in the graph
	 * @param &lt;V&gt;        The weight data type
	 * @param &lt;WeightsT&gt; the weights container, used to avoid casts of containers of
	 *                   primitive types
	 */
	public &lt;V, WeightsT extends Weights&lt;V&gt;&gt; WeightsT addVerticesWeights(Object key, Class&lt;? super V&gt; type);

	/**
	 * Add a new weights container associated with the vertices of this graph with
	 * default value.
	 *
	 * &lt;pre&gt; {@code
	 * Graph g = ...;
	 * int v1 = g.newVertex();
	 * int v2 = g.newVertex();
	 * int v3 = g.newVertex();
	 *
	 * Weights&lt;String&gt; names = g.addVerticesWeights(&quot;name&quot;, String.class, &quot;Unknown&quot;);
	 * names.set(v1, &quot;Alice&quot;);
	 * names.set(v2, &quot;Bob&quot;);
	 *
	 * assert &quot;Alice&quot;.equals(names.get(v1))
	 * assert &quot;Bob&quot;.equals(names.get(v2))
	 * assert &quot;Unknown&quot;.equals(names.get(v3))
	 * }&lt;/pre&gt;
	 *
	 * &lt;p&gt;
	 * See {@link Weights} for a complete documentation of the weights containers.
	 *
	 * @param key    some key of the weights, could be anything
	 * @param type   the type of the weights, used for primitive types weights
	 * @param defVal default value use for the weights container
	 * @return a new weights container
	 * @throws IllegalArgumentException if a vertices weights container with the
	 *                                  same key already exists in the graph
	 * @param &lt;V&gt;        The weight data type
	 * @param &lt;WeightsT&gt; the weights container, used to avoid casts of containers of
	 *                   primitive types
	 */
	public &lt;V, WeightsT extends Weights&lt;V&gt;&gt; WeightsT addVerticesWeights(Object key, Class&lt;? super V&gt; type, V defVal);

	/**
	 * Remove a weight type associated with the vertices of the graph.
	 * &lt;p&gt;
	 * See {@link Weights} for a complete documentation of the weights containers.
	 *
	 * @param key the key of the weights
	 */
	public void removeVerticesWeights(Object key);

	/**
	 * Get the keys of all the associated vertices weights.
	 * &lt;p&gt;
	 * See {@link Weights} for a complete documentation of the weights containers.
	 *
	 * @return the keys of all the associated vertices weights
	 */
	public Set&lt;Object&gt; getVerticesWeightKeys();

	/**
	 * Get all vertices weights.
	 * &lt;p&gt;
	 * See {@link Weights} for a complete documentation of the weights containers.
	 *
	 * @return all vertices weights
	 */
	public Collection&lt;Weights&lt;?&gt;&gt; getVerticesWeights();

	/**
	 * Get the edges weights of some key.
	 * &lt;p&gt;
	 * See {@link Weights} for a complete documentation of the weights containers.
	 *
	 * @param key some key of the weights, could be anything
	 * @return edges weights of the key, or null if no container found with the
	 *         specified key
	 * @param &lt;E&gt;        The weight data type
	 * @param &lt;WeightsT&gt; the weights container, used to avoid casts of containers of
	 *                   primitive types
	 */
	public &lt;E, WeightsT extends Weights&lt;E&gt;&gt; WeightsT edgesWeight(Object key);

	/**
	 * Add a new weights container associated with the edges of this graph.
	 *
	 * &lt;pre&gt; {@code
	 * Graph g = ...;
	 * int v1 = g.addVertex();
	 * int v2 = g.addVertex();
	 * int v3 = g.addVertex();
	 * int e1 = g.addEdge(v1, v2);
	 * int e2 = g.addEdge(v2, v3);
	 *
	 * Weights&lt;String&gt; roadTypes = g.addEdgesWeights(&quot;roadType&quot;, String.class);
	 * roadType.set(e1, &quot;Asphalt&quot;);
	 * roadType.set(e2, &quot;Gravel&quot;);
	 *
	 * Weights.Double roadLengths = g.addEdgesWeights(&quot;roadLength&quot;, double.class);
	 * lengths.set(e1, 42);
	 * lengths.set(e2, 35);
	 * }&lt;/pre&gt;
	 *
	 * &lt;p&gt;
	 * See {@link Weights} for a complete documentation of the weights containers.
	 *
	 * @param key  some key of the weights, could be anything
	 * @param type the type of the weights, used for primitive types weights
	 * @return a new weights container
	 * @throws IllegalArgumentException if a edges weights container with the same
	 *                                  key already exists in the graph
	 * @param &lt;E&gt;        The weight data type
	 * @param &lt;WeightsT&gt; the weights container, used to avoid casts of containers of
	 *                   primitive types
	 */
	public &lt;E, WeightsT extends Weights&lt;E&gt;&gt; WeightsT addEdgesWeights(Object key, Class&lt;? super E&gt; type);

	/**
	 * Add a new weights container associated with the edges of this graph with
	 * default value.
	 *
	 * &lt;pre&gt; {@code
	 * Graph g = ...;
	 * int v1 = g.addVertex();
	 * int v2 = g.addVertex();
	 * int v3 = g.addVertex();
	 * int e1 = g.addEdge(v1, v2);
	 * int e2 = g.addEdge(v2, v3);
	 * int e3 = g.addEdge(v1, v3);
	 *
	 * Weights&lt;String&gt; roadTypes = g.addEdgesWeights(&quot;roadType&quot;, String.class, &quot;Unknown&quot;);
	 * roadType.set(e1, &quot;Asphalt&quot;);
	 * roadType.set(e2, &quot;Gravel&quot;);
	 *
	 * assert &quot;Asphalt&quot;.equals(names.get(e1))
	 * assert &quot;Gravel&quot;.equals(names.get(e2))
	 * assert &quot;Unknown&quot;.equals(names.get(e3))
	 * }&lt;/pre&gt;
	 *
	 * &lt;p&gt;
	 * See {@link Weights} for a complete documentation of the weights containers.
	 *
	 * @param key    some key of the weights, could be anything
	 * @param type   the type of the weights, used for primitive types weights
	 * @param defVal default value use for the weights container
	 * @return a new weights container
	 * @throws IllegalArgumentException if a edges weights container with the same
	 *                                  key already exists in the graph
	 * @param &lt;E&gt;        The weight data type
	 * @param &lt;WeightsT&gt; the weights container, used to avoid casts of containers of
	 *                   primitive types
	 */
	public &lt;E, WeightsT extends Weights&lt;E&gt;&gt; WeightsT addEdgesWeights(Object key, Class&lt;? super E&gt; type, E defVal);

	/**
	 * Remove a weight type associated with the edges of the graph.
	 * &lt;p&gt;
	 * See {@link Weights} for a complete documentation of the weights containers.
	 *
	 * @param key the key of the weights
	 */
	public void removeEdgesWeights(Object key);

	/**
	 * Get the keys of all the associated edges weights.
	 * &lt;p&gt;
	 * See {@link Weights} for a complete documentation of the weights containers.
	 *
	 * @return the keys of all the associated edges weights
	 */
	public Set&lt;Object&gt; getEdgesWeightsKeys();

	/**
	 * Get all edges weights.
	 * &lt;p&gt;
	 * See {@link Weights} for a complete documentation of the weights containers.
	 *
	 * @return all edges weights
	 */
	public Collection&lt;Weights&lt;?&gt;&gt; getEdgesWeights();

	/**
	 * Get the ID strategy of the vertices of the graph.
	 *
	 * &lt;p&gt;
	 * Each vertex in the graph is identified by a unique non negative int ID, which
	 * is determined by some strategy. Only {@link IDStrategy.Continues} is
	 * supported for vertices, which ensure that at all times the vertices IDs are
	 * {@code 0,1,..., verticesNum-1}, and it might rename some vertices when a
	 * vertex is removed to maintain this invariant. This rename can be subscribed
	 * using {@link IDStrategy#addIDSwapListener}.
	 *
	 * @see IDStrategy
	 *
	 * @return the vertices IDs strategy
	 */
	public IDStrategy.Continues getVerticesIDStrategy();

	/**
	 * Get the ID strategy of the edges of the graph.
	 *
	 * &lt;p&gt;
	 * Each edge in the graph is identified by a unique non negative int ID, which
	 * is determined by some strategy. For example, {@link IDStrategy.Continues}
	 * ensure that at all times the edges IDs are {@code 0,1,..., edgesNum-1}, and
	 * it might rename some edges when an edge is removed to maintain this
	 * invariant. This rename can be subscribed using
	 * {@link IDStrategy#addIDSwapListener}. Another option for an ID strategy is
	 * {@link IDStrategy.Fixed} which ensure once an edge is assigned an ID, it will
	 * not change. There might be some performance differences between different ID
	 * strategies.
	 *
	 * @see IDStrategy
	 *
	 * @return the edges IDs strategy
	 */
	public IDStrategy getEdgesIDStrategy();

	/**
	 * Get the {@linkplain GraphCapabilities capabilities} of this graph.
	 *
	 * @return a {@link GraphCapabilities} object describing what this graph support
	 *         and what not.
	 * @see GraphCapabilities
	 */
	public GraphCapabilities getCapabilities();

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>