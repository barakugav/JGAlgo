<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Graph.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jgalgo</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo</a> &gt; <span class="el_source">Graph.java</span></div><h1>Graph.java</h1><pre class="source lang-java linenums">package com.jgalgo;

import java.util.Collection;
import java.util.Set;

import it.unimi.dsi.fastutil.ints.IntArrayList;
import it.unimi.dsi.fastutil.ints.IntIterator;
import it.unimi.dsi.fastutil.ints.IntList;
import it.unimi.dsi.fastutil.ints.IntSet;

public interface Graph {

	/**
	 * Get the set of all vertices of the graph.
	 *
	 * &lt;p&gt;
	 * Each vertex in the graph is identified by a unique non negative int ID,
	 * determined by {@link #getVerticesIDStrategy()}. The returned set is a set of
	 * all these identifiers, and its size is equivalent to the number of vertices
	 * in the graph.
	 *
	 * @return a set containing all IDs of the graph vertices
	 */
	IntSet vertices();

	/**
	 * Get the set of all edges of the graph.
	 *
	 * &lt;p&gt;
	 * Each edge in the graph is identified by a unique non negative int ID,
	 * determined by {@link #getEdgesIDStrategy()}. The returned set is a set of all
	 * these identifiers, and its size is equivalent to the number of edges in the
	 * graph.
	 *
	 * @return a set containing all IDs of the graph edges
	 */
	IntSet edges();

	/**
	 * Add a new vertex to the graph.
	 *
	 * @return the new vertex identifier
	 */
	int addVertex();

	/**
	 * Remove a vertex and all its edges from the graph.
	 *
	 * &lt;p&gt;
	 * After removing a vertex, the vertices ID strategy may rename other vertices
	 * identifiers to maintain its invariants, see {@link #getVerticesIDStrategy()}.
	 * Theses renames can be subscribed using
	 * {@link com.jgalgo.IDStrategy#addIDSwapListener}. It may be more convenient to
	 * remove all edges of a vertex and ignore it, instead of actually removing it
	 * and dealing with IDs renames, but that depends on the specific use case.
	 *
	 * @see com.jgalgo.IDStrategy
	 *
	 * @param v the vertex identifier to remove
	 */
	void removeVertex(int v);

	/**
	 * Get the edges of a vertex u.
	 *
	 * &lt;p&gt;
	 * In case the graph is directed, this function returns the edges which u is
	 * their source vertex.
	 *
	 * @param u a source vertex
	 * @return an iterator of all the edges whose source is u
	 */
	EdgeIter edgesOut(int u);

	EdgeIter edgesIn(int v);

	/**
	 * Get the edge whose source is u and target is v.
	 *
	 * &lt;p&gt;
	 * If the graph is not directed, the return edge is an edge that its end-points
	 * are u,v.
	 *
	 * &lt;p&gt;
	 * In case there are multiple (parallel) edges between u and v, a single
	 * arbitrary one is returned.
	 *
	 * @param u a source vertex
	 * @param v a target vertex
	 * @return id of the edge or -1 if no such edge exists
	 */
	default int getEdge(int u, int v) {
<span class="fc bfc" id="L93" title="All 2 branches covered.">		for (EdgeIter it = edgesOut(u); it.hasNext();) {</span>
<span class="fc" id="L94">			int e = it.nextInt();</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">			if (it.v() == v)</span>
<span class="fc" id="L96">				return e;</span>
<span class="fc" id="L97">		}</span>
<span class="fc" id="L98">		return -1;</span>
	}

	default EdgeIter getEdges(int u, int v) {
<span class="fc" id="L102">		IntList edges = new IntArrayList();</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">		for (EdgeIter it = edgesOut(u); it.hasNext();) {</span>
<span class="fc" id="L104">			int e = it.nextInt();</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">			if (it.v() == v)</span>
<span class="fc" id="L106">				edges.add(e);</span>
<span class="fc" id="L107">		}</span>
<span class="fc" id="L108">		return new EdgeIter() {</span>

<span class="fc" id="L110">			IntIterator it = edges.iterator();</span>

			@Override
			public boolean hasNext() {
<span class="fc" id="L114">				return it.hasNext();</span>
			}

			@Override
			public int nextInt() {
<span class="fc" id="L119">				return it.nextInt();</span>
			}

			@Override
			public int u() {
<span class="nc" id="L124">				return u;</span>
			}

			@Override
			public int v() {
<span class="nc" id="L129">				return v;</span>
			}
		};
	}

	/**
	 * Add a new edge to the graph.
	 *
	 * @param u a source vertex
	 * @param v a target vertex
	 * @return the new edge identifier
	 */
	int addEdge(int u, int v);

	/**
	 * Remove an edge from the graph.
	 *
	 * &lt;p&gt;
	 * After removing an edge, the edges ID strategy may rename other edges
	 * identifiers to maintain its invariants, see {@link #getEdgesIDStrategy()}.
	 * Theses renames can be subscribed using
	 * {@link com.jgalgo.IDStrategy#addIDSwapListener}.
	 *
	 * @see com.jgalgo.IDStrategy
	 *
	 * @param edge the edge identifier
	 */
	void removeEdge(int edge);

	/**
	 * Remove all the edges of a vertex u.
	 *
	 * &lt;p&gt;
	 * If the graph is directed, both the in and out edges of the vertex are
	 * removed.
	 *
	 * &lt;p&gt;
	 * After removing an edge, the edges ID strategy may rename other edges
	 * identifiers to maintain its invariants, see {@link #getEdgesIDStrategy()}.
	 * Theses renames can be subscribed using
	 * {@link com.jgalgo.IDStrategy#addIDSwapListener}.
	 *
	 * @see com.jgalgo.IDStrategy
	 *
	 * @param u a vertex in the graph
	 */
	default void removeEdgesAll(int u) {
<span class="fc" id="L176">		removeEdgesAllOut(u);</span>
<span class="fc" id="L177">		removeEdgesAllIn(u);</span>
<span class="fc" id="L178">	}</span>

	default void removeEdgesAllOut(int u) {
<span class="fc bfc" id="L181" title="All 2 branches covered.">		for (EdgeIter eit = edgesOut(u); eit.hasNext();) {</span>
<span class="fc" id="L182">			eit.nextInt();</span>
<span class="fc" id="L183">			eit.remove();</span>
		}
<span class="fc" id="L185">	}</span>

	default void removeEdgesAllIn(int v) {
<span class="fc bfc" id="L188" title="All 2 branches covered.">		for (EdgeIter eit = edgesIn(v); eit.hasNext();) {</span>
<span class="fc" id="L189">			eit.nextInt();</span>
<span class="fc" id="L190">			eit.remove();</span>
		}
<span class="fc" id="L192">	}</span>

	/**
	 * Get the source vertex of an edge.
	 *
	 * &lt;p&gt;
	 * If the graph is undirected, this function return an arbitrary end-point of
	 * the edge, but always the other end-point than {@link #edgeTarget(int)}
	 * returns.
	 *
	 * @param edge the edge identifier
	 * @return the edge source vertex
	 */
	public int edgeSource(int edge);

	/**
	 * Get the target vertex of an edge.
	 *
	 * &lt;p&gt;
	 * If the graph is undirected, this function return an arbitrary end-point of
	 * the edge, but always the other end-point than {@link #edgeSource(int)}
	 * returns.
	 *
	 * @param edge the edge identifier
	 * @return the edge target vertex
	 */
	public int edgeTarget(int edge);

	/**
	 * Get the other end-point of an edge.
	 *
	 * @param edge     the edge identifier
	 * @param endpoint one of the edge end-point
	 * @return the other end-point of the edge
	 */
	default int edgeEndpoint(int edge, int endpoint) {
<span class="nc" id="L228">		int u = edgeSource(edge);</span>
<span class="nc" id="L229">		int v = edgeTarget(edge);</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">		if (endpoint == u) {</span>
<span class="nc" id="L231">			return v;</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">		} else if (endpoint == v) {</span>
<span class="nc" id="L233">			return u;</span>
		} else {
<span class="nc" id="L235">			throw new IllegalArgumentException();</span>
		}
	}

	/**
	 * Get the out degree of a source vertex
	 *
	 * @param u a source vertex
	 * @return the number of edges whose source is u
	 */
	default int degreeOut(int u) {
<span class="fc" id="L246">		int count = 0;</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">		for (EdgeIter it = edgesOut(u); it.hasNext();) {</span>
<span class="fc" id="L248">			it.nextInt();</span>
<span class="fc" id="L249">			count++;</span>
		}
<span class="fc" id="L251">		return count;</span>
	}

	/**
	 * Get the out degree of a target vertex
	 *
	 * @param v a target vertex
	 * @return the number of edges whose target is v
	 */
	default int degreeIn(int v) {
<span class="fc" id="L261">		int count = 0;</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">		for (EdgeIter it = edgesIn(v); it.hasNext();) {</span>
<span class="fc" id="L263">			it.nextInt();</span>
<span class="fc" id="L264">			count++;</span>
		}
<span class="fc" id="L266">		return count;</span>
	}

	/**
	 * Clear the graph completely by removing all vertices and edges.
	 *
	 * &lt;p&gt;
	 * This function might be used to reuse an already allocated graph object
	 */
	public void clear();

	/**
	 * Remove all the edges from the graph.
	 *
	 * &lt;p&gt;
	 * Note that this function also clears any weights associated with removed
	 * edges.
	 */
	public void clearEdges();

	// TODO remove vertex
	// TODO documentation

	/**
	 * Get the vertices weights of some key.
	 *
	 * @param &lt;V&gt;        The weight type
	 * @param &lt;WeightsT&gt; the weights container
	 * @param key        some key of the weights, could be anything
	 * @return vertices weights of the key
	 */
	public &lt;V, WeightsT extends Weights&lt;V&gt;&gt; WeightsT verticesWeight(Object key);

	public Weights.Factory addVerticesWeight(Object key);

	/**
	 * Get the keys of all the associated vertices weights.
	 *
	 * @return the keys of all the associated vertices weights
	 */
	public Set&lt;Object&gt; getVerticesWeightKeys();

	/**
	 * Get all vertices weights.
	 *
	 * @return all vertices weights
	 */
	public Collection&lt;Weights&lt;?&gt;&gt; getVerticesWeights();

	/**
	 * Remove a weight type from the vertices of the graph.
	 *
	 * @param key the key of the weights
	 */
	public void removeVerticesWeights(Object key);

	/**
	 * Get the edges weights of some key.
	 *
	 * @param &lt;E&gt;        The weight type
	 * @param &lt;WeightsT&gt; the weights container
	 * @param key        some key of the weights, could be anything
	 * @return edges weights of the key
	 */
	public &lt;E, WeightsT extends Weights&lt;E&gt;&gt; WeightsT edgesWeight(Object key);

	public Weights.Factory addEdgesWeight(Object key);

	/**
	 * Get the keys of all the associated edges weights.
	 *
	 * @return the keys of all the associated edges weights
	 */
	public Set&lt;Object&gt; getEdgesWeightsKeys();

	/**
	 * Remove a weight type from the edges of the graph.
	 *
	 * @param key the key of the weights
	 */
	public void removeEdgesWeights(Object key);

	/**
	 * Get all edges weights.
	 *
	 * @return all edges weights
	 */
	public Collection&lt;Weights&lt;?&gt;&gt; getEdgesWeights();

	/**
	 * Get ID strategy of the vertices of the graph.
	 *
	 * &lt;p&gt;
	 * Each vertex in the graph is identified by a unique non negative int ID, which
	 * is determined by some strategy. Only {@link com.jgalgo.IDStrategy.Continues}
	 * is supported for vertices, which ensure that at all times the vertices IDs
	 * are {@code 0,1,..., verticesNum-1}, and it might rename some vertices when a
	 * vertex is removed to maintain this invariant. This rename can be subscribed
	 * using {@link com.jgalgo.IDStrategy#addIDSwapListener}.
	 *
	 * @see com.jgalgo.IDStrategy
	 *
	 * @return the vertices IDs strategy
	 */
	public IDStrategy.Continues getVerticesIDStrategy();

	/**
	 * Get the set of all edges of the graph.
	 *
	 * &lt;p&gt;
	 * Each edge in the graph is identified by a unique non negative int ID, which
	 * is determined by some strategy. For example,
	 * {@link com.jgalgo.IDStrategy.Continues} ensure that at all times the edges
	 * IDs are {@code 0,1,..., edgesNum-1}, and it might rename some edges when an
	 * edge is removed to maintain this invariant. This rename can be subscribed
	 * using {@link com.jgalgo.IDStrategy#addIDSwapListener}. Another option for an
	 * ID strategy is {@link com.jgalgo.IDStrategy.Fixed} which ensure once an edge
	 * is assigned an ID, it will not change. There might be some performance
	 * differences between different ID strategies.
	 *
	 * @see com.jgalgo.IDStrategy
	 *
	 * @return the edges IDs strategy
	 */
	public IDStrategy getEdgesIDStrategy();

	public GraphCapabilities getCapabilities();

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>