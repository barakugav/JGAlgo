<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataContainer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jgalgo</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo</a> &gt; <span class="el_source">DataContainer.java</span></div><h1>DataContainer.java</h1><pre class="source lang-java linenums">package com.jgalgo;

import java.util.Arrays;
import java.util.BitSet;
import java.util.Collection;
import java.util.NoSuchElementException;
import java.util.Objects;

import it.unimi.dsi.fastutil.booleans.AbstractBooleanCollection;
import it.unimi.dsi.fastutil.booleans.BooleanCollection;
import it.unimi.dsi.fastutil.booleans.BooleanIterator;
import it.unimi.dsi.fastutil.doubles.AbstractDoubleCollection;
import it.unimi.dsi.fastutil.doubles.DoubleArrays;
import it.unimi.dsi.fastutil.doubles.DoubleCollection;
import it.unimi.dsi.fastutil.doubles.DoubleIterator;
import it.unimi.dsi.fastutil.ints.AbstractIntCollection;
import it.unimi.dsi.fastutil.ints.IntArrays;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntIterator;
import it.unimi.dsi.fastutil.longs.AbstractLongCollection;
import it.unimi.dsi.fastutil.longs.LongArrays;
import it.unimi.dsi.fastutil.longs.LongCollection;
import it.unimi.dsi.fastutil.longs.LongIterator;
import it.unimi.dsi.fastutil.objects.AbstractObjectCollection;
import it.unimi.dsi.fastutil.objects.ObjectArrays;
import it.unimi.dsi.fastutil.objects.ObjectCollection;
import it.unimi.dsi.fastutil.objects.ObjectIterator;

<span class="fc" id="L29">abstract class DataContainer&lt;E&gt; {</span>
	int size;

	void clear() {
<span class="fc" id="L33">		size = 0;</span>
<span class="fc" id="L34">	}</span>

	abstract void add(int idx);

	abstract void remove(int idx);

	abstract void ensureCapacity(int size);

	abstract void swap(int i1, int i2);

	abstract Collection&lt;E&gt; values();

	void checkIdx(int idx) {
		// TODO add some messege of ID strategy choice
<span class="pc bpc" id="L48" title="1 of 2 branches missed.">		if (idx &gt;= size)</span>
<span class="nc" id="L49">			throw new IndexOutOfBoundsException(idx);</span>
<span class="fc" id="L50">	}</span>

<span class="fc" id="L52">	static class Obj&lt;E&gt; extends DataContainer&lt;E&gt; {</span>

		private Object[] weights;
		private final E defaultVal;
		private final ObjectCollection&lt;E&gt; values;

<span class="fc" id="L58">		Obj(int expectedSize, E defVal) {</span>
<span class="fc bfc" id="L59" title="All 2 branches covered.">			weights = expectedSize &gt; 0 ? new Object[expectedSize] : ObjectArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L60">			defaultVal = defVal;</span>
<span class="fc" id="L61">			values = new AbstractObjectCollection&lt;&gt;() {</span>

				@Override
				public int size() {
<span class="nc" id="L65">					return size;</span>
				}

				@Override
				public ObjectIterator&lt;E&gt; iterator() {
<span class="fc" id="L70">					return new ObjectIterator&lt;&gt;() {</span>
<span class="fc" id="L71">						int idx = 0;</span>

						@Override
						public boolean hasNext() {
<span class="fc bfc" id="L75" title="All 2 branches covered.">							return idx &lt; size;</span>
						}

						@SuppressWarnings(&quot;unchecked&quot;)
						@Override
						public E next() {
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">							if (!hasNext())</span>
<span class="nc" id="L82">								throw new NoSuchElementException();</span>
<span class="fc" id="L83">							return (E) weights[idx++];</span>
						}
					};
				}
			};
<span class="fc" id="L88">		}</span>

		@SuppressWarnings(&quot;unchecked&quot;)
		public E get(int idx) {
<span class="fc" id="L92">			checkIdx(idx);</span>
<span class="fc" id="L93">			return (E) weights[idx];</span>
		}

		public void set(int idx, E weight) {
<span class="fc" id="L97">			checkIdx(idx);</span>
<span class="fc" id="L98">			weights[idx] = weight;</span>
<span class="fc" id="L99">		}</span>

		public E defaultVal() {
<span class="fc" id="L102">			return defaultVal;</span>
		}

		@Override
		void add(int idx) {
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">			assert idx == size : &quot;only continues idxs are supported&quot;;</span>
<span class="fc" id="L108">			ensureCapacity(size + 1);</span>
<span class="fc" id="L109">			weights[idx] = defaultVal;</span>
<span class="fc" id="L110">			size++;</span>
<span class="fc" id="L111">		}</span>

		@Override
		void remove(int idx) {
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">			assert idx == size - 1 : &quot;only continues idxs are supported&quot;;</span>
<span class="fc" id="L116">			weights[idx] = null;</span>
<span class="fc" id="L117">			size--;</span>
<span class="fc" id="L118">		}</span>

		@Override
		void ensureCapacity(int capacity) {
<span class="fc bfc" id="L122" title="All 2 branches covered.">			if (capacity &lt; weights.length)</span>
<span class="fc" id="L123">				return;</span>
<span class="fc" id="L124">			int newLen = Math.max(2, weights.length * 2);</span>
<span class="fc" id="L125">			newLen = Math.max(newLen, capacity);</span>
<span class="fc" id="L126">			weights = Arrays.copyOf(weights, newLen);</span>
<span class="fc" id="L127">		}</span>

		@Override
		void swap(int k1, int k2) {
<span class="fc" id="L131">			checkIdx(k1);</span>
<span class="fc" id="L132">			checkIdx(k2);</span>
<span class="fc" id="L133">			Object temp = weights[k1];</span>
<span class="fc" id="L134">			weights[k1] = weights[k2];</span>
<span class="fc" id="L135">			weights[k2] = temp;</span>
<span class="fc" id="L136">		}</span>

		@Override
		public void clear() {
<span class="fc" id="L140">			Arrays.fill(weights, 0, size, null);</span>
<span class="fc" id="L141">			super.clear();</span>
<span class="fc" id="L142">		}</span>

		@Override
		Collection&lt;E&gt; values() {
<span class="fc" id="L146">			return values;</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L151" title="All 2 branches missed.">			if (other == this)</span>
<span class="nc" id="L152">				return true;</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Obj&lt;?&gt;))</span>
<span class="nc" id="L154">				return false;</span>
<span class="nc" id="L155">			DataContainer.Obj&lt;?&gt; o = (DataContainer.Obj&lt;?&gt;) other;</span>
<span class="nc" id="L156">			return Arrays.equals(weights, 0, size, o.weights, 0, o.size);</span>
		}

		@Override
		public int hashCode() {
<span class="nc" id="L161">			int h = 1;</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">			for (int i = 0; i &lt; size; i++)</span>
<span class="nc" id="L163">				h = 31 * h + Objects.hashCode(weights[i]);</span>
<span class="nc" id="L164">			return h;</span>
		}

		@Override
		public String toString() {
<span class="nc" id="L169">			int iMax = size - 1;</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">			if (iMax == -1)</span>
<span class="nc" id="L171">				return &quot;[]&quot;;</span>

<span class="nc" id="L173">			StringBuilder b = new StringBuilder();</span>
<span class="nc" id="L174">			b.append('[');</span>
<span class="nc" id="L175">			for (int i = 0;; i++) {</span>
<span class="nc" id="L176">				b.append(String.valueOf(weights[i]));</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">				if (i == iMax)</span>
<span class="nc" id="L178">					return b.append(']').toString();</span>
<span class="nc" id="L179">				b.append(&quot;, &quot;);</span>
			}
		}
	}

<span class="fc" id="L184">	static class Int extends DataContainer&lt;Integer&gt; {</span>

		private int[] weights;
		private final int defaultVal;
		private final IntCollection values;

<span class="fc" id="L190">		Int(int expectedSize, int defVal) {</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">			weights = expectedSize &gt; 0 ? new int[expectedSize] : IntArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L192">			defaultVal = defVal;</span>
<span class="fc" id="L193">			values = new AbstractIntCollection() {</span>

				@Override
				public int size() {
<span class="nc" id="L197">					return size;</span>
				}

				@Override
				public IntIterator iterator() {
<span class="nc" id="L202">					return new IntIterator() {</span>
<span class="nc" id="L203">						int idx = 0;</span>

						@Override
						public boolean hasNext() {
<span class="nc bnc" id="L207" title="All 2 branches missed.">							return idx &lt; size;</span>
						}

						@Override
						public int nextInt() {
<span class="nc bnc" id="L212" title="All 2 branches missed.">							if (!hasNext())</span>
<span class="nc" id="L213">								throw new NoSuchElementException();</span>
<span class="nc" id="L214">							return weights[idx++];</span>
						}
					};
				}
			};
<span class="fc" id="L219">		}</span>

		public int getInt(int idx) {
<span class="fc" id="L222">			checkIdx(idx);</span>
<span class="fc" id="L223">			return weights[idx];</span>
		}

		public void set(int idx, int weight) {
<span class="fc" id="L227">			checkIdx(idx);</span>
<span class="fc" id="L228">			weights[idx] = weight;</span>
<span class="fc" id="L229">		}</span>

		public int defaultValInt() {
<span class="nc" id="L232">			return defaultVal;</span>
		}

		@Override
		void add(int idx) {
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">			assert idx == size : &quot;only continues idxs are supported&quot;;</span>
<span class="fc" id="L238">			ensureCapacity(size + 1);</span>
<span class="fc" id="L239">			weights[idx] = defaultVal;</span>
<span class="fc" id="L240">			size++;</span>
<span class="fc" id="L241">		}</span>

		@Override
		void remove(int idx) {
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">			assert idx == size - 1 : &quot;only continues idxs are supported&quot;;</span>
<span class="fc" id="L246">			size--;</span>
<span class="fc" id="L247">		}</span>

		@Override
		void ensureCapacity(int capacity) {
<span class="fc bfc" id="L251" title="All 2 branches covered.">			if (capacity &lt; weights.length)</span>
<span class="fc" id="L252">				return;</span>
<span class="fc" id="L253">			int newLen = Math.max(2, weights.length * 2);</span>
<span class="fc" id="L254">			newLen = Math.max(newLen, capacity);</span>
<span class="fc" id="L255">			weights = Arrays.copyOf(weights, newLen);</span>
<span class="fc" id="L256">		}</span>

		@Override
		void swap(int i1, int i2) {
<span class="fc" id="L260">			checkIdx(i1);</span>
<span class="fc" id="L261">			checkIdx(i2);</span>
<span class="fc" id="L262">			int temp = weights[i1];</span>
<span class="fc" id="L263">			weights[i1] = weights[i2];</span>
<span class="fc" id="L264">			weights[i2] = temp;</span>
<span class="fc" id="L265">		}</span>

		@Override
		IntCollection values() {
<span class="nc" id="L269">			return values;</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L274" title="All 2 branches missed.">			if (this == other)</span>
<span class="nc" id="L275">				return true;</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Int))</span>
<span class="nc" id="L277">				return false;</span>
<span class="nc" id="L278">			DataContainer.Int o = (DataContainer.Int) other;</span>
<span class="nc" id="L279">			return Arrays.equals(weights, 0, size, o.weights, 0, o.size);</span>
		}

		@Override
		public int hashCode() {
<span class="nc" id="L284">			int h = 1;</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">			for (int i = 0; i &lt; size; i++)</span>
<span class="nc" id="L286">				h = 31 * h + weights[i];</span>
<span class="nc" id="L287">			return h;</span>
		}

		@Override
		public String toString() {
<span class="nc" id="L292">			int iMax = size - 1;</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">			if (iMax == -1)</span>
<span class="nc" id="L294">				return &quot;[]&quot;;</span>

<span class="nc" id="L296">			StringBuilder b = new StringBuilder();</span>
<span class="nc" id="L297">			b.append('[');</span>
<span class="nc" id="L298">			for (int i = 0;; i++) {</span>
<span class="nc" id="L299">				b.append(String.valueOf(weights[i]));</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">				if (i == iMax)</span>
<span class="nc" id="L301">					return b.append(']').toString();</span>
<span class="nc" id="L302">				b.append(&quot;, &quot;);</span>
			}
		}
	}

<span class="fc" id="L307">	static class Long extends DataContainer&lt;java.lang.Long&gt; {</span>

		private long[] weights;
		private final long defaultVal;
		private final LongCollection values;

<span class="fc" id="L313">		Long(int expectedSize, long defVal) {</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">			weights = expectedSize &gt; 0 ? new long[expectedSize] : LongArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L315">			defaultVal = defVal;</span>
<span class="fc" id="L316">			values = new AbstractLongCollection() {</span>

				@Override
				public int size() {
<span class="nc" id="L320">					return size;</span>
				}

				@Override
				public LongIterator iterator() {
<span class="nc" id="L325">					return new LongIterator() {</span>
<span class="nc" id="L326">						int idx = 0;</span>

						@Override
						public boolean hasNext() {
<span class="nc bnc" id="L330" title="All 2 branches missed.">							return idx &lt; size;</span>
						}

						@Override
						public long nextLong() {
<span class="nc bnc" id="L335" title="All 2 branches missed.">							if (!hasNext())</span>
<span class="nc" id="L336">								throw new NoSuchElementException();</span>
<span class="nc" id="L337">							return weights[idx++];</span>
						}
					};
				}
			};
<span class="fc" id="L342">		}</span>

		public long getLong(int idx) {
<span class="fc" id="L345">			checkIdx(idx);</span>
<span class="fc" id="L346">			return weights[idx];</span>
		}

		public void set(int idx, long weight) {
<span class="fc" id="L350">			checkIdx(idx);</span>
<span class="fc" id="L351">			weights[idx] = weight;</span>
<span class="fc" id="L352">		}</span>

		public long defaultValLong() {
<span class="nc" id="L355">			return defaultVal;</span>
		}

		@Override
		public void add(int idx) {
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">			assert idx == size : &quot;only continues idxs are supported&quot;;</span>
<span class="fc" id="L361">			ensureCapacity(size + 1);</span>
<span class="fc" id="L362">			weights[idx] = defaultVal;</span>
<span class="fc" id="L363">			size++;</span>
<span class="fc" id="L364">		}</span>

		@Override
		void remove(int idx) {
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">			assert idx == size - 1 : &quot;only continues idxs are supported&quot;;</span>
<span class="fc" id="L369">			size--;</span>
<span class="fc" id="L370">		}</span>

		@Override
		void ensureCapacity(int capacity) {
<span class="fc bfc" id="L374" title="All 2 branches covered.">			if (capacity &lt; weights.length)</span>
<span class="fc" id="L375">				return;</span>
<span class="fc" id="L376">			int newLen = Math.max(2, weights.length * 2);</span>
<span class="fc" id="L377">			newLen = Math.max(newLen, capacity);</span>
<span class="fc" id="L378">			weights = Arrays.copyOf(weights, newLen);</span>
<span class="fc" id="L379">		}</span>

		@Override
		void swap(int k1, int k2) {
<span class="fc" id="L383">			checkIdx(k1);</span>
<span class="fc" id="L384">			checkIdx(k2);</span>
<span class="fc" id="L385">			long temp = weights[k1];</span>
<span class="fc" id="L386">			weights[k1] = weights[k2];</span>
<span class="fc" id="L387">			weights[k2] = temp;</span>
<span class="fc" id="L388">		}</span>

		@Override
		LongCollection values() {
<span class="nc" id="L392">			return values;</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L397" title="All 2 branches missed.">			if (this == other)</span>
<span class="nc" id="L398">				return true;</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Long))</span>
<span class="nc" id="L400">				return false;</span>
<span class="nc" id="L401">			DataContainer.Long o = (DataContainer.Long) other;</span>
<span class="nc" id="L402">			return Arrays.equals(weights, 0, size, o.weights, 0, o.size);</span>
		}

		@Override
		public int hashCode() {
<span class="nc" id="L407">			int h = 1;</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">			for (int i = 0; i &lt; size; i++)</span>
<span class="nc" id="L409">				h = 31 * h + java.lang.Long.hashCode(weights[i]);</span>
<span class="nc" id="L410">			return h;</span>
		}

		@Override
		public String toString() {
<span class="nc" id="L415">			int iMax = size - 1;</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">			if (iMax == -1)</span>
<span class="nc" id="L417">				return &quot;[]&quot;;</span>

<span class="nc" id="L419">			StringBuilder b = new StringBuilder();</span>
<span class="nc" id="L420">			b.append('[');</span>
<span class="nc" id="L421">			for (int i = 0;; i++) {</span>
<span class="nc" id="L422">				b.append(String.valueOf(weights[i]));</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">				if (i == iMax)</span>
<span class="nc" id="L424">					return b.append(']').toString();</span>
<span class="nc" id="L425">				b.append(&quot;, &quot;);</span>
			}
		}
	}

<span class="fc" id="L430">	static class Double extends DataContainer&lt;java.lang.Double&gt; {</span>

		private double[] weights;
		private final double defaultVal;
		private final DoubleCollection values;

<span class="fc" id="L436">		Double(int expectedSize, double defVal) {</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">			weights = expectedSize &gt; 0 ? new double[expectedSize] : DoubleArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L438">			defaultVal = defVal;</span>
<span class="fc" id="L439">			values = new AbstractDoubleCollection() {</span>

				@Override
				public int size() {
<span class="nc" id="L443">					return size;</span>
				}

				@Override
				public DoubleIterator iterator() {
<span class="nc" id="L448">					return new DoubleIterator() {</span>
<span class="nc" id="L449">						int idx = 0;</span>

						@Override
						public boolean hasNext() {
<span class="nc bnc" id="L453" title="All 2 branches missed.">							return idx &lt; size;</span>
						}

						@Override
						public double nextDouble() {
<span class="nc bnc" id="L458" title="All 2 branches missed.">							if (!hasNext())</span>
<span class="nc" id="L459">								throw new NoSuchElementException();</span>
<span class="nc" id="L460">							return weights[idx++];</span>
						}
					};
				}
			};
<span class="fc" id="L465">		}</span>

		public double getDouble(int idx) {
<span class="fc" id="L468">			checkIdx(idx);</span>
<span class="fc" id="L469">			return weights[idx];</span>
		}

		public void set(int idx, double weight) {
<span class="fc" id="L473">			checkIdx(idx);</span>
<span class="fc" id="L474">			weights[idx] = weight;</span>
<span class="fc" id="L475">		}</span>

		public double defaultValDouble() {
<span class="nc" id="L478">			return defaultVal;</span>
		}

		@Override
		void add(int idx) {
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">			assert idx == size : &quot;only continues idxs are supported&quot;;</span>
<span class="fc" id="L484">			ensureCapacity(size + 1);</span>
<span class="fc" id="L485">			weights[idx] = defaultVal;</span>
<span class="fc" id="L486">			size++;</span>
<span class="fc" id="L487">		}</span>

		@Override
		void remove(int idx) {
<span class="nc bnc" id="L491" title="All 2 branches missed.">			assert idx == size - 1 : &quot;only continues idxs are supported&quot;;</span>
<span class="nc" id="L492">			size--;</span>
<span class="nc" id="L493">		}</span>

		@Override
		void ensureCapacity(int capacity) {
<span class="fc bfc" id="L497" title="All 2 branches covered.">			if (capacity &lt; weights.length)</span>
<span class="fc" id="L498">				return;</span>
<span class="fc" id="L499">			int newLen = Math.max(2, weights.length * 2);</span>
<span class="fc" id="L500">			newLen = Math.max(newLen, capacity);</span>
<span class="fc" id="L501">			weights = Arrays.copyOf(weights, newLen);</span>
<span class="fc" id="L502">		}</span>

		@Override
		void swap(int k1, int k2) {
<span class="nc" id="L506">			checkIdx(k1);</span>
<span class="nc" id="L507">			checkIdx(k2);</span>
<span class="nc" id="L508">			double temp = weights[k1];</span>
<span class="nc" id="L509">			weights[k1] = weights[k2];</span>
<span class="nc" id="L510">			weights[k2] = temp;</span>
<span class="nc" id="L511">		}</span>

		@Override
		DoubleCollection values() {
<span class="nc" id="L515">			return values;</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L520" title="All 2 branches missed.">			if (this == other)</span>
<span class="nc" id="L521">				return true;</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Double))</span>
<span class="nc" id="L523">				return false;</span>
<span class="nc" id="L524">			DataContainer.Double o = (DataContainer.Double) other;</span>
<span class="nc" id="L525">			return Arrays.equals(weights, 0, size, o.weights, 0, o.size);</span>
		}

		@Override
		public int hashCode() {
<span class="nc" id="L530">			int h = 1;</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">			for (int i = 0; i &lt; size; i++)</span>
<span class="nc" id="L532">				h = 31 * h + java.lang.Double.hashCode(weights[i]);</span>
<span class="nc" id="L533">			return h;</span>
		}

		@Override
		public String toString() {
<span class="nc" id="L538">			int iMax = size - 1;</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">			if (iMax == -1)</span>
<span class="nc" id="L540">				return &quot;[]&quot;;</span>

<span class="nc" id="L542">			StringBuilder b = new StringBuilder();</span>
<span class="nc" id="L543">			b.append('[');</span>
<span class="nc" id="L544">			for (int i = 0;; i++) {</span>
<span class="nc" id="L545">				b.append(String.valueOf(weights[i]));</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">				if (i == iMax)</span>
<span class="nc" id="L547">					return b.append(']').toString();</span>
<span class="nc" id="L548">				b.append(&quot;, &quot;);</span>
			}
		}
	}

<span class="fc" id="L553">	static class Bool extends DataContainer&lt;Boolean&gt; {</span>

		private final BitSet weights;
		private final boolean defaultVal;
		private final BooleanCollection values;

<span class="fc" id="L559">		Bool(int expectedSize, boolean defVal) {</span>
			// We don't do anything with expectedSize, but we keep it for forward
			// compatibility
<span class="fc" id="L562">			weights = new BitSet();</span>
<span class="fc" id="L563">			defaultVal = defVal;</span>
<span class="fc" id="L564">			values = new AbstractBooleanCollection() {</span>

				@Override
				public int size() {
<span class="nc" id="L568">					return size;</span>
				}

				@Override
				public BooleanIterator iterator() {
<span class="nc" id="L573">					return new BooleanIterator() {</span>
<span class="nc" id="L574">						int idx = 0;</span>

						@Override
						public boolean hasNext() {
<span class="nc bnc" id="L578" title="All 2 branches missed.">							return idx &lt; size;</span>
						}

						@Override
						public boolean nextBoolean() {
<span class="nc bnc" id="L583" title="All 2 branches missed.">							if (!hasNext())</span>
<span class="nc" id="L584">								throw new NoSuchElementException();</span>
<span class="nc" id="L585">							return weights.get(idx++);</span>
						}
					};
				}
			};
<span class="fc" id="L590">		}</span>

		public boolean getBool(int idx) {
<span class="fc" id="L593">			checkIdx(idx);</span>
<span class="fc" id="L594">			return weights.get(idx);</span>
		}

		public void set(int idx, boolean weight) {
<span class="fc" id="L598">			checkIdx(idx);</span>
<span class="fc" id="L599">			weights.set(idx, weight);</span>
<span class="fc" id="L600">		}</span>

		public boolean defaultValBool() {
<span class="nc" id="L603">			return defaultVal;</span>
		}

		@Override
		void add(int idx) {
<span class="pc bpc" id="L608" title="1 of 2 branches missed.">			assert idx == size : &quot;only continues idxs are supported&quot;;</span>
<span class="fc" id="L609">			weights.set(idx, defaultVal);</span>
<span class="fc" id="L610">			size++;</span>
<span class="fc" id="L611">		}</span>

		@Override
		void remove(int idx) {
<span class="nc bnc" id="L615" title="All 2 branches missed.">			assert idx == size - 1 : &quot;only continues idxs are supported&quot;;</span>
<span class="nc" id="L616">			size--;</span>
<span class="nc" id="L617">		}</span>

		@Override
		void ensureCapacity(int capacity) {
<span class="fc" id="L621">		}</span>

		@Override
		void swap(int k1, int k2) {
<span class="nc" id="L625">			checkIdx(k1);</span>
<span class="nc" id="L626">			checkIdx(k2);</span>
<span class="nc" id="L627">			boolean temp = weights.get(k1);</span>
<span class="nc" id="L628">			weights.set(k1, weights.get(k2));</span>
<span class="nc" id="L629">			weights.set(k2, temp);</span>
<span class="nc" id="L630">		}</span>

		@Override
		BooleanCollection values() {
<span class="nc" id="L634">			return values;</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L639" title="All 2 branches missed.">			if (this == other)</span>
<span class="nc" id="L640">				return true;</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Bool))</span>
<span class="nc" id="L642">				return false;</span>
<span class="nc" id="L643">			DataContainer.Bool o = (DataContainer.Bool) other;</span>
<span class="nc bnc" id="L644" title="All 4 branches missed.">			return size == o.size &amp;&amp; weights.equals(o.weights);</span>
		}

		@Override
		public int hashCode() {
<span class="nc" id="L649">			return size * 1237 ^ weights.hashCode();</span>
		}

		@Override
		public String toString() {
<span class="nc" id="L654">			int iMax = size - 1;</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">			if (iMax == -1)</span>
<span class="nc" id="L656">				return &quot;[]&quot;;</span>

<span class="nc" id="L658">			StringBuilder b = new StringBuilder();</span>
<span class="nc" id="L659">			b.append('[');</span>
<span class="nc" id="L660">			for (int i = 0;; i++) {</span>
<span class="nc" id="L661">				b.append(String.valueOf(weights.get(i)));</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">				if (i == iMax)</span>
<span class="nc" id="L663">					return b.append(']').toString();</span>
<span class="nc" id="L664">				b.append(&quot;, &quot;);</span>
			}
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>