<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataContainer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo</a> &gt; <span class="el_source">DataContainer.java</span></div><h1>DataContainer.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jgalgo;

import java.util.Arrays;
import java.util.BitSet;
import java.util.Collection;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import it.unimi.dsi.fastutil.booleans.AbstractBooleanList;
import it.unimi.dsi.fastutil.booleans.BooleanCollection;
import it.unimi.dsi.fastutil.booleans.BooleanListIterator;
import it.unimi.dsi.fastutil.bytes.AbstractByteList;
import it.unimi.dsi.fastutil.bytes.ByteArrays;
import it.unimi.dsi.fastutil.bytes.ByteCollection;
import it.unimi.dsi.fastutil.bytes.ByteIterators;
import it.unimi.dsi.fastutil.bytes.ByteListIterator;
import it.unimi.dsi.fastutil.chars.AbstractCharList;
import it.unimi.dsi.fastutil.chars.CharArrays;
import it.unimi.dsi.fastutil.chars.CharCollection;
import it.unimi.dsi.fastutil.chars.CharIterators;
import it.unimi.dsi.fastutil.chars.CharListIterator;
import it.unimi.dsi.fastutil.doubles.AbstractDoubleList;
import it.unimi.dsi.fastutil.doubles.DoubleArrays;
import it.unimi.dsi.fastutil.doubles.DoubleCollection;
import it.unimi.dsi.fastutil.doubles.DoubleIterators;
import it.unimi.dsi.fastutil.doubles.DoubleListIterator;
import it.unimi.dsi.fastutil.floats.AbstractFloatList;
import it.unimi.dsi.fastutil.floats.FloatArrays;
import it.unimi.dsi.fastutil.floats.FloatCollection;
import it.unimi.dsi.fastutil.floats.FloatIterators;
import it.unimi.dsi.fastutil.floats.FloatListIterator;
import it.unimi.dsi.fastutil.ints.AbstractIntList;
import it.unimi.dsi.fastutil.ints.IntArrays;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntIterators;
import it.unimi.dsi.fastutil.ints.IntListIterator;
import it.unimi.dsi.fastutil.longs.AbstractLongList;
import it.unimi.dsi.fastutil.longs.LongArrays;
import it.unimi.dsi.fastutil.longs.LongCollection;
import it.unimi.dsi.fastutil.longs.LongIterators;
import it.unimi.dsi.fastutil.longs.LongListIterator;
import it.unimi.dsi.fastutil.objects.AbstractObjectList;
import it.unimi.dsi.fastutil.objects.Object2ObjectArrayMap;
import it.unimi.dsi.fastutil.objects.ObjectArrays;
import it.unimi.dsi.fastutil.objects.ObjectCollection;
import it.unimi.dsi.fastutil.objects.ObjectIterators;
import it.unimi.dsi.fastutil.objects.ObjectListIterator;
import it.unimi.dsi.fastutil.shorts.AbstractShortList;
import it.unimi.dsi.fastutil.shorts.ShortArrays;
import it.unimi.dsi.fastutil.shorts.ShortCollection;
import it.unimi.dsi.fastutil.shorts.ShortIterators;
import it.unimi.dsi.fastutil.shorts.ShortListIterator;

abstract class DataContainer&lt;E&gt; {
	final IDStrategy idStrat;

<span class="fc" id="L73">	DataContainer(IDStrategy idStrat) {</span>
<span class="fc" id="L74">		this.idStrat = Objects.requireNonNull(idStrat);</span>
<span class="fc" id="L75">	}</span>

	abstract int capacity();

	abstract void expand(int newCapacity);

	abstract void clear(int idx);

	abstract void clear();

	abstract void swap(int idx1, int idx2);

	abstract Collection&lt;E&gt; values();

	abstract Class&lt;E&gt; getTypeClass();

	abstract DataContainer&lt;E&gt; copy(IDStrategy idStrat);

	int size() {
<span class="fc" id="L94">		return idStrat.size();</span>
	}

	@Override
	public int hashCode() {
<span class="nc" id="L99">		return values().hashCode();</span>
	}

	@Override
	public String toString() {
<span class="nc" id="L104">		return values().toString();</span>
	}

	void checkIdx(int idx) {
<span class="pc bpc" id="L108" title="2 of 4 branches missed.">		if (!(0 &lt;= idx &amp;&amp; idx &lt; idStrat.size()))</span>
<span class="nc" id="L109">			throw new IndexOutOfBoundsException(idx);</span>
<span class="fc" id="L110">	}</span>

	static &lt;D&gt; DataContainer&lt;D&gt; newInstance(IDStrategy idStart, Class&lt;? super D&gt; type, D defVal) {
		@SuppressWarnings(&quot;rawtypes&quot;)
		DataContainer container;
<span class="fc bfc" id="L115" title="All 2 branches covered.">		if (type == byte.class) {</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">			byte defVal0 = defVal != null ? ((java.lang.Byte) defVal).byteValue() : 0;</span>
<span class="fc" id="L117">			container = new DataContainer.Byte(idStart, defVal0);</span>

<span class="fc bfc" id="L119" title="All 2 branches covered.">		} else if (type == short.class) {</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">			short defVal0 = defVal != null ? ((java.lang.Short) defVal).shortValue() : 0;</span>
<span class="fc" id="L121">			container = new DataContainer.Short(idStart, defVal0);</span>

<span class="fc bfc" id="L123" title="All 2 branches covered.">		} else if (type == int.class) {</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">			int defVal0 = defVal != null ? ((Integer) defVal).intValue() : 0;</span>
<span class="fc" id="L125">			container = new DataContainer.Int(idStart, defVal0);</span>

<span class="fc bfc" id="L127" title="All 2 branches covered.">		} else if (type == long.class) {</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">			long defVal0 = defVal != null ? ((java.lang.Long) defVal).longValue() : 0;</span>
<span class="fc" id="L129">			container = new DataContainer.Long(idStart, defVal0);</span>

<span class="fc bfc" id="L131" title="All 2 branches covered.">		} else if (type == float.class) {</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">			float defVal0 = defVal != null ? ((java.lang.Float) defVal).floatValue() : 0;</span>
<span class="fc" id="L133">			container = new DataContainer.Float(idStart, defVal0);</span>

<span class="fc bfc" id="L135" title="All 2 branches covered.">		} else if (type == double.class) {</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">			double defVal0 = defVal != null ? ((java.lang.Double) defVal).doubleValue() : 0;</span>
<span class="fc" id="L137">			container = new DataContainer.Double(idStart, defVal0);</span>

<span class="fc bfc" id="L139" title="All 2 branches covered.">		} else if (type == boolean.class) {</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">			boolean defVal0 = defVal != null ? ((Boolean) defVal).booleanValue() : false;</span>
<span class="fc" id="L141">			container = new DataContainer.Bool(idStart, defVal0);</span>

<span class="fc bfc" id="L143" title="All 2 branches covered.">		} else if (type == char.class) {</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">			char defVal0 = defVal != null ? ((Character) defVal).charValue() : 0;</span>
<span class="fc" id="L145">			container = new DataContainer.Char(idStart, defVal0);</span>

<span class="fc" id="L147">		} else {</span>
<span class="fc" id="L148">			container = new DataContainer.Obj&lt;&gt;(idStart, defVal, type);</span>
		}
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L151">		DataContainer&lt;D&gt; container0 = container;</span>
<span class="fc" id="L152">		return container0;</span>
	}

<span class="fc" id="L155">	static class Obj&lt;E&gt; extends DataContainer&lt;E&gt; {</span>

		private Object[] weights;
		private final E defaultVal;
		private final ObjectCollection&lt;E&gt; values;
		private final Class&lt;E&gt; type;

		Obj(IDStrategy idStrat, E defVal, Class&lt;E&gt; type) {
<span class="fc" id="L163">			super(idStrat);</span>

<span class="fc" id="L165">			defaultVal = defVal;</span>
<span class="fc" id="L166">			weights = ObjectArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L167">			Arrays.fill(weights, defaultVal);</span>

<span class="fc" id="L169">			this.type = Objects.requireNonNull(type);</span>
<span class="fc" id="L170">			values = new AbstractObjectList&lt;&gt;() {</span>
				@Override
				public int size() {
<span class="fc" id="L173">					return DataContainer.Obj.super.size();</span>
				}

				@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
				@Override
				public ObjectListIterator&lt;E&gt; iterator() {
<span class="fc" id="L179">					return (ObjectListIterator) ObjectIterators.wrap(weights, 0, size());</span>
				}

				@SuppressWarnings(&quot;unchecked&quot;)
				@Override
				public E get(int index) {
<span class="nc" id="L185">					checkIdx(index);</span>
<span class="nc" id="L186">					return (E) weights[index];</span>
				}
			};
<span class="fc" id="L189">		}</span>

		@SuppressWarnings(&quot;unchecked&quot;)
		public E get(int idx) {
<span class="fc" id="L193">			checkIdx(idx);</span>
<span class="fc" id="L194">			return (E) weights[idx];</span>
		}

		void set(int idx, E weight) {
<span class="fc" id="L198">			checkIdx(idx);</span>
<span class="fc" id="L199">			weights[idx] = weight;</span>
<span class="fc" id="L200">		}</span>

		E defaultVal() {
<span class="fc" id="L203">			return defaultVal;</span>
		}

		@Override
		int capacity() {
<span class="fc" id="L208">			return weights.length;</span>
		}

		@Override
		void expand(int newCapacity) {
<span class="fc" id="L213">			int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">			assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L215">			weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L216">			Arrays.fill(weights, oldCapacity, newCapacity, defaultVal);</span>
<span class="fc" id="L217">		}</span>

		@Override
		void swap(int idx1, int idx2) {
<span class="fc" id="L221">			checkIdx(idx1);</span>
<span class="fc" id="L222">			checkIdx(idx2);</span>
<span class="fc" id="L223">			ObjectArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L224">		}</span>

		@Override
		void clear(int idx) {
			// checkIdx(idx);
<span class="fc" id="L229">			weights[idx] = defaultVal;</span>
<span class="fc" id="L230">		}</span>

		@Override
		void clear() {
<span class="fc" id="L234">			Arrays.fill(weights, 0, size(), defaultVal);</span>
<span class="fc" id="L235">		}</span>

		@Override
		Collection&lt;E&gt; values() {
<span class="fc" id="L239">			return values;</span>
		}

		@Override
		Class&lt;E&gt; getTypeClass() {
<span class="nc" id="L244">			return type;</span>
		}

		@Override
		DataContainer.Obj&lt;E&gt; copy(IDStrategy idStrat) {
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">			if (idStrat.size() != this.idStrat.size())</span>
<span class="nc" id="L250">				throw new IllegalArgumentException();</span>
<span class="fc" id="L251">			DataContainer.Obj&lt;E&gt; copy = new DataContainer.Obj&lt;&gt;(idStrat, defaultVal, type);</span>
<span class="fc" id="L252">			copy.weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="fc" id="L253">			return copy;</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L258" title="All 2 branches missed.">			if (other == this)</span>
<span class="nc" id="L259">				return true;</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Obj&lt;?&gt;))</span>
<span class="nc" id="L261">				return false;</span>
<span class="nc" id="L262">			DataContainer.Obj&lt;?&gt; o = (DataContainer.Obj&lt;?&gt;) other;</span>
<span class="nc" id="L263">			return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
		}
	}

<span class="fc" id="L267">	static class Byte extends DataContainer&lt;java.lang.Byte&gt; {</span>

		private byte[] weights;
		private final byte defaultVal;
		private final ByteCollection values;

		Byte(IDStrategy idStrat, byte defVal) {
<span class="fc" id="L274">			super(idStrat);</span>

<span class="fc" id="L276">			weights = ByteArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L277">			defaultVal = defVal;</span>
<span class="fc" id="L278">			values = new AbstractByteList() {</span>

				@Override
				public int size() {
<span class="nc" id="L282">					return DataContainer.Byte.super.size();</span>
				}

				@Override
				public ByteListIterator iterator() {
<span class="nc" id="L287">					return ByteIterators.wrap(weights, 0, size());</span>
				}

				@Override
				public byte getByte(int index) {
<span class="nc" id="L292">					checkIdx(index);</span>
<span class="nc" id="L293">					return weights[index];</span>
				}
			};
<span class="fc" id="L296">		}</span>

		byte getByte(int idx) {
<span class="fc" id="L299">			checkIdx(idx);</span>
<span class="fc" id="L300">			return weights[idx];</span>
		}

		void set(int idx, byte weight) {
<span class="fc" id="L304">			checkIdx(idx);</span>
<span class="fc" id="L305">			weights[idx] = weight;</span>
<span class="fc" id="L306">		}</span>

		byte defaultValByte() {
<span class="fc" id="L309">			return defaultVal;</span>
		}

		@Override
		int capacity() {
<span class="fc" id="L314">			return weights.length;</span>
		}

		@Override
		void expand(int newCapacity) {
<span class="fc" id="L319">			int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">			assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L321">			weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L322">			Arrays.fill(weights, oldCapacity, newCapacity, defaultVal);</span>
<span class="fc" id="L323">		}</span>

		@Override
		void swap(int idx1, int idx2) {
<span class="fc" id="L327">			checkIdx(idx1);</span>
<span class="fc" id="L328">			checkIdx(idx2);</span>
<span class="fc" id="L329">			ByteArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L330">		}</span>

		@Override
		void clear(int idx) {
			// checkIdx(idx);
<span class="fc" id="L335">			weights[idx] = defaultVal;</span>
<span class="fc" id="L336">		}</span>

		@Override
		void clear() {
<span class="nc" id="L340">			Arrays.fill(weights, 0, size(), defaultVal);</span>
<span class="nc" id="L341">		}</span>

		@Override
		ByteCollection values() {
<span class="nc" id="L345">			return values;</span>
		}

		@Override
		Class&lt;java.lang.Byte&gt; getTypeClass() {
<span class="nc" id="L350">			return byte.class;</span>
		}

		@Override
		DataContainer.Byte copy(IDStrategy idStrat) {
<span class="nc bnc" id="L355" title="All 2 branches missed.">			if (idStrat.size() != this.idStrat.size())</span>
<span class="nc" id="L356">				throw new IllegalArgumentException();</span>
<span class="nc" id="L357">			DataContainer.Byte copy = new DataContainer.Byte(idStrat, defaultVal);</span>
<span class="nc" id="L358">			copy.weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="nc" id="L359">			return copy;</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L364" title="All 2 branches missed.">			if (this == other)</span>
<span class="nc" id="L365">				return true;</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Byte))</span>
<span class="nc" id="L367">				return false;</span>
<span class="nc" id="L368">			DataContainer.Byte o = (DataContainer.Byte) other;</span>
<span class="nc" id="L369">			return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
		}
	}

<span class="fc" id="L373">	static class Short extends DataContainer&lt;java.lang.Short&gt; {</span>

		private short[] weights;
		private final short defaultVal;
		private final ShortCollection values;

		Short(IDStrategy idStrat, short defVal) {
<span class="fc" id="L380">			super(idStrat);</span>

<span class="fc" id="L382">			weights = ShortArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L383">			defaultVal = defVal;</span>
<span class="fc" id="L384">			values = new AbstractShortList() {</span>

				@Override
				public int size() {
<span class="nc" id="L388">					return DataContainer.Short.super.size();</span>
				}

				@Override
				public ShortListIterator iterator() {
<span class="nc" id="L393">					return ShortIterators.wrap(weights, 0, size());</span>
				}

				@Override
				public short getShort(int index) {
<span class="nc" id="L398">					checkIdx(index);</span>
<span class="nc" id="L399">					return weights[index];</span>
				}
			};
<span class="fc" id="L402">		}</span>

		short getShort(int idx) {
<span class="fc" id="L405">			checkIdx(idx);</span>
<span class="fc" id="L406">			return weights[idx];</span>
		}

		void set(int idx, short weight) {
<span class="fc" id="L410">			checkIdx(idx);</span>
<span class="fc" id="L411">			weights[idx] = weight;</span>
<span class="fc" id="L412">		}</span>

		short defaultValShort() {
<span class="fc" id="L415">			return defaultVal;</span>
		}

		@Override
		int capacity() {
<span class="fc" id="L420">			return weights.length;</span>
		}

		@Override
		void expand(int newCapacity) {
<span class="fc" id="L425">			int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">			assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L427">			weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L428">			Arrays.fill(weights, oldCapacity, newCapacity, defaultVal);</span>
<span class="fc" id="L429">		}</span>

		@Override
		void swap(int idx1, int idx2) {
<span class="fc" id="L433">			checkIdx(idx1);</span>
<span class="fc" id="L434">			checkIdx(idx2);</span>
<span class="fc" id="L435">			ShortArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L436">		}</span>

		@Override
		void clear(int idx) {
			// checkIdx(idx);
<span class="fc" id="L441">			weights[idx] = defaultVal;</span>
<span class="fc" id="L442">		}</span>

		@Override
		void clear() {
<span class="nc" id="L446">			Arrays.fill(weights, 0, size(), defaultVal);</span>
<span class="nc" id="L447">		}</span>

		@Override
		ShortCollection values() {
<span class="nc" id="L451">			return values;</span>
		}

		@Override
		Class&lt;java.lang.Short&gt; getTypeClass() {
<span class="nc" id="L456">			return short.class;</span>
		}

		@Override
		DataContainer.Short copy(IDStrategy idStrat) {
<span class="nc bnc" id="L461" title="All 2 branches missed.">			if (idStrat.size() != this.idStrat.size())</span>
<span class="nc" id="L462">				throw new IllegalArgumentException();</span>
<span class="nc" id="L463">			DataContainer.Short copy = new DataContainer.Short(idStrat, defaultVal);</span>
<span class="nc" id="L464">			copy.weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="nc" id="L465">			return copy;</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L470" title="All 2 branches missed.">			if (this == other)</span>
<span class="nc" id="L471">				return true;</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Short))</span>
<span class="nc" id="L473">				return false;</span>
<span class="nc" id="L474">			DataContainer.Short o = (DataContainer.Short) other;</span>
<span class="nc" id="L475">			return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
		}
	}

<span class="fc" id="L479">	static class Int extends DataContainer&lt;Integer&gt; {</span>

		private int[] weights;
		private final int defaultVal;
		private final IntCollection values;

		Int(IDStrategy idStrat, int defVal) {
<span class="fc" id="L486">			super(idStrat);</span>

<span class="fc" id="L488">			weights = IntArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L489">			defaultVal = defVal;</span>
<span class="fc" id="L490">			values = new AbstractIntList() {</span>

				@Override
				public int size() {
<span class="nc" id="L494">					return DataContainer.Int.super.size();</span>
				}

				@Override
				public IntListIterator iterator() {
<span class="nc" id="L499">					return IntIterators.wrap(weights, 0, size());</span>
				}

				@Override
				public int getInt(int index) {
<span class="nc" id="L504">					checkIdx(index);</span>
<span class="nc" id="L505">					return weights[index];</span>
				}
			};
<span class="fc" id="L508">		}</span>

		int getInt(int idx) {
<span class="fc" id="L511">			checkIdx(idx);</span>
<span class="fc" id="L512">			return weights[idx];</span>
		}

		void set(int idx, int weight) {
<span class="fc" id="L516">			checkIdx(idx);</span>
<span class="fc" id="L517">			weights[idx] = weight;</span>
<span class="fc" id="L518">		}</span>

		int defaultValInt() {
<span class="fc" id="L521">			return defaultVal;</span>
		}

		@Override
		int capacity() {
<span class="fc" id="L526">			return weights.length;</span>
		}

		@Override
		void expand(int newCapacity) {
<span class="fc" id="L531">			int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">			assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L533">			weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L534">			Arrays.fill(weights, oldCapacity, newCapacity, defaultVal);</span>
<span class="fc" id="L535">		}</span>

		@Override
		void swap(int idx1, int idx2) {
<span class="fc" id="L539">			checkIdx(idx1);</span>
<span class="fc" id="L540">			checkIdx(idx2);</span>
<span class="fc" id="L541">			IntArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L542">		}</span>

		@Override
		void clear(int idx) {
			// checkIdx(idx);
<span class="fc" id="L547">			weights[idx] = defaultVal;</span>
<span class="fc" id="L548">		}</span>

		@Override
		void clear() {
<span class="fc" id="L552">			Arrays.fill(weights, 0, size(), defaultVal);</span>
<span class="fc" id="L553">		}</span>

		@Override
		IntCollection values() {
<span class="nc" id="L557">			return values;</span>
		}

		@Override
		Class&lt;Integer&gt; getTypeClass() {
<span class="nc" id="L562">			return int.class;</span>
		}

		@Override
		DataContainer.Int copy(IDStrategy idStrat) {
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">			if (idStrat.size() != this.idStrat.size())</span>
<span class="nc" id="L568">				throw new IllegalArgumentException();</span>
<span class="fc" id="L569">			DataContainer.Int copy = new DataContainer.Int(idStrat, defaultVal);</span>
<span class="fc" id="L570">			copy.weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="fc" id="L571">			return copy;</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L576" title="All 2 branches missed.">			if (this == other)</span>
<span class="nc" id="L577">				return true;</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Int))</span>
<span class="nc" id="L579">				return false;</span>
<span class="nc" id="L580">			DataContainer.Int o = (DataContainer.Int) other;</span>
<span class="nc" id="L581">			return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
		}
	}

<span class="fc" id="L585">	static class Long extends DataContainer&lt;java.lang.Long&gt; {</span>

		private long[] weights;
		private final long defaultVal;
<span class="fc" id="L589">		private final LongCollection values = new AbstractLongList() {</span>

			@Override
			public int size() {
<span class="nc" id="L593">				return DataContainer.Long.super.size();</span>
			}

			@Override
			public LongListIterator iterator() {
<span class="nc" id="L598">				return LongIterators.wrap(weights, 0, size());</span>
			}

			@Override
			public long getLong(int index) {
<span class="nc" id="L603">				checkIdx(index);</span>
<span class="nc" id="L604">				return weights[index];</span>
			}
		};

		Long(IDStrategy idStrat, long defVal) {
<span class="fc" id="L609">			super(idStrat);</span>

<span class="fc" id="L611">			weights = LongArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L612">			defaultVal = defVal;</span>
<span class="fc" id="L613">		}</span>

		Long(DataContainer.Long orig, IDStrategy idStrat) {
<span class="fc" id="L616">			super(idStrat);</span>
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">			if (idStrat.size() != this.idStrat.size())</span>
<span class="nc" id="L618">				throw new IllegalArgumentException();</span>

<span class="fc" id="L620">			weights = Arrays.copyOf(orig.weights, idStrat.size());</span>
<span class="fc" id="L621">			defaultVal = orig.defaultVal;</span>
<span class="fc" id="L622">		}</span>

		long getLong(int idx) {
<span class="fc" id="L625">			checkIdx(idx);</span>
<span class="fc" id="L626">			return weights[idx];</span>
		}

		void set(int idx, long weight) {
<span class="fc" id="L630">			checkIdx(idx);</span>
<span class="fc" id="L631">			weights[idx] = weight;</span>
<span class="fc" id="L632">		}</span>

		long defaultValLong() {
<span class="fc" id="L635">			return defaultVal;</span>
		}

		@Override
		int capacity() {
<span class="fc" id="L640">			return weights.length;</span>
		}

		@Override
		void expand(int newCapacity) {
<span class="fc" id="L645">			int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">			assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L647">			weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L648">			Arrays.fill(weights, oldCapacity, newCapacity, defaultVal);</span>
<span class="fc" id="L649">		}</span>

		@Override
		void swap(int idx1, int idx2) {
<span class="fc" id="L653">			checkIdx(idx1);</span>
<span class="fc" id="L654">			checkIdx(idx2);</span>
<span class="fc" id="L655">			LongArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L656">		}</span>

		@Override
		void clear(int idx) {
			// checkIdx(idx);
<span class="fc" id="L661">			weights[idx] = defaultVal;</span>
<span class="fc" id="L662">		}</span>

		@Override
		void clear() {
<span class="fc" id="L666">			Arrays.fill(weights, 0, size(), defaultVal);</span>
<span class="fc" id="L667">		}</span>

		@Override
		LongCollection values() {
<span class="nc" id="L671">			return values;</span>
		}

		@Override
		Class&lt;java.lang.Long&gt; getTypeClass() {
<span class="nc" id="L676">			return long.class;</span>
		}

		@Override
		DataContainer.Long copy(IDStrategy idStrat) {
<span class="nc" id="L681">			return new DataContainer.Long(this, idStrat);</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L686" title="All 2 branches missed.">			if (this == other)</span>
<span class="nc" id="L687">				return true;</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Long))</span>
<span class="nc" id="L689">				return false;</span>
<span class="nc" id="L690">			DataContainer.Long o = (DataContainer.Long) other;</span>
<span class="nc" id="L691">			return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
		}
	}

<span class="fc" id="L695">	static class Float extends DataContainer&lt;java.lang.Float&gt; {</span>

		private float[] weights;
		private final float defaultVal;
		private final FloatCollection values;

		Float(IDStrategy idStrat, float defVal) {
<span class="fc" id="L702">			super(idStrat);</span>

<span class="fc" id="L704">			weights = FloatArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L705">			defaultVal = defVal;</span>
<span class="fc" id="L706">			values = new AbstractFloatList() {</span>

				@Override
				public int size() {
<span class="nc" id="L710">					return DataContainer.Float.super.size();</span>
				}

				@Override
				public FloatListIterator iterator() {
<span class="nc" id="L715">					return FloatIterators.wrap(weights, 0, size());</span>
				}

				@Override
				public float getFloat(int index) {
<span class="nc" id="L720">					checkIdx(index);</span>
<span class="nc" id="L721">					return weights[index];</span>
				}
			};
<span class="fc" id="L724">		}</span>

		float getFloat(int idx) {
<span class="fc" id="L727">			checkIdx(idx);</span>
<span class="fc" id="L728">			return weights[idx];</span>
		}

		void set(int idx, float weight) {
<span class="fc" id="L732">			checkIdx(idx);</span>
<span class="fc" id="L733">			weights[idx] = weight;</span>
<span class="fc" id="L734">		}</span>

		float defaultValFloat() {
<span class="fc" id="L737">			return defaultVal;</span>
		}

		@Override
		int capacity() {
<span class="fc" id="L742">			return weights.length;</span>
		}

		@Override
		void expand(int newCapacity) {
<span class="fc" id="L747">			int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L748" title="1 of 2 branches missed.">			assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L749">			weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L750">			Arrays.fill(weights, oldCapacity, newCapacity, defaultVal);</span>
<span class="fc" id="L751">		}</span>

		@Override
		void swap(int idx1, int idx2) {
<span class="fc" id="L755">			checkIdx(idx1);</span>
<span class="fc" id="L756">			checkIdx(idx2);</span>
<span class="fc" id="L757">			FloatArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L758">		}</span>

		@Override
		void clear(int idx) {
			// checkIdx(idx);
<span class="fc" id="L763">			weights[idx] = defaultVal;</span>
<span class="fc" id="L764">		}</span>

		@Override
		void clear() {
<span class="nc" id="L768">			Arrays.fill(weights, 0, size(), defaultVal);</span>
<span class="nc" id="L769">		}</span>

		@Override
		FloatCollection values() {
<span class="nc" id="L773">			return values;</span>
		}

		@Override
		Class&lt;java.lang.Float&gt; getTypeClass() {
<span class="nc" id="L778">			return float.class;</span>
		}

		@Override
		DataContainer.Float copy(IDStrategy idStrat) {
<span class="nc bnc" id="L783" title="All 2 branches missed.">			if (idStrat.size() != this.idStrat.size())</span>
<span class="nc" id="L784">				throw new IllegalArgumentException();</span>
<span class="nc" id="L785">			DataContainer.Float copy = new DataContainer.Float(idStrat, defaultVal);</span>
<span class="nc" id="L786">			copy.weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="nc" id="L787">			return copy;</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L792" title="All 2 branches missed.">			if (this == other)</span>
<span class="nc" id="L793">				return true;</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Float))</span>
<span class="nc" id="L795">				return false;</span>
<span class="nc" id="L796">			DataContainer.Float o = (DataContainer.Float) other;</span>
<span class="nc" id="L797">			return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
		}
	}

<span class="fc" id="L801">	static class Double extends DataContainer&lt;java.lang.Double&gt; {</span>

		private double[] weights;
		private final double defaultVal;
		private final DoubleCollection values;

		Double(IDStrategy idStrat, double defVal) {
<span class="fc" id="L808">			super(idStrat);</span>

<span class="fc" id="L810">			weights = DoubleArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L811">			defaultVal = defVal;</span>
<span class="fc" id="L812">			values = new AbstractDoubleList() {</span>

				@Override
				public int size() {
<span class="nc" id="L816">					return DataContainer.Double.super.size();</span>
				}

				@Override
				public DoubleListIterator iterator() {
<span class="nc" id="L821">					return DoubleIterators.wrap(weights, 0, size());</span>
				}

				@Override
				public double getDouble(int index) {
<span class="nc" id="L826">					checkIdx(index);</span>
<span class="nc" id="L827">					return weights[index];</span>
				}
			};
<span class="fc" id="L830">		}</span>

		double getDouble(int idx) {
<span class="fc" id="L833">			checkIdx(idx);</span>
<span class="fc" id="L834">			return weights[idx];</span>
		}

		void set(int idx, double weight) {
<span class="fc" id="L838">			checkIdx(idx);</span>
<span class="fc" id="L839">			weights[idx] = weight;</span>
<span class="fc" id="L840">		}</span>

		double defaultValDouble() {
<span class="fc" id="L843">			return defaultVal;</span>
		}

		@Override
		int capacity() {
<span class="fc" id="L848">			return weights.length;</span>
		}

		@Override
		void expand(int newCapacity) {
<span class="fc" id="L853">			int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L854" title="1 of 2 branches missed.">			assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L855">			weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L856">			Arrays.fill(weights, oldCapacity, newCapacity, defaultVal);</span>
<span class="fc" id="L857">		}</span>

		@Override
		void swap(int idx1, int idx2) {
<span class="fc" id="L861">			checkIdx(idx1);</span>
<span class="fc" id="L862">			checkIdx(idx2);</span>
<span class="fc" id="L863">			DoubleArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L864">		}</span>

		@Override
		void clear(int idx) {
			// checkIdx(idx);
<span class="fc" id="L869">			weights[idx] = defaultVal;</span>
<span class="fc" id="L870">		}</span>

		@Override
		void clear() {
<span class="fc" id="L874">			Arrays.fill(weights, 0, size(), defaultVal);</span>
<span class="fc" id="L875">		}</span>

		@Override
		DoubleCollection values() {
<span class="nc" id="L879">			return values;</span>
		}

		@Override
		Class&lt;java.lang.Double&gt; getTypeClass() {
<span class="nc" id="L884">			return double.class;</span>
		}

		@Override
		DataContainer.Double copy(IDStrategy idStrat) {
<span class="nc bnc" id="L889" title="All 2 branches missed.">			if (idStrat.size() != this.idStrat.size())</span>
<span class="nc" id="L890">				throw new IllegalArgumentException();</span>
<span class="nc" id="L891">			DataContainer.Double copy = new DataContainer.Double(idStrat, defaultVal);</span>
<span class="nc" id="L892">			copy.weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="nc" id="L893">			return copy;</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L898" title="All 2 branches missed.">			if (this == other)</span>
<span class="nc" id="L899">				return true;</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Double))</span>
<span class="nc" id="L901">				return false;</span>
<span class="nc" id="L902">			DataContainer.Double o = (DataContainer.Double) other;</span>
<span class="nc" id="L903">			return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
		}
	}

<span class="fc" id="L907">	static class Bool extends DataContainer&lt;Boolean&gt; {</span>

		private final BitSet weights;
		private int capacity;
		private final boolean defaultVal;
<span class="pc" id="L912">		private final BooleanCollection values = new AbstractBooleanList() {</span>

			@Override
			public int size() {
<span class="nc" id="L916">				return DataContainer.Bool.super.size();</span>
			}

			@Override
			public BooleanListIterator iterator() {
<span class="nc" id="L921">				return new BooleanListIterator() {</span>
<span class="nc" id="L922">					int idx = 0;</span>

					@Override
					public boolean hasNext() {
<span class="nc bnc" id="L926" title="All 2 branches missed.">						return idx &lt; size();</span>
					}

					@Override
					public boolean nextBoolean() {
<span class="nc bnc" id="L931" title="All 2 branches missed.">						if (!hasNext())</span>
<span class="nc" id="L932">							throw new NoSuchElementException();</span>
<span class="nc" id="L933">						return weights.get(idx++);</span>
					}

					@Override
					public boolean previousBoolean() {
<span class="nc bnc" id="L938" title="All 2 branches missed.">						if (!hasPrevious())</span>
<span class="nc" id="L939">							throw new NoSuchElementException();</span>
<span class="nc" id="L940">						return weights.get(--idx);</span>
					}

					@Override
					public boolean hasPrevious() {
<span class="nc bnc" id="L945" title="All 2 branches missed.">						return idx &gt; 0;</span>
					}

					@Override
					public int nextIndex() {
<span class="nc" id="L950">						return idx;</span>
					}

					@Override
					public int previousIndex() {
<span class="nc" id="L955">						return idx - 1;</span>
					}
				};
			}

			@Override
			public boolean getBoolean(int index) {
<span class="nc" id="L962">				checkIdx(index);</span>
<span class="nc" id="L963">				return weights.get(index);</span>
			}
		};

		Bool(DataContainer.Bool orig, IDStrategy idStrat) {
<span class="nc" id="L968">			super(idStrat);</span>
<span class="nc" id="L969">			defaultVal = orig.defaultVal;</span>
<span class="nc" id="L970">			weights = (BitSet) orig.weights.clone();</span>
<span class="nc" id="L971">		}</span>

		Bool(IDStrategy idStrat, boolean defVal) {
<span class="fc" id="L974">			super(idStrat);</span>

<span class="fc" id="L976">			defaultVal = defVal;</span>
<span class="fc" id="L977">			weights = new BitSet();</span>
<span class="fc" id="L978">		}</span>

		boolean getBool(int idx) {
<span class="fc" id="L981">			checkIdx(idx);</span>
<span class="fc" id="L982">			return weights.get(idx);</span>
		}

		void set(int idx, boolean weight) {
<span class="fc" id="L986">			checkIdx(idx);</span>
<span class="fc" id="L987">			weights.set(idx, weight);</span>
<span class="fc" id="L988">		}</span>

		boolean defaultValBool() {
<span class="fc" id="L991">			return defaultVal;</span>
		}

		@Override
		int capacity() {
<span class="fc" id="L996">			return capacity;</span>
		}

		@Override
		void expand(int newCapacity) {
<span class="fc" id="L1001">			int oldCapacity = capacity;</span>
<span class="pc bpc" id="L1002" title="1 of 2 branches missed.">			assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L1003">			capacity = newCapacity;</span>
<span class="fc bfc" id="L1004" title="All 2 branches covered.">			if (defaultVal)</span>
<span class="fc" id="L1005">				weights.set(oldCapacity, newCapacity);</span>
<span class="fc" id="L1006">		}</span>

		@Override
		void swap(int idx1, int idx2) {
<span class="fc" id="L1010">			checkIdx(idx1);</span>
<span class="fc" id="L1011">			checkIdx(idx2);</span>
<span class="fc" id="L1012">			boolean temp = weights.get(idx1);</span>
<span class="fc" id="L1013">			weights.set(idx1, weights.get(idx2));</span>
<span class="fc" id="L1014">			weights.set(idx2, temp);</span>
<span class="fc" id="L1015">		}</span>

		@Override
		void clear(int idx) {
			// checkIdx(idx);
<span class="fc" id="L1020">			weights.set(idx, defaultVal);</span>
<span class="fc" id="L1021">		}</span>

		@Override
		void clear() {
<span class="nc" id="L1025">			weights.set(0, capacity, defaultVal);</span>
<span class="nc" id="L1026">		}</span>

		@Override
		BooleanCollection values() {
<span class="nc" id="L1030">			return values;</span>
		}

		@Override
		Class&lt;Boolean&gt; getTypeClass() {
<span class="nc" id="L1035">			return boolean.class;</span>
		}

		@Override
		DataContainer.Bool copy(IDStrategy idStrat) {
<span class="nc bnc" id="L1040" title="All 2 branches missed.">			if (idStrat.size() != this.idStrat.size())</span>
<span class="nc" id="L1041">				throw new IllegalArgumentException();</span>
<span class="nc" id="L1042">			return new DataContainer.Bool(this, idStrat);</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L1047" title="All 2 branches missed.">			if (this == other)</span>
<span class="nc" id="L1048">				return true;</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Bool))</span>
<span class="nc" id="L1050">				return false;</span>
<span class="nc" id="L1051">			DataContainer.Bool o = (DataContainer.Bool) other;</span>
<span class="nc bnc" id="L1052" title="All 4 branches missed.">			return size() == o.size() &amp;&amp; weights.equals(o.weights);</span>
		}
	}

<span class="fc" id="L1056">	static class Char extends DataContainer&lt;Character&gt; {</span>

		private char[] weights;
		private final char defaultVal;
		private final CharCollection values;

		Char(IDStrategy idStrat, char defVal) {
<span class="fc" id="L1063">			super(idStrat);</span>

<span class="fc" id="L1065">			weights = CharArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L1066">			defaultVal = defVal;</span>
<span class="fc" id="L1067">			values = new AbstractCharList() {</span>

				@Override
				public int size() {
<span class="nc" id="L1071">					return DataContainer.Char.super.size();</span>
				}

				@Override
				public CharListIterator iterator() {
<span class="nc" id="L1076">					return CharIterators.wrap(weights, 0, size());</span>
				}

				@Override
				public char getChar(int index) {
<span class="nc" id="L1081">					checkIdx(index);</span>
<span class="nc" id="L1082">					return weights[index];</span>
				}
			};
<span class="fc" id="L1085">		}</span>

		char getChar(int idx) {
<span class="fc" id="L1088">			checkIdx(idx);</span>
<span class="fc" id="L1089">			return weights[idx];</span>
		}

		void set(int idx, char weight) {
<span class="fc" id="L1093">			checkIdx(idx);</span>
<span class="fc" id="L1094">			weights[idx] = weight;</span>
<span class="fc" id="L1095">		}</span>

		char defaultValChar() {
<span class="fc" id="L1098">			return defaultVal;</span>
		}

		@Override
		int capacity() {
<span class="fc" id="L1103">			return weights.length;</span>
		}

		@Override
		void expand(int newCapacity) {
<span class="fc" id="L1108">			int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L1109" title="1 of 2 branches missed.">			assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L1110">			weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L1111">			Arrays.fill(weights, oldCapacity, newCapacity, defaultVal);</span>
<span class="fc" id="L1112">		}</span>

		@Override
		void swap(int idx1, int idx2) {
<span class="fc" id="L1116">			checkIdx(idx1);</span>
<span class="fc" id="L1117">			checkIdx(idx2);</span>
<span class="fc" id="L1118">			CharArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L1119">		}</span>

		@Override
		void clear(int idx) {
			// checkIdx(idx);
<span class="fc" id="L1124">			weights[idx] = defaultVal;</span>
<span class="fc" id="L1125">		}</span>

		@Override
		void clear() {
<span class="nc" id="L1129">			Arrays.fill(weights, 0, size(), defaultVal);</span>
<span class="nc" id="L1130">		}</span>

		@Override
		CharCollection values() {
<span class="nc" id="L1134">			return values;</span>
		}

		@Override
		Class&lt;Character&gt; getTypeClass() {
<span class="nc" id="L1139">			return char.class;</span>
		}

		@Override
		DataContainer.Char copy(IDStrategy idStrat) {
<span class="nc bnc" id="L1144" title="All 2 branches missed.">			if (idStrat.size() != this.idStrat.size())</span>
<span class="nc" id="L1145">				throw new IllegalArgumentException();</span>
<span class="nc" id="L1146">			DataContainer.Char copy = new DataContainer.Char(idStrat, defaultVal);</span>
<span class="nc" id="L1147">			copy.weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="nc" id="L1148">			return copy;</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L1153" title="All 2 branches missed.">			if (this == other)</span>
<span class="nc" id="L1154">				return true;</span>
<span class="nc bnc" id="L1155" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Char))</span>
<span class="nc" id="L1156">				return false;</span>
<span class="nc" id="L1157">			DataContainer.Char o = (DataContainer.Char) other;</span>
<span class="nc" id="L1158">			return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
		}
	}

	static class Manager {

<span class="fc" id="L1164">		final Map&lt;Object, DataContainer&lt;?&gt;&gt; containers = new Object2ObjectArrayMap&lt;&gt;();</span>
		private int containersCapacity;

<span class="fc" id="L1167">		Manager(int initCapacity) {</span>
<span class="fc" id="L1168">			containersCapacity = initCapacity;</span>
<span class="fc" id="L1169">		}</span>

		Manager(Manager orig, IDStrategy idStrat) {
<span class="nc" id="L1172">			this(idStrat.size());</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">			for (var entry : orig.containers.entrySet())</span>
<span class="nc" id="L1174">				containers.put(entry.getKey(), entry.getValue().copy(idStrat));</span>
<span class="nc" id="L1175">		}</span>

		Manager copy(IDStrategy idStrat) {
<span class="nc" id="L1178">			return new Manager(this, idStrat);</span>
		}

		void addContainer(Object key, DataContainer&lt;?&gt; container) {
<span class="fc" id="L1182">			DataContainer&lt;?&gt; oldContainer = containers.put(key, container);</span>
<span class="pc bpc" id="L1183" title="1 of 2 branches missed.">			if (oldContainer != null)</span>
<span class="nc" id="L1184">				throw new IllegalArgumentException(&quot;Two weights types with the same key: &quot; + key);</span>
<span class="fc bfc" id="L1185" title="All 2 branches covered.">			if (containersCapacity &gt; container.capacity())</span>
<span class="fc" id="L1186">				container.expand(containersCapacity);</span>
<span class="fc" id="L1187">		}</span>

		void ensureCapacity(int capacity) {
<span class="fc bfc" id="L1190" title="All 2 branches covered.">			if (capacity &lt;= containersCapacity)</span>
<span class="fc" id="L1191">				return;</span>
<span class="fc" id="L1192">			int newCapacity = Math.max(Math.max(2, 2 * containersCapacity), capacity);</span>
<span class="fc bfc" id="L1193" title="All 2 branches covered.">			for (DataContainer&lt;?&gt; container : containers.values())</span>
<span class="fc" id="L1194">				container.expand(newCapacity);</span>
<span class="fc" id="L1195">			containersCapacity = newCapacity;</span>
<span class="fc" id="L1196">		}</span>

		void swapElements(int idx1, int idx2) {
<span class="fc bfc" id="L1199" title="All 2 branches covered.">			for (DataContainer&lt;?&gt; container : containers.values())</span>
<span class="fc" id="L1200">				container.swap(idx1, idx2);</span>
<span class="fc" id="L1201">		}</span>

		void clearElement(int idx) {
<span class="fc bfc" id="L1204" title="All 2 branches covered.">			for (DataContainer&lt;?&gt; container : containers.values())</span>
<span class="fc" id="L1205">				container.clear(idx);</span>
<span class="fc" id="L1206">		}</span>

		void clearContainers() {
<span class="fc bfc" id="L1209" title="All 2 branches covered.">			for (DataContainer&lt;?&gt; container : containers.values())</span>
<span class="fc" id="L1210">				container.clear();</span>
<span class="fc" id="L1211">		}</span>

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>