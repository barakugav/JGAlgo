<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataContainer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo</a> &gt; <span class="el_source">DataContainer.java</span></div><h1>DataContainer.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jgalgo;

import java.util.Arrays;
import java.util.BitSet;
import java.util.Collection;
import java.util.NoSuchElementException;
import java.util.Objects;
import it.unimi.dsi.fastutil.booleans.AbstractBooleanList;
import it.unimi.dsi.fastutil.booleans.BooleanCollection;
import it.unimi.dsi.fastutil.booleans.BooleanListIterator;
import it.unimi.dsi.fastutil.bytes.AbstractByteList;
import it.unimi.dsi.fastutil.bytes.ByteArrays;
import it.unimi.dsi.fastutil.bytes.ByteCollection;
import it.unimi.dsi.fastutil.bytes.ByteIterators;
import it.unimi.dsi.fastutil.bytes.ByteListIterator;
import it.unimi.dsi.fastutil.chars.AbstractCharList;
import it.unimi.dsi.fastutil.chars.CharArrays;
import it.unimi.dsi.fastutil.chars.CharCollection;
import it.unimi.dsi.fastutil.chars.CharIterators;
import it.unimi.dsi.fastutil.chars.CharListIterator;
import it.unimi.dsi.fastutil.doubles.AbstractDoubleList;
import it.unimi.dsi.fastutil.doubles.DoubleArrays;
import it.unimi.dsi.fastutil.doubles.DoubleCollection;
import it.unimi.dsi.fastutil.doubles.DoubleIterators;
import it.unimi.dsi.fastutil.doubles.DoubleListIterator;
import it.unimi.dsi.fastutil.floats.AbstractFloatList;
import it.unimi.dsi.fastutil.floats.FloatArrays;
import it.unimi.dsi.fastutil.floats.FloatCollection;
import it.unimi.dsi.fastutil.floats.FloatIterators;
import it.unimi.dsi.fastutil.floats.FloatListIterator;
import it.unimi.dsi.fastutil.ints.AbstractIntList;
import it.unimi.dsi.fastutil.ints.IntArrays;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntIterators;
import it.unimi.dsi.fastutil.ints.IntListIterator;
import it.unimi.dsi.fastutil.longs.AbstractLongList;
import it.unimi.dsi.fastutil.longs.LongArrays;
import it.unimi.dsi.fastutil.longs.LongCollection;
import it.unimi.dsi.fastutil.longs.LongIterators;
import it.unimi.dsi.fastutil.longs.LongListIterator;
import it.unimi.dsi.fastutil.objects.AbstractObjectList;
import it.unimi.dsi.fastutil.objects.ObjectArrays;
import it.unimi.dsi.fastutil.objects.ObjectCollection;
import it.unimi.dsi.fastutil.objects.ObjectIterators;
import it.unimi.dsi.fastutil.objects.ObjectListIterator;
import it.unimi.dsi.fastutil.shorts.AbstractShortList;
import it.unimi.dsi.fastutil.shorts.ShortArrays;
import it.unimi.dsi.fastutil.shorts.ShortCollection;
import it.unimi.dsi.fastutil.shorts.ShortIterators;
import it.unimi.dsi.fastutil.shorts.ShortListIterator;

<span class="fc" id="L68">abstract class DataContainer&lt;E&gt; {</span>
	int size;

	void clear() {
<span class="fc" id="L72">		size = 0;</span>
<span class="fc" id="L73">	}</span>

	abstract void add(int idx);

	abstract void addUpTo(int endIdx);

	abstract void remove(int idx);

	abstract void swap(int i1, int i2);

	abstract Collection&lt;E&gt; values();

	abstract Class&lt;E&gt; getTypeClass();

	@Override
	public int hashCode() {
<span class="nc" id="L89">		return values().hashCode();</span>
	}

	@Override
	public String toString() {
<span class="nc" id="L94">		return values().toString();</span>
	}

	void checkIdx(int idx) {
		// TODO add some messege of ID strategy choice
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">		if (idx &gt;= size)</span>
<span class="nc" id="L100">			throw new IndexOutOfBoundsException(idx);</span>
<span class="fc" id="L101">	}</span>

	static &lt;D&gt; DataContainer&lt;D&gt; newInstance(Class&lt;? super D&gt; type, D defVal, int size) {
		@SuppressWarnings(&quot;rawtypes&quot;)
		DataContainer container;
<span class="fc bfc" id="L106" title="All 2 branches covered.">		if (type == byte.class) {</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">			byte defVal0 = defVal != null ? ((java.lang.Byte) defVal).byteValue() : 0;</span>
<span class="fc" id="L108">			container = new DataContainer.Byte(size, defVal0);</span>

<span class="fc bfc" id="L110" title="All 2 branches covered.">		} else if (type == short.class) {</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">			short defVal0 = defVal != null ? ((java.lang.Short) defVal).shortValue() : 0;</span>
<span class="fc" id="L112">			container = new DataContainer.Short(size, defVal0);</span>

<span class="fc bfc" id="L114" title="All 2 branches covered.">		} else if (type == int.class) {</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">			int defVal0 = defVal != null ? ((Integer) defVal).intValue() : 0;</span>
<span class="fc" id="L116">			container = new DataContainer.Int(size, defVal0);</span>

<span class="fc bfc" id="L118" title="All 2 branches covered.">		} else if (type == long.class) {</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">			long defVal0 = defVal != null ? ((java.lang.Long) defVal).longValue() : 0;</span>
<span class="fc" id="L120">			container = new DataContainer.Long(size, defVal0);</span>

<span class="fc bfc" id="L122" title="All 2 branches covered.">		} else if (type == float.class) {</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">			float defVal0 = defVal != null ? ((java.lang.Float) defVal).floatValue() : 0;</span>
<span class="fc" id="L124">			container = new DataContainer.Float(size, defVal0);</span>

<span class="fc bfc" id="L126" title="All 2 branches covered.">		} else if (type == double.class) {</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">			double defVal0 = defVal != null ? ((java.lang.Double) defVal).doubleValue() : 0;</span>
<span class="fc" id="L128">			container = new DataContainer.Double(size, defVal0);</span>

<span class="fc bfc" id="L130" title="All 2 branches covered.">		} else if (type == boolean.class) {</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">			boolean defVal0 = defVal != null ? ((Boolean) defVal).booleanValue() : false;</span>
<span class="fc" id="L132">			container = new DataContainer.Bool(size, defVal0);</span>

<span class="fc bfc" id="L134" title="All 2 branches covered.">		} else if (type == char.class) {</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">			char defVal0 = defVal != null ? ((Character) defVal).charValue() : 0;</span>
<span class="fc" id="L136">			container = new DataContainer.Char(size, defVal0);</span>

<span class="fc" id="L138">		} else {</span>
<span class="fc" id="L139">			container = new DataContainer.Obj&lt;&gt;(size, defVal, type);</span>
		}
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L142">		DataContainer&lt;D&gt; container0 = container;</span>
<span class="fc" id="L143">		return container0;</span>
	}

<span class="fc" id="L146">	static class Obj&lt;E&gt; extends DataContainer&lt;E&gt; {</span>

		private Object[] weights;
		private final E defaultVal;
		private final ObjectCollection&lt;E&gt; values;
		private final Class&lt;E&gt; type;

<span class="fc" id="L153">		Obj(int expectedSize, E defVal, Class&lt;E&gt; type) {</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">			weights = expectedSize &gt; 0 ? new Object[expectedSize] : ObjectArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L155">			defaultVal = defVal;</span>
<span class="fc" id="L156">			this.type = Objects.requireNonNull(type);</span>
<span class="fc" id="L157">			values = new AbstractObjectList&lt;&gt;() {</span>

				@Override
				public int size() {
<span class="nc" id="L161">					return size;</span>
				}

				@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
				@Override
				public ObjectListIterator&lt;E&gt; iterator() {
<span class="fc" id="L167">					return (ObjectListIterator) ObjectIterators.wrap(weights, 0, size);</span>
				}

				@SuppressWarnings(&quot;unchecked&quot;)
				@Override
				public E get(int index) {
<span class="nc" id="L173">					checkIdx(index);</span>
<span class="nc" id="L174">					return (E) weights[index];</span>
				}
			};
<span class="fc" id="L177">		}</span>

		@SuppressWarnings(&quot;unchecked&quot;)
		public E get(int idx) {
<span class="fc" id="L181">			checkIdx(idx);</span>
<span class="fc" id="L182">			return (E) weights[idx];</span>
		}

		void set(int idx, E weight) {
<span class="fc" id="L186">			checkIdx(idx);</span>
<span class="fc" id="L187">			weights[idx] = weight;</span>
<span class="fc" id="L188">		}</span>

		E defaultVal() {
<span class="fc" id="L191">			return defaultVal;</span>
		}

		private void add0(int idx) {
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">			assert idx == size : &quot;only continues idxs are supported&quot;;</span>
<span class="fc" id="L196">			ensureCapacity(size + 1);</span>
<span class="fc" id="L197">			size++;</span>
<span class="fc" id="L198">		}</span>

		@Override
		void add(int idx) {
<span class="fc" id="L202">			add0(idx);</span>
<span class="fc" id="L203">			weights[idx] = defaultVal;</span>
<span class="fc" id="L204">		}</span>

		void addWithoutSettingDefaultVal(int idx) {
<span class="fc" id="L207">			add0(idx);</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">			if (weights[idx] == null)</span>
<span class="fc" id="L209">				weights[idx] = defaultVal;</span>
<span class="fc" id="L210">		}</span>

		@Override
		void remove(int idx) {
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">			assert idx == size - 1 : &quot;only continues idxs are supported&quot;;</span>
<span class="fc" id="L215">			weights[idx] = null;</span>
<span class="fc" id="L216">			size--;</span>
<span class="fc" id="L217">		}</span>

		@Override
		void addUpTo(int endIdx) {
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">			if (endIdx &lt; size)</span>
<span class="nc" id="L222">				throw new IllegalArgumentException();</span>
<span class="fc" id="L223">			ensureCapacity(endIdx);</span>
<span class="fc" id="L224">			Arrays.fill(weights, size, endIdx, defaultVal);</span>
<span class="fc" id="L225">			size = endIdx;</span>
<span class="fc" id="L226">		}</span>

		private void ensureCapacity(int capacity) {
<span class="fc bfc" id="L229" title="All 2 branches covered.">			if (capacity &lt; weights.length)</span>
<span class="fc" id="L230">				return;</span>
<span class="fc" id="L231">			int newLen = Math.max(2, weights.length * 2);</span>
<span class="fc" id="L232">			newLen = Math.max(newLen, capacity);</span>
<span class="fc" id="L233">			weights = Arrays.copyOf(weights, newLen);</span>
<span class="fc" id="L234">		}</span>

		@Override
		void swap(int k1, int k2) {
<span class="fc" id="L238">			checkIdx(k1);</span>
<span class="fc" id="L239">			checkIdx(k2);</span>
<span class="fc" id="L240">			Object temp = weights[k1];</span>
<span class="fc" id="L241">			weights[k1] = weights[k2];</span>
<span class="fc" id="L242">			weights[k2] = temp;</span>
<span class="fc" id="L243">		}</span>

		void clearWithoutDeallocation() {
<span class="fc" id="L246">			super.clear();</span>
<span class="fc" id="L247">		}</span>

		@Override
		void clear() {
<span class="fc" id="L251">			Arrays.fill(weights, 0, size, null);</span>
<span class="fc" id="L252">			super.clear();</span>
<span class="fc" id="L253">		}</span>

		@Override
		Collection&lt;E&gt; values() {
<span class="fc" id="L257">			return values;</span>
		}

		@Override
		Class&lt;E&gt; getTypeClass() {
<span class="nc" id="L262">			return type;</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L267" title="All 2 branches missed.">			if (other == this)</span>
<span class="nc" id="L268">				return true;</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Obj&lt;?&gt;))</span>
<span class="nc" id="L270">				return false;</span>
<span class="nc" id="L271">			DataContainer.Obj&lt;?&gt; o = (DataContainer.Obj&lt;?&gt;) other;</span>
<span class="nc" id="L272">			return Arrays.equals(weights, 0, size, o.weights, 0, o.size);</span>
		}
	}

<span class="fc" id="L276">	static class Byte extends DataContainer&lt;java.lang.Byte&gt; {</span>

		private byte[] weights;
		private final byte defaultVal;
		private final ByteCollection values;

<span class="fc" id="L282">		Byte(int expectedSize, byte defVal) {</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">			weights = expectedSize &gt; 0 ? new byte[expectedSize] : ByteArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L284">			defaultVal = defVal;</span>
<span class="fc" id="L285">			values = new AbstractByteList() {</span>

				@Override
				public int size() {
<span class="nc" id="L289">					return size;</span>
				}

				@Override
				public ByteListIterator iterator() {
<span class="nc" id="L294">					return ByteIterators.wrap(weights, 0, size);</span>
				}

				@Override
				public byte getByte(int index) {
<span class="nc" id="L299">					checkIdx(index);</span>
<span class="nc" id="L300">					return weights[index];</span>
				}
			};
<span class="fc" id="L303">		}</span>

		byte getByte(int idx) {
<span class="fc" id="L306">			checkIdx(idx);</span>
<span class="fc" id="L307">			return weights[idx];</span>
		}

		void set(int idx, byte weight) {
<span class="fc" id="L311">			checkIdx(idx);</span>
<span class="fc" id="L312">			weights[idx] = weight;</span>
<span class="fc" id="L313">		}</span>

		byte defaultValByte() {
<span class="fc" id="L316">			return defaultVal;</span>
		}

		@Override
		public void add(int idx) {
<span class="nc bnc" id="L321" title="All 2 branches missed.">			assert idx == size : &quot;only continues idxs are supported&quot;;</span>
<span class="nc" id="L322">			ensureCapacity(size + 1);</span>
<span class="nc" id="L323">			weights[idx] = defaultVal;</span>
<span class="nc" id="L324">			size++;</span>
<span class="nc" id="L325">		}</span>

		@Override
		void remove(int idx) {
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">			assert idx == size - 1 : &quot;only continues idxs are supported&quot;;</span>
<span class="fc" id="L330">			size--;</span>
<span class="fc" id="L331">		}</span>

		@Override
		void addUpTo(int endIdx) {
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">			if (endIdx &lt; size)</span>
<span class="nc" id="L336">				throw new IllegalArgumentException();</span>
<span class="fc" id="L337">			ensureCapacity(endIdx);</span>
<span class="fc" id="L338">			Arrays.fill(weights, size, endIdx, defaultVal);</span>
<span class="fc" id="L339">			size = endIdx;</span>
<span class="fc" id="L340">		}</span>

		private void ensureCapacity(int capacity) {
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">			if (capacity &lt; weights.length)</span>
<span class="nc" id="L344">				return;</span>
<span class="fc" id="L345">			int newLen = Math.max(2, weights.length * 2);</span>
<span class="fc" id="L346">			newLen = Math.max(newLen, capacity);</span>
<span class="fc" id="L347">			weights = Arrays.copyOf(weights, newLen);</span>
<span class="fc" id="L348">		}</span>

		@Override
		void swap(int k1, int k2) {
<span class="fc" id="L352">			checkIdx(k1);</span>
<span class="fc" id="L353">			checkIdx(k2);</span>
<span class="fc" id="L354">			byte temp = weights[k1];</span>
<span class="fc" id="L355">			weights[k1] = weights[k2];</span>
<span class="fc" id="L356">			weights[k2] = temp;</span>
<span class="fc" id="L357">		}</span>

		@Override
		ByteCollection values() {
<span class="nc" id="L361">			return values;</span>
		}

		@Override
		Class&lt;java.lang.Byte&gt; getTypeClass() {
<span class="nc" id="L366">			return byte.class;</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L371" title="All 2 branches missed.">			if (this == other)</span>
<span class="nc" id="L372">				return true;</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Byte))</span>
<span class="nc" id="L374">				return false;</span>
<span class="nc" id="L375">			DataContainer.Byte o = (DataContainer.Byte) other;</span>
<span class="nc" id="L376">			return Arrays.equals(weights, 0, size, o.weights, 0, o.size);</span>
		}
	}

<span class="fc" id="L380">	static class Short extends DataContainer&lt;java.lang.Short&gt; {</span>

		private short[] weights;
		private final short defaultVal;
		private final ShortCollection values;

<span class="fc" id="L386">		Short(int expectedSize, short defVal) {</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">			weights = expectedSize &gt; 0 ? new short[expectedSize] : ShortArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L388">			defaultVal = defVal;</span>
<span class="fc" id="L389">			values = new AbstractShortList() {</span>

				@Override
				public int size() {
<span class="nc" id="L393">					return size;</span>
				}

				@Override
				public ShortListIterator iterator() {
<span class="nc" id="L398">					return ShortIterators.wrap(weights, 0, size);</span>
				}

				@Override
				public short getShort(int index) {
<span class="nc" id="L403">					checkIdx(index);</span>
<span class="nc" id="L404">					return weights[index];</span>
				}
			};
<span class="fc" id="L407">		}</span>

		short getShort(int idx) {
<span class="fc" id="L410">			checkIdx(idx);</span>
<span class="fc" id="L411">			return weights[idx];</span>
		}

		void set(int idx, short weight) {
<span class="fc" id="L415">			checkIdx(idx);</span>
<span class="fc" id="L416">			weights[idx] = weight;</span>
<span class="fc" id="L417">		}</span>

		short defaultValShort() {
<span class="fc" id="L420">			return defaultVal;</span>
		}

		@Override
		public void add(int idx) {
<span class="nc bnc" id="L425" title="All 2 branches missed.">			assert idx == size : &quot;only continues idxs are supported&quot;;</span>
<span class="nc" id="L426">			ensureCapacity(size + 1);</span>
<span class="nc" id="L427">			weights[idx] = defaultVal;</span>
<span class="nc" id="L428">			size++;</span>
<span class="nc" id="L429">		}</span>

		@Override
		void remove(int idx) {
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">			assert idx == size - 1 : &quot;only continues idxs are supported&quot;;</span>
<span class="fc" id="L434">			size--;</span>
<span class="fc" id="L435">		}</span>

		@Override
		void addUpTo(int endIdx) {
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">			if (endIdx &lt; size)</span>
<span class="nc" id="L440">				throw new IllegalArgumentException();</span>
<span class="fc" id="L441">			ensureCapacity(endIdx);</span>
<span class="fc" id="L442">			Arrays.fill(weights, size, endIdx, defaultVal);</span>
<span class="fc" id="L443">			size = endIdx;</span>
<span class="fc" id="L444">		}</span>

		private void ensureCapacity(int capacity) {
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">			if (capacity &lt; weights.length)</span>
<span class="nc" id="L448">				return;</span>
<span class="fc" id="L449">			int newLen = Math.max(2, weights.length * 2);</span>
<span class="fc" id="L450">			newLen = Math.max(newLen, capacity);</span>
<span class="fc" id="L451">			weights = Arrays.copyOf(weights, newLen);</span>
<span class="fc" id="L452">		}</span>

		@Override
		void swap(int k1, int k2) {
<span class="fc" id="L456">			checkIdx(k1);</span>
<span class="fc" id="L457">			checkIdx(k2);</span>
<span class="fc" id="L458">			short temp = weights[k1];</span>
<span class="fc" id="L459">			weights[k1] = weights[k2];</span>
<span class="fc" id="L460">			weights[k2] = temp;</span>
<span class="fc" id="L461">		}</span>

		@Override
		ShortCollection values() {
<span class="nc" id="L465">			return values;</span>
		}

		@Override
		Class&lt;java.lang.Short&gt; getTypeClass() {
<span class="nc" id="L470">			return short.class;</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L475" title="All 2 branches missed.">			if (this == other)</span>
<span class="nc" id="L476">				return true;</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Short))</span>
<span class="nc" id="L478">				return false;</span>
<span class="nc" id="L479">			DataContainer.Short o = (DataContainer.Short) other;</span>
<span class="nc" id="L480">			return Arrays.equals(weights, 0, size, o.weights, 0, o.size);</span>
		}
	}

<span class="fc" id="L484">	static class Int extends DataContainer&lt;Integer&gt; {</span>

		private int[] weights;
		private final int defaultVal;
		private final IntCollection values;

<span class="fc" id="L490">		Int(int expectedSize, int defVal) {</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">			weights = expectedSize &gt; 0 ? new int[expectedSize] : IntArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L492">			defaultVal = defVal;</span>
<span class="fc" id="L493">			values = new AbstractIntList() {</span>

				@Override
				public int size() {
<span class="nc" id="L497">					return size;</span>
				}

				@Override
				public IntListIterator iterator() {
<span class="nc" id="L502">					return IntIterators.wrap(weights, 0, size);</span>
				}

				@Override
				public int getInt(int index) {
<span class="nc" id="L507">					checkIdx(index);</span>
<span class="nc" id="L508">					return weights[index];</span>
				}
			};
<span class="fc" id="L511">		}</span>

		int getInt(int idx) {
<span class="fc" id="L514">			checkIdx(idx);</span>
<span class="fc" id="L515">			return weights[idx];</span>
		}

		void set(int idx, int weight) {
<span class="fc" id="L519">			checkIdx(idx);</span>
<span class="fc" id="L520">			weights[idx] = weight;</span>
<span class="fc" id="L521">		}</span>

		int defaultValInt() {
<span class="fc" id="L524">			return defaultVal;</span>
		}

		@Override
		void add(int idx) {
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">			assert idx == size : &quot;only continues idxs are supported&quot;;</span>
<span class="fc" id="L530">			ensureCapacity(size + 1);</span>
<span class="fc" id="L531">			weights[idx] = defaultVal;</span>
<span class="fc" id="L532">			size++;</span>
<span class="fc" id="L533">		}</span>

		@Override
		void remove(int idx) {
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">			assert idx == size - 1 : &quot;only continues idxs are supported&quot;;</span>
<span class="fc" id="L538">			size--;</span>
<span class="fc" id="L539">		}</span>

		@Override
		void addUpTo(int endIdx) {
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">			if (endIdx &lt; size)</span>
<span class="nc" id="L544">				throw new IllegalArgumentException();</span>
<span class="fc" id="L545">			ensureCapacity(endIdx);</span>
<span class="fc" id="L546">			Arrays.fill(weights, size, endIdx, defaultVal);</span>
<span class="fc" id="L547">			size = endIdx;</span>
<span class="fc" id="L548">		}</span>

		private void ensureCapacity(int capacity) {
<span class="fc bfc" id="L551" title="All 2 branches covered.">			if (capacity &lt; weights.length)</span>
<span class="fc" id="L552">				return;</span>
<span class="fc" id="L553">			int newLen = Math.max(2, weights.length * 2);</span>
<span class="fc" id="L554">			newLen = Math.max(newLen, capacity);</span>
<span class="fc" id="L555">			weights = Arrays.copyOf(weights, newLen);</span>
<span class="fc" id="L556">		}</span>

		@Override
		void swap(int i1, int i2) {
<span class="fc" id="L560">			checkIdx(i1);</span>
<span class="fc" id="L561">			checkIdx(i2);</span>
<span class="fc" id="L562">			int temp = weights[i1];</span>
<span class="fc" id="L563">			weights[i1] = weights[i2];</span>
<span class="fc" id="L564">			weights[i2] = temp;</span>
<span class="fc" id="L565">		}</span>

		@Override
		IntCollection values() {
<span class="nc" id="L569">			return values;</span>
		}

		@Override
		Class&lt;Integer&gt; getTypeClass() {
<span class="nc" id="L574">			return int.class;</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L579" title="All 2 branches missed.">			if (this == other)</span>
<span class="nc" id="L580">				return true;</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Int))</span>
<span class="nc" id="L582">				return false;</span>
<span class="nc" id="L583">			DataContainer.Int o = (DataContainer.Int) other;</span>
<span class="nc" id="L584">			return Arrays.equals(weights, 0, size, o.weights, 0, o.size);</span>
		}
	}

<span class="fc" id="L588">	static class Long extends DataContainer&lt;java.lang.Long&gt; {</span>

		private long[] weights;
		private final long defaultVal;
		private final LongCollection values;

<span class="fc" id="L594">		Long(int expectedSize, long defVal) {</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">			weights = expectedSize &gt; 0 ? new long[expectedSize] : LongArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L596">			defaultVal = defVal;</span>
<span class="fc" id="L597">			values = new AbstractLongList() {</span>

				@Override
				public int size() {
<span class="nc" id="L601">					return size;</span>
				}

				@Override
				public LongListIterator iterator() {
<span class="nc" id="L606">					return LongIterators.wrap(weights, 0, size);</span>
				}

				@Override
				public long getLong(int index) {
<span class="nc" id="L611">					checkIdx(index);</span>
<span class="nc" id="L612">					return weights[index];</span>
				}
			};
<span class="fc" id="L615">		}</span>

		long getLong(int idx) {
<span class="fc" id="L618">			checkIdx(idx);</span>
<span class="fc" id="L619">			return weights[idx];</span>
		}

		void set(int idx, long weight) {
<span class="fc" id="L623">			checkIdx(idx);</span>
<span class="fc" id="L624">			weights[idx] = weight;</span>
<span class="fc" id="L625">		}</span>

		long defaultValLong() {
<span class="fc" id="L628">			return defaultVal;</span>
		}

		@Override
		public void add(int idx) {
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">			assert idx == size : &quot;only continues idxs are supported&quot;;</span>
<span class="fc" id="L634">			ensureCapacity(size + 1);</span>
<span class="fc" id="L635">			weights[idx] = defaultVal;</span>
<span class="fc" id="L636">			size++;</span>
<span class="fc" id="L637">		}</span>

		@Override
		void remove(int idx) {
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">			assert idx == size - 1 : &quot;only continues idxs are supported&quot;;</span>
<span class="fc" id="L642">			size--;</span>
<span class="fc" id="L643">		}</span>

		@Override
		void addUpTo(int endIdx) {
<span class="pc bpc" id="L647" title="1 of 2 branches missed.">			if (endIdx &lt; size)</span>
<span class="nc" id="L648">				throw new IllegalArgumentException();</span>
<span class="fc" id="L649">			ensureCapacity(endIdx);</span>
<span class="fc" id="L650">			Arrays.fill(weights, size, endIdx, defaultVal);</span>
<span class="fc" id="L651">			size = endIdx;</span>
<span class="fc" id="L652">		}</span>

		private void ensureCapacity(int capacity) {
<span class="fc bfc" id="L655" title="All 2 branches covered.">			if (capacity &lt; weights.length)</span>
<span class="fc" id="L656">				return;</span>
<span class="fc" id="L657">			int newLen = Math.max(2, weights.length * 2);</span>
<span class="fc" id="L658">			newLen = Math.max(newLen, capacity);</span>
<span class="fc" id="L659">			weights = Arrays.copyOf(weights, newLen);</span>
<span class="fc" id="L660">		}</span>

		@Override
		void swap(int k1, int k2) {
<span class="fc" id="L664">			checkIdx(k1);</span>
<span class="fc" id="L665">			checkIdx(k2);</span>
<span class="fc" id="L666">			long temp = weights[k1];</span>
<span class="fc" id="L667">			weights[k1] = weights[k2];</span>
<span class="fc" id="L668">			weights[k2] = temp;</span>
<span class="fc" id="L669">		}</span>

		@Override
		LongCollection values() {
<span class="nc" id="L673">			return values;</span>
		}

		@Override
		Class&lt;java.lang.Long&gt; getTypeClass() {
<span class="nc" id="L678">			return long.class;</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L683" title="All 2 branches missed.">			if (this == other)</span>
<span class="nc" id="L684">				return true;</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Long))</span>
<span class="nc" id="L686">				return false;</span>
<span class="nc" id="L687">			DataContainer.Long o = (DataContainer.Long) other;</span>
<span class="nc" id="L688">			return Arrays.equals(weights, 0, size, o.weights, 0, o.size);</span>
		}
	}

<span class="fc" id="L692">	static class Float extends DataContainer&lt;java.lang.Float&gt; {</span>

		private float[] weights;
		private final float defaultVal;
		private final FloatCollection values;

<span class="fc" id="L698">		Float(int expectedSize, float defVal) {</span>
<span class="pc bpc" id="L699" title="1 of 2 branches missed.">			weights = expectedSize &gt; 0 ? new float[expectedSize] : FloatArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L700">			defaultVal = defVal;</span>
<span class="fc" id="L701">			values = new AbstractFloatList() {</span>

				@Override
				public int size() {
<span class="nc" id="L705">					return size;</span>
				}

				@Override
				public FloatListIterator iterator() {
<span class="nc" id="L710">					return FloatIterators.wrap(weights, 0, size);</span>
				}

				@Override
				public float getFloat(int index) {
<span class="nc" id="L715">					checkIdx(index);</span>
<span class="nc" id="L716">					return weights[index];</span>
				}
			};
<span class="fc" id="L719">		}</span>

		float getFloat(int idx) {
<span class="fc" id="L722">			checkIdx(idx);</span>
<span class="fc" id="L723">			return weights[idx];</span>
		}

		void set(int idx, float weight) {
<span class="fc" id="L727">			checkIdx(idx);</span>
<span class="fc" id="L728">			weights[idx] = weight;</span>
<span class="fc" id="L729">		}</span>

		float defaultValFloat() {
<span class="fc" id="L732">			return defaultVal;</span>
		}

		@Override
		void add(int idx) {
<span class="nc bnc" id="L737" title="All 2 branches missed.">			assert idx == size : &quot;only continues idxs are supported&quot;;</span>
<span class="nc" id="L738">			ensureCapacity(size + 1);</span>
<span class="nc" id="L739">			weights[idx] = defaultVal;</span>
<span class="nc" id="L740">			size++;</span>
<span class="nc" id="L741">		}</span>

		@Override
		void remove(int idx) {
<span class="pc bpc" id="L745" title="1 of 2 branches missed.">			assert idx == size - 1 : &quot;only continues idxs are supported&quot;;</span>
<span class="fc" id="L746">			size--;</span>
<span class="fc" id="L747">		}</span>

		@Override
		void addUpTo(int endIdx) {
<span class="pc bpc" id="L751" title="1 of 2 branches missed.">			if (endIdx &lt; size)</span>
<span class="nc" id="L752">				throw new IllegalArgumentException();</span>
<span class="fc" id="L753">			ensureCapacity(endIdx);</span>
<span class="fc" id="L754">			Arrays.fill(weights, size, endIdx, defaultVal);</span>
<span class="fc" id="L755">			size = endIdx;</span>
<span class="fc" id="L756">		}</span>

		private void ensureCapacity(int capacity) {
<span class="pc bpc" id="L759" title="1 of 2 branches missed.">			if (capacity &lt; weights.length)</span>
<span class="nc" id="L760">				return;</span>
<span class="fc" id="L761">			int newLen = Math.max(2, weights.length * 2);</span>
<span class="fc" id="L762">			newLen = Math.max(newLen, capacity);</span>
<span class="fc" id="L763">			weights = Arrays.copyOf(weights, newLen);</span>
<span class="fc" id="L764">		}</span>

		@Override
		void swap(int k1, int k2) {
<span class="fc" id="L768">			checkIdx(k1);</span>
<span class="fc" id="L769">			checkIdx(k2);</span>
<span class="fc" id="L770">			float temp = weights[k1];</span>
<span class="fc" id="L771">			weights[k1] = weights[k2];</span>
<span class="fc" id="L772">			weights[k2] = temp;</span>
<span class="fc" id="L773">		}</span>

		@Override
		FloatCollection values() {
<span class="nc" id="L777">			return values;</span>
		}

		@Override
		Class&lt;java.lang.Float&gt; getTypeClass() {
<span class="nc" id="L782">			return float.class;</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L787" title="All 2 branches missed.">			if (this == other)</span>
<span class="nc" id="L788">				return true;</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Float))</span>
<span class="nc" id="L790">				return false;</span>
<span class="nc" id="L791">			DataContainer.Float o = (DataContainer.Float) other;</span>
<span class="nc" id="L792">			return Arrays.equals(weights, 0, size, o.weights, 0, o.size);</span>
		}
	}

<span class="fc" id="L796">	static class Double extends DataContainer&lt;java.lang.Double&gt; {</span>

		private double[] weights;
		private final double defaultVal;
		private final DoubleCollection values;

<span class="fc" id="L802">		Double(int expectedSize, double defVal) {</span>
<span class="fc bfc" id="L803" title="All 2 branches covered.">			weights = expectedSize &gt; 0 ? new double[expectedSize] : DoubleArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L804">			defaultVal = defVal;</span>
<span class="fc" id="L805">			values = new AbstractDoubleList() {</span>

				@Override
				public int size() {
<span class="nc" id="L809">					return size;</span>
				}

				@Override
				public DoubleListIterator iterator() {
<span class="nc" id="L814">					return DoubleIterators.wrap(weights, 0, size);</span>
				}

				@Override
				public double getDouble(int index) {
<span class="nc" id="L819">					checkIdx(index);</span>
<span class="nc" id="L820">					return weights[index];</span>
				}
			};
<span class="fc" id="L823">		}</span>

		double getDouble(int idx) {
<span class="fc" id="L826">			checkIdx(idx);</span>
<span class="fc" id="L827">			return weights[idx];</span>
		}

		void set(int idx, double weight) {
<span class="fc" id="L831">			checkIdx(idx);</span>
<span class="fc" id="L832">			weights[idx] = weight;</span>
<span class="fc" id="L833">		}</span>

		double defaultValDouble() {
<span class="fc" id="L836">			return defaultVal;</span>
		}

		@Override
		void add(int idx) {
<span class="pc bpc" id="L841" title="1 of 2 branches missed.">			assert idx == size : &quot;only continues idxs are supported&quot;;</span>
<span class="fc" id="L842">			ensureCapacity(size + 1);</span>
<span class="fc" id="L843">			weights[idx] = defaultVal;</span>
<span class="fc" id="L844">			size++;</span>
<span class="fc" id="L845">		}</span>

		@Override
		void remove(int idx) {
<span class="pc bpc" id="L849" title="1 of 2 branches missed.">			assert idx == size - 1 : &quot;only continues idxs are supported&quot;;</span>
<span class="fc" id="L850">			size--;</span>
<span class="fc" id="L851">		}</span>

		@Override
		void addUpTo(int endIdx) {
<span class="pc bpc" id="L855" title="1 of 2 branches missed.">			if (endIdx &lt; size)</span>
<span class="nc" id="L856">				throw new IllegalArgumentException();</span>
<span class="fc" id="L857">			ensureCapacity(endIdx);</span>
<span class="fc" id="L858">			Arrays.fill(weights, size, endIdx, defaultVal);</span>
<span class="fc" id="L859">			size = endIdx;</span>
<span class="fc" id="L860">		}</span>

		private void ensureCapacity(int capacity) {
<span class="fc bfc" id="L863" title="All 2 branches covered.">			if (capacity &lt; weights.length)</span>
<span class="fc" id="L864">				return;</span>
<span class="fc" id="L865">			int newLen = Math.max(2, weights.length * 2);</span>
<span class="fc" id="L866">			newLen = Math.max(newLen, capacity);</span>
<span class="fc" id="L867">			weights = Arrays.copyOf(weights, newLen);</span>
<span class="fc" id="L868">		}</span>

		@Override
		void swap(int k1, int k2) {
<span class="fc" id="L872">			checkIdx(k1);</span>
<span class="fc" id="L873">			checkIdx(k2);</span>
<span class="fc" id="L874">			double temp = weights[k1];</span>
<span class="fc" id="L875">			weights[k1] = weights[k2];</span>
<span class="fc" id="L876">			weights[k2] = temp;</span>
<span class="fc" id="L877">		}</span>

		@Override
		DoubleCollection values() {
<span class="nc" id="L881">			return values;</span>
		}

		@Override
		Class&lt;java.lang.Double&gt; getTypeClass() {
<span class="nc" id="L886">			return double.class;</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L891" title="All 2 branches missed.">			if (this == other)</span>
<span class="nc" id="L892">				return true;</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Double))</span>
<span class="nc" id="L894">				return false;</span>
<span class="nc" id="L895">			DataContainer.Double o = (DataContainer.Double) other;</span>
<span class="nc" id="L896">			return Arrays.equals(weights, 0, size, o.weights, 0, o.size);</span>
		}
	}

<span class="fc" id="L900">	static class Bool extends DataContainer&lt;Boolean&gt; {</span>

		private final BitSet weights;
		private final boolean defaultVal;
		private final BooleanCollection values;

<span class="fc" id="L906">		Bool(int expectedSize, boolean defVal) {</span>
			// We don't do anything with expectedSize, but we keep it for forward
			// compatibility
<span class="fc" id="L909">			weights = new BitSet();</span>
<span class="fc" id="L910">			defaultVal = defVal;</span>
<span class="fc" id="L911">			values = new AbstractBooleanList() {</span>

				@Override
				public int size() {
<span class="nc" id="L915">					return size;</span>
				}

				@Override
				public BooleanListIterator iterator() {
<span class="nc" id="L920">					return new BooleanListIterator() {</span>
<span class="nc" id="L921">						int idx = 0;</span>

						@Override
						public boolean hasNext() {
<span class="nc bnc" id="L925" title="All 2 branches missed.">							return idx &lt; size;</span>
						}

						@Override
						public boolean nextBoolean() {
<span class="nc bnc" id="L930" title="All 2 branches missed.">							if (!hasNext())</span>
<span class="nc" id="L931">								throw new NoSuchElementException();</span>
<span class="nc" id="L932">							return weights.get(idx++);</span>
						}

						@Override
						public boolean previousBoolean() {
<span class="nc bnc" id="L937" title="All 2 branches missed.">							if (!hasPrevious())</span>
<span class="nc" id="L938">								throw new NoSuchElementException();</span>
<span class="nc" id="L939">							return weights.get(--idx);</span>
						}

						@Override
						public boolean hasPrevious() {
<span class="nc bnc" id="L944" title="All 2 branches missed.">							return idx &gt; 0;</span>
						}

						@Override
						public int nextIndex() {
<span class="nc" id="L949">							return idx;</span>
						}

						@Override
						public int previousIndex() {
<span class="nc" id="L954">							return idx - 1;</span>
						}
					};
				}

				@Override
				public boolean getBoolean(int index) {
<span class="nc" id="L961">					checkIdx(index);</span>
<span class="nc" id="L962">					return weights.get(index);</span>
				}
			};
<span class="fc" id="L965">		}</span>

		boolean getBool(int idx) {
<span class="fc" id="L968">			checkIdx(idx);</span>
<span class="fc" id="L969">			return weights.get(idx);</span>
		}

		void set(int idx, boolean weight) {
<span class="fc" id="L973">			checkIdx(idx);</span>
<span class="fc" id="L974">			weights.set(idx, weight);</span>
<span class="fc" id="L975">		}</span>

		boolean defaultValBool() {
<span class="fc" id="L978">			return defaultVal;</span>
		}

		@Override
		void add(int idx) {
<span class="nc bnc" id="L983" title="All 2 branches missed.">			assert idx == size : &quot;only continues idxs are supported&quot;;</span>
<span class="nc" id="L984">			weights.set(idx, defaultVal);</span>
<span class="nc" id="L985">			size++;</span>
<span class="nc" id="L986">		}</span>

		@Override
		void remove(int idx) {
<span class="pc bpc" id="L990" title="1 of 2 branches missed.">			assert idx == size - 1 : &quot;only continues idxs are supported&quot;;</span>
<span class="fc" id="L991">			size--;</span>
<span class="fc" id="L992">		}</span>

		@Override
		void addUpTo(int endIdx) {
<span class="pc bpc" id="L996" title="1 of 2 branches missed.">			if (endIdx &lt; size)</span>
<span class="nc" id="L997">				throw new IllegalArgumentException();</span>
<span class="fc" id="L998">			weights.set(size, endIdx, defaultVal);</span>
<span class="fc" id="L999">			size = endIdx;</span>
<span class="fc" id="L1000">		}</span>

		@Override
		void swap(int k1, int k2) {
<span class="fc" id="L1004">			checkIdx(k1);</span>
<span class="fc" id="L1005">			checkIdx(k2);</span>
<span class="fc" id="L1006">			boolean temp = weights.get(k1);</span>
<span class="fc" id="L1007">			weights.set(k1, weights.get(k2));</span>
<span class="fc" id="L1008">			weights.set(k2, temp);</span>
<span class="fc" id="L1009">		}</span>

		@Override
		BooleanCollection values() {
<span class="nc" id="L1013">			return values;</span>
		}

		@Override
		Class&lt;Boolean&gt; getTypeClass() {
<span class="nc" id="L1018">			return boolean.class;</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L1023" title="All 2 branches missed.">			if (this == other)</span>
<span class="nc" id="L1024">				return true;</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Bool))</span>
<span class="nc" id="L1026">				return false;</span>
<span class="nc" id="L1027">			DataContainer.Bool o = (DataContainer.Bool) other;</span>
<span class="nc bnc" id="L1028" title="All 4 branches missed.">			return size == o.size &amp;&amp; weights.equals(o.weights);</span>
		}
	}

<span class="fc" id="L1032">	static class Char extends DataContainer&lt;Character&gt; {</span>

		private char[] weights;
		private final char defaultVal;
		private final CharCollection values;

<span class="fc" id="L1038">		Char(int expectedSize, char defVal) {</span>
<span class="pc bpc" id="L1039" title="1 of 2 branches missed.">			weights = expectedSize &gt; 0 ? new char[expectedSize] : CharArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L1040">			defaultVal = defVal;</span>
<span class="fc" id="L1041">			values = new AbstractCharList() {</span>

				@Override
				public int size() {
<span class="nc" id="L1045">					return size;</span>
				}

				@Override
				public CharListIterator iterator() {
<span class="nc" id="L1050">					return CharIterators.wrap(weights, 0, size);</span>
				}

				@Override
				public char getChar(int index) {
<span class="nc" id="L1055">					checkIdx(index);</span>
<span class="nc" id="L1056">					return weights[index];</span>
				}
			};
<span class="fc" id="L1059">		}</span>

		char getChar(int idx) {
<span class="fc" id="L1062">			checkIdx(idx);</span>
<span class="fc" id="L1063">			return weights[idx];</span>
		}

		void set(int idx, char weight) {
<span class="fc" id="L1067">			checkIdx(idx);</span>
<span class="fc" id="L1068">			weights[idx] = weight;</span>
<span class="fc" id="L1069">		}</span>

		char defaultValChar() {
<span class="fc" id="L1072">			return defaultVal;</span>
		}

		@Override
		void add(int idx) {
<span class="nc bnc" id="L1077" title="All 2 branches missed.">			assert idx == size : &quot;only continues idxs are supported&quot;;</span>
<span class="nc" id="L1078">			ensureCapacity(size + 1);</span>
<span class="nc" id="L1079">			weights[idx] = defaultVal;</span>
<span class="nc" id="L1080">			size++;</span>
<span class="nc" id="L1081">		}</span>

		@Override
		void remove(int idx) {
<span class="pc bpc" id="L1085" title="1 of 2 branches missed.">			assert idx == size - 1 : &quot;only continues idxs are supported&quot;;</span>
<span class="fc" id="L1086">			size--;</span>
<span class="fc" id="L1087">		}</span>

		@Override
		void addUpTo(int endIdx) {
<span class="pc bpc" id="L1091" title="1 of 2 branches missed.">			if (endIdx &lt; size)</span>
<span class="nc" id="L1092">				throw new IllegalArgumentException();</span>
<span class="fc" id="L1093">			ensureCapacity(endIdx);</span>
<span class="fc" id="L1094">			Arrays.fill(weights, size, endIdx, defaultVal);</span>
<span class="fc" id="L1095">			size = endIdx;</span>
<span class="fc" id="L1096">		}</span>

		private void ensureCapacity(int capacity) {
<span class="pc bpc" id="L1099" title="1 of 2 branches missed.">			if (capacity &lt; weights.length)</span>
<span class="nc" id="L1100">				return;</span>
<span class="fc" id="L1101">			int newLen = Math.max(2, weights.length * 2);</span>
<span class="fc" id="L1102">			newLen = Math.max(newLen, capacity);</span>
<span class="fc" id="L1103">			weights = Arrays.copyOf(weights, newLen);</span>
<span class="fc" id="L1104">		}</span>

		@Override
		void swap(int k1, int k2) {
<span class="fc" id="L1108">			checkIdx(k1);</span>
<span class="fc" id="L1109">			checkIdx(k2);</span>
<span class="fc" id="L1110">			char temp = weights[k1];</span>
<span class="fc" id="L1111">			weights[k1] = weights[k2];</span>
<span class="fc" id="L1112">			weights[k2] = temp;</span>
<span class="fc" id="L1113">		}</span>

		@Override
		CharCollection values() {
<span class="nc" id="L1117">			return values;</span>
		}

		@Override
		Class&lt;Character&gt; getTypeClass() {
<span class="nc" id="L1122">			return char.class;</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L1127" title="All 2 branches missed.">			if (this == other)</span>
<span class="nc" id="L1128">				return true;</span>
<span class="nc bnc" id="L1129" title="All 2 branches missed.">			if (!(other instanceof DataContainer.Char))</span>
<span class="nc" id="L1130">				return false;</span>
<span class="nc" id="L1131">			DataContainer.Char o = (DataContainer.Char) other;</span>
<span class="nc" id="L1132">			return Arrays.equals(weights, 0, size, o.weights, 0, o.size);</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>