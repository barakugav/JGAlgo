<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RMQStaticLinearAbstract.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo</a> &gt; <span class="el_source">RMQStaticLinearAbstract.java</span></div><h1>RMQStaticLinearAbstract.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jgalgo;

import it.unimi.dsi.fastutil.bytes.Byte2ObjectMap;
import it.unimi.dsi.fastutil.bytes.Byte2ObjectOpenHashMap;
import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
import it.unimi.dsi.fastutil.shorts.Short2ObjectMap;
import it.unimi.dsi.fastutil.shorts.Short2ObjectOpenHashMap;

abstract class RMQStaticLinearAbstract implements RMQStatic {

	/*
	 * This implementation divides the elements sequence into blocks, for each block calculate the minimum in the block
	 * and the minimum within the block from each index to the borders of the block. In addition, we use the \(O(x \log
	 * x)\) implementation on the minimum values from each block (which we have less than n).
	 *
	 * To answer a query, if the two indices are not in the same block, we check the minimum from i to the end of the
	 * block, from j to the end of the block, and the minimum along all the blocks between them. If the two elements are
	 * not in the same block we have no implementation, and the implementations that extends this class will implement
	 * it in different methods.
	 *
	 * \(O(n)\) pre processing time, \(O(n)\) space, \(O(1)\) query.
	 */

<span class="fc" id="L41">	RMQStaticLinearAbstract() {}</span>

	abstract class DS implements RMQStatic.DataStructure {

		final RMQStaticComparator cmpOrig;
		final RMQStaticComparator cmpPadded;
		final int n;
		final byte blockSize;
		final int blockNum;

		private final byte[][] blocksRightMinimum;
		private final byte[][] blocksLeftMinimum;
		private final RMQStatic.DataStructure xlogxTableDS;

		final RMQStatic.DataStructure[] interBlocksDs;
		private final RMQStatic outerRMQ;
		private final RMQStatic innerRMQ;

<span class="fc" id="L59">		DS(RMQStaticComparator c, int n) {</span>
<span class="fc" id="L60">			this.n = n;</span>
<span class="fc" id="L61">			blockSize = getBlockSize(n);</span>
<span class="fc" id="L62">			blockNum = (int) Math.ceil((double) n / blockSize);</span>
<span class="fc" id="L63">			this.cmpOrig = c;</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">			this.cmpPadded = n &lt; blockNum * blockSize ? new PaddedComparator(n, c) : c;</span>
<span class="fc" id="L65">			blocksRightMinimum = new byte[blockNum][blockSize - 1];</span>
<span class="fc" id="L66">			blocksLeftMinimum = new byte[blockNum][blockSize - 1];</span>

<span class="fc" id="L68">			outerRMQ = new RMQStaticPowerOf2Table();</span>
			// TODO probably better to use a simple lookup table, need to measure
<span class="fc" id="L70">			innerRMQ = new RMQStaticPowerOf2Table();</span>

<span class="fc bfc" id="L72" title="All 2 branches covered.">			for (int b = 0; b &lt; blockNum; b++) {</span>
<span class="fc bfc" id="L73" title="All 2 branches covered.">				c = b &lt; blockNum - 1 ? cmpOrig : cmpPadded;</span>
<span class="fc" id="L74">				int base = b * blockSize;</span>

<span class="fc" id="L76">				byte min = 0;</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">				for (byte i = 0; i &lt; blockSize - 1; i++) {</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">					if (c.compare(base + i + 1, base + min) &lt; 0)</span>
<span class="fc" id="L79">						min = (byte) (i + 1);</span>
<span class="fc" id="L80">					blocksLeftMinimum[b][i] = min;</span>
				}

<span class="fc" id="L83">				min = (byte) (blockSize - 1);</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">				for (byte i = (byte) (blockSize - 2); i &gt;= 0; i--) {</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">					if (c.compare(base + i, base + min) &lt; 0)</span>
<span class="fc" id="L86">						min = i;</span>
<span class="fc" id="L87">					blocksRightMinimum[b][i] = min;</span>
				}
			}

<span class="fc" id="L91">			xlogxTableDS =</span>
<span class="fc" id="L92">					outerRMQ.preProcessSequence((i, j) -&gt; cmpOrig.compare(i * blockSize + blocksRightMinimum[i][0],</span>
							j * blockSize + blocksRightMinimum[j][0]), blockNum);

<span class="fc" id="L95">			interBlocksDs = new RMQStatic.DataStructure[blockNum];</span>
<span class="fc" id="L96">		}</span>

		void preProcessInnerBlocks() {
<span class="fc" id="L99">			int keySize = getBlockKeySize();</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">			if (keySize &lt; Byte.SIZE) {</span>
<span class="fc" id="L101">				Byte2ObjectMap&lt;RMQStatic.DataStructure&gt; tables = new Byte2ObjectOpenHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">				for (int b = 0; b &lt; blockNum; b++) {</span>
<span class="fc" id="L103">					byte key = (byte) calcBlockKey(b);</span>

<span class="fc" id="L105">					interBlocksDs[b] = tables.computeIfAbsent(key, k -&gt; {</span>
<span class="fc" id="L106">						byte[] demoBlock = calcDemoBlock(k &amp; 0xff);</span>
<span class="fc" id="L107">						return innerRMQ.preProcessSequence(RMQStaticComparator.ofByteArray(demoBlock),</span>
								demoBlock.length);
					});
				}
<span class="fc" id="L111">				tables.clear();</span>

<span class="pc bpc" id="L113" title="1 of 2 branches missed.">			} else if (keySize &lt; Short.SIZE) {</span>
<span class="fc" id="L114">				Short2ObjectMap&lt;RMQStatic.DataStructure&gt; tables = new Short2ObjectOpenHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">				for (int b = 0; b &lt; blockNum; b++) {</span>
<span class="fc" id="L116">					short key = (short) calcBlockKey(b);</span>

<span class="fc" id="L118">					interBlocksDs[b] = tables.computeIfAbsent(key, k -&gt; {</span>
<span class="fc" id="L119">						byte[] demoBlock = calcDemoBlock(k &amp; 0xffff);</span>
<span class="fc" id="L120">						return innerRMQ.preProcessSequence(RMQStaticComparator.ofByteArray(demoBlock),</span>
								demoBlock.length);
					});
				}
<span class="fc" id="L124">				tables.clear();</span>

<span class="fc" id="L126">			} else {</span>
<span class="nc" id="L127">				Int2ObjectMap&lt;RMQStatic.DataStructure&gt; tables = new Int2ObjectOpenHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">				for (int b = 0; b &lt; blockNum; b++) {</span>
<span class="nc" id="L129">					int key = calcBlockKey(b);</span>

<span class="nc" id="L131">					interBlocksDs[b] = tables.computeIfAbsent(key, k -&gt; {</span>
<span class="nc" id="L132">						byte[] demoBlock = calcDemoBlock(k);</span>
<span class="nc" id="L133">						return innerRMQ.preProcessSequence(RMQStaticComparator.ofByteArray(demoBlock),</span>
								demoBlock.length);
					});
				}
<span class="nc" id="L137">				tables.clear();</span>
			}
<span class="fc" id="L139">		}</span>

		abstract byte getBlockSize(int n);

		abstract int getBlockKeySize();

		abstract int calcBlockKey(int b);

		abstract byte[] calcDemoBlock(int key);

		@Override
		public int findMinimumInRange(int i, int j) {
<span class="pc bpc" id="L151" title="3 of 6 branches missed.">			if (!(0 &lt;= i &amp;&amp; i &lt;= j &amp;&amp; j &lt; n))</span>
<span class="nc" id="L152">				throw new IllegalArgumentException(&quot;Illegal indices [&quot; + i + &quot;,&quot; + j + &quot;]&quot;);</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">			if (i == j)</span>
<span class="fc" id="L154">				return i;</span>

<span class="fc" id="L156">			int blk0 = i / blockSize;</span>
<span class="fc" id="L157">			int blk1 = j / blockSize;</span>
<span class="fc" id="L158">			int innerI = i % blockSize;</span>
<span class="fc" id="L159">			int innerJ = j % blockSize;</span>

<span class="fc bfc" id="L161" title="All 2 branches covered.">			if (blk0 != blk1) {</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">				int blk0min = blk0 * blockSize + (innerI == blockSize - 1 ? innerI : blocksRightMinimum[blk0][innerI]);</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">				int blk1min = blk1 * blockSize + (innerJ == 0 ? innerJ : blocksLeftMinimum[blk1][innerJ - 1]);</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">				int min = cmpOrig.compare(blk0min, blk1min) &lt; 0 ? blk0min : blk1min;</span>

<span class="fc bfc" id="L166" title="All 2 branches covered.">				if (blk0 + 1 != blk1) {</span>
<span class="fc" id="L167">					int middleBlk = xlogxTableDS.findMinimumInRange(blk0 + 1, blk1 - 1);</span>
<span class="fc" id="L168">					int middleMin = middleBlk * blockSize + blocksRightMinimum[middleBlk][0];</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">					min = cmpOrig.compare(min, middleMin) &lt; 0 ? min : middleMin;</span>
				}

<span class="fc" id="L172">				return min;</span>
			} else {
<span class="fc" id="L174">				return calcRMQInnerBlock(blk0, innerI, innerJ);</span>
			}
		}

		abstract int calcRMQInnerBlock(int block, int i, int j);
	}

	private static class PaddedComparator implements RMQStaticComparator {

		final int n;
		final RMQStaticComparator c;

<span class="fc" id="L186">		PaddedComparator(int n, RMQStaticComparator c) {</span>
<span class="fc" id="L187">			this.n = n;</span>
<span class="fc" id="L188">			this.c = c;</span>
<span class="fc" id="L189">		}</span>

		@Override
		public int compare(int i, int j) {
<span class="fc bfc" id="L193" title="All 4 branches covered.">			if (i &lt; n &amp;&amp; j &lt; n)</span>
<span class="fc" id="L194">				return c.compare(i, j);</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">			return i &gt;= n ? 1 : -1;</span>
		}

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>