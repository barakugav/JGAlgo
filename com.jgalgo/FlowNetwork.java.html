<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FlowNetwork.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo</a> &gt; <span class="el_source">FlowNetwork.java</span></div><h1>FlowNetwork.java</h1><pre class="source lang-java linenums">package com.jgalgo;

/**
 * Flow on graph edges, with capacities and flows values.
 * &lt;p&gt;
 * A flow network on graph edges is defined as two functions: the capacity function \(C:E \rightarrow R\) and flow
 * function \( F:E \rightarrow R\). The capacity function define how many units of flow an edge can transfer from its
 * source to its target. The flow function is the number of units of flow that are currently transferred along the edge.
 * For each edge, the flow must be smaller or equal to its capacity.
 * &lt;p&gt;
 * Problems formulated using flow networks involve a source and a sink vertices. The source is a vertex from which the
 * flow is originated, and every flow going along its edges must reach the sink vertex using the edges of the graphs
 * while not violating the capacities of the network. For each vertex except the source and sink the sum of flow units
 * going along {@link Graph#edgesIn(int)} must be equal to the sum of flow units going along
 * {@link Graph#edgesOut(int)}.
 *
 * &lt;pre&gt; {@code
 * DiGraph g = ...;
 * FlowNetwork net = FlowNetwork.createAsEdgeWeight(g);
 * for (IntIterator edgeIter = g.edges().iterator(); edgeIter.hasNext();)
 *  f.setCapacity(edgeIter.nextInt(), 1);
 *
 * int sourceVertex = ...;
 * int targetVertex = ...;
 * MaximumFlow maxFlowAlg = MaximumFlow.newBuilder().build();
 *
 * double totalFlow = maxFlowAlg.computeMaximumFlow(g, net, sourceVertex, targetVertex);
 * System.out.println(&quot;The maximum flow that can be pushed in the network is &quot; + totalFlow);
 * for (IntIterator it = g.edges().iterator(); it.hasNext();) {
 * 	int e = it.nextInt();
 * 	double capacity = net.getCapacity(e);
 * 	double flow = net.getFlow(e);
 * 	System.out.println(&quot;flow on edge &quot; + e + &quot;: &quot; + flow + &quot;/&quot; + capacity);
 * }
 * }&lt;/pre&gt;
 *
 * @see    MaximumFlow
 * @author Barak Ugav
 */
public interface FlowNetwork {

    /**
     * Get the capacity of an edge.
     *
     * @param  edge                      an edge identifier in the graph
     * @return                           the capacity of the edge
     * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge identifier
     */
    double getCapacity(int edge);

    /**
     * Set the capacity of an edge.
     *
     * @param  edge                      an edge identifier in the graph
     * @param  capacity                  the new capacity of the edge
     * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge identifier
     */
    void setCapacity(int edge, double capacity);

    /**
     * Get the amount of flow units going along an edge.
     *
     * @param  edge                      an edge identifier in the graph
     * @return                           the amount of flow units going along an edge
     * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge identifier
     */
    double getFlow(int edge);

    /**
     * Set the amount of flow units going along an edge.
     *
     * @param  edge                      an edge identifier in the graph
     * @param  flow                      the new flow of the edge
     * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge identifier
     */
    void setFlow(int edge, double flow);

    /**
     * Create a flow network by adding edge weights using {@link Graph#addEdgesWeights}.
     * &lt;p&gt;
     * Unless {@link #setCapacity(int, double)} or {@link #setFlow(int, double)} are used, the capacity and flow of each
     * edge will be zero.
     *
     * @param  g a graph
     * @return   a flow network implemented as edge weights
     */
    static FlowNetwork createAsEdgeWeight(Graph g) {
<span class="fc" id="L88">        Weights.Double capacityWeights = g.addEdgesWeights(new Object(), double.class);</span>
<span class="fc" id="L89">        Weights.Double flowWeights = g.addEdgesWeights(new Object(), double.class);</span>
<span class="fc" id="L90">        return new FlowNetwork() {</span>

            private static final double EPS = 0.0001;

            @Override
            public double getCapacity(int edge) {
<span class="fc" id="L96">                return capacityWeights.getDouble(edge);</span>
            }

            @Override
            public void setCapacity(int edge, double capacity) {
<span class="fc" id="L101">                capacityWeights.set(edge, capacity);</span>
<span class="fc" id="L102">            }</span>

            @Override
            public double getFlow(int e) {
<span class="fc" id="L106">                return flowWeights.getDouble(e);</span>
            }

            @Override
            public void setFlow(int edge, double flow) {
<span class="fc" id="L111">                double capacity = getCapacity(edge);</span>
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">                if (flow &gt; capacity + EPS)</span>
<span class="nc" id="L113">                    throw new IllegalArgumentException(&quot;Illegal flow &quot; + flow + &quot; on edge &quot; + edge);</span>
<span class="fc" id="L114">                flowWeights.set(edge, Math.min(flow, capacity));</span>
<span class="fc" id="L115">            }</span>
        };
    }

    /**
     * Flow on graph edges, with integer capacities and flows values.
     * &lt;p&gt;
     * Similar to the regular {@link FlowNetwork} interface, but with integer capacities and flows. Some algorithms that
     * work on flow networks are specifically for integers networks, or may performed faster if the capacities and flows
     * are integers.
     *
     * @author Barak Ugav
     */
    static interface Int extends FlowNetwork {

        /**
         * Get the integer capacity of an edge.
         *
         * @param  edge                      an edge identifier in the graph
         * @return                           the capacity of the edge
         * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge identifier
         */
        public int getCapacityInt(int edge);

        @Deprecated
        @Override
        default double getCapacity(int edge) {
<span class="fc" id="L142">            return getCapacityInt(edge);</span>
        }

        /**
         * Set the integer capacity of an edge.
         *
         * @param  edge                      an edge identifier in the graph
         * @param  capacity                  the new capacity of the edge
         * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge identifier
         */
        public void setCapacity(int edge, int capacity);

        @Deprecated
        @Override
        default void setCapacity(int edge, double capacity) {
<span class="nc" id="L157">            setCapacity(edge, (int) capacity);</span>
<span class="nc" id="L158">        }</span>

        /**
         * Get the integer amount of flow units going along an edge.
         *
         * @param  edge                      an edge identifier in the graph
         * @return                           the amount of flow units going along an edge
         * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge identifier
         */
        public int getFlowInt(int edge);

        @Deprecated
        @Override
        default double getFlow(int edge) {
<span class="nc" id="L172">            return getFlowInt(edge);</span>
        }

        /**
         * Set the integer amount of flow units going along an edge.
         *
         * @param  edge                      an edge identifier in the graph
         * @param  flow                      the new flow of the edge
         * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge identifier
         */
        public void setFlow(int edge, int flow);

        @Deprecated
        @Override
        default void setFlow(int edge, double flow) {
<span class="nc" id="L187">            setFlow(edge, (int) flow);</span>
<span class="nc" id="L188">        }</span>

        /**
         * Create an integer flow network by adding edge weights using {@link Graph#addEdgesWeights}.
         * &lt;p&gt;
         * Unless {@link #setCapacity(int, int)} or {@link #setFlow(int, int)} are used, the capacity and flow of each
         * edge will be zero.
         *
         * @param  g a graph
         * @return   a flow network implemented as edge weights
         */
        static FlowNetwork.Int createAsEdgeWeight(Graph g) {
<span class="fc" id="L200">            Weights.Int capacityWeights = g.addEdgesWeights(new Object(), int.class);</span>
<span class="fc" id="L201">            Weights.Int flowWeights = g.addEdgesWeights(new Object(), int.class);</span>
<span class="fc" id="L202">            return new FlowNetwork.Int() {</span>

                @Override
                public int getCapacityInt(int edge) {
<span class="fc" id="L206">                    return capacityWeights.getInt(edge);</span>
                }

                @Override
                public void setCapacity(int edge, int capacity) {
<span class="fc" id="L211">                    capacityWeights.set(edge, capacity);</span>
<span class="fc" id="L212">                }</span>

                @Override
                public int getFlowInt(int e) {
<span class="fc" id="L216">                    return flowWeights.getInt(e);</span>
                }

                @Override
                public void setFlow(int edge, int flow) {
<span class="fc" id="L221">                    int capacity = getCapacityInt(edge);</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">                    if (flow &gt; capacity)</span>
<span class="nc" id="L223">                        throw new IllegalArgumentException(&quot;Illegal flow &quot; + flow + &quot; on edge &quot; + edge);</span>
<span class="fc" id="L224">                    flowWeights.set(edge, Math.min(flow, capacity));</span>
<span class="fc" id="L225">                }</span>
            };
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>