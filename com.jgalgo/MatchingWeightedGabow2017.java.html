<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MatchingWeightedGabow2017.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jgalgo</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo</a> &gt; <span class="el_source">MatchingWeightedGabow2017.java</span></div><h1>MatchingWeightedGabow2017.java</h1><pre class="source lang-java linenums">package com.jgalgo;

import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.IntConsumer;
import java.util.stream.Collectors;

import com.jgalgo.Utils.NullList;

import it.unimi.dsi.fastutil.ints.IntArrayFIFOQueue;
import it.unimi.dsi.fastutil.ints.IntArrayList;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntIterator;
import it.unimi.dsi.fastutil.ints.IntList;
import it.unimi.dsi.fastutil.ints.IntPriorityQueue;

public class MatchingWeightedGabow2017 implements MatchingWeighted, DebugPrintable {

	/*
	 * This class implement Edmonds' &quot;Blossom algorithm&quot; for weighted matching on
	 * general graphs. The algorithm runs in O(m n + n^2 log n).
	 */

	private final DebugPrintsManager debugPrintManager;
<span class="fc" id="L31">	private HeapDirectAccessed.Builder heapBuilder = HeapPairing::new;</span>

	private static final double EPS = 0.00001;

<span class="fc" id="L35">	public MatchingWeightedGabow2017() {</span>
<span class="fc" id="L36">		debugPrintManager = new DebugPrintsManager();</span>
<span class="fc" id="L37">	}</span>

	public void setHeapBuilder(HeapDirectAccessed.Builder heapBuilder) {
<span class="nc" id="L40">		this.heapBuilder = Objects.requireNonNull(heapBuilder);</span>
<span class="nc" id="L41">	}</span>

	@Override
	public IntCollection calcMaxMatching(Graph g, EdgeWeightFunc w) {
<span class="pc bpc" id="L45" title="1 of 2 branches missed.">		if (g instanceof DiGraph)</span>
<span class="nc" id="L46">			throw new IllegalArgumentException(&quot;Only undirected bipartite graphs are supported&quot;);</span>
<span class="fc" id="L47">		return new Worker(g, w, heapBuilder, debugPrintManager).calcMaxMatching(false);</span>

	}

	@Override
	public IntCollection calcPerfectMaxMatching(Graph g, EdgeWeightFunc w) {
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">		if (g instanceof DiGraph)</span>
<span class="nc" id="L54">			throw new IllegalArgumentException(&quot;Only undirected bipartite graphs are supported&quot;);</span>
<span class="fc" id="L55">		return new Worker(g, w, heapBuilder, debugPrintManager).calcMaxMatching(true);</span>
	}

	private static class Worker {

		/* the graph */
		final Graph g;

		final Weights&lt;EdgeVal&gt; edgeVal;

		/* the weight function */
		final EdgeWeightFunc w;

		/* vertex -&gt; matched edge */
		final int[] matched;

		/* vertex -&gt; trivial blossom */
		final Blossom[] blossoms;

		/*
		 * Union find data structure for even blossoms, used with find0Blossoms:
		 * find0Blossoms[find0.find(v)]
		 */
		final UnionFind find0;

		/* find0 result -&gt; blossom */
		final Blossom[] find0Blossoms;

		/*
		 * Split find data structure for odd and out blossoms, used with vToFind1Idx and
		 * find1Blossoms: find1Blossoms[find1.find(vToFind1Idx[v])]
		 */
		final SplitFindMin&lt;EdgeEvent&gt; find1;

		/* vertex -&gt; find1 index */
		final int[] vToFind1Idx;

		/* used to assign find1 index to each vertex in an odd blossom */
		int find1IdxNext;

		/* find1 result -&gt; blossom */
		final Blossom[] find1Blossoms;

		/*
		 * index used to check whether a blossom was reached in the current blossom
		 * traversy
		 */
		int blossomVisitIdx;

		/* accumulated delta from the beginning of current search */
		double delta;

		/* dual value of a vertex at the beginning of the current search. y0(u) */
		final double[] vertexDualValBase;

		/* Edge with minimum slack going to each vertex: vertex -&gt; next grow edge */
		final EdgeEvent[] vToGrowEvent;

		/* Heap storing all the grow events */
		final HeapDirectAccessed&lt;EdgeEvent&gt; growEvents;

		/* Heap storing all the blossom and augmenting events */
		final SubtreeMergeFindmin&lt;Blossom, EdgeEvent&gt; smf;

		/* Dummy SMF node, use as root of roots (SMF support only one tree) */
		SubtreeMergeFindmin.Node&lt;Blossom&gt; smfRootOfRoots;

		/* SMF index of each vertex: vertex -&gt; SMF identifier */
		final SubtreeMergeFindmin.Node&lt;Blossom&gt;[] vToSMFId;

		/*
		 * array used to calculate the path from a vertex to blossom base, used to
		 * calculate SMF skeleton from odd blossoms
		 */
		final int[] oddBlossomPath;

		/* Heap storing all expand events for odd vertices */
		final HeapDirectAccessed&lt;Blossom&gt; expandEvents;

		/* queue used during blossom creation to union all vertices */
		final IntPriorityQueue unionQueue;

		/* queue used during blossom creation to remember all new vertex to scan from */
		final IntPriorityQueue scanQueue;

		/* Manage debug prints */
		final DebugPrintsManager debug;

		static class Blossom {

			/* base vertex of this blossom */
			int base;

			/* parent blossom, null if top blossom */
			Blossom parent;

			/* child blossom, null if trivial blossom (blossom of one vertex) */
			Blossom child;

			/*
			 * left brother in current sub blossoms level (share parent), null if top
			 * blossom
			 */
			Blossom left;

			/*
			 * right brother in current sub blossoms level (share parent), null if top
			 * blossom
			 */
			Blossom right;

			/*
			 * the edge that connected this blossom and it's left brother, null if left is
			 * null
			 */
<span class="fc" id="L170">			int toLeftEdge = -1;</span>

			/*
			 * the edge that connected this blossom and it's right brother, null if right is
			 * null
			 */
<span class="fc" id="L176">			int toRightEdge = -1;</span>

			/*
			 * index of root vertex in the search tree, -1 if this blossom is out. relevant
			 * only for top blossoms
			 */
			int root;

			/* edge that connect this blossom to the parent blossom in the search tree */
<span class="fc" id="L185">			int treeParentEdge = -1;</span>

			/*
			 * true if this blossom is even, maintained only for trivial blossoms and top
			 * blossoms
			 */
			boolean isEven;

			/*
			 * find1 data structure label the vertices with indices, these are the first and
			 * last (exclusive) indices of all vertices in this blossoms. only relevant if
			 * odd
			 */
			int find1SeqBegin;
			int find1SeqEnd;

			/* dual value of this blossom at the beginning of the current search */
			double z0;

			/* the value of delta at the time this blossom became even */
			double delta0;

			/* the value of delta at the time this blossom became odd */
			double delta1;

			/*
			 * the accumulated deltas this blossom was part of odd blossom, doesn't include
			 * the time this blossom is top odd blossom
			 */
			double deltaOdd;

			/*
			 * pointer to the grow event for this blossom, relevant only if this blossom is
			 * out
			 */
			HeapDirectAccessed.Handle&lt;EdgeEvent&gt; growHandle;

			/* delta threshold for this blossom to be expanded */
			double expandDelta;

			/*
			 * pointer to the expand event for this blossom, relevant only if this blossom
			 * is top odd
			 */
			HeapDirectAccessed.Handle&lt;Blossom&gt; expandHandle;

			/* field used to keep track which blossoms were visited during traversy */
			int lastVisitIdx;

<span class="fc" id="L234">			Blossom(int base) {</span>
<span class="fc" id="L235">				this.base = base;</span>
<span class="fc" id="L236">			}</span>

			boolean isSingleton() {
<span class="fc bfc" id="L239" title="All 2 branches covered.">				return child == null;</span>
			}

			@Override
			public String toString() {
<span class="nc bnc" id="L244" title="All 4 branches missed.">				return &quot;&quot; + (root == -1 ? 'X' : isEven ? 'E' : 'O') + base;</span>
			}

		}

		static class EdgeVal {
			final int e;
			final int twin;
			Blossom b0;
			Blossom b1;

<span class="fc" id="L255">			EdgeVal(int e, int twin) {</span>
<span class="fc" id="L256">				this.e = e;</span>
<span class="fc" id="L257">				this.twin = twin;</span>
<span class="fc" id="L258">			}</span>
		}

		private static class EdgeEvent {
			final int e;
			final double slack;

<span class="fc" id="L265">			EdgeEvent(int e, double slack) {</span>
<span class="fc" id="L266">				this.e = e;</span>
<span class="fc" id="L267">				this.slack = slack;</span>
<span class="fc" id="L268">			}</span>

			@Override
			public String toString() {
<span class="nc" id="L272">				return &quot;&quot; + e + &quot;[&quot; + slack + &quot;]&quot;;</span>
			}
		}

<span class="fc" id="L276">		private static final Object EdgeValKey = new Object();</span>

		@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L279">		Worker(Graph g0, EdgeWeightFunc w, HeapDirectAccessed.Builder heapBuilder, DebugPrintsManager debugPrint) {</span>
<span class="fc" id="L280">			int n = g0.vertices().size();</span>
<span class="fc" id="L281">			this.g = new GraphArrayDirected(n);</span>
<span class="fc" id="L282">			edgeVal = g.addEdgesWeight(EdgeValKey).ofObjs();</span>
<span class="fc" id="L283">			this.w = e -&gt; w.weight(edgeVal.get(e).e);</span>

<span class="fc bfc" id="L285" title="All 2 branches covered.">			for (IntIterator it = g0.edges().iterator(); it.hasNext();) {</span>
<span class="fc" id="L286">				int e = it.nextInt();</span>
<span class="fc" id="L287">				int u = g0.edgeSource(e), v = g0.edgeTarget(e);</span>
<span class="fc" id="L288">				int e1 = g.addEdge(u, v);</span>
<span class="fc" id="L289">				int e2 = g.addEdge(v, u);</span>
<span class="fc" id="L290">				EdgeVal val1 = new EdgeVal(e, e2);</span>
<span class="fc" id="L291">				EdgeVal val2 = new EdgeVal(e, e1);</span>
<span class="fc" id="L292">				edgeVal.set(e1, val1);</span>
<span class="fc" id="L293">				edgeVal.set(e2, val2);</span>
<span class="fc" id="L294">			}</span>

<span class="fc" id="L296">			matched = new int[n];</span>
<span class="fc" id="L297">			Arrays.fill(matched, -1);</span>

<span class="fc" id="L299">			blossoms = new Blossom[n];</span>
<span class="fc" id="L300">			find0 = new UnionFindArray(n);</span>
<span class="fc" id="L301">			find0Blossoms = new Blossom[n];</span>
<span class="fc" id="L302">			find1 = new SplitFindMinArray&lt;&gt;();</span>
<span class="fc" id="L303">			vToFind1Idx = new int[n];</span>
<span class="fc" id="L304">			find1Blossoms = new Blossom[n];</span>
<span class="fc" id="L305">			blossomVisitIdx = 0;</span>

<span class="fc" id="L307">			delta = 0;</span>
<span class="fc" id="L308">			vertexDualValBase = new double[n];</span>

<span class="fc" id="L310">			vToGrowEvent = new EdgeEvent[n];</span>
<span class="fc" id="L311">			vToSMFId = new SubtreeMergeFindmin.Node[n];</span>
<span class="fc" id="L312">			oddBlossomPath = new int[n];</span>
<span class="fc" id="L313">			growEvents = heapBuilder.build((e1, e2) -&gt; Double.compare(growEventsKey(e1), growEventsKey(e2)));</span>
<span class="fc" id="L314">			smf = new SubtreeMergeFindminImpl&lt;&gt;((e1, e2) -&gt; Double.compare(e1.slack, e2.slack));</span>
<span class="fc" id="L315">			expandEvents = heapBuilder.build((b1, b2) -&gt; Double.compare(b1.expandDelta, b2.expandDelta));</span>

<span class="fc" id="L317">			unionQueue = new IntArrayFIFOQueue();</span>
<span class="fc" id="L318">			scanQueue = new IntArrayFIFOQueue();</span>

<span class="fc" id="L320">			this.debug = debugPrint;</span>
<span class="fc" id="L321">		}</span>

		private IntCollection calcMaxMatching(boolean perfect) {
<span class="fc" id="L324">			int n = g.vertices().size();</span>

			// init dual value of all vertices as maxWeight / 2
<span class="fc" id="L327">			double maxWeight = Double.MIN_VALUE;</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">			for (IntIterator it = g.edges().iterator(); it.hasNext();) {</span>
<span class="fc" id="L329">				int e = it.nextInt();</span>
<span class="fc" id="L330">				maxWeight = Math.max(maxWeight, w.weight(e));</span>
<span class="fc" id="L331">			}</span>
<span class="fc" id="L332">			double delta1Threshold = maxWeight / 2;</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">			for (int u = 0; u &lt; n; u++)</span>
<span class="fc" id="L334">				vertexDualValBase[u] = delta1Threshold;</span>

			// init all trivial (singleton) blossoms
<span class="fc bfc" id="L337" title="All 2 branches covered.">			for (int u = 0; u &lt; n; u++)</span>
<span class="fc" id="L338">				blossoms[u] = new Blossom(u);</span>

<span class="fc" id="L340">			Comparator&lt;EdgeEvent&gt; edgeSlackBarComparator = (e1,</span>
<span class="fc bfc" id="L341" title="All 4 branches covered.">					e2) -&gt; (e2 == null ? -1 : e1 == null ? 1 : Double.compare(e1.slack, e2.slack));</span>

			mainLoop: for (;;) {

				// Reset find0 and find1
<span class="fc" id="L346">				find0.clear();</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">				for (int u = 0; u &lt; n; u++)</span>
<span class="fc" id="L348">					find0.make();</span>
<span class="fc" id="L349">				Arrays.fill(vToFind1Idx, -1);</span>
<span class="fc" id="L350">				find1.init(new NullList&lt;&gt;(n), edgeSlackBarComparator);</span>
<span class="fc" id="L351">				find1IdxNext = 0;</span>
<span class="fc" id="L352">				Arrays.fill(vToSMFId, null);</span>
<span class="fc" id="L353">				smfRootOfRoots = smf.initTree(null);</span>

				// Init unmatched blossoms as even and all other as out
<span class="fc" id="L356">				forEachTopBlossom(b -&gt; {</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">					if (matched[b.base] != -1) {</span>
						// Out blossom
<span class="fc" id="L359">						find1InitIndexing(b);</span>
<span class="fc" id="L360">						find1Split(b);</span>
<span class="fc" id="L361">						b.delta1 = delta;</span>

					} else {
						// Unmatched even blossom
<span class="fc" id="L365">						b.root = b.base;</span>
<span class="fc" id="L366">						b.isEven = true;</span>
<span class="fc" id="L367">						b.delta0 = delta;</span>
<span class="fc" id="L368">						int base = b.base;</span>

						/* Update SMF data structure */
<span class="fc" id="L371">						SubtreeMergeFindmin.Node&lt;Blossom&gt; baseSMFNode = smfAddLeaf(base, smfRootOfRoots);</span>
<span class="fc" id="L372">						forEachVertexInBlossom(b, u -&gt; {</span>
<span class="fc" id="L373">							blossoms[u].isEven = true;</span>
<span class="fc" id="L374">							find0.union(base, u);</span>

<span class="fc bfc" id="L376" title="All 2 branches covered.">							if (u != base) {</span>
<span class="fc" id="L377">								SubtreeMergeFindmin.Node&lt;Blossom&gt; smfNode = smfAddLeaf(u, baseSMFNode);</span>
<span class="fc" id="L378">								smf.mergeSubTrees(baseSMFNode, smfNode);</span>
							}
<span class="fc" id="L380">						});</span>
<span class="fc" id="L381">						find0Blossoms[find0.find(base)] = b;</span>
					}
<span class="fc" id="L383">				});</span>
				// Insert grow and blossom events into heaps
<span class="fc" id="L385">				forEachTopBlossom(U -&gt; {</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">					if (matched[U.base] == -1) { /* only root blossoms */</span>
<span class="fc" id="L387">						forEachVertexInBlossom(U, this::insertGrowEventsFromVertex);</span>
<span class="fc" id="L388">						forEachVertexInBlossom(U, this::insertBlossomEventsFromVertex);</span>
					}
<span class="fc" id="L390">				});</span>

				/* [debug] print current roots */
<span class="fc" id="L393">				debug.printExec(() -&gt; {</span>
<span class="nc" id="L394">					debug.print(&quot;roots:&quot;);</span>
<span class="nc" id="L395">					forEachTopBlossom(b -&gt; {</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">						if (matched[b.base] == -1)</span>
<span class="nc" id="L397">							debug.print(&quot; &quot;, b);</span>
<span class="nc" id="L398">					});</span>
<span class="nc" id="L399">					debug.println();</span>
<span class="nc" id="L400">				});</span>

				currentSearch: for (;;) {
<span class="fc" id="L403">					double delta1 = delta1Threshold;</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">					double delta2 = growEvents.isEmpty() ? Double.MAX_VALUE : growEventsKey(growEvents.findMin());</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">					double delta3 = !smf.hasNonTreeEdge() ? Double.MAX_VALUE</span>
<span class="fc" id="L406">							: smf.findMinNonTreeEdge().edgeData().slack / 2;</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">					double delta4 = expandEvents.isEmpty() ? Double.MAX_VALUE : expandEvents.findMin().expandDelta;</span>

<span class="fc" id="L409">					double deltaNext = Math.min(delta2, Math.min(delta3, delta4));</span>
<span class="fc bfc" id="L410" title="All 6 branches covered.">					if (deltaNext == Double.MAX_VALUE || (!perfect &amp;&amp; delta1 &lt; deltaNext))</span>
<span class="fc" id="L411">						break mainLoop;</span>

<span class="fc" id="L413">					debug.print(&quot;delta &quot;, Double.valueOf(deltaNext), &quot; (+&quot;, Double.valueOf(deltaNext - delta), &quot;)&quot;);</span>
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">					assert deltaNext + EPS &gt;= delta;</span>
<span class="fc" id="L415">					delta = deltaNext;</span>

<span class="fc" id="L417">					debug.printExec(() -&gt; {</span>
<span class="nc" id="L418">						debug.print(&quot; &quot;, Arrays.asList(blossoms).stream().map(b -&gt; String.valueOf(dualVal(b.base)))</span>
<span class="nc" id="L419">								.collect(Collectors.joining(&quot;, &quot;, &quot;[&quot;, &quot;]&quot;)));</span>
<span class="nc" id="L420">						List&lt;Blossom&gt; topLevelBlossoms = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">						for (Blossom b : blossoms) {</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">							for (; b.parent != null; b = b.parent)</span>
								;
<span class="nc" id="L424">							topLevelBlossoms.add(b);</span>
						}
<span class="nc bnc" id="L426" title="All 2 branches missed.">						debug.print(&quot; &quot;, topLevelBlossoms.stream().distinct().filter(b -&gt; !b.isSingleton())</span>
<span class="nc" id="L427">								.map(b -&gt; &quot;&quot; + b + &quot; &quot; + dualVal(b)).collect(Collectors.joining(&quot;, &quot;, &quot;[&quot;, &quot;]&quot;)));</span>

<span class="nc" id="L429">						debug.print(&quot;\nMatched: &quot;);</span>
<span class="nc" id="L430">						debug.println(Arrays.toString(matched));</span>
<span class="nc" id="L431">					});</span>

<span class="fc bfc" id="L433" title="All 2 branches covered.">					if (deltaNext == delta2) {</span>
<span class="fc" id="L434">						growStep();</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">					} else if (deltaNext == delta3) {</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">						assert delta == smf.findMinNonTreeEdge().edgeData().slack / 2;</span>
<span class="fc" id="L437">						int e = smf.findMinNonTreeEdge().edgeData().e;</span>
<span class="fc" id="L438">						int u = g.edgeSource(e), v = g.edgeTarget(e);</span>
<span class="pc bpc" id="L439" title="2 of 4 branches missed.">						assert isEven(u) &amp;&amp; isEven(v);</span>

<span class="fc bfc" id="L441" title="All 2 branches covered.">						if (find0(u).root == find0(v).root)</span>
<span class="fc" id="L442">							blossomStep(e);</span>
						else {
<span class="fc" id="L444">							augmentStep(e);</span>
<span class="fc" id="L445">							break currentSearch;</span>
						}
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">					} else if (deltaNext == delta4) {</span>
<span class="fc" id="L448">						expandStep();</span>
					} else
<span class="nc" id="L450">						throw new IllegalStateException();</span>
<span class="fc" id="L451">				}</span>

				// Update dual values
<span class="fc bfc" id="L454" title="All 2 branches covered.">				for (int u = 0; u &lt; n; u++)</span>
<span class="fc" id="L455">					vertexDualValBase[u] = dualVal(u);</span>
<span class="fc" id="L456">				forEachBlossom(b -&gt; {</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">					if (!b.isSingleton())</span>
<span class="fc" id="L458">						b.z0 = dualVal(b);</span>
<span class="fc" id="L459">					b.delta0 = b.delta1 = b.deltaOdd = 0;</span>
<span class="fc" id="L460">				});</span>
<span class="fc" id="L461">				delta1Threshold -= delta;</span>
<span class="fc" id="L462">				delta = 0;</span>

				// Reset blossoms search tree
<span class="fc" id="L465">				forEachBlossom(b -&gt; {</span>
<span class="fc" id="L466">					b.root = -1;</span>
<span class="fc" id="L467">					b.treeParentEdge = -1;</span>
<span class="fc" id="L468">					b.isEven = false;</span>
<span class="fc" id="L469">					b.find1SeqBegin = b.find1SeqEnd = 0;</span>
<span class="fc" id="L470">					b.growHandle = null;</span>
<span class="fc" id="L471">					b.expandDelta = 0;</span>
<span class="fc" id="L472">					b.expandHandle = null;</span>
<span class="fc" id="L473">				});</span>

				// Reset heaps
<span class="fc" id="L476">				Arrays.fill(vToGrowEvent, null);</span>
<span class="fc" id="L477">				growEvents.clear();</span>
<span class="fc" id="L478">				smf.clear();</span>
<span class="fc" id="L479">				expandEvents.clear();</span>
			}

<span class="fc" id="L482">			IntList res = new IntArrayList();</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">			for (int u = 0; u &lt; n; u++)</span>
<span class="fc bfc" id="L484" title="All 4 branches covered.">				if (matched[u] != -1 &amp;&amp; u &lt; g.edgeEndpoint(matched[u], u))</span>
<span class="fc" id="L485">					res.add(edgeVal.get(matched[u]).e);</span>
<span class="fc" id="L486">			return res;</span>
		}

		private void growStep() {
<span class="fc" id="L490">			debug.print(&quot;growStep (root=&quot;, Integer.valueOf(find0(g.edgeSource(growEvents.findMin().e)).root), &quot;): &quot;,</span>
<span class="fc" id="L491">					Integer.valueOf(growEvents.findMin().e));</span>

			// Grow step
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">			assert delta == growEventsKey(growEvents.findMin());</span>
<span class="fc" id="L495">			int e = growEvents.extractMin().e;</span>
<span class="fc" id="L496">			int u = g.edgeSource(e), v = g.edgeTarget(e);</span>

<span class="fc" id="L498">			Blossom U = find0(u), V = find1(v);</span>
<span class="pc bpc" id="L499" title="2 of 4 branches missed.">			assert !V.isEven &amp;&amp; !isInTree(V);</span>

			// Add odd vertex
<span class="fc" id="L502">			V.root = U.root;</span>
<span class="fc" id="L503">			V.treeParentEdge = edgeVal.get(e).twin;</span>
<span class="fc" id="L504">			V.isEven = false;</span>
<span class="fc" id="L505">			V.delta1 = delta;</span>
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">			assert V.growHandle.get().e == e;</span>
<span class="fc" id="L507">			V.growHandle = null;</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">			if (!V.isSingleton()) {</span>
<span class="fc" id="L509">				V.expandDelta = V.z0 / 2 + V.delta1;</span>
<span class="fc" id="L510">				V.expandHandle = expandEvents.insert(V);</span>
			}
<span class="fc" id="L512">			debug.print(&quot; &quot;, V);</span>

<span class="fc" id="L514">			int pathLen = computePath(V, v, oddBlossomPath);</span>
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">			assert pathLen &gt; 0;</span>
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">			assert oddBlossomPath[0] == v;</span>
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">			assert vToSMFId[u] != null;</span>
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">			assert vToSMFId[v] == null;</span>
<span class="fc" id="L519">			SubtreeMergeFindmin.Node&lt;Blossom&gt; smfParent = smfAddLeaf(v, vToSMFId[u]);</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">			for (int i = 1; i &lt; pathLen; i++) {</span>
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">				assert vToSMFId[oddBlossomPath[i]] == null;</span>
<span class="fc" id="L522">				smfParent = smfAddLeaf(oddBlossomPath[i], smfParent);</span>
			}
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">			assert oddBlossomPath[pathLen - 1] == V.base;</span>

			// Immediately add it's matched edge and vertex as even vertex
<span class="fc" id="L527">			int matchedEdge = matched[V.base];</span>
<span class="fc" id="L528">			V = topBlossom(g.edgeTarget(matchedEdge));</span>
<span class="fc" id="L529">			V.root = U.root;</span>
<span class="fc" id="L530">			V.treeParentEdge = edgeVal.get(matchedEdge).twin;</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">			if (V.growHandle != null) {</span>
<span class="fc" id="L532">				growEvents.removeHandle(V.growHandle);</span>
<span class="fc" id="L533">				V.growHandle = null;</span>
			}
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">			assert vToSMFId[V.base] == null;</span>
<span class="fc" id="L536">			smfAddLeaf(V.base, smfParent);</span>
<span class="fc" id="L537">			makeEven(V);</span>
<span class="fc" id="L538">			debug.println(&quot; &quot;, V);</span>
<span class="fc" id="L539">		}</span>

		private void blossomStep(int e) {
<span class="fc" id="L542">			debug.println(&quot;blossomStep&quot;);</span>
<span class="fc" id="L543">			int eu = g.edgeSource(e), ev = g.edgeTarget(e);</span>
<span class="pc bpc" id="L544" title="2 of 4 branches missed.">			assert isEven(eu) &amp;&amp; isEven(ev);</span>
<span class="fc" id="L545">			Blossom U = find0(eu), V = find0(ev);</span>
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">			if (U == V)</span>
<span class="nc" id="L547">				return; // Edge in same blossom, ignore</span>

			// Create new blossom
<span class="fc" id="L550">			Blossom base = lcaInSearchTree(U, V);</span>
<span class="fc" id="L551">			Blossom newb = new Blossom(base.base);</span>
<span class="fc" id="L552">			newb.root = base.root;</span>
<span class="fc" id="L553">			newb.treeParentEdge = base.treeParentEdge;</span>
<span class="fc" id="L554">			newb.isEven = true;</span>
<span class="fc" id="L555">			newb.child = base;</span>
<span class="fc" id="L556">			newb.delta0 = delta;</span>

			// Add all sub blossoms
<span class="fc" id="L559">			unionQueue.clear();</span>
<span class="fc" id="L560">			scanQueue.clear();</span>
<span class="fc" id="L561">			Blossom[] bs = new Blossom[] { U, V };</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">			for (Blossom b : bs) {</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">				boolean prevIsRight = b == U;</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">				Blossom prev = b == U ? V : U;</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">				int toPrevEdge = b == U ? e : edgeVal.get(e).twin;</span>

				for (;;) {
					// handle even sub blossom
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">					assert b.isEven;</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">					if (!b.isSingleton())</span>
<span class="fc" id="L571">						b.z0 = dualVal(b);</span>
<span class="fc" id="L572">					b.parent = newb;</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">					if (b != base)</span>
<span class="fc" id="L574">						smf.mergeSubTrees(vToSMFId[g.edgeTarget(b.treeParentEdge)], vToSMFId[b.base]);</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">					connectSubBlossoms(b, prev, toPrevEdge, !prevIsRight);</span>
<span class="fc" id="L576">					unionQueue.enqueue(b.base);</span>

<span class="fc bfc" id="L578" title="All 2 branches covered.">					if (b == base)</span>
<span class="fc" id="L579">						break;</span>
<span class="fc" id="L580">					prev = b;</span>
<span class="fc" id="L581">					toPrevEdge = edgeVal.get(matched[b.base]).twin;</span>
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">					assert matched[b.base] == b.treeParentEdge;</span>
<span class="fc" id="L583">					b = topBlossom(g.edgeSource(toPrevEdge));</span>

					// handle odd vertex
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">					assert !b.isEven;</span>
<span class="fc" id="L587">					b.deltaOdd += delta - b.delta1;</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">					if (!b.isSingleton())</span>
<span class="fc" id="L589">						b.z0 = dualVal(b);</span>
<span class="fc" id="L590">					b.parent = newb;</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">					connectSubBlossoms(b, prev, toPrevEdge, !prevIsRight);</span>
<span class="fc" id="L592">					SubtreeMergeFindmin.Node&lt;Blossom&gt; smfTopNode = vToSMFId[g.edgeSource(b.treeParentEdge)];</span>
<span class="fc" id="L593">					smf.mergeSubTrees(vToSMFId[g.edgeTarget(b.treeParentEdge)], smfTopNode);</span>
<span class="fc" id="L594">					forEachVertexInBlossom(b, v -&gt; {</span>
<span class="fc" id="L595">						blossoms[v].isEven = true;</span>

<span class="fc" id="L597">						SubtreeMergeFindmin.Node&lt;Blossom&gt; smfId = vToSMFId[v];</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">						if (smfId == null) {</span>
<span class="fc" id="L599">							smfId = smfAddLeaf(v, smfTopNode);</span>
<span class="fc" id="L600">							smf.mergeSubTrees(smfId, smfTopNode);</span>
						} else {
<span class="fc bfc" id="L602" title="All 2 branches covered.">							while (!smf.isSameSubTree(smfId, smfTopNode)) {</span>
<span class="fc" id="L603">								SubtreeMergeFindmin.Node&lt;Blossom&gt; p = smfParent(smfId);</span>
<span class="fc" id="L604">								smf.mergeSubTrees(smfId, p);</span>
<span class="fc" id="L605">								smfId = p;</span>
<span class="fc" id="L606">							}</span>
						}
<span class="fc" id="L608">						unionQueue.enqueue(v);</span>
<span class="fc" id="L609">						scanQueue.enqueue(v);</span>
<span class="fc" id="L610">					});</span>
<span class="fc" id="L611">					b.delta0 = delta;</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">					if (!b.isSingleton()) {</span>
<span class="fc" id="L613">						expandEvents.removeHandle(b.expandHandle);</span>
<span class="fc" id="L614">						b.expandHandle = null;</span>
					}

<span class="fc" id="L617">					prev = b;</span>
<span class="fc" id="L618">					toPrevEdge = edgeVal.get(b.treeParentEdge).twin;</span>
<span class="fc" id="L619">					b = topBlossom(g.edgeSource(toPrevEdge));</span>
<span class="fc" id="L620">				}</span>
			}

			// Union all sub blossom in find0 data structure
<span class="fc bfc" id="L624" title="All 2 branches covered.">			while (!unionQueue.isEmpty())</span>
<span class="fc" id="L625">				find0.union(newb.base, unionQueue.dequeueInt());</span>
<span class="fc" id="L626">			find0Blossoms[find0.find(newb.base)] = newb;</span>

			// Scan new edges from all new even vertices
<span class="fc bfc" id="L629" title="All 2 branches covered.">			while (!scanQueue.isEmpty()) {</span>
<span class="fc" id="L630">				int u = scanQueue.dequeueInt();</span>
<span class="fc" id="L631">				insertGrowEventsFromVertex(u);</span>
<span class="fc" id="L632">				insertBlossomEventsFromVertex(u);</span>
<span class="fc" id="L633">			}</span>
<span class="fc" id="L634">		}</span>

		private void makeEven(Blossom V) {
<span class="fc" id="L637">			V.isEven = true;</span>
<span class="fc" id="L638">			V.delta0 = delta;</span>
<span class="fc" id="L639">			int base = V.base;</span>
<span class="fc" id="L640">			forEachVertexInBlossom(V, v -&gt; {</span>
<span class="fc" id="L641">				blossoms[v].isEven = true;</span>
<span class="fc" id="L642">				find0.union(base, v);</span>
<span class="fc" id="L643">			});</span>
<span class="fc" id="L644">			find0Blossoms[find0.find(base)] = V;</span>

			/*
			 * If a SMF structure already exists in the blossom, we can't just merge all the
			 * vertices with the base, as not all of them will be adjacent sub trees.
			 * Therefore, we first merge the base to all it's SMF ancestors in the blossom,
			 * and than merging all vertices up to the base sub tree.
			 */
<span class="fc" id="L652">			final SubtreeMergeFindmin.Node&lt;Blossom&gt; smfBaseNode = vToSMFId[base];</span>
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">			assert smfBaseNode != null;</span>
<span class="fc" id="L654">			for (SubtreeMergeFindmin.Node&lt;Blossom&gt; smfId = smfBaseNode;;) {</span>
<span class="fc" id="L655">				SubtreeMergeFindmin.Node&lt;Blossom&gt; parentSmf = smfParent(smfId);</span>
<span class="pc bpc" id="L656" title="1 of 4 branches missed.">				if (parentSmf == null || topBlossom(parentSmf.getNodeData()) != V)</span>
<span class="fc" id="L657">					break;</span>
<span class="fc" id="L658">				smf.mergeSubTrees(smfBaseNode, parentSmf);</span>
<span class="fc" id="L659">				smfId = parentSmf;</span>
<span class="fc" id="L660">			}</span>

<span class="fc" id="L662">			forEachVertexInBlossom(V, v -&gt; {</span>
<span class="fc" id="L663">				SubtreeMergeFindmin.Node&lt;Blossom&gt; smfNode = vToSMFId[v];</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">				if (smfNode == null) {</span>
<span class="fc" id="L665">					smfNode = smfAddLeaf(v, smfBaseNode);</span>
<span class="fc" id="L666">					smf.mergeSubTrees(smfBaseNode, smfNode);</span>
				} else {
<span class="fc bfc" id="L668" title="All 2 branches covered.">					while (!smf.isSameSubTree(smfNode, smfBaseNode)) {</span>
<span class="fc" id="L669">						SubtreeMergeFindmin.Node&lt;Blossom&gt; p = smfParent(smfNode);</span>
<span class="fc" id="L670">						smf.mergeSubTrees(smfNode, p);</span>
<span class="fc" id="L671">						smfNode = p;</span>
<span class="fc" id="L672">					}</span>
				}
<span class="fc" id="L674">			});</span>

<span class="fc" id="L676">			forEachVertexInBlossom(V, this::insertGrowEventsFromVertex);</span>
<span class="fc" id="L677">			forEachVertexInBlossom(V, this::insertBlossomEventsFromVertex);</span>
<span class="fc" id="L678">		}</span>

		private void expandStep() {
<span class="fc" id="L681">			debug.println(&quot;expandStep&quot;);</span>

<span class="pc bpc" id="L683" title="1 of 2 branches missed.">			assert delta == expandEvents.findMin().expandDelta;</span>
<span class="fc" id="L684">			final Blossom B = expandEvents.extractMin();</span>

<span class="pc bpc" id="L686" title="4 of 8 branches missed.">			assert B.root != -1 &amp;&amp; !B.isEven &amp;&amp; !B.isSingleton() &amp;&amp; dualVal(B) &lt;= EPS;</span>

<span class="fc" id="L688">			int baseFind1Idx = vToFind1Idx[B.base];</span>
<span class="fc" id="L689">			int topFind1Idx = vToFind1Idx[g.edgeSource(B.treeParentEdge)];</span>
<span class="fc" id="L690">			Blossom base = null;</span>
<span class="fc" id="L691">			Blossom top = null;</span>
			// Remove parent pointer from all children, and find the sub blossom containing
			// the base ('base') and the sub blossom containing the vertex of the edge from
			// parent in search tree ('top')
<span class="fc" id="L695">			for (Blossom b = B.child;;) {</span>
<span class="fc bfc" id="L696" title="All 4 branches covered.">				if (b.find1SeqBegin &lt;= baseFind1Idx &amp;&amp; baseFind1Idx &lt; b.find1SeqEnd) {</span>
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">					assert base == null;</span>
<span class="fc" id="L698">					base = b;</span>
				}
<span class="fc bfc" id="L700" title="All 4 branches covered.">				if (b.find1SeqBegin &lt;= topFind1Idx &amp;&amp; topFind1Idx &lt; b.find1SeqEnd) {</span>
<span class="pc bpc" id="L701" title="1 of 2 branches missed.">					assert top == null;</span>
<span class="fc" id="L702">					top = b;</span>
				}
<span class="fc" id="L704">				b.parent = null;</span>
<span class="fc" id="L705">				b = b.right;</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">				if (b == B.child)</span>
<span class="fc" id="L707">					break;</span>
			}
<span class="fc" id="L709">			B.deltaOdd += delta - B.delta1;</span>
<span class="fc" id="L710">			B.delta0 = delta;</span>

			// Iterate over sub blossom that should stay in the tree
<span class="fc bfc" id="L713" title="All 2 branches covered.">			boolean left = matched[g.edgeSource(top.toLeftEdge)] == top.toLeftEdge;</span>
<span class="fc" id="L714">			Consumer&lt;Blossom&gt; inBlossom = b -&gt; {</span>
<span class="fc" id="L715">				b.root = B.root;</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">				b.treeParentEdge = left ? b.toRightEdge : b.toLeftEdge;</span>
<span class="fc" id="L717">				b.deltaOdd = B.deltaOdd;</span>
<span class="fc" id="L718">			};</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">			Function&lt;Blossom, Blossom&gt; next = b -&gt; left ? b.left : b.right;</span>
<span class="fc" id="L720">			for (Blossom b = top;;) {</span>
				// sub blossom odd
<span class="fc" id="L722">				inBlossom.accept(b);</span>
<span class="fc" id="L723">				b.isEven = false;</span>
<span class="fc" id="L724">				b.delta1 = delta;</span>
<span class="fc" id="L725">				find1Split(b);</span>
<span class="pc bpc" id="L726" title="1 of 2 branches missed.">				assert b.expandHandle == null;</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">				if (!b.isSingleton()) {</span>
<span class="fc" id="L728">					b.expandDelta = b.z0 / 2 + b.delta1;</span>
<span class="fc" id="L729">					b.expandHandle = expandEvents.insert(b);</span>
				}
<span class="fc bfc" id="L731" title="All 2 branches covered.">				if (b == base)</span>
<span class="fc" id="L732">					break;</span>
<span class="fc" id="L733">				b = next.apply(b);</span>

				// sub blossom even
<span class="fc" id="L736">				inBlossom.accept(b);</span>
<span class="fc" id="L737">				makeEven(b);</span>
<span class="fc" id="L738">				b = next.apply(b);</span>
			}
<span class="fc" id="L740">			top.treeParentEdge = B.treeParentEdge;</span>
<span class="fc" id="L741">			B.root = -1;</span>

			// Iterate over sub blossoms that should not stay in the tree
<span class="fc" id="L744">			for (Blossom b = base;;) {</span>
<span class="fc" id="L745">				b = next.apply(b);</span>
<span class="fc bfc" id="L746" title="All 2 branches covered.">				if (b == top)</span>
<span class="fc" id="L747">					break;</span>
<span class="pc bpc" id="L748" title="1 of 2 branches missed.">				assert vToSMFId[b.base] == null;</span>
<span class="fc" id="L749">				b.root = -1;</span>
<span class="fc" id="L750">				b.treeParentEdge = -1;</span>
<span class="fc" id="L751">				b.isEven = false;</span>
<span class="fc" id="L752">				find1Split(b);</span>
<span class="fc" id="L753">				b.deltaOdd = B.deltaOdd;</span>
<span class="pc bpc" id="L754" title="1 of 2 branches missed.">				assert b.growHandle == null;</span>
<span class="fc" id="L755">				EdgeEvent inEdgeEvent = find1.getKey(find1.findMin(vToFind1Idx[b.base]));</span>
<span class="fc bfc" id="L756" title="All 2 branches covered.">				if (inEdgeEvent != null)</span>
<span class="fc" id="L757">					b.growHandle = growEvents.insert(inEdgeEvent);</span>
<span class="fc" id="L758">			}</span>

			// Disassemble right and left pointers of sub blossoms
<span class="fc" id="L761">			for (Blossom b = top;;) {</span>
<span class="fc" id="L762">				Blossom nextB = b.left;</span>
<span class="fc" id="L763">				b.right = b.left = null;</span>
<span class="fc" id="L764">				EdgeVal bRightData = edgeVal.get(b.toRightEdge);</span>
<span class="fc" id="L765">				EdgeVal bRightTwinData = edgeVal.get(bRightData.twin);</span>
<span class="fc" id="L766">				EdgeVal bLeftData = edgeVal.get(b.toLeftEdge);</span>
<span class="fc" id="L767">				EdgeVal bLeftTwinData = edgeVal.get(bLeftData.twin);</span>
<span class="fc" id="L768">				bRightData.b0 = bRightData.b1 = null;</span>
<span class="fc" id="L769">				bRightTwinData.b0 = bRightTwinData.b1 = null;</span>
<span class="fc" id="L770">				bLeftData.b0 = bLeftData.b1 = null;</span>
<span class="fc" id="L771">				bLeftTwinData.b0 = bLeftTwinData.b1 = null;</span>
<span class="fc" id="L772">				b.toRightEdge = b.toLeftEdge = -1;</span>
<span class="fc bfc" id="L773" title="All 2 branches covered.">				if (nextB == top)</span>
<span class="fc" id="L774">					break;</span>
<span class="fc" id="L775">				b = nextB;</span>
<span class="fc" id="L776">			}</span>
<span class="fc" id="L777">		}</span>

		private void augmentStep(int bridge) {
<span class="fc" id="L780">			debug.print(&quot;augStep:&quot;);</span>
<span class="fc" id="L781">			final int bu = g.edgeSource(bridge), bv = g.edgeTarget(bridge);</span>
<span class="fc" id="L782">			Blossom U = topBlossom(bu), V = topBlossom(bv);</span>
<span class="fc" id="L783">			Blossom[] bs = new Blossom[] { U, V };</span>
<span class="fc bfc" id="L784" title="All 2 branches covered.">			for (Blossom b : bs) {</span>

<span class="pc bpc" id="L786" title="1 of 2 branches missed.">				assert b.isEven;</span>
<span class="fc" id="L787">				int e = -1;</span>
<span class="fc bfc" id="L788" title="All 2 branches covered.">				for (int u = b == U ? bu : bv;;) {</span>
<span class="pc bpc" id="L789" title="1 of 2 branches missed.">					assert b.isEven;</span>
<span class="fc" id="L790">					augmentPath(b, u);</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">					if (e != -1) {</span>
<span class="fc" id="L792">						int eu = g.edgeSource(e), ev = g.edgeTarget(e);</span>
<span class="fc" id="L793">						matched[eu] = e;</span>
<span class="fc" id="L794">						matched[ev] = edgeVal.get(e).twin;</span>

<span class="fc" id="L796">						debug.print(&quot; &quot;, Integer.valueOf(e));</span>
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">						assert matched[eu] != -1;</span>
<span class="pc bpc" id="L798" title="1 of 2 branches missed.">						assert matched[ev] != -1;</span>
					}
<span class="fc bfc" id="L800" title="All 2 branches covered.">					if (b.treeParentEdge == -1)</span>
<span class="fc" id="L801">						break;</span>
					// Odd
<span class="fc" id="L803">					b = topBlossom(g.edgeTarget(b.treeParentEdge));</span>
<span class="pc bpc" id="L804" title="1 of 2 branches missed.">					assert !b.isEven;</span>
<span class="fc" id="L805">					u = g.edgeSource(b.treeParentEdge);</span>
<span class="fc" id="L806">					augmentPath(b, u);</span>

					// Even
<span class="fc" id="L809">					e = b.treeParentEdge;</span>
<span class="fc" id="L810">					u = g.edgeTarget(e);</span>
<span class="fc" id="L811">					b = topBlossom(u);</span>
				}
			}
<span class="fc" id="L814">			matched[bu] = bridge;</span>
<span class="fc" id="L815">			matched[bv] = edgeVal.get(bridge).twin;</span>
<span class="fc" id="L816">			debug.println(&quot; &quot;, Integer.valueOf(bridge));</span>
<span class="fc" id="L817">		}</span>

		private void augmentPath(Blossom B, int u) {
<span class="fc bfc" id="L820" title="All 2 branches covered.">			if (B.base == u)</span>
<span class="fc" id="L821">				return;</span>

<span class="fc" id="L823">			int m = matched[u];</span>
<span class="fc" id="L824">			int mu = g.edgeSource(m), mv = g.edgeTarget(m);</span>
<span class="fc" id="L825">			matched[mu] = matched[mv] = -1;</span>
<span class="fc" id="L826">			EdgeVal mData = edgeVal.get(m);</span>
			int v;
			Blossom b0, b1, b2;
<span class="pc bpc" id="L829" title="1 of 2 branches missed.">			if (mu == u) {</span>
//				u = m.u();
<span class="fc" id="L831">				v = mv;</span>
<span class="fc" id="L832">				b0 = mData.b0;</span>
<span class="fc" id="L833">				b1 = mData.b1;</span>
			} else {
//				u = m.v();
<span class="nc" id="L836">				v = mu;</span>
<span class="nc" id="L837">				b0 = mData.b1;</span>
<span class="nc" id="L838">				b1 = mData.b0;</span>
			}

			int xy;
<span class="fc bfc" id="L842" title="All 2 branches covered.">			if (b0.right == b1) {</span>
<span class="fc" id="L843">				b2 = b1.right;</span>
<span class="fc" id="L844">				xy = b1.toRightEdge;</span>
			} else {
<span class="pc bpc" id="L846" title="1 of 2 branches missed.">				assert b0.left == b1;</span>
<span class="fc" id="L847">				b2 = b1.left;</span>
<span class="fc" id="L848">				xy = b1.toLeftEdge;</span>
			}

<span class="pc bpc" id="L851" title="1 of 2 branches missed.">			assert b0 != b1;</span>
<span class="pc bpc" id="L852" title="1 of 2 branches missed.">			assert b1 != b2;</span>
<span class="pc bpc" id="L853" title="1 of 2 branches missed.">			assert b2 != b0;</span>
<span class="pc bpc" id="L854" title="1 of 2 branches missed.">			assert b1.base == v;</span>

<span class="fc" id="L856">			int xyU = g.edgeSource(xy), xyV = g.edgeTarget(xy);</span>
<span class="fc" id="L857">			augmentPath(b1, xyU);</span>
<span class="fc" id="L858">			augmentPath(B, xyV);</span>
<span class="fc" id="L859">			matched[xyU] = xy;</span>
<span class="fc" id="L860">			matched[xyV] = edgeVal.get(xy).twin;</span>

<span class="pc bpc" id="L862" title="1 of 2 branches missed.">			assert g.edgeSource(matched[xyU]) == xyU;</span>
<span class="pc bpc" id="L863" title="1 of 2 branches missed.">			assert g.edgeTarget(matched[xyU]) == xyV;</span>
<span class="pc bpc" id="L864" title="1 of 2 branches missed.">			assert g.edgeSource(matched[xyV]) == xyV;</span>
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">			assert g.edgeSource(matched[xyV]) == xyV;</span>

<span class="pc bpc" id="L867" title="1 of 2 branches missed.">			assert matched[b1.base] != -1;</span>
<span class="pc bpc" id="L868" title="1 of 2 branches missed.">			assert matched[b2.base] != -1;</span>

<span class="fc" id="L870">			debug.print(&quot; &quot;, Integer.valueOf(xy));</span>
<span class="fc" id="L871">			for (Blossom p = b0.parent;; p = p.parent) {</span>
<span class="fc bfc" id="L872" title="All 2 branches covered.">				if (p == B.parent)</span>
<span class="fc" id="L873">					break;</span>
<span class="fc" id="L874">				p.base = u;</span>
			}
<span class="fc" id="L876">		}</span>

		/* compute the path from vertex to base */
		private int computePath(Blossom B, int u, int[] path) {
<span class="fc" id="L880">			return computePath(B, u, path, 0, false);</span>
		}

		private int computePath(Blossom B, int u, int[] path, int pathSize, boolean reverse) {
<span class="fc bfc" id="L884" title="All 2 branches covered.">			if (!reverse)</span>
<span class="fc" id="L885">				path[pathSize++] = u;</span>

<span class="fc bfc" id="L887" title="All 2 branches covered.">			if (B.base != u) {</span>
<span class="fc" id="L888">				int m = matched[u];</span>
<span class="fc" id="L889">				EdgeVal mData = edgeVal.get(m);</span>
//				int v;
				Blossom b0, b1 /* , b2 */;
<span class="pc bpc" id="L892" title="1 of 2 branches missed.">				if (g.edgeSource(m) == u) {</span>
//					v = m.v();
<span class="fc" id="L894">					b0 = mData.b0;</span>
<span class="fc" id="L895">					b1 = mData.b1;</span>
				} else {
//					v = m.u();
<span class="nc" id="L898">					b0 = mData.b1;</span>
<span class="nc" id="L899">					b1 = mData.b0;</span>
				}

				int xy;
<span class="fc bfc" id="L903" title="All 2 branches covered.">				if (b0.right == b1) {</span>
//					b2 = b1.right;
<span class="fc" id="L905">					xy = b1.toRightEdge;</span>
				} else {
//					b2 = b1.left;
<span class="fc" id="L908">					xy = b1.toLeftEdge;</span>
				}

<span class="fc bfc" id="L911" title="All 2 branches covered.">				pathSize = computePath(b1, g.edgeSource(xy), path, pathSize, !reverse);</span>
<span class="fc" id="L912">				pathSize = computePath(B, g.edgeTarget(xy), path, pathSize, reverse);</span>
			}

<span class="fc bfc" id="L915" title="All 2 branches covered.">			if (reverse)</span>
<span class="fc" id="L916">				path[pathSize++] = u;</span>
<span class="fc" id="L917">			return pathSize;</span>
		}

		private boolean isEven(int v) {
<span class="fc" id="L921">			return blossoms[v].isEven;</span>
		}

		private boolean isInTree(int v) {
<span class="nc bnc" id="L925" title="All 2 branches missed.">			return topBlossom(v).root != -1;</span>
		}

		private boolean isInTree(Blossom b) {
<span class="pc bpc" id="L929" title="1 of 4 branches missed.">			return b.parent != null ? isInTree(b.base) : b.root != -1;</span>
		}

		private Blossom find0(int v) {
<span class="fc" id="L933">			return find0Blossoms[find0.find(v)];</span>
		}

		private Blossom find1(int v) {
<span class="fc" id="L937">			int idx = vToFind1Idx[v];</span>
<span class="fc bfc" id="L938" title="All 2 branches covered.">			return idx &lt; 0 ? null : find1Blossoms[find1.find(idx)];</span>
		}

		/* Init find1 indexing for all vertices contained in the blossomD */
		private void find1InitIndexing(Blossom b) {
<span class="fc" id="L943">			b.find1SeqBegin = find1IdxNext;</span>
<span class="fc bfc" id="L944" title="All 2 branches covered.">			if (b.child == null) {</span>
<span class="fc" id="L945">				b.isEven = false;</span>
<span class="fc" id="L946">				vToFind1Idx[b.base] = find1IdxNext++;</span>
			} else {
<span class="fc" id="L948">				for (Blossom sub = b.child;;) {</span>
<span class="fc" id="L949">					find1InitIndexing(sub);</span>
<span class="fc" id="L950">					sub = sub.right;</span>
<span class="fc bfc" id="L951" title="All 2 branches covered.">					if (sub == b.child)</span>
<span class="fc" id="L952">						break;</span>
				}
			}
<span class="fc" id="L955">			b.find1SeqEnd = find1IdxNext;</span>
<span class="fc" id="L956">		}</span>

		/* Split a blossom from a bigger blossom in the find1 data structure */
		private void find1Split(Blossom b) {
<span class="fc" id="L960">			int begin = b.find1SeqBegin, end = b.find1SeqEnd;</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">			Blossom b1 = begin &gt; 0 ? find1Blossoms[find1.find(begin - 1)] : null;</span>
<span class="fc bfc" id="L962" title="All 2 branches covered.">			Blossom b2 = end &lt; find1Blossoms.length ? find1Blossoms[find1.find(end)] : null;</span>

<span class="fc bfc" id="L964" title="All 2 branches covered.">			if (begin &gt; 0) {</span>
<span class="fc" id="L965">				find1.split(begin);</span>
<span class="fc" id="L966">				find1Blossoms[find1.find(begin - 1)] = b1;</span>
			}
<span class="fc bfc" id="L968" title="All 2 branches covered.">			if (end &lt; find1Blossoms.length) {</span>
<span class="fc" id="L969">				find1.split(end);</span>
<span class="fc" id="L970">				find1Blossoms[find1.find(end)] = b2;</span>
			}
<span class="fc" id="L972">			find1Blossoms[find1.find(b.find1SeqBegin)] = b;</span>
<span class="fc" id="L973">		}</span>

		private Blossom topBlossom(int v) {
<span class="fc bfc" id="L976" title="All 2 branches covered.">			return isEven(v) ? find0(v) : find1(v);</span>
		}

		private Blossom topBlossom(Blossom v) {
<span class="pc bpc" id="L980" title="1 of 2 branches missed.">			assert v.isSingleton();</span>
<span class="fc bfc" id="L981" title="All 2 branches covered.">			return v.isEven ? find0(v.base) : find1(v.base);</span>
		}

		private void forEachBlossom(Consumer&lt;Blossom&gt; f) {
<span class="fc" id="L985">			int n = g.vertices().size();</span>
<span class="fc" id="L986">			int visitIdx = ++blossomVisitIdx;</span>
<span class="fc bfc" id="L987" title="All 2 branches covered.">			for (int v = 0; v &lt; n; v++) {</span>
<span class="fc bfc" id="L988" title="All 2 branches covered.">				for (Blossom b = blossoms[v]; b.lastVisitIdx != visitIdx; b = b.parent) {</span>
<span class="fc" id="L989">					b.lastVisitIdx = visitIdx;</span>
<span class="fc" id="L990">					f.accept(b);</span>
<span class="fc bfc" id="L991" title="All 2 branches covered.">					if (b.parent == null)</span>
<span class="fc" id="L992">						break;</span>
				}
			}
<span class="fc" id="L995">		}</span>

		private void forEachTopBlossom(Consumer&lt;Blossom&gt; f) {
<span class="fc" id="L998">			int n = g.vertices().size();</span>
<span class="fc" id="L999">			int visitIdx = ++blossomVisitIdx;</span>
<span class="fc bfc" id="L1000" title="All 2 branches covered.">			for (int v = 0; v &lt; n; v++) {</span>
<span class="fc bfc" id="L1001" title="All 2 branches covered.">				for (Blossom b = blossoms[v]; b.lastVisitIdx != visitIdx; b = b.parent) {</span>
<span class="fc" id="L1002">					b.lastVisitIdx = visitIdx;</span>
<span class="fc bfc" id="L1003" title="All 2 branches covered.">					if (b.parent == null) {</span>
<span class="fc bfc" id="L1004" title="All 2 branches covered.">						if (b.child != null) {</span>
							// Mark children as visited in case blossom expand
<span class="fc" id="L1006">							for (Blossom c = b.child;;) {</span>
<span class="fc" id="L1007">								c.lastVisitIdx = visitIdx;</span>
<span class="fc" id="L1008">								c = c.left;</span>
<span class="fc bfc" id="L1009" title="All 2 branches covered.">								if (c == b.child)</span>
<span class="fc" id="L1010">									break;</span>
							}
						}
<span class="fc" id="L1013">						f.accept(b);</span>
<span class="fc" id="L1014">						break;</span>
					}
				}
			}
<span class="fc" id="L1018">		}</span>

		private static void forEachVertexInBlossom(Blossom b, IntConsumer op) {
<span class="fc bfc" id="L1021" title="All 2 branches covered.">			if (b.child == null) {</span>
<span class="fc" id="L1022">				op.accept(b.base);</span>
<span class="fc" id="L1023">				return;</span>
			}

<span class="fc" id="L1026">			for (Blossom sub = b.child;;) {</span>
<span class="fc" id="L1027">				forEachVertexInBlossom(sub, op);</span>
<span class="fc" id="L1028">				sub = sub.right;</span>
<span class="fc bfc" id="L1029" title="All 2 branches covered.">				if (sub == b.child)</span>
<span class="fc" id="L1030">					break;</span>
			}
<span class="fc" id="L1032">		}</span>

		private double dualVal(int v) {
<span class="fc" id="L1035">			Blossom b = find1(v);</span>
<span class="fc bfc" id="L1036" title="All 2 branches covered.">			double deltaB = b == null ? 0 : b.deltaOdd;</span>
<span class="fc" id="L1037">			double val = vertexDualValBase[v] + deltaB;</span>
			boolean isEven;

<span class="fc bfc" id="L1040" title="All 2 branches covered.">			if (b == null)</span>
				// v was part of an even blossom from the beginning of the current search
<span class="fc" id="L1042">				val -= delta;</span>
<span class="fc bfc" id="L1043" title="All 4 branches covered.">			else if ((isEven = isEven(v)) || b.root != -1)</span>
				// v was part of an out blossom, b is max blossom before v became even
<span class="fc bfc" id="L1045" title="All 2 branches covered.">				val += isEven ? -(delta - b.delta0) : +(delta - b.delta1);</span>
<span class="fc" id="L1046">			return val;</span>
		}

		private double dualVal(Blossom b) {
<span class="pc bpc" id="L1050" title="1 of 2 branches missed.">			assert !b.isSingleton();</span>
<span class="fc" id="L1051">			double zb = b.z0;</span>
<span class="fc bfc" id="L1052" title="All 4 branches covered.">			if (b.parent == null &amp;&amp; b.root != -1)</span>
<span class="fc bfc" id="L1053" title="All 2 branches covered.">				zb += 2 * (b.isEven ? +(delta - b.delta0) : -(delta - b.delta1));</span>
<span class="fc" id="L1054">			return zb;</span>
		}

		private double growEventsKey(EdgeEvent event) {
<span class="fc" id="L1058">			int v = g.edgeTarget(event.e);</span>
<span class="pc bpc" id="L1059" title="1 of 2 branches missed.">			assert !isEven(v);</span>
<span class="fc" id="L1060">			return find1(v).deltaOdd + event.slack;</span>
		}

		private void insertGrowEventsFromVertex(int u) {
<span class="fc" id="L1064">			double Yu = delta + dualVal(u);</span>
<span class="fc bfc" id="L1065" title="All 2 branches covered.">			for (EdgeIter eit = g.edgesOut(u); eit.hasNext();) {</span>
<span class="fc" id="L1066">				int e = eit.nextInt();</span>
<span class="fc" id="L1067">				int v = eit.v();</span>
<span class="fc bfc" id="L1068" title="All 2 branches covered.">				if (isEven(v))</span>
<span class="fc" id="L1069">					continue;</span>
<span class="fc" id="L1070">				double slackBar = Yu + vertexDualValBase[v] - w.weight(e);</span>
<span class="fc bfc" id="L1071" title="All 4 branches covered.">				if (vToGrowEvent[v] == null || slackBar &lt; vToGrowEvent[v].slack) {</span>
<span class="fc" id="L1072">					EdgeEvent event = vToGrowEvent[v] = new EdgeEvent(e, slackBar);</span>
<span class="fc bfc" id="L1073" title="All 2 branches covered.">					if (!find1.decreaseKey(vToFind1Idx[v], event))</span>
<span class="fc" id="L1074">						continue;</span>
<span class="pc bpc" id="L1075" title="1 of 2 branches missed.">					assert find1.getKey(find1.findMin(vToFind1Idx[v])) == event;</span>

<span class="fc" id="L1077">					Blossom V = find1(v);</span>
<span class="fc bfc" id="L1078" title="All 2 branches covered.">					if (!isInTree(V)) {</span>
<span class="fc bfc" id="L1079" title="All 2 branches covered.">						if (V.growHandle == null)</span>
<span class="fc" id="L1080">							V.growHandle = growEvents.insert(event);</span>
						else
<span class="fc" id="L1082">							growEvents.decreaseKey(V.growHandle, event);</span>
					}
				}
<span class="fc" id="L1085">			}</span>
<span class="fc" id="L1086">		}</span>

		private void insertBlossomEventsFromVertex(int u) {
<span class="pc bpc" id="L1089" title="1 of 2 branches missed.">			assert isEven(u);</span>
<span class="fc" id="L1090">			Blossom U = find0(u);</span>
<span class="fc" id="L1091">			double Yu = delta + dualVal(u);</span>
<span class="fc bfc" id="L1092" title="All 2 branches covered.">			for (EdgeIter eit = g.edgesOut(u); eit.hasNext();) {</span>
<span class="fc" id="L1093">				final int e = eit.nextInt();</span>
<span class="fc" id="L1094">				int v = eit.v();</span>
<span class="fc bfc" id="L1095" title="All 2 branches covered.">				if (!isEven(v))</span>
<span class="fc" id="L1096">					continue;</span>
<span class="fc" id="L1097">				Blossom V = find0(v);</span>
<span class="fc bfc" id="L1098" title="All 2 branches covered.">				if (U == V)</span>
<span class="fc" id="L1099">					continue;</span>
<span class="fc" id="L1100">				double Yv = delta + dualVal(v);</span>
<span class="fc" id="L1101">				double slackBar = Yu + Yv - w.weight(e);</span>

<span class="pc bpc" id="L1103" title="1 of 2 branches missed.">				assert slackBar &gt;= 0;</span>
<span class="fc" id="L1104">				smf.addNonTreeEdge(vToSMFId[u], vToSMFId[v], new EdgeEvent(e, slackBar));</span>
<span class="fc" id="L1105">			}</span>
<span class="fc" id="L1106">		};</span>

		private void connectSubBlossoms(Blossom left, Blossom right, int leftToRightEdge, boolean reverse) {
<span class="fc bfc" id="L1109" title="All 2 branches covered.">			if (reverse) {</span>
<span class="fc" id="L1110">				Blossom temp = left;</span>
<span class="fc" id="L1111">				left = right;</span>
<span class="fc" id="L1112">				right = temp;</span>
<span class="fc" id="L1113">				leftToRightEdge = edgeVal.get(leftToRightEdge).twin;</span>
			}
<span class="fc" id="L1115">			EdgeVal edgeData = edgeVal.get(leftToRightEdge);</span>
<span class="fc" id="L1116">			EdgeVal twinData = edgeVal.get(edgeData.twin);</span>
<span class="fc" id="L1117">			left.right = right;</span>
<span class="fc" id="L1118">			left.toRightEdge = leftToRightEdge;</span>
<span class="fc" id="L1119">			right.left = left;</span>
<span class="fc" id="L1120">			right.toLeftEdge = edgeData.twin;</span>
<span class="fc" id="L1121">			edgeData.b0 = left;</span>
<span class="fc" id="L1122">			edgeData.b1 = right;</span>
<span class="fc" id="L1123">			twinData.b0 = right;</span>
<span class="fc" id="L1124">			twinData.b1 = left;</span>
<span class="fc" id="L1125">		}</span>

		private SubtreeMergeFindmin.Node&lt;Blossom&gt; smfAddLeaf(int v, SubtreeMergeFindmin.Node&lt;Blossom&gt; parentSmfNode) {
<span class="fc" id="L1128">			SubtreeMergeFindmin.Node&lt;Blossom&gt; smfNode = smf.addLeaf(parentSmfNode, blossoms[v]);</span>
<span class="pc bpc" id="L1129" title="1 of 2 branches missed.">			assert vToSMFId[v] == null;</span>
<span class="fc" id="L1130">			return vToSMFId[v] = smfNode;</span>
		}

		private SubtreeMergeFindmin.Node&lt;Blossom&gt; smfParent(SubtreeMergeFindmin.Node&lt;Blossom&gt; smfNode) {
<span class="fc" id="L1134">			SubtreeMergeFindmin.Node&lt;Blossom&gt; p = smfNode.getParent();</span>
<span class="pc bpc" id="L1135" title="1 of 2 branches missed.">			return p != smfRootOfRoots ? p : null;</span>
		}

		private Blossom lcaInSearchTree(Blossom b1, Blossom b2) {
<span class="fc" id="L1139">			int visitIdx = ++blossomVisitIdx;</span>
<span class="fc" id="L1140">			for (Blossom[] bs = new Blossom[] { b1, b2 };;) {</span>
<span class="pc bpc" id="L1141" title="1 of 4 branches missed.">				if (bs[0] == null &amp;&amp; bs[1] == null)</span>
<span class="nc" id="L1142">					return null;</span>
<span class="fc bfc" id="L1143" title="All 2 branches covered.">				for (int i = 0; i &lt; bs.length; i++) {</span>
<span class="fc" id="L1144">					Blossom b = bs[i];</span>
<span class="fc bfc" id="L1145" title="All 2 branches covered.">					if (b == null)</span>
<span class="fc" id="L1146">						continue;</span>
<span class="fc bfc" id="L1147" title="All 2 branches covered.">					if (b.lastVisitIdx == visitIdx)</span>
<span class="fc" id="L1148">						return b;</span>
<span class="fc" id="L1149">					b.lastVisitIdx = visitIdx;</span>
<span class="fc bfc" id="L1150" title="All 2 branches covered.">					bs[i] = b.treeParentEdge == -1 ? null : topBlossom(g.edgeTarget(b.treeParentEdge));</span>
				}
			}
		}

	}

	@Override
	public boolean isDebugPrintEnable() {
<span class="nc" id="L1159">		return debugPrintManager.isEnable();</span>
	}

	@Override
	public void setDebugPrintEnable(boolean enable) {
<span class="nc" id="L1164">		debugPrintManager.setEnable(enable);</span>
<span class="nc" id="L1165">	}</span>

	@Override
	public void setDebugPrintStream(PrintStream printStream) {
<span class="nc" id="L1169">		debugPrintManager.setPrintStream(printStream);</span>
<span class="nc" id="L1170">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>