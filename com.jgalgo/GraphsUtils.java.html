<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GraphsUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo</a> &gt; <span class="el_source">GraphsUtils.java</span></div><h1>GraphsUtils.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jgalgo;

import java.util.Collections;
import java.util.Set;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntIterator;
import it.unimi.dsi.fastutil.ints.IntSet;
import it.unimi.dsi.fastutil.ints.IntSets;

class GraphsUtils {

	private GraphsUtils() {}

	static int getFullyBranchingTreeDepth(Graph t, int root) {
<span class="fc" id="L31">		for (int parent = -1, u = root, depth = 0;; depth++) {</span>
<span class="fc" id="L32">			int v = parent;</span>
<span class="fc bfc" id="L33" title="All 2 branches covered.">			for (EdgeIter eit = t.edgesOut(u); eit.hasNext();) {</span>
<span class="fc" id="L34">				eit.nextInt();</span>
<span class="fc" id="L35">				v = eit.target();</span>
<span class="fc bfc" id="L36" title="All 2 branches covered.">				if (v != parent)</span>
<span class="fc" id="L37">					break;</span>
			}
<span class="fc bfc" id="L39" title="All 2 branches covered.">			if (v == parent)</span>
<span class="fc" id="L40">				return depth;</span>
<span class="fc" id="L41">			parent = u;</span>
<span class="fc" id="L42">			u = v;</span>
		}
	}

	static int[] calcDegree(Graph g, IntCollection edges) {
<span class="fc" id="L47">		int[] degree = new int[g.vertices().size()];</span>
<span class="fc bfc" id="L48" title="All 2 branches covered.">		for (IntIterator eit = edges.iterator(); eit.hasNext();) {</span>
<span class="fc" id="L49">			int e = eit.nextInt();</span>
<span class="fc" id="L50">			degree[g.edgeSource(e)]++;</span>
<span class="fc" id="L51">			degree[g.edgeTarget(e)]++;</span>
<span class="fc" id="L52">		}</span>
<span class="fc" id="L53">		return degree;</span>
	}

	// static String formatAdjacencyMatrix(Graph g) {
	// return formatAdjacencyMatrix(g, e -&gt; e == -1 ? &quot;0&quot; : &quot;1&quot;);
	// }

	// static String formatAdjacencyMatrixWeighted(Graph g, EdgeWeightFunc w) {
	// double minWeight = Double.MAX_VALUE;
	// for (IntIterator it = g.edges().iterator(); it.hasNext();) {
	// int e = it.nextInt();
	// double ew = w.weight(e);
	// if (ew &lt; minWeight)
	// minWeight = ew;
	// }

	// int unlimitedPrecision = 64;
	// int precision = minWeight &gt;= 1 ? 2 : Math.min(unlimitedPrecision, (int) -Math.log10(minWeight));

	// return precision == unlimitedPrecision
	// ? formatAdjacencyMatrix(g, e -&gt; e == -1 ? &quot;-&quot; : Double.toString(w.weight(e)))
	// : formatAdjacencyMatrix(g,
	// e -&gt; e == -1 ? &quot;-&quot; : String.format(&quot;%.&quot; + precision + &quot;f&quot;, Double.valueOf(w.weight(e))));
	// }

	// static String formatAdjacencyMatrixWeightedInt(Graph g, EdgeWeightFunc.Int w) {
	// return formatAdjacencyMatrix(g, e -&gt; e == -1 ? &quot;-&quot; : Integer.toString(w.weightInt(e)));
	// }

	// static String formatAdjacencyMatrix(Graph g, Int2ObjectFunction&lt;String&gt; formatter) {
	// int n = g.vertices().size();
	// if (n == 0)
	// return &quot;[]&quot;;

	// /* format all edges */
	// String[][] strs = new String[n][n];
	// for (int u = 0; u &lt; n; u++) {
	// for (EdgeIter eit = g.edgesOut(u); eit.hasNext();) {
	// int e = eit.nextInt();
	// strs[u][eit.target()] = formatter.apply(e);
	// }
	// }

	// /* calculate cell size */
	// int maxStr = 0;
	// for (int u = 0; u &lt; n; u++) {
	// for (int v = 0; v &lt; n; v++) {
	// if (strs[u][v] == null)
	// strs[u][v] = formatter.apply(null);
	// if (strs[u][v].length() &gt; maxStr)
	// maxStr = strs[u][v].length();
	// }
	// }
	// int vertexLabelCellSize = String.valueOf(n - 1).length() + 1;
	// int cellSize = Math.max(maxStr + 1, vertexLabelCellSize);

	// /* format header row */
	// StringBuilder s = new StringBuilder();
	// s.append(strMult(&quot; &quot;, vertexLabelCellSize));
	// for (int v = 0; v &lt; n; v++)
	// s.append(String.format(&quot;% &quot; + cellSize + &quot;d&quot;, Integer.valueOf(v)));
	// s.append('\n');

	// /* format adjacency matrix */
	// for (int u = 0; u &lt; n; u++) {
	// s.append(String.format(&quot;% &quot; + vertexLabelCellSize + &quot;d&quot;, Integer.valueOf(u)));
	// for (int v = 0; v &lt; n; v++) {
	// if (strs[u][v].length() &lt; cellSize)
	// s.append(strMult(&quot; &quot;, cellSize - strs[u][v].length()));
	// s.append(strs[u][v]);
	// }
	// s.append('\n');
	// }

	// return s.toString();
	// }

	// private static String strMult(String s, int n) {
	// return String.join(&quot;&quot;, Collections.nCopies(n, s));
	// }

	static Graph referenceGraph(Graph g, Object refEdgeWeightKey) {
<span class="fc bfc" id="L135" title="All 2 branches covered.">		if (g.getCapabilities().directed()) {</span>
<span class="fc" id="L136">			Graph g0 = new GraphArrayDirected(g.vertices().size());</span>
<span class="fc" id="L137">			Weights.Int edgeRef = g0.addEdgesWeights(refEdgeWeightKey, int.class);</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">			for (IntIterator it = g.edges().iterator(); it.hasNext();) {</span>
<span class="fc" id="L139">				int e = it.nextInt();</span>
<span class="fc" id="L140">				int e0 = g0.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L141">				edgeRef.set(e0, e);</span>
<span class="fc" id="L142">			}</span>
<span class="fc" id="L143">			return g0;</span>
		} else {
<span class="fc" id="L145">			Graph g0 = new GraphArrayUndirected(g.vertices().size());</span>
<span class="fc" id="L146">			Weights.Int edgeRef = g0.addEdgesWeights(refEdgeWeightKey, int.class);</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">			for (IntIterator it = g.edges().iterator(); it.hasNext();) {</span>
<span class="fc" id="L148">				int e = it.nextInt();</span>
<span class="fc" id="L149">				int e0 = g0.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L150">				edgeRef.set(e0, e);</span>
<span class="fc" id="L151">			}</span>
<span class="fc" id="L152">			return g0;</span>
		}
	}

	static boolean containsSelfLoops(Graph g) {
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">		if (!g.getCapabilities().selfEdges())</span>
<span class="nc" id="L158">			return false;</span>
<span class="fc" id="L159">		int n = g.vertices().size();</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">		for (int u = 0; u &lt; n; u++) {</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">			for (EdgeIter eit = g.edgesOut(u); eit.hasNext();) {</span>
<span class="fc" id="L162">				eit.nextInt();</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">				if (u == eit.target())</span>
<span class="nc" id="L164">					return true;</span>
			}
		}
<span class="fc" id="L167">		return false;</span>
	}

	static boolean containsParallelEdges(Graph g) {
<span class="fc bfc" id="L171" title="All 2 branches covered.">		if (!g.getCapabilities().parallelEdges())</span>
<span class="fc" id="L172">			return false;</span>
<span class="fc" id="L173">		int n = g.vertices().size();</span>
<span class="fc" id="L174">		int[] lastVisit = new int[n];</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">		for (int u = 0; u &lt; n; u++) {</span>
<span class="fc" id="L176">			final int visitIdx = u + 1;</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">			for (EdgeIter eit = g.edgesOut(u); eit.hasNext();) {</span>
<span class="fc" id="L178">				eit.nextInt();</span>
<span class="fc" id="L179">				int v = eit.target();</span>
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">				if (lastVisit[v] == visitIdx)</span>
<span class="nc" id="L181">					return true;</span>
<span class="fc" id="L182">				lastVisit[v] = visitIdx;</span>
<span class="fc" id="L183">			}</span>
		}
<span class="fc" id="L185">		return false;</span>
	}

	static interface UndirectedGraphImpl extends Graph {

		@Override
		default EdgeIter edgesIn(int v) {
<span class="fc" id="L192">			return edgesOut(v);</span>
		}

		@Override
		default void removeEdgesOf(int u) {
<span class="fc bfc" id="L197" title="All 2 branches covered.">			for (EdgeIter eit = edgesOut(u); eit.hasNext();) {</span>
<span class="fc" id="L198">				eit.nextInt();</span>
<span class="fc" id="L199">				eit.remove();</span>
			}
<span class="fc" id="L201">		}</span>

		@Override
		default void removeEdgesOutOf(int u) {
<span class="nc" id="L205">			removeEdgesOf(u);</span>
<span class="nc" id="L206">		}</span>

		@Override
		default void removeEdgesInOf(int v) {
<span class="nc" id="L210">			removeEdgesOf(v);</span>
<span class="nc" id="L211">		}</span>

		@Override
		default void reverseEdge(int edge) {
			// Do nothing
<span class="nc" id="L216">		}</span>

		@Override
		default int degreeIn(int v) {
<span class="fc" id="L220">			return degreeOut(v);</span>
		}

	}

	private abstract static class EmptyGraph implements Graph {

		@Override
		public IntSet vertices() {
<span class="nc" id="L229">			return IntSets.emptySet();</span>
		}

		@Override
		public IntSet edges() {
<span class="nc" id="L234">			return IntSets.emptySet();</span>
		}

		@Override
		public int addVertex() {
<span class="nc" id="L239">			throw new UnsupportedOperationException();</span>
		}

		@Override
		public void removeVertex(int v) {
<span class="nc" id="L244">			throw new IndexOutOfBoundsException(v);</span>
		}

		@Override
		public void removeVertices(IntCollection vs) {
<span class="nc bnc" id="L249" title="All 2 branches missed.">			if (!vs.isEmpty())</span>
<span class="nc" id="L250">				throw new IndexOutOfBoundsException(vs.iterator().nextInt());</span>
<span class="nc" id="L251">		}</span>

		@Override
		public EdgeIter edgesOut(int u) {
<span class="nc" id="L255">			throw new IndexOutOfBoundsException(u);</span>
		}

		@Override
		public EdgeIter edgesIn(int v) {
<span class="nc" id="L260">			throw new IndexOutOfBoundsException(v);</span>
		}

		@Override
		public EdgeIter getEdges(int u, int v) {
<span class="nc" id="L265">			throw new IndexOutOfBoundsException(u);</span>
		}

		@Override
		public int addEdge(int u, int v) {
<span class="nc" id="L270">			throw new IndexOutOfBoundsException(u);</span>
		}

		@Override
		public void removeEdge(int edge) {
<span class="nc" id="L275">			throw new IndexOutOfBoundsException(edge);</span>
		}

		@Override
		public void removeEdges(IntCollection edges) {
<span class="nc bnc" id="L280" title="All 2 branches missed.">			if (!edges.isEmpty())</span>
<span class="nc" id="L281">				throw new IndexOutOfBoundsException(edges.iterator().nextInt());</span>
<span class="nc" id="L282">		}</span>

		@Override
		public void reverseEdge(int edge) {
<span class="nc" id="L286">			throw new IndexOutOfBoundsException(edge);</span>
		}

		@Override
		public int edgeSource(int edge) {
<span class="nc" id="L291">			throw new IndexOutOfBoundsException(edge);</span>
		}

		@Override
		public int edgeTarget(int edge) {
<span class="nc" id="L296">			throw new IndexOutOfBoundsException(edge);</span>
		}

		@Override
<span class="nc" id="L300">		public void clear() {}</span>

		@Override
<span class="nc" id="L303">		public void clearEdges() {}</span>

		@Override
		public &lt;V, WeightsT extends Weights&lt;V&gt;&gt; WeightsT getVerticesWeights(Object key) {
<span class="nc" id="L307">			return null;</span>
		}

		@Override
		public &lt;V, WeightsT extends Weights&lt;V&gt;&gt; WeightsT addVerticesWeights(Object key, Class&lt;? super V&gt; type) {
<span class="nc" id="L312">			throw new UnsupportedOperationException();</span>
		}

		@Override
		public &lt;V, WeightsT extends Weights&lt;V&gt;&gt; WeightsT addVerticesWeights(Object key, Class&lt;? super V&gt; type,
				V defVal) {
<span class="nc" id="L318">			throw new UnsupportedOperationException();</span>
		}

		@Override
<span class="nc" id="L322">		public void removeVerticesWeights(Object key) {}</span>

		@Override
		public Set&lt;Object&gt; getVerticesWeightKeys() {
<span class="nc" id="L326">			return Collections.emptySet();</span>
		}

		@Override
		public &lt;E, WeightsT extends Weights&lt;E&gt;&gt; WeightsT getEdgesWeights(Object key) {
<span class="nc" id="L331">			return null;</span>
		}

		@Override
		public &lt;E, WeightsT extends Weights&lt;E&gt;&gt; WeightsT addEdgesWeights(Object key, Class&lt;? super E&gt; type) {
<span class="nc" id="L336">			throw new UnsupportedOperationException();</span>
		}

		@Override
		public &lt;E, WeightsT extends Weights&lt;E&gt;&gt; WeightsT addEdgesWeights(Object key, Class&lt;? super E&gt; type, E defVal) {
<span class="nc" id="L341">			throw new UnsupportedOperationException();</span>
		}

		@Override
<span class="nc" id="L345">		public void removeEdgesWeights(Object key) {}</span>

		@Override
		public Set&lt;Object&gt; getEdgesWeightsKeys() {
<span class="nc" id="L349">			return Collections.emptySet();</span>
		}

		@Override
		public IDStrategy.Continues getVerticesIDStrategy() {
			// TODO Auto-generated method stub
<span class="nc" id="L355">			throw new UnsupportedOperationException(&quot;Unimplemented method 'getVerticesIDStrategy'&quot;);</span>
		}

		@Override
		public IDStrategy getEdgesIDStrategy() {
			// TODO Auto-generated method stub
<span class="nc" id="L361">			throw new UnsupportedOperationException(&quot;Unimplemented method 'getEdgesIDStrategy'&quot;);</span>
		}

	}

<span class="fc" id="L366">	static final Graph EmptyGraphUndirected = new EmptyGraph() {</span>
		@Override
		public GraphCapabilities getCapabilities() {
<span class="nc" id="L369">			return EmptyCapabilitiesUndirected;</span>
		}
	};

<span class="fc" id="L373">	static final Graph EmptyGraphDirected = new EmptyGraph() {</span>
		@Override
		public GraphCapabilities getCapabilities() {
<span class="nc" id="L376">			return EmptyCapabilitiesDirected;</span>
		}
	};

	private abstract static class EmptyCapabilities implements GraphCapabilities {

		@Override
		public boolean vertexAdd() {
<span class="nc" id="L384">			return false;</span>
		}

		@Override
		public boolean vertexRemove() {
<span class="nc" id="L389">			return false;</span>
		}

		@Override
		public boolean edgeAdd() {
<span class="nc" id="L394">			return false;</span>
		}

		@Override
		public boolean edgeRemove() {
<span class="nc" id="L399">			return false;</span>
		}

		@Override
		public boolean parallelEdges() {
<span class="nc" id="L404">			return false;</span>
		}

		@Override
		public boolean selfEdges() {
<span class="nc" id="L409">			return false;</span>
		}
	}

<span class="fc" id="L413">	static final GraphCapabilities EmptyCapabilitiesUndirected = new EmptyCapabilities() {</span>
		@Override
		public boolean directed() {
<span class="nc" id="L416">			return false;</span>
		}
	};

<span class="fc" id="L420">	static final GraphCapabilities EmptyCapabilitiesDirected = new EmptyCapabilities() {</span>
		@Override
		public boolean directed() {
<span class="nc" id="L423">			return true;</span>
		}
	};

	static double edgesWeightSum(IntIterator eit, EdgeWeightFunc w) {
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">		if (w instanceof EdgeWeightFunc.Int) {</span>
<span class="fc" id="L429">			EdgeWeightFunc.Int w0 = (EdgeWeightFunc.Int) w;</span>
<span class="fc" id="L430">			int sum = 0;</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">			while (eit.hasNext())</span>
<span class="fc" id="L432">				sum += w0.weightInt(eit.nextInt());</span>
<span class="fc" id="L433">			return sum;</span>

		} else {
<span class="nc" id="L436">			double sum = 0;</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">			while (eit.hasNext())</span>
<span class="nc" id="L438">				sum += w.weight(eit.nextInt());</span>
<span class="nc" id="L439">			return sum;</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>