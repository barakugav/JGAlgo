<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GraphsUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo</a> &gt; <span class="el_source">GraphsUtils.java</span></div><h1>GraphsUtils.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jgalgo;

import java.util.Collections;
import java.util.Set;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntIterator;
import it.unimi.dsi.fastutil.ints.IntSet;
import it.unimi.dsi.fastutil.ints.IntSets;

class GraphsUtils {

	private GraphsUtils() {}

	static int[] calcDegree(Graph g, IntCollection edges) {
<span class="fc" id="L31">		int[] degree = new int[g.vertices().size()];</span>
<span class="fc bfc" id="L32" title="All 2 branches covered.">		for (IntIterator eit = edges.iterator(); eit.hasNext();) {</span>
<span class="fc" id="L33">			int e = eit.nextInt();</span>
<span class="fc" id="L34">			degree[g.edgeSource(e)]++;</span>
<span class="fc" id="L35">			degree[g.edgeTarget(e)]++;</span>
<span class="fc" id="L36">		}</span>
<span class="fc" id="L37">		return degree;</span>
	}

	// static String formatAdjacencyMatrix(Graph g) {
	// return formatAdjacencyMatrix(g, e -&gt; e == -1 ? &quot;0&quot; : &quot;1&quot;);
	// }

	// static String formatAdjacencyMatrixWeighted(Graph g, EdgeWeightFunc w) {
	// double minWeight = Double.MAX_VALUE;
	// for (IntIterator it = g.edges().iterator(); it.hasNext();) {
	// int e = it.nextInt();
	// double ew = w.weight(e);
	// if (ew &lt; minWeight)
	// minWeight = ew;
	// }

	// int unlimitedPrecision = 64;
	// int precision = minWeight &gt;= 1 ? 2 : Math.min(unlimitedPrecision, (int) -Math.log10(minWeight));

	// return precision == unlimitedPrecision
	// ? formatAdjacencyMatrix(g, e -&gt; e == -1 ? &quot;-&quot; : Double.toString(w.weight(e)))
	// : formatAdjacencyMatrix(g,
	// e -&gt; e == -1 ? &quot;-&quot; : String.format(&quot;%.&quot; + precision + &quot;f&quot;, Double.valueOf(w.weight(e))));
	// }

	// static String formatAdjacencyMatrixWeightedInt(Graph g, EdgeWeightFunc.Int w) {
	// return formatAdjacencyMatrix(g, e -&gt; e == -1 ? &quot;-&quot; : Integer.toString(w.weightInt(e)));
	// }

	// static String formatAdjacencyMatrix(Graph g, Int2ObjectFunction&lt;String&gt; formatter) {
	// int n = g.vertices().size();
	// if (n == 0)
	// return &quot;[]&quot;;

	// /* format all edges */
	// String[][] strs = new String[n][n];
	// for (int u = 0; u &lt; n; u++) {
	// for (EdgeIter eit = g.edgesOut(u); eit.hasNext();) {
	// int e = eit.nextInt();
	// strs[u][eit.target()] = formatter.apply(e);
	// }
	// }

	// /* calculate cell size */
	// int maxStr = 0;
	// for (int u = 0; u &lt; n; u++) {
	// for (int v = 0; v &lt; n; v++) {
	// if (strs[u][v] == null)
	// strs[u][v] = formatter.apply(null);
	// if (strs[u][v].length() &gt; maxStr)
	// maxStr = strs[u][v].length();
	// }
	// }
	// int vertexLabelCellSize = String.valueOf(n - 1).length() + 1;
	// int cellSize = Math.max(maxStr + 1, vertexLabelCellSize);

	// /* format header row */
	// StringBuilder s = new StringBuilder();
	// s.append(strMult(&quot; &quot;, vertexLabelCellSize));
	// for (int v = 0; v &lt; n; v++)
	// s.append(String.format(&quot;% &quot; + cellSize + &quot;d&quot;, Integer.valueOf(v)));
	// s.append('\n');

	// /* format adjacency matrix */
	// for (int u = 0; u &lt; n; u++) {
	// s.append(String.format(&quot;% &quot; + vertexLabelCellSize + &quot;d&quot;, Integer.valueOf(u)));
	// for (int v = 0; v &lt; n; v++) {
	// if (strs[u][v].length() &lt; cellSize)
	// s.append(strMult(&quot; &quot;, cellSize - strs[u][v].length()));
	// s.append(strs[u][v]);
	// }
	// s.append('\n');
	// }

	// return s.toString();
	// }

	// private static String strMult(String s, int n) {
	// return String.join(&quot;&quot;, Collections.nCopies(n, s));
	// }

	static Graph referenceGraph(Graph g, Object refEdgeWeightKey) {
<span class="fc" id="L119">		Graph gRef = GraphBuilder.newDirected().setDirected(g.getCapabilities().directed()).build(g.vertices().size());</span>
<span class="fc" id="L120">		Weights.Int edgeRef = gRef.addEdgesWeights(refEdgeWeightKey, int.class);</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">		for (IntIterator it = g.edges().iterator(); it.hasNext();) {</span>
<span class="fc" id="L122">			int e = it.nextInt();</span>
<span class="fc" id="L123">			int eRef = gRef.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L124">			edgeRef.set(eRef, e);</span>
<span class="fc" id="L125">		}</span>
<span class="fc" id="L126">		return gRef;</span>
	}

	static boolean containsSelfLoops(Graph g) {
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">		if (!g.getCapabilities().selfEdges())</span>
<span class="nc" id="L131">			return false;</span>
<span class="fc" id="L132">		int n = g.vertices().size();</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">		for (int u = 0; u &lt; n; u++) {</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">			for (EdgeIter eit = g.edgesOut(u); eit.hasNext();) {</span>
<span class="fc" id="L135">				eit.nextInt();</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">				if (u == eit.target())</span>
<span class="nc" id="L137">					return true;</span>
			}
		}
<span class="fc" id="L140">		return false;</span>
	}

	static boolean containsParallelEdges(Graph g) {
<span class="fc bfc" id="L144" title="All 2 branches covered.">		if (!g.getCapabilities().parallelEdges())</span>
<span class="fc" id="L145">			return false;</span>
<span class="fc" id="L146">		int n = g.vertices().size();</span>
<span class="fc" id="L147">		int[] lastVisit = new int[n];</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">		for (int u = 0; u &lt; n; u++) {</span>
<span class="fc" id="L149">			final int visitIdx = u + 1;</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">			for (EdgeIter eit = g.edgesOut(u); eit.hasNext();) {</span>
<span class="fc" id="L151">				eit.nextInt();</span>
<span class="fc" id="L152">				int v = eit.target();</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">				if (lastVisit[v] == visitIdx)</span>
<span class="nc" id="L154">					return true;</span>
<span class="fc" id="L155">				lastVisit[v] = visitIdx;</span>
<span class="fc" id="L156">			}</span>
		}
<span class="fc" id="L158">		return false;</span>
	}

	static interface UndirectedGraphImpl extends Graph {

		@Override
		default EdgeIter edgesIn(int target) {
<span class="fc" id="L165">			return edgesOut(target);</span>
		}

		@Override
		default void removeEdgesOf(int source) {
<span class="fc bfc" id="L170" title="All 2 branches covered.">			for (EdgeIter eit = edgesOut(source); eit.hasNext();) {</span>
<span class="fc" id="L171">				eit.nextInt();</span>
<span class="fc" id="L172">				eit.remove();</span>
			}
<span class="fc" id="L174">		}</span>

		@Override
		default void removeEdgesOutOf(int source) {
<span class="nc" id="L178">			removeEdgesOf(source);</span>
<span class="nc" id="L179">		}</span>

		@Override
		default void removeEdgesInOf(int target) {
<span class="nc" id="L183">			removeEdgesOf(target);</span>
<span class="nc" id="L184">		}</span>

		@Override
		default void reverseEdge(int edge) {
			// Do nothing
<span class="nc" id="L189">		}</span>

		@Override
		default int degreeIn(int target) {
<span class="fc" id="L193">			return degreeOut(target);</span>
		}

	}

	private abstract static class EmptyGraph implements Graph {

		@Override
		public IntSet vertices() {
<span class="nc" id="L202">			return IntSets.emptySet();</span>
		}

		@Override
		public IntSet edges() {
<span class="nc" id="L207">			return IntSets.emptySet();</span>
		}

		@Override
		public int addVertex() {
<span class="nc" id="L212">			throw new UnsupportedOperationException();</span>
		}

		@Override
		public void removeVertex(int vertex) {
<span class="nc" id="L217">			throw new IndexOutOfBoundsException(vertex);</span>
		}

		// @Override
		// public void removeVertices(IntCollection vs) {
		// if (!vs.isEmpty())
		// throw new IndexOutOfBoundsException(vs.iterator().nextInt());
		// }

		@Override
		public EdgeIter edgesOut(int source) {
<span class="nc" id="L228">			throw new IndexOutOfBoundsException(source);</span>
		}

		@Override
		public EdgeIter edgesIn(int target) {
<span class="nc" id="L233">			throw new IndexOutOfBoundsException(target);</span>
		}

		@Override
		public EdgeIter getEdges(int source, int target) {
<span class="nc" id="L238">			throw new IndexOutOfBoundsException(source);</span>
		}

		@Override
		public int addEdge(int source, int target) {
<span class="nc" id="L243">			throw new IndexOutOfBoundsException(source);</span>
		}

		@Override
		public void removeEdge(int edge) {
<span class="nc" id="L248">			throw new IndexOutOfBoundsException(edge);</span>
		}

		// @Override
		// public void removeEdges(IntCollection edges) {
		// if (!edges.isEmpty())
		// throw new IndexOutOfBoundsException(edges.iterator().nextInt());
		// }

		@Override
		public void reverseEdge(int edge) {
<span class="nc" id="L259">			throw new IndexOutOfBoundsException(edge);</span>
		}

		@Override
		public int edgeSource(int edge) {
<span class="nc" id="L264">			throw new IndexOutOfBoundsException(edge);</span>
		}

		@Override
		public int edgeTarget(int edge) {
<span class="nc" id="L269">			throw new IndexOutOfBoundsException(edge);</span>
		}

		@Override
<span class="nc" id="L273">		public void clear() {}</span>

		@Override
<span class="nc" id="L276">		public void clearEdges() {}</span>

		@Override
		public &lt;V, WeightsT extends Weights&lt;V&gt;&gt; WeightsT getVerticesWeights(Object key) {
<span class="nc" id="L280">			return null;</span>
		}

		@Override
		public &lt;V, WeightsT extends Weights&lt;V&gt;&gt; WeightsT addVerticesWeights(Object key, Class&lt;? super V&gt; type) {
<span class="nc" id="L285">			throw new UnsupportedOperationException();</span>
		}

		@Override
		public &lt;V, WeightsT extends Weights&lt;V&gt;&gt; WeightsT addVerticesWeights(Object key, Class&lt;? super V&gt; type,
				V defVal) {
<span class="nc" id="L291">			throw new UnsupportedOperationException();</span>
		}

		@Override
<span class="nc" id="L295">		public void removeVerticesWeights(Object key) {}</span>

		@Override
		public Set&lt;Object&gt; getVerticesWeightKeys() {
<span class="nc" id="L299">			return Collections.emptySet();</span>
		}

		@Override
		public &lt;E, WeightsT extends Weights&lt;E&gt;&gt; WeightsT getEdgesWeights(Object key) {
<span class="nc" id="L304">			return null;</span>
		}

		@Override
		public &lt;E, WeightsT extends Weights&lt;E&gt;&gt; WeightsT addEdgesWeights(Object key, Class&lt;? super E&gt; type) {
<span class="nc" id="L309">			throw new UnsupportedOperationException();</span>
		}

		@Override
		public &lt;E, WeightsT extends Weights&lt;E&gt;&gt; WeightsT addEdgesWeights(Object key, Class&lt;? super E&gt; type, E defVal) {
<span class="nc" id="L314">			throw new UnsupportedOperationException();</span>
		}

		@Override
<span class="nc" id="L318">		public void removeEdgesWeights(Object key) {}</span>

		@Override
		public Set&lt;Object&gt; getEdgesWeightsKeys() {
<span class="nc" id="L322">			return Collections.emptySet();</span>
		}

		@Override
		public IDStrategy.Continues getVerticesIDStrategy() {
			// TODO Auto-generated method stub
<span class="nc" id="L328">			throw new UnsupportedOperationException(&quot;Unimplemented method 'getVerticesIDStrategy'&quot;);</span>
		}

		@Override
		public IDStrategy getEdgesIDStrategy() {
			// TODO Auto-generated method stub
<span class="nc" id="L334">			throw new UnsupportedOperationException(&quot;Unimplemented method 'getEdgesIDStrategy'&quot;);</span>
		}

	}

<span class="fc" id="L339">	static final Graph EmptyGraphUndirected = new EmptyGraph() {</span>
		@Override
		public GraphCapabilities getCapabilities() {
<span class="nc" id="L342">			return EmptyCapabilitiesUndirected;</span>
		}
	};

<span class="fc" id="L346">	static final Graph EmptyGraphDirected = new EmptyGraph() {</span>
		@Override
		public GraphCapabilities getCapabilities() {
<span class="nc" id="L349">			return EmptyCapabilitiesDirected;</span>
		}
	};

	private abstract static class EmptyCapabilities implements GraphCapabilities {

		@Override
		public boolean vertexAdd() {
<span class="nc" id="L357">			return false;</span>
		}

		@Override
		public boolean vertexRemove() {
<span class="nc" id="L362">			return false;</span>
		}

		@Override
		public boolean edgeAdd() {
<span class="nc" id="L367">			return false;</span>
		}

		@Override
		public boolean edgeRemove() {
<span class="nc" id="L372">			return false;</span>
		}

		@Override
		public boolean parallelEdges() {
<span class="nc" id="L377">			return false;</span>
		}

		@Override
		public boolean selfEdges() {
<span class="nc" id="L382">			return false;</span>
		}
	}

<span class="fc" id="L386">	static final GraphCapabilities EmptyCapabilitiesUndirected = new EmptyCapabilities() {</span>
		@Override
		public boolean directed() {
<span class="nc" id="L389">			return false;</span>
		}
	};

<span class="fc" id="L393">	static final GraphCapabilities EmptyCapabilitiesDirected = new EmptyCapabilities() {</span>
		@Override
		public boolean directed() {
<span class="nc" id="L396">			return true;</span>
		}
	};

	static double edgesWeightSum(IntIterator eit, EdgeWeightFunc w) {
<span class="fc bfc" id="L401" title="All 2 branches covered.">		if (w instanceof EdgeWeightFunc.Int) {</span>
<span class="fc" id="L402">			EdgeWeightFunc.Int w0 = (EdgeWeightFunc.Int) w;</span>
<span class="fc" id="L403">			int sum = 0;</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">			while (eit.hasNext())</span>
<span class="fc" id="L405">				sum += w0.weightInt(eit.nextInt());</span>
<span class="fc" id="L406">			return sum;</span>

		} else {
<span class="fc" id="L409">			double sum = 0;</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">			while (eit.hasNext())</span>
<span class="fc" id="L411">				sum += w.weight(eit.nextInt());</span>
<span class="fc" id="L412">			return sum;</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>