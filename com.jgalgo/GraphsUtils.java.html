<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GraphsUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo</a> &gt; <span class="el_source">GraphsUtils.java</span></div><h1>GraphsUtils.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jgalgo;

import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntIterator;

class GraphsUtils {

	private GraphsUtils() {}

	static int getFullyBranchingTreeDepth(Graph t, int root) {
<span class="fc" id="L27">		for (int parent = -1, u = root, depth = 0;; depth++) {</span>
<span class="fc" id="L28">			int v = parent;</span>
<span class="fc bfc" id="L29" title="All 2 branches covered.">			for (EdgeIter eit = t.edgesOut(u); eit.hasNext();) {</span>
<span class="fc" id="L30">				eit.nextInt();</span>
<span class="fc" id="L31">				v = eit.target();</span>
<span class="fc bfc" id="L32" title="All 2 branches covered.">				if (v != parent)</span>
<span class="fc" id="L33">					break;</span>
			}
<span class="fc bfc" id="L35" title="All 2 branches covered.">			if (v == parent)</span>
<span class="fc" id="L36">				return depth;</span>
<span class="fc" id="L37">			parent = u;</span>
<span class="fc" id="L38">			u = v;</span>
		}
	}

	static int[] calcDegree(Graph g, IntCollection edges) {
<span class="fc" id="L43">		int[] degree = new int[g.vertices().size()];</span>
<span class="fc bfc" id="L44" title="All 2 branches covered.">		for (IntIterator eit = edges.iterator(); eit.hasNext();) {</span>
<span class="fc" id="L45">			int e = eit.nextInt();</span>
<span class="fc" id="L46">			degree[g.edgeSource(e)]++;</span>
<span class="fc" id="L47">			degree[g.edgeTarget(e)]++;</span>
<span class="fc" id="L48">		}</span>
<span class="fc" id="L49">		return degree;</span>
	}

	// static String formatAdjacencyMatrix(Graph g) {
	// return formatAdjacencyMatrix(g, e -&gt; e == -1 ? &quot;0&quot; : &quot;1&quot;);
	// }

	// static String formatAdjacencyMatrixWeighted(Graph g, EdgeWeightFunc w) {
	// double minWeight = Double.MAX_VALUE;
	// for (IntIterator it = g.edges().iterator(); it.hasNext();) {
	// int e = it.nextInt();
	// double ew = w.weight(e);
	// if (ew &lt; minWeight)
	// minWeight = ew;
	// }

	// int unlimitedPrecision = 64;
	// int precision = minWeight &gt;= 1 ? 2 : Math.min(unlimitedPrecision, (int) -Math.log10(minWeight));

	// return precision == unlimitedPrecision
	// ? formatAdjacencyMatrix(g, e -&gt; e == -1 ? &quot;-&quot; : Double.toString(w.weight(e)))
	// : formatAdjacencyMatrix(g,
	// e -&gt; e == -1 ? &quot;-&quot; : String.format(&quot;%.&quot; + precision + &quot;f&quot;, Double.valueOf(w.weight(e))));
	// }

	// static String formatAdjacencyMatrixWeightedInt(Graph g, EdgeWeightFunc.Int w) {
	// return formatAdjacencyMatrix(g, e -&gt; e == -1 ? &quot;-&quot; : Integer.toString(w.weightInt(e)));
	// }

	// static String formatAdjacencyMatrix(Graph g, Int2ObjectFunction&lt;String&gt; formatter) {
	// int n = g.vertices().size();
	// if (n == 0)
	// return &quot;[]&quot;;

	// /* format all edges */
	// String[][] strs = new String[n][n];
	// for (int u = 0; u &lt; n; u++) {
	// for (EdgeIter eit = g.edgesOut(u); eit.hasNext();) {
	// int e = eit.nextInt();
	// strs[u][eit.target()] = formatter.apply(e);
	// }
	// }

	// /* calculate cell size */
	// int maxStr = 0;
	// for (int u = 0; u &lt; n; u++) {
	// for (int v = 0; v &lt; n; v++) {
	// if (strs[u][v] == null)
	// strs[u][v] = formatter.apply(null);
	// if (strs[u][v].length() &gt; maxStr)
	// maxStr = strs[u][v].length();
	// }
	// }
	// int vertexLabelCellSize = String.valueOf(n - 1).length() + 1;
	// int cellSize = Math.max(maxStr + 1, vertexLabelCellSize);

	// /* format header row */
	// StringBuilder s = new StringBuilder();
	// s.append(strMult(&quot; &quot;, vertexLabelCellSize));
	// for (int v = 0; v &lt; n; v++)
	// s.append(String.format(&quot;% &quot; + cellSize + &quot;d&quot;, Integer.valueOf(v)));
	// s.append('\n');

	// /* format adjacency matrix */
	// for (int u = 0; u &lt; n; u++) {
	// s.append(String.format(&quot;% &quot; + vertexLabelCellSize + &quot;d&quot;, Integer.valueOf(u)));
	// for (int v = 0; v &lt; n; v++) {
	// if (strs[u][v].length() &lt; cellSize)
	// s.append(strMult(&quot; &quot;, cellSize - strs[u][v].length()));
	// s.append(strs[u][v]);
	// }
	// s.append('\n');
	// }

	// return s.toString();
	// }

	// private static String strMult(String s, int n) {
	// return String.join(&quot;&quot;, Collections.nCopies(n, s));
	// }

	static Graph referenceGraph(Graph g, Object refEdgeWeightKey) {
<span class="fc bfc" id="L131" title="All 2 branches covered.">		if (g.getCapabilities().directed()) {</span>
<span class="fc" id="L132">			Graph g0 = new GraphArrayDirected(g.vertices().size());</span>
<span class="fc" id="L133">			Weights.Int edgeRef = g0.addEdgesWeights(refEdgeWeightKey, int.class);</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">			for (IntIterator it = g.edges().iterator(); it.hasNext();) {</span>
<span class="fc" id="L135">				int e = it.nextInt();</span>
<span class="fc" id="L136">				int e0 = g0.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L137">				edgeRef.set(e0, e);</span>
<span class="fc" id="L138">			}</span>
<span class="fc" id="L139">			return g0;</span>
		} else {
<span class="fc" id="L141">			Graph g0 = new GraphArrayUndirected(g.vertices().size());</span>
<span class="fc" id="L142">			Weights.Int edgeRef = g0.addEdgesWeights(refEdgeWeightKey, int.class);</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">			for (IntIterator it = g.edges().iterator(); it.hasNext();) {</span>
<span class="fc" id="L144">				int e = it.nextInt();</span>
<span class="fc" id="L145">				int e0 = g0.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L146">				edgeRef.set(e0, e);</span>
<span class="fc" id="L147">			}</span>
<span class="fc" id="L148">			return g0;</span>
		}
	}

	static boolean containsSelfLoops(Graph g) {
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">		if (!g.getCapabilities().selfEdges())</span>
<span class="nc" id="L154">			return false;</span>
<span class="fc" id="L155">		int n = g.vertices().size();</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">		for (int u = 0; u &lt; n; u++) {</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">			for (EdgeIter eit = g.edgesOut(u); eit.hasNext();) {</span>
<span class="fc" id="L158">				eit.nextInt();</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">				if (u == eit.target())</span>
<span class="nc" id="L160">					return true;</span>
			}
		}
<span class="fc" id="L163">		return false;</span>
	}

	static boolean containsParallelEdges(Graph g) {
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">		if (!g.getCapabilities().parallelEdges())</span>
<span class="nc" id="L168">			return false;</span>
<span class="fc" id="L169">		int n = g.vertices().size();</span>
<span class="fc" id="L170">		int[] lastVisit = new int[n];</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">		for (int u = 0; u &lt; n; u++) {</span>
<span class="fc" id="L172">			final int visitIdx = u + 1;</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">			for (EdgeIter eit = g.edgesOut(u); eit.hasNext();) {</span>
<span class="fc" id="L174">				eit.nextInt();</span>
<span class="fc" id="L175">				int v = eit.target();</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">				if (lastVisit[v] == visitIdx)</span>
<span class="nc" id="L177">					return true;</span>
<span class="fc" id="L178">				lastVisit[v] = visitIdx;</span>
<span class="fc" id="L179">			}</span>
		}
<span class="fc" id="L181">		return false;</span>
	}

	static interface UndirectedGraphImpl extends Graph {

		@Override
		default EdgeIter edgesIn(int v) {
<span class="fc" id="L188">			return edgesOut(v);</span>
		}

		@Override
		default void removeEdgesOf(int u) {
<span class="fc bfc" id="L193" title="All 2 branches covered.">			for (EdgeIter eit = edgesOut(u); eit.hasNext();) {</span>
<span class="fc" id="L194">				eit.nextInt();</span>
<span class="fc" id="L195">				eit.remove();</span>
			}
<span class="fc" id="L197">		}</span>

		@Override
		default void removeEdgesOutOf(int u) {
<span class="nc" id="L201">			removeEdgesOf(u);</span>
<span class="nc" id="L202">		}</span>

		@Override
		default void removeEdgesInOf(int v) {
<span class="nc" id="L206">			removeEdgesOf(v);</span>
<span class="nc" id="L207">		}</span>

		@Override
		default void reverseEdge(int edge) {
			// Do nothing
<span class="nc" id="L212">		}</span>

		@Override
		default int degreeIn(int v) {
<span class="fc" id="L216">			return degreeOut(v);</span>
		}

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>