<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GraphsUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo</a> &gt; <span class="el_source">GraphsUtils.java</span></div><h1>GraphsUtils.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jgalgo;

import java.util.Collections;
import java.util.Set;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntIterator;
import it.unimi.dsi.fastutil.ints.IntSet;
import it.unimi.dsi.fastutil.ints.IntSets;

class GraphsUtils {

	private GraphsUtils() {}

	static int[] calcDegree(Graph g, IntCollection edges) {
<span class="fc" id="L31">		int[] degree = new int[g.vertices().size()];</span>
<span class="fc bfc" id="L32" title="All 2 branches covered.">		for (IntIterator eit = edges.iterator(); eit.hasNext();) {</span>
<span class="fc" id="L33">			int e = eit.nextInt();</span>
<span class="fc" id="L34">			degree[g.edgeSource(e)]++;</span>
<span class="fc" id="L35">			degree[g.edgeTarget(e)]++;</span>
<span class="fc" id="L36">		}</span>
<span class="fc" id="L37">		return degree;</span>
	}

	// static String formatAdjacencyMatrix(Graph g) {
	// return formatAdjacencyMatrix(g, e -&gt; e == -1 ? &quot;0&quot; : &quot;1&quot;);
	// }

	// static String formatAdjacencyMatrixWeighted(Graph g, EdgeWeightFunc w) {
	// double minWeight = Double.MAX_VALUE;
	// for (IntIterator it = g.edges().iterator(); it.hasNext();) {
	// int e = it.nextInt();
	// double ew = w.weight(e);
	// if (ew &lt; minWeight)
	// minWeight = ew;
	// }

	// int unlimitedPrecision = 64;
	// int precision = minWeight &gt;= 1 ? 2 : Math.min(unlimitedPrecision, (int) -Math.log10(minWeight));

	// return precision == unlimitedPrecision
	// ? formatAdjacencyMatrix(g, e -&gt; e == -1 ? &quot;-&quot; : Double.toString(w.weight(e)))
	// : formatAdjacencyMatrix(g,
	// e -&gt; e == -1 ? &quot;-&quot; : String.format(&quot;%.&quot; + precision + &quot;f&quot;, Double.valueOf(w.weight(e))));
	// }

	// static String formatAdjacencyMatrixWeightedInt(Graph g, EdgeWeightFunc.Int w) {
	// return formatAdjacencyMatrix(g, e -&gt; e == -1 ? &quot;-&quot; : Integer.toString(w.weightInt(e)));
	// }

	// static String formatAdjacencyMatrix(Graph g, Int2ObjectFunction&lt;String&gt; formatter) {
	// int n = g.vertices().size();
	// if (n == 0)
	// return &quot;[]&quot;;

	// /* format all edges */
	// String[][] strs = new String[n][n];
	// for (int u = 0; u &lt; n; u++) {
	// for (EdgeIter eit = g.edgesOut(u); eit.hasNext();) {
	// int e = eit.nextInt();
	// strs[u][eit.target()] = formatter.apply(e);
	// }
	// }

	// /* calculate cell size */
	// int maxStr = 0;
	// for (int u = 0; u &lt; n; u++) {
	// for (int v = 0; v &lt; n; v++) {
	// if (strs[u][v] == null)
	// strs[u][v] = formatter.apply(null);
	// if (strs[u][v].length() &gt; maxStr)
	// maxStr = strs[u][v].length();
	// }
	// }
	// int vertexLabelCellSize = String.valueOf(n - 1).length() + 1;
	// int cellSize = Math.max(maxStr + 1, vertexLabelCellSize);

	// /* format header row */
	// StringBuilder s = new StringBuilder();
	// s.append(strMult(&quot; &quot;, vertexLabelCellSize));
	// for (int v = 0; v &lt; n; v++)
	// s.append(String.format(&quot;% &quot; + cellSize + &quot;d&quot;, Integer.valueOf(v)));
	// s.append('\n');

	// /* format adjacency matrix */
	// for (int u = 0; u &lt; n; u++) {
	// s.append(String.format(&quot;% &quot; + vertexLabelCellSize + &quot;d&quot;, Integer.valueOf(u)));
	// for (int v = 0; v &lt; n; v++) {
	// if (strs[u][v].length() &lt; cellSize)
	// s.append(strMult(&quot; &quot;, cellSize - strs[u][v].length()));
	// s.append(strs[u][v]);
	// }
	// s.append('\n');
	// }

	// return s.toString();
	// }

	// private static String strMult(String s, int n) {
	// return String.join(&quot;&quot;, Collections.nCopies(n, s));
	// }

	static Graph referenceGraph(Graph g, Object refEdgeWeightKey) {
<span class="fc" id="L119">		Graph gRef = GraphBuilder.newDirected().setDirected(g.getCapabilities().directed())</span>
<span class="fc" id="L120">				.setVerticesNum(g.vertices().size()).build();</span>
<span class="fc" id="L121">		Weights.Int edgeRef = gRef.addEdgesWeights(refEdgeWeightKey, int.class);</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">		for (IntIterator it = g.edges().iterator(); it.hasNext();) {</span>
<span class="fc" id="L123">			int e = it.nextInt();</span>
<span class="fc" id="L124">			int eRef = gRef.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L125">			edgeRef.set(eRef, e);</span>
<span class="fc" id="L126">		}</span>
<span class="fc" id="L127">		return gRef;</span>
	}

	static boolean containsSelfLoops(Graph g) {
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">		if (!g.getCapabilities().selfEdges())</span>
<span class="nc" id="L132">			return false;</span>
<span class="fc" id="L133">		int n = g.vertices().size();</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">		for (int u = 0; u &lt; n; u++) {</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">			for (EdgeIter eit = g.edgesOut(u); eit.hasNext();) {</span>
<span class="fc" id="L136">				eit.nextInt();</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">				if (u == eit.target())</span>
<span class="nc" id="L138">					return true;</span>
			}
		}
<span class="fc" id="L141">		return false;</span>
	}

	static boolean containsParallelEdges(Graph g) {
<span class="fc bfc" id="L145" title="All 2 branches covered.">		if (!g.getCapabilities().parallelEdges())</span>
<span class="fc" id="L146">			return false;</span>
<span class="fc" id="L147">		int n = g.vertices().size();</span>
<span class="fc" id="L148">		int[] lastVisit = new int[n];</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">		for (int u = 0; u &lt; n; u++) {</span>
<span class="fc" id="L150">			final int visitIdx = u + 1;</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">			for (EdgeIter eit = g.edgesOut(u); eit.hasNext();) {</span>
<span class="fc" id="L152">				eit.nextInt();</span>
<span class="fc" id="L153">				int v = eit.target();</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">				if (lastVisit[v] == visitIdx)</span>
<span class="nc" id="L155">					return true;</span>
<span class="fc" id="L156">				lastVisit[v] = visitIdx;</span>
<span class="fc" id="L157">			}</span>
		}
<span class="fc" id="L159">		return false;</span>
	}

	static interface UndirectedGraphImpl extends Graph {

		@Override
		default EdgeIter edgesIn(int v) {
<span class="fc" id="L166">			return edgesOut(v);</span>
		}

		@Override
		default void removeEdgesOf(int u) {
<span class="fc bfc" id="L171" title="All 2 branches covered.">			for (EdgeIter eit = edgesOut(u); eit.hasNext();) {</span>
<span class="fc" id="L172">				eit.nextInt();</span>
<span class="fc" id="L173">				eit.remove();</span>
			}
<span class="fc" id="L175">		}</span>

		@Override
		default void removeEdgesOutOf(int u) {
<span class="nc" id="L179">			removeEdgesOf(u);</span>
<span class="nc" id="L180">		}</span>

		@Override
		default void removeEdgesInOf(int v) {
<span class="nc" id="L184">			removeEdgesOf(v);</span>
<span class="nc" id="L185">		}</span>

		@Override
		default void reverseEdge(int edge) {
			// Do nothing
<span class="nc" id="L190">		}</span>

		@Override
		default int degreeIn(int v) {
<span class="fc" id="L194">			return degreeOut(v);</span>
		}

	}

	private abstract static class EmptyGraph implements Graph {

		@Override
		public IntSet vertices() {
<span class="nc" id="L203">			return IntSets.emptySet();</span>
		}

		@Override
		public IntSet edges() {
<span class="nc" id="L208">			return IntSets.emptySet();</span>
		}

		@Override
		public int addVertex() {
<span class="nc" id="L213">			throw new UnsupportedOperationException();</span>
		}

		@Override
		public void removeVertex(int v) {
<span class="nc" id="L218">			throw new IndexOutOfBoundsException(v);</span>
		}

		@Override
		public void removeVertices(IntCollection vs) {
<span class="nc bnc" id="L223" title="All 2 branches missed.">			if (!vs.isEmpty())</span>
<span class="nc" id="L224">				throw new IndexOutOfBoundsException(vs.iterator().nextInt());</span>
<span class="nc" id="L225">		}</span>

		@Override
		public EdgeIter edgesOut(int u) {
<span class="nc" id="L229">			throw new IndexOutOfBoundsException(u);</span>
		}

		@Override
		public EdgeIter edgesIn(int v) {
<span class="nc" id="L234">			throw new IndexOutOfBoundsException(v);</span>
		}

		@Override
		public EdgeIter getEdges(int u, int v) {
<span class="nc" id="L239">			throw new IndexOutOfBoundsException(u);</span>
		}

		@Override
		public int addEdge(int u, int v) {
<span class="nc" id="L244">			throw new IndexOutOfBoundsException(u);</span>
		}

		@Override
		public void removeEdge(int edge) {
<span class="nc" id="L249">			throw new IndexOutOfBoundsException(edge);</span>
		}

		@Override
		public void removeEdges(IntCollection edges) {
<span class="nc bnc" id="L254" title="All 2 branches missed.">			if (!edges.isEmpty())</span>
<span class="nc" id="L255">				throw new IndexOutOfBoundsException(edges.iterator().nextInt());</span>
<span class="nc" id="L256">		}</span>

		@Override
		public void reverseEdge(int edge) {
<span class="nc" id="L260">			throw new IndexOutOfBoundsException(edge);</span>
		}

		@Override
		public int edgeSource(int edge) {
<span class="nc" id="L265">			throw new IndexOutOfBoundsException(edge);</span>
		}

		@Override
		public int edgeTarget(int edge) {
<span class="nc" id="L270">			throw new IndexOutOfBoundsException(edge);</span>
		}

		@Override
<span class="nc" id="L274">		public void clear() {}</span>

		@Override
<span class="nc" id="L277">		public void clearEdges() {}</span>

		@Override
		public &lt;V, WeightsT extends Weights&lt;V&gt;&gt; WeightsT getVerticesWeights(Object key) {
<span class="nc" id="L281">			return null;</span>
		}

		@Override
		public &lt;V, WeightsT extends Weights&lt;V&gt;&gt; WeightsT addVerticesWeights(Object key, Class&lt;? super V&gt; type) {
<span class="nc" id="L286">			throw new UnsupportedOperationException();</span>
		}

		@Override
		public &lt;V, WeightsT extends Weights&lt;V&gt;&gt; WeightsT addVerticesWeights(Object key, Class&lt;? super V&gt; type,
				V defVal) {
<span class="nc" id="L292">			throw new UnsupportedOperationException();</span>
		}

		@Override
<span class="nc" id="L296">		public void removeVerticesWeights(Object key) {}</span>

		@Override
		public Set&lt;Object&gt; getVerticesWeightKeys() {
<span class="nc" id="L300">			return Collections.emptySet();</span>
		}

		@Override
		public &lt;E, WeightsT extends Weights&lt;E&gt;&gt; WeightsT getEdgesWeights(Object key) {
<span class="nc" id="L305">			return null;</span>
		}

		@Override
		public &lt;E, WeightsT extends Weights&lt;E&gt;&gt; WeightsT addEdgesWeights(Object key, Class&lt;? super E&gt; type) {
<span class="nc" id="L310">			throw new UnsupportedOperationException();</span>
		}

		@Override
		public &lt;E, WeightsT extends Weights&lt;E&gt;&gt; WeightsT addEdgesWeights(Object key, Class&lt;? super E&gt; type, E defVal) {
<span class="nc" id="L315">			throw new UnsupportedOperationException();</span>
		}

		@Override
<span class="nc" id="L319">		public void removeEdgesWeights(Object key) {}</span>

		@Override
		public Set&lt;Object&gt; getEdgesWeightsKeys() {
<span class="nc" id="L323">			return Collections.emptySet();</span>
		}

		@Override
		public IDStrategy.Continues getVerticesIDStrategy() {
			// TODO Auto-generated method stub
<span class="nc" id="L329">			throw new UnsupportedOperationException(&quot;Unimplemented method 'getVerticesIDStrategy'&quot;);</span>
		}

		@Override
		public IDStrategy getEdgesIDStrategy() {
			// TODO Auto-generated method stub
<span class="nc" id="L335">			throw new UnsupportedOperationException(&quot;Unimplemented method 'getEdgesIDStrategy'&quot;);</span>
		}

	}

<span class="fc" id="L340">	static final Graph EmptyGraphUndirected = new EmptyGraph() {</span>
		@Override
		public GraphCapabilities getCapabilities() {
<span class="nc" id="L343">			return EmptyCapabilitiesUndirected;</span>
		}
	};

<span class="fc" id="L347">	static final Graph EmptyGraphDirected = new EmptyGraph() {</span>
		@Override
		public GraphCapabilities getCapabilities() {
<span class="nc" id="L350">			return EmptyCapabilitiesDirected;</span>
		}
	};

	private abstract static class EmptyCapabilities implements GraphCapabilities {

		@Override
		public boolean vertexAdd() {
<span class="nc" id="L358">			return false;</span>
		}

		@Override
		public boolean vertexRemove() {
<span class="nc" id="L363">			return false;</span>
		}

		@Override
		public boolean edgeAdd() {
<span class="nc" id="L368">			return false;</span>
		}

		@Override
		public boolean edgeRemove() {
<span class="nc" id="L373">			return false;</span>
		}

		@Override
		public boolean parallelEdges() {
<span class="nc" id="L378">			return false;</span>
		}

		@Override
		public boolean selfEdges() {
<span class="nc" id="L383">			return false;</span>
		}
	}

<span class="fc" id="L387">	static final GraphCapabilities EmptyCapabilitiesUndirected = new EmptyCapabilities() {</span>
		@Override
		public boolean directed() {
<span class="nc" id="L390">			return false;</span>
		}
	};

<span class="fc" id="L394">	static final GraphCapabilities EmptyCapabilitiesDirected = new EmptyCapabilities() {</span>
		@Override
		public boolean directed() {
<span class="nc" id="L397">			return true;</span>
		}
	};

	static double edgesWeightSum(IntIterator eit, EdgeWeightFunc w) {
<span class="fc bfc" id="L402" title="All 2 branches covered.">		if (w instanceof EdgeWeightFunc.Int) {</span>
<span class="fc" id="L403">			EdgeWeightFunc.Int w0 = (EdgeWeightFunc.Int) w;</span>
<span class="fc" id="L404">			int sum = 0;</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">			while (eit.hasNext())</span>
<span class="fc" id="L406">				sum += w0.weightInt(eit.nextInt());</span>
<span class="fc" id="L407">			return sum;</span>

		} else {
<span class="fc" id="L410">			double sum = 0;</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">			while (eit.hasNext())</span>
<span class="fc" id="L412">				sum += w.weight(eit.nextInt());</span>
<span class="fc" id="L413">			return sum;</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>