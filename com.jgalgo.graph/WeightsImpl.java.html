<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WeightsImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.graph</a> &gt; <span class="el_source">WeightsImpl.java</span></div><h1>WeightsImpl.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jgalgo.graph;

import java.util.Arrays;
import java.util.BitSet;
import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Set;
import it.unimi.dsi.fastutil.booleans.AbstractBooleanList;
import it.unimi.dsi.fastutil.booleans.BooleanCollection;
import it.unimi.dsi.fastutil.booleans.BooleanListIterator;
import it.unimi.dsi.fastutil.bytes.AbstractByteList;
import it.unimi.dsi.fastutil.bytes.ByteArrays;
import it.unimi.dsi.fastutil.bytes.ByteCollection;
import it.unimi.dsi.fastutil.bytes.ByteIterators;
import it.unimi.dsi.fastutil.bytes.ByteListIterator;
import it.unimi.dsi.fastutil.chars.AbstractCharList;
import it.unimi.dsi.fastutil.chars.CharArrays;
import it.unimi.dsi.fastutil.chars.CharCollection;
import it.unimi.dsi.fastutil.chars.CharIterators;
import it.unimi.dsi.fastutil.chars.CharListIterator;
import it.unimi.dsi.fastutil.doubles.AbstractDoubleList;
import it.unimi.dsi.fastutil.doubles.DoubleArrays;
import it.unimi.dsi.fastutil.doubles.DoubleCollection;
import it.unimi.dsi.fastutil.doubles.DoubleIterators;
import it.unimi.dsi.fastutil.doubles.DoubleListIterator;
import it.unimi.dsi.fastutil.floats.AbstractFloatList;
import it.unimi.dsi.fastutil.floats.FloatArrays;
import it.unimi.dsi.fastutil.floats.FloatCollection;
import it.unimi.dsi.fastutil.floats.FloatIterators;
import it.unimi.dsi.fastutil.floats.FloatListIterator;
import it.unimi.dsi.fastutil.ints.AbstractIntList;
import it.unimi.dsi.fastutil.ints.IntArrays;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntIterators;
import it.unimi.dsi.fastutil.ints.IntListIterator;
import it.unimi.dsi.fastutil.longs.AbstractLongList;
import it.unimi.dsi.fastutil.longs.LongArrays;
import it.unimi.dsi.fastutil.longs.LongCollection;
import it.unimi.dsi.fastutil.longs.LongIterators;
import it.unimi.dsi.fastutil.longs.LongListIterator;
import it.unimi.dsi.fastutil.objects.AbstractObjectList;
import it.unimi.dsi.fastutil.objects.Object2ObjectArrayMap;
import it.unimi.dsi.fastutil.objects.ObjectArrays;
import it.unimi.dsi.fastutil.objects.ObjectCollection;
import it.unimi.dsi.fastutil.objects.ObjectIterators;
import it.unimi.dsi.fastutil.objects.ObjectListIterator;
import it.unimi.dsi.fastutil.shorts.AbstractShortList;
import it.unimi.dsi.fastutil.shorts.ShortArrays;
import it.unimi.dsi.fastutil.shorts.ShortCollection;
import it.unimi.dsi.fastutil.shorts.ShortIterators;
import it.unimi.dsi.fastutil.shorts.ShortListIterator;

interface WeightsImpl&lt;E&gt; extends Weights&lt;E&gt; {

	@SuppressWarnings(&quot;unchecked&quot;)
	static &lt;E&gt; Weights&lt;E&gt; immutableView(Weights&lt;E&gt; weights) {
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">		if (weights instanceof Immutable&lt;?&gt;)</span>
<span class="nc" id="L77">			return weights;</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">		if (weights instanceof Weights.Byte)</span>
<span class="fc" id="L79">			return (WeightsImpl&lt;E&gt;) new ImmutableView.Byte((Weights.Byte) weights);</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">		if (weights instanceof Weights.Short)</span>
<span class="fc" id="L81">			return (WeightsImpl&lt;E&gt;) new ImmutableView.Short((Weights.Short) weights);</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">		if (weights instanceof Weights.Int)</span>
<span class="fc" id="L83">			return (WeightsImpl&lt;E&gt;) new ImmutableView.Int((Weights.Int) weights);</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">		if (weights instanceof Weights.Long)</span>
<span class="fc" id="L85">			return (WeightsImpl&lt;E&gt;) new ImmutableView.Long((Weights.Long) weights);</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">		if (weights instanceof Weights.Float)</span>
<span class="fc" id="L87">			return (WeightsImpl&lt;E&gt;) new ImmutableView.Float((Weights.Float) weights);</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">		if (weights instanceof Weights.Double)</span>
<span class="fc" id="L89">			return (WeightsImpl&lt;E&gt;) new ImmutableView.Double((Weights.Double) weights);</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">		if (weights instanceof Weights.Bool)</span>
<span class="fc" id="L91">			return (WeightsImpl&lt;E&gt;) new ImmutableView.Bool((Weights.Bool) weights);</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">		if (weights instanceof Weights.Char)</span>
<span class="fc" id="L93">			return (WeightsImpl&lt;E&gt;) new ImmutableView.Char((Weights.Char) weights);</span>
<span class="fc" id="L94">		return new ImmutableView.Obj&lt;&gt;(weights);</span>
	}

	static interface Index&lt;E&gt; extends WeightsImpl&lt;E&gt; {

		Collection&lt;E&gt; values();

		Class&lt;E&gt; getTypeClass();

		static abstract class Abstract&lt;E&gt; implements WeightsImpl.Index&lt;E&gt; {

			final IdStrategy idStrat;

<span class="fc" id="L107">			Abstract(IdStrategy idStrat) {</span>
<span class="fc" id="L108">				this.idStrat = Objects.requireNonNull(idStrat);</span>
<span class="fc" id="L109">			}</span>

			int size() {
<span class="fc" id="L112">				return idStrat.size();</span>
			}

			@Override
			public int hashCode() {
<span class="nc" id="L117">				return values().hashCode();</span>
			}

			@Override
			public String toString() {
<span class="nc" id="L122">				return values().toString();</span>
			}

			void checkIdx(int idx) {
<span class="pc bpc" id="L126" title="2 of 4 branches missed.">				if (!(0 &lt;= idx &amp;&amp; idx &lt; idStrat.size()))</span>
<span class="nc" id="L127">					throw new IndexOutOfBoundsException(idx);</span>
<span class="fc" id="L128">			}</span>
		}

		static abstract class Obj&lt;E&gt; extends WeightsImpl.Index.Abstract&lt;E&gt; {

			Object[] weights;
			final E defaultWeight;
			private final ObjectCollection&lt;E&gt; values;
			private final Class&lt;E&gt; type;

			Obj(IdStrategy idStrat, E defVal, Class&lt;E&gt; type) {
<span class="fc" id="L139">				super(idStrat);</span>

<span class="fc" id="L141">				defaultWeight = defVal;</span>
<span class="fc" id="L142">				weights = ObjectArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L143">				Arrays.fill(weights, defaultWeight);</span>

<span class="fc" id="L145">				this.type = Objects.requireNonNull(type);</span>
<span class="fc" id="L146">				values = new AbstractObjectList&lt;&gt;() {</span>
					@Override
					public int size() {
<span class="nc" id="L149">						return WeightsImpl.Index.Obj.super.size();</span>
					}

					@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
					@Override
					public ObjectListIterator&lt;E&gt; iterator() {
<span class="nc" id="L155">						return (ObjectListIterator) ObjectIterators.wrap(weights, 0, size());</span>
					}

					@SuppressWarnings(&quot;unchecked&quot;)
					@Override
					public E get(int index) {
<span class="nc" id="L161">						checkIdx(index);</span>
<span class="nc" id="L162">						return (E) weights[index];</span>
					}
				};
<span class="fc" id="L165">			}</span>

			Obj(WeightsImpl.Index.Obj&lt;E&gt; orig, IdStrategy idStrat) {
<span class="fc" id="L168">				this(idStrat, orig.defaultWeight, orig.type);</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">				if (idStrat.size() != orig.idStrat.size())</span>
<span class="nc" id="L170">					throw new IllegalArgumentException();</span>
<span class="fc" id="L171">				weights = Arrays.copyOf(orig.weights, idStrat.size());</span>
<span class="fc" id="L172">			}</span>

			Obj(WeightsImpl.Index.Obj&lt;E&gt; orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L175">				this(idStrat, orig.defaultWeight, orig.type);</span>
<span class="nc" id="L176">				final int s = idStrat.size();</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">				if (s != orig.idStrat.size())</span>
<span class="nc" id="L178">					throw new IllegalArgumentException();</span>
<span class="nc" id="L179">				weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">				for (int i = 0; i &lt; s; i++)</span>
<span class="nc" id="L181">					weights[reIndexMap.origToReIndexed(i)] = orig.weights[i];</span>
<span class="nc" id="L182">			}</span>

			@Override
			@SuppressWarnings(&quot;unchecked&quot;)
			public E get(int idx) {
<span class="fc" id="L187">				checkIdx(idx);</span>
<span class="fc" id="L188">				return (E) weights[idx];</span>
			}

			@Override
			public E defaultWeight() {
<span class="fc" id="L193">				return defaultWeight;</span>
			}

			@Override
			public Collection&lt;E&gt; values() {
<span class="nc" id="L198">				return values;</span>
			}

			@Override
			public Class&lt;E&gt; getTypeClass() {
<span class="nc" id="L203">				return type;</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="nc bnc" id="L208" title="All 2 branches missed.">				if (other == this)</span>
<span class="nc" id="L209">					return true;</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">				if (!(other instanceof WeightsImpl.Index.Obj&lt;?&gt;))</span>
<span class="nc" id="L211">					return false;</span>
<span class="nc" id="L212">				WeightsImpl.Index.Obj&lt;?&gt; o = (WeightsImpl.Index.Obj&lt;?&gt;) other;</span>
<span class="nc" id="L213">				return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
			}
		}

		static abstract class Byte extends WeightsImpl.Index.Abstract&lt;java.lang.Byte&gt; implements Weights.Byte {

			byte[] weights;
			final byte defaultWeight;
			private final ByteCollection values;

			Byte(IdStrategy idStrat, byte defVal) {
<span class="fc" id="L224">				super(idStrat);</span>

<span class="fc" id="L226">				weights = ByteArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L227">				defaultWeight = defVal;</span>
<span class="fc" id="L228">				values = new AbstractByteList() {</span>

					@Override
					public int size() {
<span class="nc" id="L232">						return WeightsImpl.Index.Byte.super.size();</span>
					}

					@Override
					public ByteListIterator iterator() {
<span class="nc" id="L237">						return ByteIterators.wrap(weights, 0, size());</span>
					}

					@Override
					public byte getByte(int index) {
<span class="nc" id="L242">						checkIdx(index);</span>
<span class="nc" id="L243">						return weights[index];</span>
					}
				};
<span class="fc" id="L246">			}</span>

			Byte(WeightsImpl.Index.Byte orig, IdStrategy idStrat) {
<span class="nc" id="L249">				this(idStrat, orig.defaultWeight);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">				if (idStrat.size() != orig.idStrat.size())</span>
<span class="nc" id="L251">					throw new IllegalArgumentException();</span>
<span class="nc" id="L252">				weights = Arrays.copyOf(orig.weights, idStrat.size());</span>
<span class="nc" id="L253">			}</span>

			Byte(WeightsImpl.Index.Byte orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L256">				this(idStrat, orig.defaultWeight);</span>
<span class="nc" id="L257">				final int s = idStrat.size();</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">				if (s != orig.idStrat.size())</span>
<span class="nc" id="L259">					throw new IllegalArgumentException();</span>
<span class="nc" id="L260">				weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">				for (int i = 0; i &lt; s; i++)</span>
<span class="nc" id="L262">					weights[reIndexMap.origToReIndexed(i)] = orig.weights[i];</span>
<span class="nc" id="L263">			}</span>

			@Override
			public byte getByte(int idx) {
<span class="fc" id="L267">				checkIdx(idx);</span>
<span class="fc" id="L268">				return weights[idx];</span>
			}

			@Override
			public byte defaultWeightByte() {
<span class="fc" id="L273">				return defaultWeight;</span>
			}

			@Override
			public ByteCollection values() {
<span class="nc" id="L278">				return values;</span>
			}

			@Override
			public Class&lt;java.lang.Byte&gt; getTypeClass() {
<span class="nc" id="L283">				return byte.class;</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="nc bnc" id="L288" title="All 2 branches missed.">				if (this == other)</span>
<span class="nc" id="L289">					return true;</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">				if (!(other instanceof WeightsImpl.Index.Byte))</span>
<span class="nc" id="L291">					return false;</span>
<span class="nc" id="L292">				WeightsImpl.Index.Byte o = (WeightsImpl.Index.Byte) other;</span>
<span class="nc" id="L293">				return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
			}
		}

		static abstract class Short extends WeightsImpl.Index.Abstract&lt;java.lang.Short&gt; implements Weights.Short {

			short[] weights;
			final short defaultWeight;
			private final ShortCollection values;

			Short(IdStrategy idStrat, short defVal) {
<span class="fc" id="L304">				super(idStrat);</span>

<span class="fc" id="L306">				weights = ShortArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L307">				defaultWeight = defVal;</span>
<span class="fc" id="L308">				values = new AbstractShortList() {</span>

					@Override
					public int size() {
<span class="nc" id="L312">						return WeightsImpl.Index.Short.super.size();</span>
					}

					@Override
					public ShortListIterator iterator() {
<span class="nc" id="L317">						return ShortIterators.wrap(weights, 0, size());</span>
					}

					@Override
					public short getShort(int index) {
<span class="nc" id="L322">						checkIdx(index);</span>
<span class="nc" id="L323">						return weights[index];</span>
					}
				};
<span class="fc" id="L326">			}</span>

			Short(WeightsImpl.Index.Short orig, IdStrategy idStrat) {
<span class="nc" id="L329">				this(idStrat, orig.defaultWeight);</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">				if (idStrat.size() != orig.idStrat.size())</span>
<span class="nc" id="L331">					throw new IllegalArgumentException();</span>
<span class="nc" id="L332">				weights = Arrays.copyOf(orig.weights, idStrat.size());</span>
<span class="nc" id="L333">			}</span>

			Short(WeightsImpl.Index.Short orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L336">				this(idStrat, orig.defaultWeight);</span>
<span class="nc" id="L337">				final int s = idStrat.size();</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">				if (s != orig.idStrat.size())</span>
<span class="nc" id="L339">					throw new IllegalArgumentException();</span>
<span class="nc" id="L340">				weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">				for (int i = 0; i &lt; s; i++)</span>
<span class="nc" id="L342">					weights[reIndexMap.origToReIndexed(i)] = orig.weights[i];</span>
<span class="nc" id="L343">			}</span>

			@Override
			public short getShort(int idx) {
<span class="fc" id="L347">				checkIdx(idx);</span>
<span class="fc" id="L348">				return weights[idx];</span>
			}

			@Override
			public short defaultWeightShort() {
<span class="fc" id="L353">				return defaultWeight;</span>
			}

			@Override
			public ShortCollection values() {
<span class="nc" id="L358">				return values;</span>
			}

			@Override
			public Class&lt;java.lang.Short&gt; getTypeClass() {
<span class="nc" id="L363">				return short.class;</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="nc bnc" id="L368" title="All 2 branches missed.">				if (this == other)</span>
<span class="nc" id="L369">					return true;</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">				if (!(other instanceof WeightsImpl.Index.Short))</span>
<span class="nc" id="L371">					return false;</span>
<span class="nc" id="L372">				WeightsImpl.Index.Short o = (WeightsImpl.Index.Short) other;</span>
<span class="nc" id="L373">				return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
			}
		}

		static abstract class Int extends WeightsImpl.Index.Abstract&lt;Integer&gt; implements Weights.Int {

			int[] weights;
			final int defaultWeight;
			private final IntCollection values;

			Int(IdStrategy idStrat, int defVal) {
<span class="fc" id="L384">				super(idStrat);</span>

<span class="fc" id="L386">				weights = IntArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L387">				defaultWeight = defVal;</span>
<span class="fc" id="L388">				values = new AbstractIntList() {</span>

					@Override
					public int size() {
<span class="nc" id="L392">						return WeightsImpl.Index.Int.super.size();</span>
					}

					@Override
					public IntListIterator iterator() {
<span class="nc" id="L397">						return IntIterators.wrap(weights, 0, size());</span>
					}

					@Override
					public int getInt(int index) {
<span class="nc" id="L402">						checkIdx(index);</span>
<span class="nc" id="L403">						return weights[index];</span>
					}
				};
<span class="fc" id="L406">			}</span>

			Int(WeightsImpl.Index.Int orig, IdStrategy idStrat) {
<span class="fc" id="L409">				this(idStrat, orig.defaultWeight);</span>
<span class="pc bpc" id="L410" title="1 of 2 branches missed.">				if (idStrat.size() != orig.idStrat.size())</span>
<span class="nc" id="L411">					throw new IllegalArgumentException();</span>
<span class="fc" id="L412">				weights = Arrays.copyOf(orig.weights, idStrat.size());</span>
<span class="fc" id="L413">			}</span>

			Int(WeightsImpl.Index.Int orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L416">				this(idStrat, orig.defaultWeight);</span>
<span class="nc" id="L417">				final int s = idStrat.size();</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">				if (s != orig.idStrat.size())</span>
<span class="nc" id="L419">					throw new IllegalArgumentException();</span>
<span class="nc" id="L420">				weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">				for (int i = 0; i &lt; s; i++)</span>
<span class="nc" id="L422">					weights[reIndexMap.origToReIndexed(i)] = orig.weights[i];</span>
<span class="nc" id="L423">			}</span>

			@Override
			public int getInt(int idx) {
<span class="fc" id="L427">				checkIdx(idx);</span>
<span class="fc" id="L428">				return weights[idx];</span>
			}

			@Override
			public int defaultWeightInt() {
<span class="fc" id="L433">				return defaultWeight;</span>
			}

			@Override
			public IntCollection values() {
<span class="nc" id="L438">				return values;</span>
			}

			@Override
			public Class&lt;Integer&gt; getTypeClass() {
<span class="nc" id="L443">				return int.class;</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="nc bnc" id="L448" title="All 2 branches missed.">				if (this == other)</span>
<span class="nc" id="L449">					return true;</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">				if (!(other instanceof WeightsImpl.Index.Int))</span>
<span class="nc" id="L451">					return false;</span>
<span class="nc" id="L452">				WeightsImpl.Index.Int o = (WeightsImpl.Index.Int) other;</span>
<span class="nc" id="L453">				return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
			}
		}

		static abstract class Long extends WeightsImpl.Index.Abstract&lt;java.lang.Long&gt; implements Weights.Long {

			long[] weights;
			final long defaultWeight;
<span class="fc" id="L461">			private final LongCollection values = new AbstractLongList() {</span>

				@Override
				public int size() {
<span class="nc" id="L465">					return WeightsImpl.Index.Long.super.size();</span>
				}

				@Override
				public LongListIterator iterator() {
<span class="nc" id="L470">					return LongIterators.wrap(weights, 0, size());</span>
				}

				@Override
				public long getLong(int index) {
<span class="nc" id="L475">					checkIdx(index);</span>
<span class="nc" id="L476">					return weights[index];</span>
				}
			};

			Long(IdStrategy idStrat, long defVal) {
<span class="fc" id="L481">				super(idStrat);</span>

<span class="fc" id="L483">				weights = LongArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L484">				defaultWeight = defVal;</span>
<span class="fc" id="L485">			}</span>

			Long(WeightsImpl.Index.Long orig, IdStrategy idStrat) {
<span class="nc" id="L488">				this(idStrat, orig.defaultWeight);</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">				if (idStrat.size() != orig.idStrat.size())</span>
<span class="nc" id="L490">					throw new IllegalArgumentException();</span>
<span class="nc" id="L491">				weights = Arrays.copyOf(orig.weights, idStrat.size());</span>
<span class="nc" id="L492">			}</span>

			Long(WeightsImpl.Index.Long orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L495">				this(idStrat, orig.defaultWeight);</span>
<span class="nc" id="L496">				final int s = idStrat.size();</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">				if (s != orig.idStrat.size())</span>
<span class="nc" id="L498">					throw new IllegalArgumentException();</span>
<span class="nc" id="L499">				weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">				for (int i = 0; i &lt; s; i++)</span>
<span class="nc" id="L501">					weights[reIndexMap.origToReIndexed(i)] = orig.weights[i];</span>
<span class="nc" id="L502">			}</span>

			@Override
			public long getLong(int idx) {
<span class="fc" id="L506">				checkIdx(idx);</span>
<span class="fc" id="L507">				return weights[idx];</span>
			}

			@Override
			public long defaultWeightLong() {
<span class="fc" id="L512">				return defaultWeight;</span>
			}

			@Override
			public LongCollection values() {
<span class="nc" id="L517">				return values;</span>
			}

			@Override
			public Class&lt;java.lang.Long&gt; getTypeClass() {
<span class="nc" id="L522">				return long.class;</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="nc bnc" id="L527" title="All 2 branches missed.">				if (this == other)</span>
<span class="nc" id="L528">					return true;</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">				if (!(other instanceof WeightsImpl.Index.Long))</span>
<span class="nc" id="L530">					return false;</span>
<span class="nc" id="L531">				WeightsImpl.Index.Long o = (WeightsImpl.Index.Long) other;</span>
<span class="nc" id="L532">				return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
			}
		}

		static abstract class Float extends WeightsImpl.Index.Abstract&lt;java.lang.Float&gt; implements Weights.Float {

			float[] weights;
			final float defaultWeight;
			private final FloatCollection values;

			Float(IdStrategy idStrat, float defVal) {
<span class="fc" id="L543">				super(idStrat);</span>

<span class="fc" id="L545">				weights = FloatArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L546">				defaultWeight = defVal;</span>
<span class="fc" id="L547">				values = new AbstractFloatList() {</span>

					@Override
					public int size() {
<span class="nc" id="L551">						return WeightsImpl.Index.Float.super.size();</span>
					}

					@Override
					public FloatListIterator iterator() {
<span class="nc" id="L556">						return FloatIterators.wrap(weights, 0, size());</span>
					}

					@Override
					public float getFloat(int index) {
<span class="nc" id="L561">						checkIdx(index);</span>
<span class="nc" id="L562">						return weights[index];</span>
					}
				};
<span class="fc" id="L565">			}</span>

			Float(WeightsImpl.Index.Float orig, IdStrategy idStrat) {
<span class="nc" id="L568">				this(idStrat, orig.defaultWeight);</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">				if (idStrat.size() != orig.idStrat.size())</span>
<span class="nc" id="L570">					throw new IllegalArgumentException();</span>
<span class="nc" id="L571">				weights = Arrays.copyOf(orig.weights, idStrat.size());</span>
<span class="nc" id="L572">			}</span>

			Float(WeightsImpl.Index.Float orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L575">				this(idStrat, orig.defaultWeight);</span>
<span class="nc" id="L576">				final int s = idStrat.size();</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">				if (s != orig.idStrat.size())</span>
<span class="nc" id="L578">					throw new IllegalArgumentException();</span>
<span class="nc" id="L579">				weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">				for (int i = 0; i &lt; s; i++)</span>
<span class="nc" id="L581">					weights[reIndexMap.origToReIndexed(i)] = orig.weights[i];</span>
<span class="nc" id="L582">			}</span>

			@Override
			public float getFloat(int idx) {
<span class="fc" id="L586">				checkIdx(idx);</span>
<span class="fc" id="L587">				return weights[idx];</span>
			}

			@Override
			public float defaultWeightFloat() {
<span class="fc" id="L592">				return defaultWeight;</span>
			}

			@Override
			public FloatCollection values() {
<span class="nc" id="L597">				return values;</span>
			}

			@Override
			public Class&lt;java.lang.Float&gt; getTypeClass() {
<span class="nc" id="L602">				return float.class;</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="nc bnc" id="L607" title="All 2 branches missed.">				if (this == other)</span>
<span class="nc" id="L608">					return true;</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">				if (!(other instanceof WeightsImpl.Index.Float))</span>
<span class="nc" id="L610">					return false;</span>
<span class="nc" id="L611">				WeightsImpl.Index.Float o = (WeightsImpl.Index.Float) other;</span>
<span class="nc" id="L612">				return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
			}
		}

		static abstract class Double extends WeightsImpl.Index.Abstract&lt;java.lang.Double&gt; implements Weights.Double {

			double[] weights;
			final double defaultWeight;
			private final DoubleCollection values;

			Double(IdStrategy idStrat, double defVal) {
<span class="fc" id="L623">				super(idStrat);</span>

<span class="fc" id="L625">				weights = DoubleArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L626">				defaultWeight = defVal;</span>
<span class="fc" id="L627">				values = new AbstractDoubleList() {</span>

					@Override
					public int size() {
<span class="nc" id="L631">						return WeightsImpl.Index.Double.super.size();</span>
					}

					@Override
					public DoubleListIterator iterator() {
<span class="nc" id="L636">						return DoubleIterators.wrap(weights, 0, size());</span>
					}

					@Override
					public double getDouble(int index) {
<span class="nc" id="L641">						checkIdx(index);</span>
<span class="nc" id="L642">						return weights[index];</span>
					}
				};
<span class="fc" id="L645">			}</span>

			Double(WeightsImpl.Index.Double orig, IdStrategy idStrat) {
<span class="nc" id="L648">				this(idStrat, orig.defaultWeight);</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">				if (idStrat.size() != orig.idStrat.size())</span>
<span class="nc" id="L650">					throw new IllegalArgumentException();</span>
<span class="nc" id="L651">				weights = Arrays.copyOf(orig.weights, idStrat.size());</span>
<span class="nc" id="L652">			}</span>

			Double(WeightsImpl.Index.Double orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L655">				this(idStrat, orig.defaultWeight);</span>
<span class="nc" id="L656">				final int s = idStrat.size();</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">				if (s != orig.idStrat.size())</span>
<span class="nc" id="L658">					throw new IllegalArgumentException();</span>
<span class="nc" id="L659">				weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">				for (int i = 0; i &lt; s; i++)</span>
<span class="nc" id="L661">					weights[reIndexMap.origToReIndexed(i)] = orig.weights[i];</span>
<span class="nc" id="L662">			}</span>

			@Override
			public double getDouble(int idx) {
<span class="fc" id="L666">				checkIdx(idx);</span>
<span class="fc" id="L667">				return weights[idx];</span>
			}

			@Override
			public double defaultWeightDouble() {
<span class="fc" id="L672">				return defaultWeight;</span>
			}

			@Override
			public DoubleCollection values() {
<span class="nc" id="L677">				return values;</span>
			}

			@Override
			public Class&lt;java.lang.Double&gt; getTypeClass() {
<span class="nc" id="L682">				return double.class;</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="nc bnc" id="L687" title="All 2 branches missed.">				if (this == other)</span>
<span class="nc" id="L688">					return true;</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">				if (!(other instanceof WeightsImpl.Index.Double))</span>
<span class="nc" id="L690">					return false;</span>
<span class="nc" id="L691">				WeightsImpl.Index.Double o = (WeightsImpl.Index.Double) other;</span>
<span class="nc" id="L692">				return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
			}
		}

		static abstract class Bool extends WeightsImpl.Index.Abstract&lt;Boolean&gt; implements Weights.Bool {

			final BitSet weights;
			int capacity;
			final boolean defaultWeight;
<span class="pc" id="L701">			private final BooleanCollection values = new AbstractBooleanList() {</span>

				@Override
				public int size() {
<span class="nc" id="L705">					return WeightsImpl.Index.Bool.super.size();</span>
				}

				@Override
				public BooleanListIterator iterator() {
<span class="nc" id="L710">					return new BooleanListIterator() {</span>
<span class="nc" id="L711">						int idx = 0;</span>

						@Override
						public boolean hasNext() {
<span class="nc bnc" id="L715" title="All 2 branches missed.">							return idx &lt; size();</span>
						}

						@Override
						public boolean nextBoolean() {
<span class="nc bnc" id="L720" title="All 2 branches missed.">							if (!hasNext())</span>
<span class="nc" id="L721">								throw new NoSuchElementException();</span>
<span class="nc" id="L722">							return weights.get(idx++);</span>
						}

						@Override
						public boolean previousBoolean() {
<span class="nc bnc" id="L727" title="All 2 branches missed.">							if (!hasPrevious())</span>
<span class="nc" id="L728">								throw new NoSuchElementException();</span>
<span class="nc" id="L729">							return weights.get(--idx);</span>
						}

						@Override
						public boolean hasPrevious() {
<span class="nc bnc" id="L734" title="All 2 branches missed.">							return idx &gt; 0;</span>
						}

						@Override
						public int nextIndex() {
<span class="nc" id="L739">							return idx;</span>
						}

						@Override
						public int previousIndex() {
<span class="nc" id="L744">							return idx - 1;</span>
						}
					};
				}

				@Override
				public boolean getBoolean(int index) {
<span class="nc" id="L751">					checkIdx(index);</span>
<span class="nc" id="L752">					return weights.get(index);</span>
				}
			};

			Bool(IdStrategy idStrat, boolean defVal) {
<span class="fc" id="L757">				super(idStrat);</span>

<span class="fc" id="L759">				defaultWeight = defVal;</span>
<span class="fc" id="L760">				weights = new BitSet();</span>
<span class="fc" id="L761">			}</span>

			Bool(WeightsImpl.Index.Bool orig, IdStrategy idStrat) {
<span class="nc" id="L764">				super(idStrat);</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">				if (idStrat.size() != orig.idStrat.size())</span>
<span class="nc" id="L766">					throw new IllegalArgumentException();</span>
<span class="nc" id="L767">				defaultWeight = orig.defaultWeight;</span>
<span class="nc" id="L768">				weights = (BitSet) orig.weights.clone();</span>
<span class="nc" id="L769">			}</span>

			Bool(WeightsImpl.Index.Bool orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L772">				this(idStrat, orig.defaultWeight);</span>
<span class="nc" id="L773">				final int s = idStrat.size();</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">				if (s != orig.idStrat.size())</span>
<span class="nc" id="L775">					throw new IllegalArgumentException();</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">				for (int i = 0; i &lt; s; i++)</span>
<span class="nc" id="L777">					weights.set(reIndexMap.origToReIndexed(i), orig.weights.get(i));</span>
<span class="nc" id="L778">			}</span>

			@Override
			public boolean getBool(int idx) {
<span class="fc" id="L782">				checkIdx(idx);</span>
<span class="fc" id="L783">				return weights.get(idx);</span>
			}

			@Override
			public boolean defaultWeightBool() {
<span class="fc" id="L788">				return defaultWeight;</span>
			}

			@Override
			public BooleanCollection values() {
<span class="nc" id="L793">				return values;</span>
			}

			@Override
			public Class&lt;Boolean&gt; getTypeClass() {
<span class="nc" id="L798">				return boolean.class;</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="nc bnc" id="L803" title="All 2 branches missed.">				if (this == other)</span>
<span class="nc" id="L804">					return true;</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">				if (!(other instanceof WeightsImpl.Index.Bool))</span>
<span class="nc" id="L806">					return false;</span>
<span class="nc" id="L807">				WeightsImpl.Index.Bool o = (WeightsImpl.Index.Bool) other;</span>
<span class="nc bnc" id="L808" title="All 4 branches missed.">				return size() == o.size() &amp;&amp; weights.equals(o.weights);</span>
			}
		}

		static abstract class Char extends WeightsImpl.Index.Abstract&lt;Character&gt; implements Weights.Char {

			char[] weights;
			final char defaultWeight;
			private final CharCollection values;

			Char(IdStrategy idStrat, char defVal) {
<span class="fc" id="L819">				super(idStrat);</span>

<span class="fc" id="L821">				weights = CharArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L822">				defaultWeight = defVal;</span>
<span class="fc" id="L823">				values = new AbstractCharList() {</span>

					@Override
					public int size() {
<span class="nc" id="L827">						return WeightsImpl.Index.Char.super.size();</span>
					}

					@Override
					public CharListIterator iterator() {
<span class="nc" id="L832">						return CharIterators.wrap(weights, 0, size());</span>
					}

					@Override
					public char getChar(int index) {
<span class="nc" id="L837">						checkIdx(index);</span>
<span class="nc" id="L838">						return weights[index];</span>
					}
				};
<span class="fc" id="L841">			}</span>

			Char(WeightsImpl.Index.Char orig, IdStrategy idStrat) {
<span class="nc" id="L844">				this(idStrat, orig.defaultWeight);</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">				if (idStrat.size() != orig.idStrat.size())</span>
<span class="nc" id="L846">					throw new IllegalArgumentException();</span>
<span class="nc" id="L847">				weights = Arrays.copyOf(orig.weights, idStrat.size());</span>
<span class="nc" id="L848">			}</span>

			Char(WeightsImpl.Index.Char orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L851">				this(idStrat, orig.defaultWeight);</span>
<span class="nc" id="L852">				final int s = idStrat.size();</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">				if (s != orig.idStrat.size())</span>
<span class="nc" id="L854">					throw new IllegalArgumentException();</span>
<span class="nc" id="L855">				weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">				for (int i = 0; i &lt; s; i++)</span>
<span class="nc" id="L857">					weights[reIndexMap.origToReIndexed(i)] = orig.weights[i];</span>
<span class="nc" id="L858">			}</span>

			@Override
			public char getChar(int idx) {
<span class="fc" id="L862">				checkIdx(idx);</span>
<span class="fc" id="L863">				return weights[idx];</span>
			}

			@Override
			public char defaultWeightChar() {
<span class="fc" id="L868">				return defaultWeight;</span>
			}

			@Override
			public CharCollection values() {
<span class="nc" id="L873">				return values;</span>
			}

			@Override
			public Class&lt;Character&gt; getTypeClass() {
<span class="nc" id="L878">				return char.class;</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="nc bnc" id="L883" title="All 2 branches missed.">				if (this == other)</span>
<span class="nc" id="L884">					return true;</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">				if (!(other instanceof WeightsImpl.Index.Char))</span>
<span class="nc" id="L886">					return false;</span>
<span class="nc" id="L887">				WeightsImpl.Index.Char o = (WeightsImpl.Index.Char) other;</span>
<span class="nc" id="L888">				return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
			}
		}

	}

	static interface IndexImmutable&lt;E&gt; extends WeightsImpl.Index&lt;E&gt; {

		static &lt;D&gt; WeightsImpl.IndexImmutable&lt;D&gt; newInstance(IdStrategy.FixedSize idStart, Class&lt;? super D&gt; type,
				D defVal) {
			@SuppressWarnings(&quot;rawtypes&quot;)
			WeightsImpl container;
<span class="nc bnc" id="L900" title="All 2 branches missed.">			if (type == byte.class) {</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">				byte defVal0 = defVal != null ? ((java.lang.Byte) defVal).byteValue() : 0;</span>
<span class="nc" id="L902">				container = new WeightsImpl.IndexImmutable.Byte(idStart, defVal0);</span>

<span class="nc bnc" id="L904" title="All 2 branches missed.">			} else if (type == short.class) {</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">				short defVal0 = defVal != null ? ((java.lang.Short) defVal).shortValue() : 0;</span>
<span class="nc" id="L906">				container = new WeightsImpl.IndexImmutable.Short(idStart, defVal0);</span>

<span class="nc bnc" id="L908" title="All 2 branches missed.">			} else if (type == int.class) {</span>
<span class="nc bnc" id="L909" title="All 2 branches missed.">				int defVal0 = defVal != null ? ((Integer) defVal).intValue() : 0;</span>
<span class="nc" id="L910">				container = new WeightsImpl.IndexImmutable.Int(idStart, defVal0);</span>

<span class="nc bnc" id="L912" title="All 2 branches missed.">			} else if (type == long.class) {</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">				long defVal0 = defVal != null ? ((java.lang.Long) defVal).longValue() : 0;</span>
<span class="nc" id="L914">				container = new WeightsImpl.IndexImmutable.Long(idStart, defVal0);</span>

<span class="nc bnc" id="L916" title="All 2 branches missed.">			} else if (type == float.class) {</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">				float defVal0 = defVal != null ? ((java.lang.Float) defVal).floatValue() : 0;</span>
<span class="nc" id="L918">				container = new WeightsImpl.IndexImmutable.Float(idStart, defVal0);</span>

<span class="nc bnc" id="L920" title="All 2 branches missed.">			} else if (type == double.class) {</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">				double defVal0 = defVal != null ? ((java.lang.Double) defVal).doubleValue() : 0;</span>
<span class="nc" id="L922">				container = new WeightsImpl.IndexImmutable.Double(idStart, defVal0);</span>

<span class="nc bnc" id="L924" title="All 2 branches missed.">			} else if (type == boolean.class) {</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">				boolean defVal0 = defVal != null ? ((Boolean) defVal).booleanValue() : false;</span>
<span class="nc" id="L926">				container = new WeightsImpl.IndexImmutable.Bool(idStart, defVal0);</span>

<span class="nc bnc" id="L928" title="All 2 branches missed.">			} else if (type == char.class) {</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">				char defVal0 = defVal != null ? ((Character) defVal).charValue() : 0;</span>
<span class="nc" id="L930">				container = new WeightsImpl.IndexImmutable.Char(idStart, defVal0);</span>

<span class="nc" id="L932">			} else {</span>
<span class="nc" id="L933">				container = new WeightsImpl.IndexImmutable.Obj&lt;&gt;(idStart, defVal, type);</span>
			}
			@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L936">			WeightsImpl.IndexImmutable&lt;D&gt; container0 = (WeightsImpl.IndexImmutable&lt;D&gt;) container;</span>
<span class="nc" id="L937">			return container0;</span>
		}

		static WeightsImpl.IndexImmutable&lt;?&gt; copyOf(Weights&lt;?&gt; weights, IdStrategy.FixedSize idStart) {
<span class="nc bnc" id="L941" title="All 2 branches missed.">			if (weights instanceof WeightsImpl.ImmutableView&lt;?&gt;)</span>
<span class="nc" id="L942">				weights = ((WeightsImpl.ImmutableView&lt;?&gt;) weights).weights;</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">			if (weights instanceof WeightsImpl.Index.Byte) {</span>
<span class="nc" id="L944">				return new WeightsImpl.IndexImmutable.Byte((WeightsImpl.Index.Byte) weights, idStart);</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Short) {</span>
<span class="nc" id="L946">				return new WeightsImpl.IndexImmutable.Short((WeightsImpl.Index.Short) weights, idStart);</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Int) {</span>
<span class="nc" id="L948">				return new WeightsImpl.IndexImmutable.Int((WeightsImpl.Index.Int) weights, idStart);</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Long) {</span>
<span class="nc" id="L950">				return new WeightsImpl.IndexImmutable.Long((WeightsImpl.Index.Long) weights, idStart);</span>
<span class="nc bnc" id="L951" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Float) {</span>
<span class="nc" id="L952">				return new WeightsImpl.IndexImmutable.Float((WeightsImpl.Index.Float) weights, idStart);</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Double) {</span>
<span class="nc" id="L954">				return new WeightsImpl.IndexImmutable.Double((WeightsImpl.Index.Double) weights, idStart);</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Bool) {</span>
<span class="nc" id="L956">				return new WeightsImpl.IndexImmutable.Bool((WeightsImpl.Index.Bool) weights, idStart);</span>
<span class="nc bnc" id="L957" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Char) {</span>
<span class="nc" id="L958">				return new WeightsImpl.IndexImmutable.Char((WeightsImpl.Index.Char) weights, idStart);</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Obj) {</span>
<span class="nc" id="L960">				return new WeightsImpl.IndexImmutable.Obj&lt;&gt;((WeightsImpl.Index.Obj&lt;?&gt;) weights, idStart);</span>
			} else {
<span class="nc" id="L962">				throw new IllegalArgumentException(&quot;unknown weights implementation: &quot; + weights.getClass());</span>
			}
		}

		static WeightsImpl.IndexImmutable&lt;?&gt; copyOfReindexed(Weights&lt;?&gt; weights, IdStrategy.FixedSize idStart,
				IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc bnc" id="L968" title="All 2 branches missed.">			if (weights instanceof WeightsImpl.ImmutableView&lt;?&gt;)</span>
<span class="nc" id="L969">				weights = ((WeightsImpl.ImmutableView&lt;?&gt;) weights).weights;</span>
<span class="nc bnc" id="L970" title="All 2 branches missed.">			if (weights instanceof WeightsImpl.Index.Byte) {</span>
<span class="nc" id="L971">				return new WeightsImpl.IndexImmutable.Byte((WeightsImpl.Index.Byte) weights, idStart, reIndexMap);</span>
<span class="nc bnc" id="L972" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Short) {</span>
<span class="nc" id="L973">				return new WeightsImpl.IndexImmutable.Short((WeightsImpl.Index.Short) weights, idStart, reIndexMap);</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Int) {</span>
<span class="nc" id="L975">				return new WeightsImpl.IndexImmutable.Int((WeightsImpl.Index.Int) weights, idStart, reIndexMap);</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Long) {</span>
<span class="nc" id="L977">				return new WeightsImpl.IndexImmutable.Long((WeightsImpl.Index.Long) weights, idStart, reIndexMap);</span>
<span class="nc bnc" id="L978" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Float) {</span>
<span class="nc" id="L979">				return new WeightsImpl.IndexImmutable.Float((WeightsImpl.Index.Float) weights, idStart, reIndexMap);</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Double) {</span>
<span class="nc" id="L981">				return new WeightsImpl.IndexImmutable.Double((WeightsImpl.Index.Double) weights, idStart, reIndexMap);</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Bool) {</span>
<span class="nc" id="L983">				return new WeightsImpl.IndexImmutable.Bool((WeightsImpl.Index.Bool) weights, idStart, reIndexMap);</span>
<span class="nc bnc" id="L984" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Char) {</span>
<span class="nc" id="L985">				return new WeightsImpl.IndexImmutable.Char((WeightsImpl.Index.Char) weights, idStart, reIndexMap);</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Obj) {</span>
<span class="nc" id="L987">				return new WeightsImpl.IndexImmutable.Obj&lt;&gt;((WeightsImpl.Index.Obj&lt;?&gt;) weights, idStart, reIndexMap);</span>
			} else {
<span class="nc" id="L989">				throw new IllegalArgumentException(&quot;unknown weights implementation: &quot; + weights.getClass());</span>
			}
		}

		static class Obj&lt;E&gt; extends WeightsImpl.Index.Obj&lt;E&gt; implements WeightsImpl.IndexImmutable&lt;E&gt; {

			Obj(IdStrategy.FixedSize idStrat, E defVal, Class&lt;E&gt; type) {
<span class="nc" id="L996">				super(idStrat, defVal, type);</span>
<span class="nc" id="L997">			}</span>

			Obj(WeightsImpl.Index.Obj&lt;E&gt; orig, IdStrategy.FixedSize idStrat) {
<span class="nc" id="L1000">				super(orig, idStrat);</span>
<span class="nc" id="L1001">			}</span>

			Obj(WeightsImpl.Index.Obj&lt;E&gt; orig, IdStrategy.FixedSize idStrat,
					IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L1005">				super(orig, idStrat, reIndexMap);</span>
<span class="nc" id="L1006">			}</span>

			@Override
			public void set(int idx, E weight) {
<span class="nc" id="L1010">				throw new UnsupportedOperationException();</span>
			}
		}

		static class Byte extends WeightsImpl.Index.Byte implements WeightsImpl.IndexImmutable&lt;java.lang.Byte&gt; {

			Byte(IdStrategy.FixedSize idStrat, byte defVal) {
<span class="nc" id="L1017">				super(idStrat, defVal);</span>
<span class="nc" id="L1018">			}</span>

			Byte(WeightsImpl.Index.Byte orig, IdStrategy.FixedSize idStrat) {
<span class="nc" id="L1021">				super(orig, idStrat);</span>
<span class="nc" id="L1022">			}</span>

			Byte(WeightsImpl.Index.Byte orig, IdStrategy.FixedSize idStrat,
					IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L1026">				super(orig, idStrat, reIndexMap);</span>
<span class="nc" id="L1027">			}</span>

			@Override
			public void set(int idx, byte weight) {
<span class="nc" id="L1031">				throw new UnsupportedOperationException();</span>
			}
		}

		static class Short extends WeightsImpl.Index.Short implements WeightsImpl.IndexImmutable&lt;java.lang.Short&gt; {

			Short(IdStrategy.FixedSize idStrat, short defVal) {
<span class="nc" id="L1038">				super(idStrat, defVal);</span>
<span class="nc" id="L1039">			}</span>

			Short(WeightsImpl.Index.Short orig, IdStrategy.FixedSize idStrat) {
<span class="nc" id="L1042">				super(orig, idStrat);</span>
<span class="nc" id="L1043">			}</span>

			Short(WeightsImpl.Index.Short orig, IdStrategy.FixedSize idStrat,
					IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L1047">				super(orig, idStrat, reIndexMap);</span>
<span class="nc" id="L1048">			}</span>

			@Override
			public void set(int idx, short weight) {
<span class="nc" id="L1052">				throw new UnsupportedOperationException();</span>
			}
		}

		static class Int extends WeightsImpl.Index.Int implements WeightsImpl.IndexImmutable&lt;Integer&gt; {

			Int(IdStrategy.FixedSize idStrat, int defVal) {
<span class="nc" id="L1059">				super(idStrat, defVal);</span>
<span class="nc" id="L1060">			}</span>

			Int(WeightsImpl.Index.Int orig, IdStrategy.FixedSize idStrat) {
<span class="nc" id="L1063">				super(orig, idStrat);</span>
<span class="nc" id="L1064">			}</span>

			Int(WeightsImpl.Index.Int orig, IdStrategy.FixedSize idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L1067">				super(orig, idStrat, reIndexMap);</span>
<span class="nc" id="L1068">			}</span>

			@Override
			public void set(int idx, int weight) {
<span class="nc" id="L1072">				throw new UnsupportedOperationException();</span>
			}
		}

		static class Long extends WeightsImpl.Index.Long implements WeightsImpl.IndexImmutable&lt;java.lang.Long&gt; {

			Long(IdStrategy.FixedSize idStrat, long defVal) {
<span class="nc" id="L1079">				super(idStrat, defVal);</span>
<span class="nc" id="L1080">			}</span>

			Long(WeightsImpl.Index.Long orig, IdStrategy.FixedSize idStrat) {
<span class="nc" id="L1083">				super(orig, idStrat);</span>
<span class="nc" id="L1084">			}</span>

			Long(WeightsImpl.Index.Long orig, IdStrategy.FixedSize idStrat,
					IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L1088">				super(orig, idStrat, reIndexMap);</span>
<span class="nc" id="L1089">			}</span>

			@Override
			public void set(int idx, long weight) {
<span class="nc" id="L1093">				throw new UnsupportedOperationException();</span>
			}
		}

		static class Float extends WeightsImpl.Index.Float implements WeightsImpl.IndexImmutable&lt;java.lang.Float&gt; {

			Float(IdStrategy.FixedSize idStrat, float defVal) {
<span class="nc" id="L1100">				super(idStrat, defVal);</span>
<span class="nc" id="L1101">			}</span>

			Float(WeightsImpl.Index.Float orig, IdStrategy.FixedSize idStrat) {
<span class="nc" id="L1104">				super(orig, idStrat);</span>
<span class="nc" id="L1105">			}</span>

			Float(WeightsImpl.Index.Float orig, IdStrategy.FixedSize idStrat,
					IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L1109">				super(orig, idStrat, reIndexMap);</span>
<span class="nc" id="L1110">			}</span>

			@Override
			public void set(int idx, float weight) {
<span class="nc" id="L1114">				throw new UnsupportedOperationException();</span>
			}
		}

		static class Double extends WeightsImpl.Index.Double implements WeightsImpl.IndexImmutable&lt;java.lang.Double&gt; {

			Double(IdStrategy.FixedSize idStrat, double defVal) {
<span class="nc" id="L1121">				super(idStrat, defVal);</span>
<span class="nc" id="L1122">			}</span>

			Double(WeightsImpl.Index.Double orig, IdStrategy.FixedSize idStrat) {
<span class="nc" id="L1125">				super(orig, idStrat);</span>
<span class="nc" id="L1126">			}</span>

			Double(WeightsImpl.Index.Double orig, IdStrategy.FixedSize idStrat,
					IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L1130">				super(orig, idStrat, reIndexMap);</span>
<span class="nc" id="L1131">			}</span>

			@Override
			public void set(int idx, double weight) {
<span class="nc" id="L1135">				throw new UnsupportedOperationException();</span>
			}
		}

		static class Bool extends WeightsImpl.Index.Bool implements WeightsImpl.IndexImmutable&lt;Boolean&gt; {

			Bool(IdStrategy.FixedSize idStrat, boolean defVal) {
<span class="nc" id="L1142">				super(idStrat, defVal);</span>
<span class="nc" id="L1143">			}</span>

			Bool(WeightsImpl.Index.Bool orig, IdStrategy.FixedSize idStrat) {
<span class="nc" id="L1146">				super(orig, idStrat);</span>
<span class="nc" id="L1147">			}</span>

			Bool(WeightsImpl.Index.Bool orig, IdStrategy.FixedSize idStrat,
					IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L1151">				super(orig, idStrat, reIndexMap);</span>
<span class="nc" id="L1152">			}</span>

			@Override
			public void set(int idx, boolean weight) {
<span class="nc" id="L1156">				throw new UnsupportedOperationException();</span>
			}
		}

		static class Char extends WeightsImpl.Index.Char implements WeightsImpl.IndexImmutable&lt;Character&gt; {

			Char(IdStrategy.FixedSize idStrat, char defVal) {
<span class="nc" id="L1163">				super(idStrat, defVal);</span>
<span class="nc" id="L1164">			}</span>

			Char(WeightsImpl.Index.Char orig, IdStrategy.FixedSize idStrat) {
<span class="nc" id="L1167">				super(orig, idStrat);</span>
<span class="nc" id="L1168">			}</span>

			Char(WeightsImpl.Index.Char orig, IdStrategy.FixedSize idStrat,
					IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L1172">				super(orig, idStrat, reIndexMap);</span>
<span class="nc" id="L1173">			}</span>

			@Override
			public void set(int idx, char weight) {
<span class="nc" id="L1177">				throw new UnsupportedOperationException();</span>
			}
		}

		static class Builder {

			private final IdStrategy.FixedSize idStrat;
			private final Map&lt;Object, WeightsImpl.IndexImmutable&lt;?&gt;&gt; weights;

<span class="fc" id="L1186">			Builder(IdStrategy.FixedSize idStrat) {</span>
<span class="fc" id="L1187">				this.idStrat = Objects.requireNonNull(idStrat);</span>
<span class="fc" id="L1188">				weights = new Object2ObjectArrayMap&lt;&gt;();</span>
<span class="fc" id="L1189">			}</span>

			void copyAndAddWeights(Object key, Weights&lt;?&gt; weights) {
<span class="nc" id="L1192">				Object oldWeights = this.weights.put(key, WeightsImpl.IndexImmutable.copyOf(weights, idStrat));</span>
<span class="nc bnc" id="L1193" title="All 2 branches missed.">				if (oldWeights != null)</span>
<span class="nc" id="L1194">					throw new IllegalArgumentException(&quot;duplicate key: &quot; + key);</span>
<span class="nc" id="L1195">			}</span>

			void copyAndAddWeightsReindexed(Object key, Weights&lt;?&gt; weights,
					IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L1199">				Object oldWeights =</span>
<span class="nc" id="L1200">						this.weights.put(key, WeightsImpl.IndexImmutable.copyOfReindexed(weights, idStrat, reIndexMap));</span>
<span class="nc bnc" id="L1201" title="All 2 branches missed.">				if (oldWeights != null)</span>
<span class="nc" id="L1202">					throw new IllegalArgumentException(&quot;duplicate key: &quot; + key);</span>
<span class="nc" id="L1203">			}</span>

			Map&lt;Object, WeightsImpl.IndexImmutable&lt;?&gt;&gt; build() {
<span class="fc" id="L1206">				return Map.copyOf(weights);</span>
			}
		}
	}

	static interface IndexMutable&lt;E&gt; extends WeightsImpl.Index&lt;E&gt; {

		int capacity();

		void expand(int newCapacity);

		void clear(int idx);

		void clear();

		void swap(int idx1, int idx2);

		static &lt;D&gt; WeightsImpl.IndexMutable&lt;D&gt; newInstance(IdStrategy idStart, Class&lt;? super D&gt; type, D defVal) {
			@SuppressWarnings(&quot;rawtypes&quot;)
			WeightsImpl container;
<span class="fc bfc" id="L1226" title="All 2 branches covered.">			if (type == byte.class) {</span>
<span class="fc bfc" id="L1227" title="All 2 branches covered.">				byte defVal0 = defVal != null ? ((java.lang.Byte) defVal).byteValue() : 0;</span>
<span class="fc" id="L1228">				container = new WeightsImpl.IndexMutable.Byte(idStart, defVal0);</span>

<span class="fc bfc" id="L1230" title="All 2 branches covered.">			} else if (type == short.class) {</span>
<span class="fc bfc" id="L1231" title="All 2 branches covered.">				short defVal0 = defVal != null ? ((java.lang.Short) defVal).shortValue() : 0;</span>
<span class="fc" id="L1232">				container = new WeightsImpl.IndexMutable.Short(idStart, defVal0);</span>

<span class="fc bfc" id="L1234" title="All 2 branches covered.">			} else if (type == int.class) {</span>
<span class="fc bfc" id="L1235" title="All 2 branches covered.">				int defVal0 = defVal != null ? ((Integer) defVal).intValue() : 0;</span>
<span class="fc" id="L1236">				container = new WeightsImpl.IndexMutable.Int(idStart, defVal0);</span>

<span class="fc bfc" id="L1238" title="All 2 branches covered.">			} else if (type == long.class) {</span>
<span class="fc bfc" id="L1239" title="All 2 branches covered.">				long defVal0 = defVal != null ? ((java.lang.Long) defVal).longValue() : 0;</span>
<span class="fc" id="L1240">				container = new WeightsImpl.IndexMutable.Long(idStart, defVal0);</span>

<span class="fc bfc" id="L1242" title="All 2 branches covered.">			} else if (type == float.class) {</span>
<span class="fc bfc" id="L1243" title="All 2 branches covered.">				float defVal0 = defVal != null ? ((java.lang.Float) defVal).floatValue() : 0;</span>
<span class="fc" id="L1244">				container = new WeightsImpl.IndexMutable.Float(idStart, defVal0);</span>

<span class="fc bfc" id="L1246" title="All 2 branches covered.">			} else if (type == double.class) {</span>
<span class="fc bfc" id="L1247" title="All 2 branches covered.">				double defVal0 = defVal != null ? ((java.lang.Double) defVal).doubleValue() : 0;</span>
<span class="fc" id="L1248">				container = new WeightsImpl.IndexMutable.Double(idStart, defVal0);</span>

<span class="fc bfc" id="L1250" title="All 2 branches covered.">			} else if (type == boolean.class) {</span>
<span class="fc bfc" id="L1251" title="All 2 branches covered.">				boolean defVal0 = defVal != null ? ((Boolean) defVal).booleanValue() : false;</span>
<span class="fc" id="L1252">				container = new WeightsImpl.IndexMutable.Bool(idStart, defVal0);</span>

<span class="fc bfc" id="L1254" title="All 2 branches covered.">			} else if (type == char.class) {</span>
<span class="fc bfc" id="L1255" title="All 2 branches covered.">				char defVal0 = defVal != null ? ((Character) defVal).charValue() : 0;</span>
<span class="fc" id="L1256">				container = new WeightsImpl.IndexMutable.Char(idStart, defVal0);</span>

<span class="fc" id="L1258">			} else {</span>
<span class="fc" id="L1259">				container = new WeightsImpl.IndexMutable.Obj&lt;&gt;(idStart, defVal, type);</span>
			}
			@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1262">			WeightsImpl.IndexMutable&lt;D&gt; container0 = (WeightsImpl.IndexMutable&lt;D&gt;) container;</span>
<span class="fc" id="L1263">			return container0;</span>
		}

		static WeightsImpl.IndexMutable&lt;?&gt; copyOf(Weights&lt;?&gt; weights, IdStrategy idStart) {
<span class="pc bpc" id="L1267" title="1 of 2 branches missed.">			if (weights instanceof WeightsImpl.ImmutableView&lt;?&gt;)</span>
<span class="nc" id="L1268">				weights = ((WeightsImpl.ImmutableView&lt;?&gt;) weights).weights;</span>
<span class="pc bpc" id="L1269" title="1 of 2 branches missed.">			if (weights instanceof WeightsImpl.Index.Byte) {</span>
<span class="nc" id="L1270">				return new WeightsImpl.IndexMutable.Byte((WeightsImpl.Index.Byte) weights, idStart);</span>
<span class="pc bpc" id="L1271" title="1 of 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Short) {</span>
<span class="nc" id="L1272">				return new WeightsImpl.IndexMutable.Short((WeightsImpl.Index.Short) weights, idStart);</span>
<span class="fc bfc" id="L1273" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Int) {</span>
<span class="fc" id="L1274">				return new WeightsImpl.IndexMutable.Int((WeightsImpl.Index.Int) weights, idStart);</span>
<span class="pc bpc" id="L1275" title="1 of 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Long) {</span>
<span class="nc" id="L1276">				return new WeightsImpl.IndexMutable.Long((WeightsImpl.Index.Long) weights, idStart);</span>
<span class="pc bpc" id="L1277" title="1 of 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Float) {</span>
<span class="nc" id="L1278">				return new WeightsImpl.IndexMutable.Float((WeightsImpl.Index.Float) weights, idStart);</span>
<span class="pc bpc" id="L1279" title="1 of 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Double) {</span>
<span class="nc" id="L1280">				return new WeightsImpl.IndexMutable.Double((WeightsImpl.Index.Double) weights, idStart);</span>
<span class="pc bpc" id="L1281" title="1 of 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Bool) {</span>
<span class="nc" id="L1282">				return new WeightsImpl.IndexMutable.Bool((WeightsImpl.Index.Bool) weights, idStart);</span>
<span class="pc bpc" id="L1283" title="1 of 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Char) {</span>
<span class="nc" id="L1284">				return new WeightsImpl.IndexMutable.Char((WeightsImpl.Index.Char) weights, idStart);</span>
<span class="pc bpc" id="L1285" title="1 of 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Obj) {</span>
<span class="fc" id="L1286">				return new WeightsImpl.IndexMutable.Obj&lt;&gt;((WeightsImpl.Index.Obj&lt;?&gt;) weights, idStart);</span>
			} else {
<span class="nc" id="L1288">				throw new IllegalArgumentException(&quot;unknown weights implementation: &quot; + weights.getClass());</span>
			}
		}

		static WeightsImpl.IndexMutable&lt;?&gt; copyOfReindexed(Weights&lt;?&gt; weights, IdStrategy idStart,
				IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc bnc" id="L1294" title="All 2 branches missed.">			if (weights instanceof WeightsImpl.ImmutableView&lt;?&gt;)</span>
<span class="nc" id="L1295">				weights = ((WeightsImpl.ImmutableView&lt;?&gt;) weights).weights;</span>
<span class="nc bnc" id="L1296" title="All 2 branches missed.">			if (weights instanceof WeightsImpl.Index.Byte) {</span>
<span class="nc" id="L1297">				return new WeightsImpl.IndexMutable.Byte((WeightsImpl.Index.Byte) weights, idStart, reIndexMap);</span>
<span class="nc bnc" id="L1298" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Short) {</span>
<span class="nc" id="L1299">				return new WeightsImpl.IndexMutable.Short((WeightsImpl.Index.Short) weights, idStart, reIndexMap);</span>
<span class="nc bnc" id="L1300" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Int) {</span>
<span class="nc" id="L1301">				return new WeightsImpl.IndexMutable.Int((WeightsImpl.Index.Int) weights, idStart, reIndexMap);</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Long) {</span>
<span class="nc" id="L1303">				return new WeightsImpl.IndexMutable.Long((WeightsImpl.Index.Long) weights, idStart, reIndexMap);</span>
<span class="nc bnc" id="L1304" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Float) {</span>
<span class="nc" id="L1305">				return new WeightsImpl.IndexMutable.Float((WeightsImpl.Index.Float) weights, idStart, reIndexMap);</span>
<span class="nc bnc" id="L1306" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Double) {</span>
<span class="nc" id="L1307">				return new WeightsImpl.IndexMutable.Double((WeightsImpl.Index.Double) weights, idStart, reIndexMap);</span>
<span class="nc bnc" id="L1308" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Bool) {</span>
<span class="nc" id="L1309">				return new WeightsImpl.IndexMutable.Bool((WeightsImpl.Index.Bool) weights, idStart, reIndexMap);</span>
<span class="nc bnc" id="L1310" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Char) {</span>
<span class="nc" id="L1311">				return new WeightsImpl.IndexMutable.Char((WeightsImpl.Index.Char) weights, idStart, reIndexMap);</span>
<span class="nc bnc" id="L1312" title="All 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Obj) {</span>
<span class="nc" id="L1313">				return new WeightsImpl.IndexMutable.Obj&lt;&gt;((WeightsImpl.Index.Obj&lt;?&gt;) weights, idStart, reIndexMap);</span>
			} else {
<span class="nc" id="L1315">				throw new IllegalArgumentException(&quot;unknown weights implementation: &quot; + weights.getClass());</span>
			}
		}

<span class="fc" id="L1319">		static class Obj&lt;E&gt; extends WeightsImpl.Index.Obj&lt;E&gt; implements WeightsImpl.IndexMutable&lt;E&gt; {</span>

			Obj(IdStrategy idStrat, E defVal, Class&lt;E&gt; type) {
<span class="fc" id="L1322">				super(idStrat, defVal, type);</span>
<span class="fc" id="L1323">			}</span>

			Obj(WeightsImpl.Index.Obj&lt;E&gt; orig, IdStrategy idStrat) {
<span class="fc" id="L1326">				super(orig, idStrat);</span>
<span class="fc" id="L1327">			}</span>

			Obj(WeightsImpl.Index.Obj&lt;E&gt; orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L1330">				super(orig, idStrat, reIndexMap);</span>
<span class="nc" id="L1331">			}</span>

			@Override
			public void set(int idx, E weight) {
<span class="fc" id="L1335">				checkIdx(idx);</span>
<span class="fc" id="L1336">				weights[idx] = weight;</span>
<span class="fc" id="L1337">			}</span>

			@Override
			public int capacity() {
<span class="fc" id="L1341">				return weights.length;</span>
			}

			@Override
			public void expand(int newCapacity) {
<span class="fc" id="L1346">				int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L1347" title="1 of 2 branches missed.">				assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L1348">				weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L1349">				Arrays.fill(weights, oldCapacity, newCapacity, defaultWeight);</span>
<span class="fc" id="L1350">			}</span>

			@Override
			public void swap(int idx1, int idx2) {
<span class="fc" id="L1354">				checkIdx(idx1);</span>
<span class="fc" id="L1355">				checkIdx(idx2);</span>
<span class="fc" id="L1356">				ObjectArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L1357">			}</span>

			@Override
			public void clear(int idx) {
				// checkIdx(idx);
<span class="fc" id="L1362">				weights[idx] = defaultWeight;</span>
<span class="fc" id="L1363">			}</span>

			@Override
			public void clear() {
<span class="nc" id="L1367">				Arrays.fill(weights, 0, size(), defaultWeight);</span>
<span class="nc" id="L1368">			}</span>
		}

<span class="fc" id="L1371">		static class Byte extends WeightsImpl.Index.Byte implements WeightsImpl.IndexMutable&lt;java.lang.Byte&gt; {</span>

			Byte(IdStrategy idStrat, byte defVal) {
<span class="fc" id="L1374">				super(idStrat, defVal);</span>
<span class="fc" id="L1375">			}</span>

			Byte(WeightsImpl.Index.Byte orig, IdStrategy idStrat) {
<span class="nc" id="L1378">				super(orig, idStrat);</span>
<span class="nc" id="L1379">			}</span>

			Byte(WeightsImpl.Index.Byte orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L1382">				super(orig, idStrat, reIndexMap);</span>
<span class="nc" id="L1383">			}</span>

			@Override
			public void set(int idx, byte weight) {
<span class="fc" id="L1387">				checkIdx(idx);</span>
<span class="fc" id="L1388">				weights[idx] = weight;</span>
<span class="fc" id="L1389">			}</span>

			@Override
			public int capacity() {
<span class="fc" id="L1393">				return weights.length;</span>
			}

			@Override
			public void expand(int newCapacity) {
<span class="fc" id="L1398">				int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L1399" title="1 of 2 branches missed.">				assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L1400">				weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L1401">				Arrays.fill(weights, oldCapacity, newCapacity, defaultWeight);</span>
<span class="fc" id="L1402">			}</span>

			@Override
			public void swap(int idx1, int idx2) {
<span class="fc" id="L1406">				checkIdx(idx1);</span>
<span class="fc" id="L1407">				checkIdx(idx2);</span>
<span class="fc" id="L1408">				ByteArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L1409">			}</span>

			@Override
			public void clear(int idx) {
				// checkIdx(idx);
<span class="fc" id="L1414">				weights[idx] = defaultWeight;</span>
<span class="fc" id="L1415">			}</span>

			@Override
			public void clear() {
<span class="nc" id="L1419">				Arrays.fill(weights, 0, size(), defaultWeight);</span>
<span class="nc" id="L1420">			}</span>
		}

<span class="fc" id="L1423">		static class Short extends WeightsImpl.Index.Short implements WeightsImpl.IndexMutable&lt;java.lang.Short&gt; {</span>

			Short(IdStrategy idStrat, short defVal) {
<span class="fc" id="L1426">				super(idStrat, defVal);</span>
<span class="fc" id="L1427">			}</span>

			Short(WeightsImpl.Index.Short orig, IdStrategy idStrat) {
<span class="nc" id="L1430">				super(orig, idStrat);</span>
<span class="nc" id="L1431">			}</span>

			Short(WeightsImpl.Index.Short orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L1434">				super(orig, idStrat, reIndexMap);</span>
<span class="nc" id="L1435">			}</span>

			@Override
			public void set(int idx, short weight) {
<span class="fc" id="L1439">				checkIdx(idx);</span>
<span class="fc" id="L1440">				weights[idx] = weight;</span>
<span class="fc" id="L1441">			}</span>

			@Override
			public int capacity() {
<span class="fc" id="L1445">				return weights.length;</span>
			}

			@Override
			public void expand(int newCapacity) {
<span class="fc" id="L1450">				int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L1451" title="1 of 2 branches missed.">				assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L1452">				weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L1453">				Arrays.fill(weights, oldCapacity, newCapacity, defaultWeight);</span>
<span class="fc" id="L1454">			}</span>

			@Override
			public void swap(int idx1, int idx2) {
<span class="fc" id="L1458">				checkIdx(idx1);</span>
<span class="fc" id="L1459">				checkIdx(idx2);</span>
<span class="fc" id="L1460">				ShortArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L1461">			}</span>

			@Override
			public void clear(int idx) {
				// checkIdx(idx);
<span class="fc" id="L1466">				weights[idx] = defaultWeight;</span>
<span class="fc" id="L1467">			}</span>

			@Override
			public void clear() {
<span class="nc" id="L1471">				Arrays.fill(weights, 0, size(), defaultWeight);</span>
<span class="nc" id="L1472">			}</span>
		}

<span class="fc" id="L1475">		static class Int extends WeightsImpl.Index.Int implements WeightsImpl.IndexMutable&lt;Integer&gt; {</span>

			Int(IdStrategy idStrat, int defVal) {
<span class="fc" id="L1478">				super(idStrat, defVal);</span>
<span class="fc" id="L1479">			}</span>

			Int(WeightsImpl.Index.Int orig, IdStrategy idStrat) {
<span class="fc" id="L1482">				super(orig, idStrat);</span>
<span class="fc" id="L1483">			}</span>

			Int(WeightsImpl.Index.Int orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L1486">				super(orig, idStrat, reIndexMap);</span>
<span class="nc" id="L1487">			}</span>

			@Override
			public void set(int idx, int weight) {
<span class="fc" id="L1491">				checkIdx(idx);</span>
<span class="fc" id="L1492">				weights[idx] = weight;</span>
<span class="fc" id="L1493">			}</span>

			@Override
			public int capacity() {
<span class="fc" id="L1497">				return weights.length;</span>
			}

			@Override
			public void expand(int newCapacity) {
<span class="fc" id="L1502">				int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L1503" title="1 of 2 branches missed.">				assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L1504">				weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L1505">				Arrays.fill(weights, oldCapacity, newCapacity, defaultWeight);</span>
<span class="fc" id="L1506">			}</span>

			@Override
			public void swap(int idx1, int idx2) {
<span class="fc" id="L1510">				checkIdx(idx1);</span>
<span class="fc" id="L1511">				checkIdx(idx2);</span>
<span class="fc" id="L1512">				IntArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L1513">			}</span>

			@Override
			public void clear(int idx) {
				// checkIdx(idx);
<span class="fc" id="L1518">				weights[idx] = defaultWeight;</span>
<span class="fc" id="L1519">			}</span>

			@Override
			public void clear() {
<span class="fc" id="L1523">				Arrays.fill(weights, 0, size(), defaultWeight);</span>
<span class="fc" id="L1524">			}</span>
		}

<span class="fc" id="L1527">		static class Long extends WeightsImpl.Index.Long implements WeightsImpl.IndexMutable&lt;java.lang.Long&gt; {</span>

			Long(IdStrategy idStrat, long defVal) {
<span class="fc" id="L1530">				super(idStrat, defVal);</span>
<span class="fc" id="L1531">			}</span>

			Long(WeightsImpl.Index.Long orig, IdStrategy idStrat) {
<span class="nc" id="L1534">				super(orig, idStrat);</span>
<span class="nc" id="L1535">			}</span>

			Long(WeightsImpl.Index.Long orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L1538">				super(orig, idStrat, reIndexMap);</span>
<span class="nc" id="L1539">			}</span>

			@Override
			public void set(int idx, long weight) {
<span class="fc" id="L1543">				checkIdx(idx);</span>
<span class="fc" id="L1544">				weights[idx] = weight;</span>
<span class="fc" id="L1545">			}</span>

			@Override
			public int capacity() {
<span class="fc" id="L1549">				return weights.length;</span>
			}

			@Override
			public void expand(int newCapacity) {
<span class="fc" id="L1554">				int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L1555" title="1 of 2 branches missed.">				assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L1556">				weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L1557">				Arrays.fill(weights, oldCapacity, newCapacity, defaultWeight);</span>
<span class="fc" id="L1558">			}</span>

			@Override
			public void swap(int idx1, int idx2) {
<span class="fc" id="L1562">				checkIdx(idx1);</span>
<span class="fc" id="L1563">				checkIdx(idx2);</span>
<span class="fc" id="L1564">				LongArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L1565">			}</span>

			@Override
			public void clear(int idx) {
				// checkIdx(idx);
<span class="fc" id="L1570">				weights[idx] = defaultWeight;</span>
<span class="fc" id="L1571">			}</span>

			@Override
			public void clear() {
<span class="nc" id="L1575">				Arrays.fill(weights, 0, size(), defaultWeight);</span>
<span class="nc" id="L1576">			}</span>
		}

<span class="fc" id="L1579">		static class Float extends WeightsImpl.Index.Float implements WeightsImpl.IndexMutable&lt;java.lang.Float&gt; {</span>

			Float(IdStrategy idStrat, float defVal) {
<span class="fc" id="L1582">				super(idStrat, defVal);</span>
<span class="fc" id="L1583">			}</span>

			Float(WeightsImpl.Index.Float orig, IdStrategy idStrat) {
<span class="nc" id="L1586">				super(orig, idStrat);</span>
<span class="nc" id="L1587">			}</span>

			Float(WeightsImpl.Index.Float orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L1590">				super(orig, idStrat, reIndexMap);</span>
<span class="nc" id="L1591">			}</span>

			@Override
			public void set(int idx, float weight) {
<span class="fc" id="L1595">				checkIdx(idx);</span>
<span class="fc" id="L1596">				weights[idx] = weight;</span>
<span class="fc" id="L1597">			}</span>

			@Override
			public int capacity() {
<span class="fc" id="L1601">				return weights.length;</span>
			}

			@Override
			public void expand(int newCapacity) {
<span class="fc" id="L1606">				int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L1607" title="1 of 2 branches missed.">				assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L1608">				weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L1609">				Arrays.fill(weights, oldCapacity, newCapacity, defaultWeight);</span>
<span class="fc" id="L1610">			}</span>

			@Override
			public void swap(int idx1, int idx2) {
<span class="fc" id="L1614">				checkIdx(idx1);</span>
<span class="fc" id="L1615">				checkIdx(idx2);</span>
<span class="fc" id="L1616">				FloatArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L1617">			}</span>

			@Override
			public void clear(int idx) {
				// checkIdx(idx);
<span class="fc" id="L1622">				weights[idx] = defaultWeight;</span>
<span class="fc" id="L1623">			}</span>

			@Override
			public void clear() {
<span class="nc" id="L1627">				Arrays.fill(weights, 0, size(), defaultWeight);</span>
<span class="nc" id="L1628">			}</span>
		}

<span class="fc" id="L1631">		static class Double extends WeightsImpl.Index.Double implements WeightsImpl.IndexMutable&lt;java.lang.Double&gt; {</span>

			Double(IdStrategy idStrat, double defVal) {
<span class="fc" id="L1634">				super(idStrat, defVal);</span>
<span class="fc" id="L1635">			}</span>

			Double(WeightsImpl.Index.Double orig, IdStrategy idStrat) {
<span class="nc" id="L1638">				super(orig, idStrat);</span>
<span class="nc" id="L1639">			}</span>

			Double(WeightsImpl.Index.Double orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L1642">				super(orig, idStrat, reIndexMap);</span>
<span class="nc" id="L1643">			}</span>

			@Override
			public void set(int idx, double weight) {
<span class="fc" id="L1647">				checkIdx(idx);</span>
<span class="fc" id="L1648">				weights[idx] = weight;</span>
<span class="fc" id="L1649">			}</span>

			@Override
			public int capacity() {
<span class="fc" id="L1653">				return weights.length;</span>
			}

			@Override
			public void expand(int newCapacity) {
<span class="fc" id="L1658">				int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L1659" title="1 of 2 branches missed.">				assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L1660">				weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L1661">				Arrays.fill(weights, oldCapacity, newCapacity, defaultWeight);</span>
<span class="fc" id="L1662">			}</span>

			@Override
			public void swap(int idx1, int idx2) {
<span class="fc" id="L1666">				checkIdx(idx1);</span>
<span class="fc" id="L1667">				checkIdx(idx2);</span>
<span class="fc" id="L1668">				DoubleArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L1669">			}</span>

			@Override
			public void clear(int idx) {
				// checkIdx(idx);
<span class="fc" id="L1674">				weights[idx] = defaultWeight;</span>
<span class="fc" id="L1675">			}</span>

			@Override
			public void clear() {
<span class="fc" id="L1679">				Arrays.fill(weights, 0, size(), defaultWeight);</span>
<span class="fc" id="L1680">			}</span>
		}

<span class="fc" id="L1683">		static class Bool extends WeightsImpl.Index.Bool implements WeightsImpl.IndexMutable&lt;Boolean&gt; {</span>

			Bool(IdStrategy idStrat, boolean defVal) {
<span class="fc" id="L1686">				super(idStrat, defVal);</span>
<span class="fc" id="L1687">			}</span>

			Bool(WeightsImpl.Index.Bool orig, IdStrategy idStrat) {
<span class="nc" id="L1690">				super(orig, idStrat);</span>
<span class="nc" id="L1691">			}</span>

			Bool(WeightsImpl.Index.Bool orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L1694">				super(orig, idStrat, reIndexMap);</span>
<span class="nc" id="L1695">			}</span>

			@Override
			public void set(int idx, boolean weight) {
<span class="fc" id="L1699">				checkIdx(idx);</span>
<span class="fc" id="L1700">				weights.set(idx, weight);</span>
<span class="fc" id="L1701">			}</span>

			@Override
			public int capacity() {
<span class="fc" id="L1705">				return capacity;</span>
			}

			@Override
			public void expand(int newCapacity) {
<span class="fc" id="L1710">				int oldCapacity = capacity;</span>
<span class="pc bpc" id="L1711" title="1 of 2 branches missed.">				assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L1712">				capacity = newCapacity;</span>
<span class="fc bfc" id="L1713" title="All 2 branches covered.">				if (defaultWeight)</span>
<span class="fc" id="L1714">					weights.set(oldCapacity, newCapacity);</span>
<span class="fc" id="L1715">			}</span>

			@Override
			public void swap(int idx1, int idx2) {
<span class="fc" id="L1719">				checkIdx(idx1);</span>
<span class="fc" id="L1720">				checkIdx(idx2);</span>
<span class="fc" id="L1721">				boolean temp = weights.get(idx1);</span>
<span class="fc" id="L1722">				weights.set(idx1, weights.get(idx2));</span>
<span class="fc" id="L1723">				weights.set(idx2, temp);</span>
<span class="fc" id="L1724">			}</span>

			@Override
			public void clear(int idx) {
				// checkIdx(idx);
<span class="fc" id="L1729">				weights.set(idx, defaultWeight);</span>
<span class="fc" id="L1730">			}</span>

			@Override
			public void clear() {
<span class="nc" id="L1734">				weights.set(0, capacity, defaultWeight);</span>
<span class="nc" id="L1735">			}</span>
		}

<span class="fc" id="L1738">		static class Char extends WeightsImpl.Index.Char implements WeightsImpl.IndexMutable&lt;Character&gt; {</span>

			Char(IdStrategy idStrat, char defVal) {
<span class="fc" id="L1741">				super(idStrat, defVal);</span>
<span class="fc" id="L1742">			}</span>

			Char(WeightsImpl.Index.Char orig, IdStrategy idStrat) {
<span class="nc" id="L1745">				super(orig, idStrat);</span>
<span class="nc" id="L1746">			}</span>

			Char(WeightsImpl.Index.Char orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="nc" id="L1749">				super(orig, idStrat, reIndexMap);</span>
<span class="nc" id="L1750">			}</span>

			@Override
			public void set(int idx, char weight) {
<span class="fc" id="L1754">				checkIdx(idx);</span>
<span class="fc" id="L1755">				weights[idx] = weight;</span>
<span class="fc" id="L1756">			}</span>

			@Override
			public int capacity() {
<span class="fc" id="L1760">				return weights.length;</span>
			}

			@Override
			public void expand(int newCapacity) {
<span class="fc" id="L1765">				int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L1766" title="1 of 2 branches missed.">				assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L1767">				weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L1768">				Arrays.fill(weights, oldCapacity, newCapacity, defaultWeight);</span>
<span class="fc" id="L1769">			}</span>

			@Override
			public void swap(int idx1, int idx2) {
<span class="fc" id="L1773">				checkIdx(idx1);</span>
<span class="fc" id="L1774">				checkIdx(idx2);</span>
<span class="fc" id="L1775">				CharArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L1776">			}</span>

			@Override
			public void clear(int idx) {
				// checkIdx(idx);
<span class="fc" id="L1781">				weights[idx] = defaultWeight;</span>
<span class="fc" id="L1782">			}</span>

			@Override
			public void clear() {
<span class="nc" id="L1786">				Arrays.fill(weights, 0, size(), defaultWeight);</span>
<span class="nc" id="L1787">			}</span>
		}

		static class Manager {

<span class="fc" id="L1792">			final Map&lt;Object, WeightsImpl.IndexMutable&lt;?&gt;&gt; weights = new Object2ObjectArrayMap&lt;&gt;();</span>
			private int weightsCapacity;

<span class="fc" id="L1795">			Manager(int initCapacity) {</span>
<span class="fc" id="L1796">				weightsCapacity = initCapacity;</span>
<span class="fc" id="L1797">			}</span>

			Manager(Manager orig, IdStrategy idStrat) {
<span class="fc" id="L1800">				this(idStrat.size());</span>
<span class="fc bfc" id="L1801" title="All 2 branches covered.">				for (var entry : orig.weights.entrySet())</span>
<span class="fc" id="L1802">					weights.put(entry.getKey(), WeightsImpl.IndexMutable.copyOf(entry.getValue(), idStrat));</span>
<span class="fc" id="L1803">			}</span>

			void addWeights(Object key, WeightsImpl.IndexMutable&lt;?&gt; weight) {
<span class="fc" id="L1806">				WeightsImpl.IndexMutable&lt;?&gt; oldContainer = weights.put(key, weight);</span>
<span class="pc bpc" id="L1807" title="1 of 2 branches missed.">				if (oldContainer != null)</span>
<span class="nc" id="L1808">					throw new IllegalArgumentException(&quot;Two weights types with the same key: &quot; + key);</span>
<span class="fc bfc" id="L1809" title="All 2 branches covered.">				if (weightsCapacity &gt; weight.capacity())</span>
<span class="fc" id="L1810">					weight.expand(weightsCapacity);</span>
<span class="fc" id="L1811">			}</span>

			void removeWeights(Object key) {
<span class="fc" id="L1814">				weights.remove(key);</span>
<span class="fc" id="L1815">			}</span>

			@SuppressWarnings(&quot;unchecked&quot;)
			&lt;E, WeightsT extends Weights&lt;E&gt;&gt; WeightsT getWeights(Object key) {
<span class="fc" id="L1819">				return (WeightsT) weights.get(key);</span>
			}

			Set&lt;Object&gt; weightsKeys() {
<span class="fc" id="L1823">				return Collections.unmodifiableSet(weights.keySet());</span>
			}

			void ensureCapacity(int capacity) {
<span class="fc bfc" id="L1827" title="All 2 branches covered.">				if (capacity &lt;= weightsCapacity)</span>
<span class="fc" id="L1828">					return;</span>
<span class="fc" id="L1829">				int newCapacity = Math.max(Math.max(2, 2 * weightsCapacity), capacity);</span>
<span class="fc bfc" id="L1830" title="All 2 branches covered.">				for (WeightsImpl.IndexMutable&lt;?&gt; container : weights.values())</span>
<span class="fc" id="L1831">					container.expand(newCapacity);</span>
<span class="fc" id="L1832">				weightsCapacity = newCapacity;</span>
<span class="fc" id="L1833">			}</span>

			void swapElements(int idx1, int idx2) {
<span class="fc bfc" id="L1836" title="All 2 branches covered.">				for (WeightsImpl.IndexMutable&lt;?&gt; container : weights.values())</span>
<span class="fc" id="L1837">					container.swap(idx1, idx2);</span>
<span class="fc" id="L1838">			}</span>

			void clearElement(int idx) {
<span class="fc bfc" id="L1841" title="All 2 branches covered.">				for (WeightsImpl.IndexMutable&lt;?&gt; container : weights.values())</span>
<span class="fc" id="L1842">					container.clear(idx);</span>
<span class="fc" id="L1843">			}</span>

			void clearContainers() {
<span class="fc bfc" id="L1846" title="All 2 branches covered.">				for (WeightsImpl.IndexMutable&lt;?&gt; container : weights.values())</span>
<span class="fc" id="L1847">					container.clear();</span>
<span class="fc" id="L1848">			}</span>
		}
	}

	static abstract class Mapped&lt;E&gt; implements WeightsImpl&lt;E&gt; {

		final WeightsImpl.Index.Abstract&lt;E&gt; weights;
		final IndexIdMap indexMap;

<span class="fc" id="L1857">		private Mapped(WeightsImpl.Index&lt;E&gt; weights, IndexIdMap indexMap) {</span>
<span class="fc" id="L1858">			this.weights = (WeightsImpl.Index.Abstract&lt;E&gt;) Objects.requireNonNull(weights);</span>
<span class="fc" id="L1859">			this.indexMap = indexMap;</span>
<span class="fc" id="L1860">		}</span>

		WeightsImpl.Index.Abstract&lt;E&gt; weights() {
<span class="fc" id="L1863">			return weights;</span>
		}

		static WeightsImpl.Mapped&lt;?&gt; newInstance(WeightsImpl.Index&lt;?&gt; weights, IndexIdMap indexMap) {
<span class="fc bfc" id="L1867" title="All 2 branches covered.">			if (weights instanceof WeightsImpl.Index.Byte) {</span>
<span class="fc" id="L1868">				return new WeightsImpl.Mapped.Byte((WeightsImpl.Index.Byte) weights, indexMap);</span>
<span class="fc bfc" id="L1869" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Short) {</span>
<span class="fc" id="L1870">				return new WeightsImpl.Mapped.Short((WeightsImpl.Index.Short) weights, indexMap);</span>
<span class="fc bfc" id="L1871" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Int) {</span>
<span class="fc" id="L1872">				return new WeightsImpl.Mapped.Int((WeightsImpl.Index.Int) weights, indexMap);</span>
<span class="fc bfc" id="L1873" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Long) {</span>
<span class="fc" id="L1874">				return new WeightsImpl.Mapped.Long((WeightsImpl.Index.Long) weights, indexMap);</span>
<span class="fc bfc" id="L1875" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Float) {</span>
<span class="fc" id="L1876">				return new WeightsImpl.Mapped.Float((WeightsImpl.Index.Float) weights, indexMap);</span>
<span class="fc bfc" id="L1877" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Double) {</span>
<span class="fc" id="L1878">				return new WeightsImpl.Mapped.Double((WeightsImpl.Index.Double) weights, indexMap);</span>
<span class="fc bfc" id="L1879" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Bool) {</span>
<span class="fc" id="L1880">				return new WeightsImpl.Mapped.Bool((WeightsImpl.Index.Bool) weights, indexMap);</span>
<span class="fc bfc" id="L1881" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Char) {</span>
<span class="fc" id="L1882">				return new WeightsImpl.Mapped.Char((WeightsImpl.Index.Char) weights, indexMap);</span>
			} else {
<span class="fc" id="L1884">				return new WeightsImpl.Mapped.Obj&lt;&gt;(weights, indexMap);</span>
			}
		}

		static class Obj&lt;E&gt; extends Mapped&lt;E&gt; {
			Obj(WeightsImpl.Index&lt;E&gt; weights, IndexIdMap indexMap) {
<span class="fc" id="L1890">				super(weights, indexMap);</span>
<span class="fc" id="L1891">			}</span>

			@Override
			public WeightsImpl.Index.Obj&lt;E&gt; weights() {
<span class="fc" id="L1895">				return (WeightsImpl.Index.Obj&lt;E&gt;) super.weights();</span>
			}

			@Override
			public E get(int id) {
<span class="fc" id="L1900">				return weights().get(indexMap.idToIndex(id));</span>
			}

			@Override
			public void set(int id, E val) {
<span class="fc" id="L1905">				weights().set(indexMap.idToIndex(id), val);</span>
<span class="fc" id="L1906">			}</span>

			@Override
			public E defaultWeight() {
<span class="fc" id="L1910">				return weights().defaultWeight();</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="nc bnc" id="L1915" title="All 2 branches missed.">				if (other == this)</span>
<span class="nc" id="L1916">					return true;</span>
<span class="nc bnc" id="L1917" title="All 2 branches missed.">				if (!(other instanceof WeightsImpl.Mapped&lt;?&gt;))</span>
<span class="nc" id="L1918">					return false;</span>
<span class="nc" id="L1919">				WeightsImpl.Mapped&lt;?&gt; o = (WeightsImpl.Mapped&lt;?&gt;) other;</span>

<span class="nc" id="L1921">				WeightsImpl.Index.Obj&lt;E&gt; w = weights();</span>
<span class="nc" id="L1922">				int size = w.size();</span>
<span class="nc bnc" id="L1923" title="All 2 branches missed.">				if (size != o.weights().size())</span>
<span class="nc" id="L1924">					return false;</span>
				try {
<span class="nc bnc" id="L1926" title="All 2 branches missed.">					for (int idx = 0; idx &lt; size; idx++)</span>
<span class="nc bnc" id="L1927" title="All 2 branches missed.">						if (!Objects.equals(w.get(idx), o.get(indexMap.indexToId(idx))))</span>
<span class="nc" id="L1928">							return false;</span>
<span class="nc" id="L1929">				} catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L1930">					return false;</span>
<span class="nc" id="L1931">				}</span>
<span class="nc" id="L1932">				return true;</span>
			}

			@Override
			public int hashCode() {
<span class="nc" id="L1937">				int h = 0;</span>
<span class="nc" id="L1938">				WeightsImpl.Index.Obj&lt;E&gt; w = weights();</span>
<span class="nc" id="L1939">				int size = w.size();</span>
<span class="nc bnc" id="L1940" title="All 2 branches missed.">				for (int idx = 0; idx &lt; size; idx++)</span>
					/* we must use addition, order shouldn't matter */
<span class="nc" id="L1942">					h += Objects.hashCode(w.get(idx));</span>
<span class="nc" id="L1943">				return h;</span>
			}

			@Override
			public String toString() {
<span class="nc" id="L1948">				WeightsImpl.Index.Obj&lt;E&gt; w = weights();</span>
<span class="nc" id="L1949">				int size = w.size();</span>
<span class="nc bnc" id="L1950" title="All 2 branches missed.">				if (size == 0)</span>
<span class="nc" id="L1951">					return &quot;[]&quot;;</span>
<span class="nc" id="L1952">				StringBuilder s = new StringBuilder().append('[');</span>
<span class="nc" id="L1953">				for (int idx = 0;; idx++) {</span>
<span class="nc" id="L1954">					int id = indexMap.indexToId(idx);</span>
<span class="nc" id="L1955">					s.append(id).append('=').append(w.get(idx));</span>
<span class="nc bnc" id="L1956" title="All 2 branches missed.">					if (idx == size - 1)</span>
<span class="nc" id="L1957">						break;</span>
<span class="nc" id="L1958">					s.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L1960">				return s.append(']').toString();</span>
			}
		}

		static class Byte extends Mapped&lt;java.lang.Byte&gt; implements Weights.Byte {
			Byte(WeightsImpl.Index.Byte weights, IndexIdMap indexMap) {
<span class="fc" id="L1966">				super(weights, indexMap);</span>
<span class="fc" id="L1967">			}</span>

			@Override
			public WeightsImpl.Index.Byte weights() {
<span class="fc" id="L1971">				return (WeightsImpl.Index.Byte) super.weights();</span>
			}

			@Override
			public byte getByte(int id) {
<span class="fc" id="L1976">				return weights().getByte(indexMap.idToIndex(id));</span>
			}

			@Override
			public void set(int id, byte weight) {
<span class="fc" id="L1981">				weights().set(indexMap.idToIndex(id), weight);</span>
<span class="fc" id="L1982">			}</span>

			@Override
			public byte defaultWeightByte() {
<span class="fc" id="L1986">				return weights().defaultWeightByte();</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="nc bnc" id="L1991" title="All 2 branches missed.">				if (other == this)</span>
<span class="nc" id="L1992">					return true;</span>
<span class="nc bnc" id="L1993" title="All 2 branches missed.">				if (!(other instanceof WeightsImpl.Mapped.Byte))</span>
<span class="nc" id="L1994">					return false;</span>
<span class="nc" id="L1995">				WeightsImpl.Mapped.Byte o = (WeightsImpl.Mapped.Byte) other;</span>

<span class="nc" id="L1997">				WeightsImpl.Index.Byte w = weights();</span>
<span class="nc" id="L1998">				int size = w.size();</span>
<span class="nc bnc" id="L1999" title="All 2 branches missed.">				if (size != o.weights().size())</span>
<span class="nc" id="L2000">					return false;</span>
				try {
<span class="nc bnc" id="L2002" title="All 2 branches missed.">					for (int idx = 0; idx &lt; size; idx++)</span>
<span class="nc bnc" id="L2003" title="All 2 branches missed.">						if (w.getByte(idx) != o.getByte(indexMap.indexToId(idx)))</span>
<span class="nc" id="L2004">							return false;</span>
<span class="nc" id="L2005">				} catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L2006">					return false;</span>
<span class="nc" id="L2007">				}</span>
<span class="nc" id="L2008">				return true;</span>
			}

			@Override
			public int hashCode() {
<span class="nc" id="L2013">				int h = 0;</span>
<span class="nc" id="L2014">				WeightsImpl.Index.Byte w = weights();</span>
<span class="nc" id="L2015">				int size = w.size();</span>
<span class="nc bnc" id="L2016" title="All 2 branches missed.">				for (int idx = 0; idx &lt; size; idx++)</span>
					/* we must use addition, order shouldn't matter */
<span class="nc" id="L2018">					h += w.getByte(idx);</span>
<span class="nc" id="L2019">				return h;</span>
			}

			@Override
			public String toString() {
<span class="nc" id="L2024">				WeightsImpl.Index.Byte w = weights();</span>
<span class="nc" id="L2025">				int size = w.size();</span>
<span class="nc bnc" id="L2026" title="All 2 branches missed.">				if (size == 0)</span>
<span class="nc" id="L2027">					return &quot;[]&quot;;</span>
<span class="nc" id="L2028">				StringBuilder s = new StringBuilder().append('[');</span>
<span class="nc" id="L2029">				for (int idx = 0;; idx++) {</span>
<span class="nc" id="L2030">					int id = indexMap.indexToId(idx);</span>
<span class="nc" id="L2031">					s.append(id).append('=').append(w.getByte(idx));</span>
<span class="nc bnc" id="L2032" title="All 2 branches missed.">					if (idx == size - 1)</span>
<span class="nc" id="L2033">						break;</span>
<span class="nc" id="L2034">					s.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L2036">				return s.append(']').toString();</span>
			}
		}

		static class Short extends Mapped&lt;java.lang.Short&gt; implements Weights.Short {
			Short(WeightsImpl.Index.Short container, IndexIdMap indexMap) {
<span class="fc" id="L2042">				super(container, indexMap);</span>
<span class="fc" id="L2043">			}</span>

			@Override
			public WeightsImpl.Index.Short weights() {
<span class="fc" id="L2047">				return (WeightsImpl.Index.Short) super.weights();</span>
			}

			@Override
			public short getShort(int id) {
<span class="fc" id="L2052">				return weights().getShort(indexMap.idToIndex(id));</span>
			}

			@Override
			public void set(int id, short weight) {
<span class="fc" id="L2057">				weights().set(indexMap.idToIndex(id), weight);</span>
<span class="fc" id="L2058">			}</span>

			@Override
			public short defaultWeightShort() {
<span class="fc" id="L2062">				return weights().defaultWeightShort();</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="nc bnc" id="L2067" title="All 2 branches missed.">				if (other == this)</span>
<span class="nc" id="L2068">					return true;</span>
<span class="nc bnc" id="L2069" title="All 2 branches missed.">				if (!(other instanceof WeightsImpl.Mapped.Short))</span>
<span class="nc" id="L2070">					return false;</span>
<span class="nc" id="L2071">				WeightsImpl.Mapped.Short o = (WeightsImpl.Mapped.Short) other;</span>

<span class="nc" id="L2073">				WeightsImpl.Index.Short w = weights();</span>
<span class="nc" id="L2074">				int size = w.size();</span>
<span class="nc bnc" id="L2075" title="All 2 branches missed.">				if (size != o.weights().size())</span>
<span class="nc" id="L2076">					return false;</span>
				try {
<span class="nc bnc" id="L2078" title="All 2 branches missed.">					for (int idx = 0; idx &lt; size; idx++)</span>
<span class="nc bnc" id="L2079" title="All 2 branches missed.">						if (w.getShort(idx) != o.getShort(indexMap.indexToId(idx)))</span>
<span class="nc" id="L2080">							return false;</span>
<span class="nc" id="L2081">				} catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L2082">					return false;</span>
<span class="nc" id="L2083">				}</span>
<span class="nc" id="L2084">				return true;</span>
			}

			@Override
			public int hashCode() {
<span class="nc" id="L2089">				int h = 0;</span>
<span class="nc" id="L2090">				WeightsImpl.Index.Short w = weights();</span>
<span class="nc" id="L2091">				int size = w.size();</span>
<span class="nc bnc" id="L2092" title="All 2 branches missed.">				for (int idx = 0; idx &lt; size; idx++)</span>
					/* we must use addition, order shouldn't matter */
<span class="nc" id="L2094">					h += w.getShort(idx);</span>
<span class="nc" id="L2095">				return h;</span>
			}

			@Override
			public String toString() {
<span class="nc" id="L2100">				WeightsImpl.Index.Short w = weights();</span>
<span class="nc" id="L2101">				int size = w.size();</span>
<span class="nc bnc" id="L2102" title="All 2 branches missed.">				if (size == 0)</span>
<span class="nc" id="L2103">					return &quot;[]&quot;;</span>
<span class="nc" id="L2104">				StringBuilder s = new StringBuilder().append('[');</span>
<span class="nc" id="L2105">				for (int idx = 0;; idx++) {</span>
<span class="nc" id="L2106">					int id = indexMap.indexToId(idx);</span>
<span class="nc" id="L2107">					s.append(id).append('=').append(w.getShort(idx));</span>
<span class="nc bnc" id="L2108" title="All 2 branches missed.">					if (idx == size - 1)</span>
<span class="nc" id="L2109">						break;</span>
<span class="nc" id="L2110">					s.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L2112">				return s.append(']').toString();</span>
			}
		}

		static class Int extends Mapped&lt;Integer&gt; implements Weights.Int {
			Int(WeightsImpl.Index.Int container, IndexIdMap indexMap) {
<span class="fc" id="L2118">				super(container, indexMap);</span>
<span class="fc" id="L2119">			}</span>

			@Override
			public WeightsImpl.Index.Int weights() {
<span class="fc" id="L2123">				return (WeightsImpl.Index.Int) super.weights();</span>
			}

			@Override
			public int getInt(int id) {
<span class="fc" id="L2128">				return weights().getInt(indexMap.idToIndex(id));</span>
			}

			@Override
			public void set(int id, int weight) {
<span class="fc" id="L2133">				weights().set(indexMap.idToIndex(id), weight);</span>
<span class="fc" id="L2134">			}</span>

			@Override
			public int defaultWeightInt() {
<span class="fc" id="L2138">				return weights().defaultWeightInt();</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="nc bnc" id="L2143" title="All 2 branches missed.">				if (other == this)</span>
<span class="nc" id="L2144">					return true;</span>
<span class="nc bnc" id="L2145" title="All 2 branches missed.">				if (!(other instanceof WeightsImpl.Mapped.Int))</span>
<span class="nc" id="L2146">					return false;</span>
<span class="nc" id="L2147">				WeightsImpl.Mapped.Int o = (WeightsImpl.Mapped.Int) other;</span>

<span class="nc" id="L2149">				WeightsImpl.Index.Int w = weights();</span>
<span class="nc" id="L2150">				int size = w.size();</span>
<span class="nc bnc" id="L2151" title="All 2 branches missed.">				if (size != o.weights().size())</span>
<span class="nc" id="L2152">					return false;</span>
				try {
<span class="nc bnc" id="L2154" title="All 2 branches missed.">					for (int idx = 0; idx &lt; size; idx++)</span>
<span class="nc bnc" id="L2155" title="All 2 branches missed.">						if (w.getInt(idx) != o.getInt(indexMap.indexToId(idx)))</span>
<span class="nc" id="L2156">							return false;</span>
<span class="nc" id="L2157">				} catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L2158">					return false;</span>
<span class="nc" id="L2159">				}</span>
<span class="nc" id="L2160">				return true;</span>
			}

			@Override
			public int hashCode() {
<span class="nc" id="L2165">				int h = 0;</span>
<span class="nc" id="L2166">				WeightsImpl.Index.Int w = weights();</span>
<span class="nc" id="L2167">				int size = w.size();</span>
<span class="nc bnc" id="L2168" title="All 2 branches missed.">				for (int idx = 0; idx &lt; size; idx++)</span>
					/* we must use addition, order shouldn't matter */
<span class="nc" id="L2170">					h += w.getInt(idx);</span>
<span class="nc" id="L2171">				return h;</span>
			}

			@Override
			public String toString() {
<span class="nc" id="L2176">				WeightsImpl.Index.Int w = weights();</span>
<span class="nc" id="L2177">				int size = w.size();</span>
<span class="nc bnc" id="L2178" title="All 2 branches missed.">				if (size == 0)</span>
<span class="nc" id="L2179">					return &quot;[]&quot;;</span>
<span class="nc" id="L2180">				StringBuilder s = new StringBuilder().append('[');</span>
<span class="nc" id="L2181">				for (int idx = 0;; idx++) {</span>
<span class="nc" id="L2182">					int id = indexMap.indexToId(idx);</span>
<span class="nc" id="L2183">					s.append(id).append('=').append(w.getInt(idx));</span>
<span class="nc bnc" id="L2184" title="All 2 branches missed.">					if (idx == size - 1)</span>
<span class="nc" id="L2185">						break;</span>
<span class="nc" id="L2186">					s.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L2188">				return s.append(']').toString();</span>
			}
		}

		static class Long extends Mapped&lt;java.lang.Long&gt; implements Weights.Long {
			Long(WeightsImpl.Index.Long container, IndexIdMap indexMap) {
<span class="fc" id="L2194">				super(container, indexMap);</span>
<span class="fc" id="L2195">			}</span>

			@Override
			public WeightsImpl.Index.Long weights() {
<span class="fc" id="L2199">				return (WeightsImpl.Index.Long) super.weights();</span>
			}

			@Override
			public long getLong(int id) {
<span class="fc" id="L2204">				return weights().getLong(indexMap.idToIndex(id));</span>
			}

			@Override
			public void set(int id, long weight) {
<span class="fc" id="L2209">				weights().set(indexMap.idToIndex(id), weight);</span>
<span class="fc" id="L2210">			}</span>

			@Override
			public long defaultWeightLong() {
<span class="fc" id="L2214">				return weights().defaultWeightLong();</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="nc bnc" id="L2219" title="All 2 branches missed.">				if (other == this)</span>
<span class="nc" id="L2220">					return true;</span>
<span class="nc bnc" id="L2221" title="All 2 branches missed.">				if (!(other instanceof WeightsImpl.Mapped.Long))</span>
<span class="nc" id="L2222">					return false;</span>
<span class="nc" id="L2223">				WeightsImpl.Mapped.Long o = (WeightsImpl.Mapped.Long) other;</span>

<span class="nc" id="L2225">				WeightsImpl.Index.Long w = weights();</span>
<span class="nc" id="L2226">				int size = w.size();</span>
<span class="nc bnc" id="L2227" title="All 2 branches missed.">				if (size != o.weights().size())</span>
<span class="nc" id="L2228">					return false;</span>
				try {
<span class="nc bnc" id="L2230" title="All 2 branches missed.">					for (int idx = 0; idx &lt; size; idx++)</span>
<span class="nc bnc" id="L2231" title="All 2 branches missed.">						if (w.getLong(idx) != o.getLong(indexMap.indexToId(idx)))</span>
<span class="nc" id="L2232">							return false;</span>
<span class="nc" id="L2233">				} catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L2234">					return false;</span>
<span class="nc" id="L2235">				}</span>
<span class="nc" id="L2236">				return true;</span>
			}

			@Override
			public int hashCode() {
<span class="nc" id="L2241">				int h = 0;</span>
<span class="nc" id="L2242">				WeightsImpl.Index.Long w = weights();</span>
<span class="nc" id="L2243">				int size = w.size();</span>
<span class="nc bnc" id="L2244" title="All 2 branches missed.">				for (int idx = 0; idx &lt; size; idx++)</span>
					/* we must use addition, order shouldn't matter */
<span class="nc" id="L2246">					h += java.lang.Long.hashCode(w.getLong(idx));</span>
<span class="nc" id="L2247">				return h;</span>
			}

			@Override
			public String toString() {
<span class="nc" id="L2252">				WeightsImpl.Index.Long w = weights();</span>
<span class="nc" id="L2253">				int size = w.size();</span>
<span class="nc bnc" id="L2254" title="All 2 branches missed.">				if (size == 0)</span>
<span class="nc" id="L2255">					return &quot;[]&quot;;</span>
<span class="nc" id="L2256">				StringBuilder s = new StringBuilder().append('[');</span>
<span class="nc" id="L2257">				for (int idx = 0;; idx++) {</span>
<span class="nc" id="L2258">					int id = indexMap.indexToId(idx);</span>
<span class="nc" id="L2259">					s.append(id).append('=').append(w.getLong(idx));</span>
<span class="nc bnc" id="L2260" title="All 2 branches missed.">					if (idx == size - 1)</span>
<span class="nc" id="L2261">						break;</span>
<span class="nc" id="L2262">					s.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L2264">				return s.append(']').toString();</span>
			}
		}

		static class Float extends Mapped&lt;java.lang.Float&gt; implements Weights.Float {
			Float(WeightsImpl.Index.Float container, IndexIdMap indexMap) {
<span class="fc" id="L2270">				super(container, indexMap);</span>
<span class="fc" id="L2271">			}</span>

			@Override
			public WeightsImpl.Index.Float weights() {
<span class="fc" id="L2275">				return (WeightsImpl.Index.Float) super.weights();</span>
			}

			@Override
			public float getFloat(int id) {
<span class="fc" id="L2280">				return weights().getFloat(indexMap.idToIndex(id));</span>
			}

			@Override
			public void set(int id, float weight) {
<span class="fc" id="L2285">				weights().set(indexMap.idToIndex(id), weight);</span>
<span class="fc" id="L2286">			}</span>

			@Override
			public float defaultWeightFloat() {
<span class="fc" id="L2290">				return weights().defaultWeightFloat();</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="nc bnc" id="L2295" title="All 2 branches missed.">				if (other == this)</span>
<span class="nc" id="L2296">					return true;</span>
<span class="nc bnc" id="L2297" title="All 2 branches missed.">				if (!(other instanceof WeightsImpl.Mapped.Float))</span>
<span class="nc" id="L2298">					return false;</span>
<span class="nc" id="L2299">				WeightsImpl.Mapped.Float o = (WeightsImpl.Mapped.Float) other;</span>

<span class="nc" id="L2301">				WeightsImpl.Index.Float w = weights();</span>
<span class="nc" id="L2302">				int size = w.size();</span>
<span class="nc bnc" id="L2303" title="All 2 branches missed.">				if (size != o.weights().size())</span>
<span class="nc" id="L2304">					return false;</span>
				try {
<span class="nc bnc" id="L2306" title="All 2 branches missed.">					for (int idx = 0; idx &lt; size; idx++)</span>
<span class="nc bnc" id="L2307" title="All 2 branches missed.">						if (w.getFloat(idx) != o.getFloat(indexMap.indexToId(idx)))</span>
<span class="nc" id="L2308">							return false;</span>
<span class="nc" id="L2309">				} catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L2310">					return false;</span>
<span class="nc" id="L2311">				}</span>
<span class="nc" id="L2312">				return true;</span>
			}

			@Override
			public int hashCode() {
<span class="nc" id="L2317">				int h = 0;</span>
<span class="nc" id="L2318">				WeightsImpl.Index.Float w = weights();</span>
<span class="nc" id="L2319">				int size = w.size();</span>
<span class="nc bnc" id="L2320" title="All 2 branches missed.">				for (int idx = 0; idx &lt; size; idx++)</span>
					/* we must use addition, order shouldn't matter */
<span class="nc" id="L2322">					h += java.lang.Float.hashCode(w.getFloat(idx));</span>
<span class="nc" id="L2323">				return h;</span>
			}

			@Override
			public String toString() {
<span class="nc" id="L2328">				WeightsImpl.Index.Float w = weights();</span>
<span class="nc" id="L2329">				int size = w.size();</span>
<span class="nc bnc" id="L2330" title="All 2 branches missed.">				if (size == 0)</span>
<span class="nc" id="L2331">					return &quot;[]&quot;;</span>
<span class="nc" id="L2332">				StringBuilder s = new StringBuilder().append('[');</span>
<span class="nc" id="L2333">				for (int idx = 0;; idx++) {</span>
<span class="nc" id="L2334">					int id = indexMap.indexToId(idx);</span>
<span class="nc" id="L2335">					s.append(id).append('=').append(w.getFloat(idx));</span>
<span class="nc bnc" id="L2336" title="All 2 branches missed.">					if (idx == size - 1)</span>
<span class="nc" id="L2337">						break;</span>
<span class="nc" id="L2338">					s.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L2340">				return s.append(']').toString();</span>
			}
		}

		static class Double extends Mapped&lt;java.lang.Double&gt; implements Weights.Double {
			Double(WeightsImpl.Index.Double container, IndexIdMap indexMap) {
<span class="fc" id="L2346">				super(container, indexMap);</span>
<span class="fc" id="L2347">			}</span>

			@Override
			WeightsImpl.Index.Double weights() {
<span class="fc" id="L2351">				return (WeightsImpl.Index.Double) super.weights();</span>
			}

			@Override
			public double getDouble(int id) {
<span class="fc" id="L2356">				return weights().getDouble(indexMap.idToIndex(id));</span>
			}

			@Override
			public void set(int id, double weight) {
<span class="fc" id="L2361">				weights().set(indexMap.idToIndex(id), weight);</span>
<span class="fc" id="L2362">			}</span>

			@Override
			public double defaultWeightDouble() {
<span class="fc" id="L2366">				return weights().defaultWeightDouble();</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="nc bnc" id="L2371" title="All 2 branches missed.">				if (other == this)</span>
<span class="nc" id="L2372">					return true;</span>
<span class="nc bnc" id="L2373" title="All 2 branches missed.">				if (!(other instanceof WeightsImpl.Mapped.Double))</span>
<span class="nc" id="L2374">					return false;</span>
<span class="nc" id="L2375">				WeightsImpl.Mapped.Double o = (WeightsImpl.Mapped.Double) other;</span>

<span class="nc" id="L2377">				WeightsImpl.Index.Double w = weights();</span>
<span class="nc" id="L2378">				int size = w.size();</span>
<span class="nc bnc" id="L2379" title="All 2 branches missed.">				if (size != o.weights().size())</span>
<span class="nc" id="L2380">					return false;</span>
				try {
<span class="nc bnc" id="L2382" title="All 2 branches missed.">					for (int idx = 0; idx &lt; size; idx++)</span>
<span class="nc bnc" id="L2383" title="All 2 branches missed.">						if (w.getDouble(idx) != o.getDouble(indexMap.indexToId(idx)))</span>
<span class="nc" id="L2384">							return false;</span>
<span class="nc" id="L2385">				} catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L2386">					return false;</span>
<span class="nc" id="L2387">				}</span>
<span class="nc" id="L2388">				return true;</span>
			}

			@Override
			public int hashCode() {
<span class="nc" id="L2393">				int h = 0;</span>
<span class="nc" id="L2394">				WeightsImpl.Index.Double w = weights();</span>
<span class="nc" id="L2395">				int size = w.size();</span>
<span class="nc bnc" id="L2396" title="All 2 branches missed.">				for (int idx = 0; idx &lt; size; idx++)</span>
					/* we must use addition, order shouldn't matter */
<span class="nc" id="L2398">					h += java.lang.Double.hashCode(w.getDouble(idx));</span>
<span class="nc" id="L2399">				return h;</span>
			}

			@Override
			public String toString() {
<span class="nc" id="L2404">				WeightsImpl.Index.Double w = weights();</span>
<span class="nc" id="L2405">				int size = w.size();</span>
<span class="nc bnc" id="L2406" title="All 2 branches missed.">				if (size == 0)</span>
<span class="nc" id="L2407">					return &quot;[]&quot;;</span>
<span class="nc" id="L2408">				StringBuilder s = new StringBuilder().append('[');</span>
<span class="nc" id="L2409">				for (int idx = 0;; idx++) {</span>
<span class="nc" id="L2410">					int id = indexMap.indexToId(idx);</span>
<span class="nc" id="L2411">					s.append(id).append('=').append(w.getDouble(idx));</span>
<span class="nc bnc" id="L2412" title="All 2 branches missed.">					if (idx == size - 1)</span>
<span class="nc" id="L2413">						break;</span>
<span class="nc" id="L2414">					s.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L2416">				return s.append(']').toString();</span>
			}
		}

		static class Bool extends Mapped&lt;Boolean&gt; implements Weights.Bool {
			Bool(WeightsImpl.Index.Bool container, IndexIdMap indexMap) {
<span class="fc" id="L2422">				super(container, indexMap);</span>
<span class="fc" id="L2423">			}</span>

			@Override
			WeightsImpl.Index.Bool weights() {
<span class="fc" id="L2427">				return (WeightsImpl.Index.Bool) super.weights();</span>
			}

			@Override
			public boolean getBool(int id) {
<span class="fc" id="L2432">				return weights().getBool(indexMap.idToIndex(id));</span>
			}

			@Override
			public void set(int id, boolean weight) {
<span class="fc" id="L2437">				weights().set(indexMap.idToIndex(id), weight);</span>
<span class="fc" id="L2438">			}</span>

			@Override
			public boolean defaultWeightBool() {
<span class="fc" id="L2442">				return weights().defaultWeightBool();</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="nc bnc" id="L2447" title="All 2 branches missed.">				if (other == this)</span>
<span class="nc" id="L2448">					return true;</span>
<span class="nc bnc" id="L2449" title="All 2 branches missed.">				if (!(other instanceof WeightsImpl.Mapped.Bool))</span>
<span class="nc" id="L2450">					return false;</span>
<span class="nc" id="L2451">				WeightsImpl.Mapped.Bool o = (WeightsImpl.Mapped.Bool) other;</span>

<span class="nc" id="L2453">				WeightsImpl.Index.Bool w = weights();</span>
<span class="nc" id="L2454">				int size = w.size();</span>
<span class="nc bnc" id="L2455" title="All 2 branches missed.">				if (size != o.weights().size())</span>
<span class="nc" id="L2456">					return false;</span>
				try {
<span class="nc bnc" id="L2458" title="All 2 branches missed.">					for (int idx = 0; idx &lt; size; idx++)</span>
<span class="nc bnc" id="L2459" title="All 2 branches missed.">						if (w.getBool(idx) != o.getBool(indexMap.indexToId(idx)))</span>
<span class="nc" id="L2460">							return false;</span>
<span class="nc" id="L2461">				} catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L2462">					return false;</span>
<span class="nc" id="L2463">				}</span>
<span class="nc" id="L2464">				return true;</span>
			}

			@Override
			public int hashCode() {
<span class="nc" id="L2469">				int h = 0;</span>
<span class="nc" id="L2470">				WeightsImpl.Index.Bool w = weights();</span>
<span class="nc" id="L2471">				int size = w.size();</span>
<span class="nc bnc" id="L2472" title="All 2 branches missed.">				for (int idx = 0; idx &lt; size; idx++)</span>
					/* we must use addition, order shouldn't matter */
<span class="nc" id="L2474">					h += Boolean.hashCode(w.getBool(idx));</span>
<span class="nc" id="L2475">				return h;</span>
			}

			@Override
			public String toString() {
<span class="nc" id="L2480">				WeightsImpl.Index.Bool w = weights();</span>
<span class="nc" id="L2481">				int size = w.size();</span>
<span class="nc bnc" id="L2482" title="All 2 branches missed.">				if (size == 0)</span>
<span class="nc" id="L2483">					return &quot;[]&quot;;</span>
<span class="nc" id="L2484">				StringBuilder s = new StringBuilder().append('[');</span>
<span class="nc" id="L2485">				for (int idx = 0;; idx++) {</span>
<span class="nc" id="L2486">					int id = indexMap.indexToId(idx);</span>
<span class="nc" id="L2487">					s.append(id).append('=').append(w.getBool(idx));</span>
<span class="nc bnc" id="L2488" title="All 2 branches missed.">					if (idx == size - 1)</span>
<span class="nc" id="L2489">						break;</span>
<span class="nc" id="L2490">					s.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L2492">				return s.append(']').toString();</span>
			}
		}

		static class Char extends Mapped&lt;Character&gt; implements Weights.Char {
			Char(WeightsImpl.Index.Char container, IndexIdMap indexMap) {
<span class="fc" id="L2498">				super(container, indexMap);</span>
<span class="fc" id="L2499">			}</span>

			@Override
			WeightsImpl.Index.Char weights() {
<span class="fc" id="L2503">				return (WeightsImpl.Index.Char) super.weights();</span>
			}

			@Override
			public char getChar(int id) {
<span class="fc" id="L2508">				return weights().getChar(indexMap.idToIndex(id));</span>
			}

			@Override
			public void set(int id, char weight) {
<span class="fc" id="L2513">				weights().set(indexMap.idToIndex(id), weight);</span>
<span class="fc" id="L2514">			}</span>

			@Override
			public char defaultWeightChar() {
<span class="fc" id="L2518">				return weights().defaultWeightChar();</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="nc bnc" id="L2523" title="All 2 branches missed.">				if (other == this)</span>
<span class="nc" id="L2524">					return true;</span>
<span class="nc bnc" id="L2525" title="All 2 branches missed.">				if (!(other instanceof WeightsImpl.Mapped.Char))</span>
<span class="nc" id="L2526">					return false;</span>
<span class="nc" id="L2527">				WeightsImpl.Mapped.Char o = (WeightsImpl.Mapped.Char) other;</span>

<span class="nc" id="L2529">				WeightsImpl.Index.Char w = weights();</span>
<span class="nc" id="L2530">				int size = w.size();</span>
<span class="nc bnc" id="L2531" title="All 2 branches missed.">				if (size != o.weights().size())</span>
<span class="nc" id="L2532">					return false;</span>
				try {
<span class="nc bnc" id="L2534" title="All 2 branches missed.">					for (int idx = 0; idx &lt; size; idx++)</span>
<span class="nc bnc" id="L2535" title="All 2 branches missed.">						if (w.getChar(idx) != o.getChar(indexMap.indexToId(idx)))</span>
<span class="nc" id="L2536">							return false;</span>
<span class="nc" id="L2537">				} catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L2538">					return false;</span>
<span class="nc" id="L2539">				}</span>
<span class="nc" id="L2540">				return true;</span>
			}

			@Override
			public int hashCode() {
<span class="nc" id="L2545">				int h = 0;</span>
<span class="nc" id="L2546">				WeightsImpl.Index.Char w = weights();</span>
<span class="nc" id="L2547">				int size = w.size();</span>
<span class="nc bnc" id="L2548" title="All 2 branches missed.">				for (int idx = 0; idx &lt; size; idx++)</span>
					/* we must use addition, order shouldn't matter */
<span class="nc" id="L2550">					h += w.getChar(idx);</span>
<span class="nc" id="L2551">				return h;</span>
			}

			@Override
			public String toString() {
<span class="nc" id="L2556">				WeightsImpl.Index.Char w = weights();</span>
<span class="nc" id="L2557">				int size = w.size();</span>
<span class="nc bnc" id="L2558" title="All 2 branches missed.">				if (size == 0)</span>
<span class="nc" id="L2559">					return &quot;[]&quot;;</span>
<span class="nc" id="L2560">				StringBuilder s = new StringBuilder().append('[');</span>
<span class="nc" id="L2561">				for (int idx = 0;; idx++) {</span>
<span class="nc" id="L2562">					int id = indexMap.indexToId(idx);</span>
<span class="nc" id="L2563">					s.append(id).append('=').append(w.getChar(idx));</span>
<span class="nc bnc" id="L2564" title="All 2 branches missed.">					if (idx == size - 1)</span>
<span class="nc" id="L2565">						break;</span>
<span class="nc" id="L2566">					s.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L2568">				return s.append(']').toString();</span>
			}
		}
	}

	/**
	 * Tag interface for graphs that can not be muted/changed/altered
	 *
	 * @author Barak Ugav
	 */
	static interface Immutable&lt;E&gt; extends WeightsImpl&lt;E&gt; {
	}

	static abstract class ImmutableView&lt;E&gt; implements Immutable&lt;E&gt; {

		final WeightsImpl&lt;E&gt; weights;

<span class="fc" id="L2585">		ImmutableView(Weights&lt;E&gt; w) {</span>
<span class="fc" id="L2586">			this.weights = (WeightsImpl&lt;E&gt;) Objects.requireNonNull(w);</span>
<span class="fc" id="L2587">		}</span>

		Weights&lt;E&gt; weights() {
<span class="fc" id="L2590">			return weights;</span>
		}

		static class Obj&lt;E&gt; extends ImmutableView&lt;E&gt; {

			Obj(Weights&lt;E&gt; w) {
<span class="fc" id="L2596">				super(w);</span>
<span class="fc" id="L2597">			}</span>

			@Override
			public E get(int id) {
<span class="fc" id="L2601">				return weights().get(id);</span>
			}

			@Override
			public void set(int id, E weight) {
<span class="fc" id="L2606">				throw new UnsupportedOperationException();</span>
			}

			@Override
			public E defaultWeight() {
<span class="fc" id="L2611">				return weights().defaultWeight();</span>
			}
		}

		static class Byte extends ImmutableView&lt;java.lang.Byte&gt; implements Weights.Byte {
			Byte(Weights.Byte w) {
<span class="fc" id="L2617">				super(w);</span>
<span class="fc" id="L2618">			}</span>

			@Override
			Weights.Byte weights() {
<span class="fc" id="L2622">				return (Weights.Byte) super.weights();</span>
			}

			@Override
			public byte getByte(int id) {
<span class="fc" id="L2627">				return weights().getByte(id);</span>
			}

			@Override
			public void set(int id, byte weight) {
<span class="fc" id="L2632">				throw new UnsupportedOperationException();</span>
			}

			@Override
			public byte defaultWeightByte() {
<span class="fc" id="L2637">				return weights().defaultWeightByte();</span>
			}
		}

		static class Short extends ImmutableView&lt;java.lang.Short&gt; implements Weights.Short {
			Short(Weights.Short w) {
<span class="fc" id="L2643">				super(w);</span>
<span class="fc" id="L2644">			}</span>

			@Override
			Weights.Short weights() {
<span class="fc" id="L2648">				return (Weights.Short) super.weights();</span>
			}

			@Override
			public short getShort(int id) {
<span class="fc" id="L2653">				return weights().getShort(id);</span>
			}

			@Override
			public void set(int id, short weight) {
<span class="fc" id="L2658">				throw new UnsupportedOperationException();</span>
			}

			@Override
			public short defaultWeightShort() {
<span class="fc" id="L2663">				return weights().defaultWeightShort();</span>
			}
		}

		static class Int extends ImmutableView&lt;Integer&gt; implements Weights.Int {
			Int(Weights.Int w) {
<span class="fc" id="L2669">				super(w);</span>
<span class="fc" id="L2670">			}</span>

			@Override
			Weights.Int weights() {
<span class="fc" id="L2674">				return (Weights.Int) super.weights();</span>
			}

			@Override
			public int getInt(int id) {
<span class="fc" id="L2679">				return weights().getInt(id);</span>
			}

			@Override
			public void set(int id, int weight) {
<span class="fc" id="L2684">				throw new UnsupportedOperationException();</span>
			}

			@Override
			public int defaultWeightInt() {
<span class="fc" id="L2689">				return weights().defaultWeightInt();</span>
			}
		}

		static class Long extends ImmutableView&lt;java.lang.Long&gt; implements Weights.Long {
			Long(Weights.Long w) {
<span class="fc" id="L2695">				super(w);</span>
<span class="fc" id="L2696">			}</span>

			@Override
			Weights.Long weights() {
<span class="fc" id="L2700">				return (Weights.Long) super.weights();</span>
			}

			@Override
			public long getLong(int id) {
<span class="fc" id="L2705">				return weights().getLong(id);</span>
			}

			@Override
			public void set(int id, long weight) {
<span class="fc" id="L2710">				throw new UnsupportedOperationException();</span>
			}

			@Override
			public long defaultWeightLong() {
<span class="fc" id="L2715">				return weights().defaultWeightLong();</span>
			}
		}

		static class Float extends ImmutableView&lt;java.lang.Float&gt; implements Weights.Float {
			Float(Weights.Float w) {
<span class="fc" id="L2721">				super(w);</span>
<span class="fc" id="L2722">			}</span>

			@Override
			Weights.Float weights() {
<span class="fc" id="L2726">				return (Weights.Float) super.weights();</span>
			}

			@Override
			public float getFloat(int id) {
<span class="fc" id="L2731">				return weights().getFloat(id);</span>
			}

			@Override
			public void set(int id, float weight) {
<span class="fc" id="L2736">				throw new UnsupportedOperationException();</span>
			}

			@Override
			public float defaultWeightFloat() {
<span class="fc" id="L2741">				return weights().defaultWeightFloat();</span>
			}
		}

		static class Double extends ImmutableView&lt;java.lang.Double&gt; implements Weights.Double {
			Double(Weights.Double w) {
<span class="fc" id="L2747">				super(w);</span>
<span class="fc" id="L2748">			}</span>

			@Override
			Weights.Double weights() {
<span class="fc" id="L2752">				return (Weights.Double) super.weights();</span>
			}

			@Override
			public double getDouble(int id) {
<span class="fc" id="L2757">				return weights().getDouble(id);</span>
			}

			@Override
			public void set(int id, double weight) {
<span class="fc" id="L2762">				throw new UnsupportedOperationException();</span>
			}

			@Override
			public double defaultWeightDouble() {
<span class="fc" id="L2767">				return weights().defaultWeightDouble();</span>
			}
		}

		static class Bool extends ImmutableView&lt;Boolean&gt; implements Weights.Bool {
			Bool(Weights.Bool w) {
<span class="fc" id="L2773">				super(w);</span>
<span class="fc" id="L2774">			}</span>

			@Override
			Weights.Bool weights() {
<span class="fc" id="L2778">				return (Weights.Bool) super.weights();</span>
			}

			@Override
			public boolean getBool(int id) {
<span class="fc" id="L2783">				return weights().getBool(id);</span>
			}

			@Override
			public void set(int id, boolean weight) {
<span class="fc" id="L2788">				throw new UnsupportedOperationException();</span>
			}

			@Override
			public boolean defaultWeightBool() {
<span class="fc" id="L2793">				return weights().defaultWeightBool();</span>
			}
		}

		static class Char extends ImmutableView&lt;Character&gt; implements Weights.Char {
			Char(Weights.Char w) {
<span class="fc" id="L2799">				super(w);</span>
<span class="fc" id="L2800">			}</span>

			@Override
			Weights.Char weights() {
<span class="fc" id="L2804">				return (Weights.Char) super.weights();</span>
			}

			@Override
			public char getChar(int id) {
<span class="fc" id="L2809">				return weights().getChar(id);</span>
			}

			@Override
			public void set(int id, char weight) {
<span class="fc" id="L2814">				throw new UnsupportedOperationException();</span>
			}

			@Override
			public char defaultWeightChar() {
<span class="fc" id="L2819">				return weights().defaultWeightChar();</span>
			}
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>