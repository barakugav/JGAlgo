<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WeightsImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.graph</a> &gt; <span class="el_source">WeightsImpl.java</span></div><h1>WeightsImpl.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jgalgo.graph;

import java.util.Arrays;
import java.util.BitSet;
import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import it.unimi.dsi.fastutil.booleans.AbstractBooleanList;
import it.unimi.dsi.fastutil.booleans.BooleanCollection;
import it.unimi.dsi.fastutil.booleans.BooleanListIterator;
import it.unimi.dsi.fastutil.bytes.AbstractByteList;
import it.unimi.dsi.fastutil.bytes.ByteArrays;
import it.unimi.dsi.fastutil.bytes.ByteCollection;
import it.unimi.dsi.fastutil.bytes.ByteIterators;
import it.unimi.dsi.fastutil.bytes.ByteListIterator;
import it.unimi.dsi.fastutil.chars.AbstractCharList;
import it.unimi.dsi.fastutil.chars.CharArrays;
import it.unimi.dsi.fastutil.chars.CharCollection;
import it.unimi.dsi.fastutil.chars.CharIterators;
import it.unimi.dsi.fastutil.chars.CharListIterator;
import it.unimi.dsi.fastutil.doubles.AbstractDoubleList;
import it.unimi.dsi.fastutil.doubles.DoubleArrays;
import it.unimi.dsi.fastutil.doubles.DoubleCollection;
import it.unimi.dsi.fastutil.doubles.DoubleIterators;
import it.unimi.dsi.fastutil.doubles.DoubleListIterator;
import it.unimi.dsi.fastutil.floats.AbstractFloatList;
import it.unimi.dsi.fastutil.floats.FloatArrays;
import it.unimi.dsi.fastutil.floats.FloatCollection;
import it.unimi.dsi.fastutil.floats.FloatIterators;
import it.unimi.dsi.fastutil.floats.FloatListIterator;
import it.unimi.dsi.fastutil.ints.AbstractIntList;
import it.unimi.dsi.fastutil.ints.IntArrays;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntIterators;
import it.unimi.dsi.fastutil.ints.IntListIterator;
import it.unimi.dsi.fastutil.longs.AbstractLongList;
import it.unimi.dsi.fastutil.longs.LongArrays;
import it.unimi.dsi.fastutil.longs.LongCollection;
import it.unimi.dsi.fastutil.longs.LongIterators;
import it.unimi.dsi.fastutil.longs.LongListIterator;
import it.unimi.dsi.fastutil.objects.AbstractObjectList;
import it.unimi.dsi.fastutil.objects.Object2ObjectArrayMap;
import it.unimi.dsi.fastutil.objects.ObjectArrays;
import it.unimi.dsi.fastutil.objects.ObjectCollection;
import it.unimi.dsi.fastutil.objects.ObjectIterators;
import it.unimi.dsi.fastutil.objects.ObjectListIterator;
import it.unimi.dsi.fastutil.shorts.AbstractShortList;
import it.unimi.dsi.fastutil.shorts.ShortArrays;
import it.unimi.dsi.fastutil.shorts.ShortCollection;
import it.unimi.dsi.fastutil.shorts.ShortIterators;
import it.unimi.dsi.fastutil.shorts.ShortListIterator;

interface WeightsImpl&lt;E&gt; extends Weights&lt;E&gt; {

	int size();

	@SuppressWarnings(&quot;unchecked&quot;)
	static &lt;E&gt; Weights&lt;E&gt; immutableView(Weights&lt;E&gt; weights) {
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">		if (weights instanceof Immutable&lt;?&gt;)</span>
<span class="nc" id="L78">			return weights;</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">		if (weights instanceof Weights.Byte)</span>
<span class="fc" id="L80">			return (WeightsImpl&lt;E&gt;) new ImmutableView.Byte((Weights.Byte) weights);</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">		if (weights instanceof Weights.Short)</span>
<span class="fc" id="L82">			return (WeightsImpl&lt;E&gt;) new ImmutableView.Short((Weights.Short) weights);</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">		if (weights instanceof Weights.Int)</span>
<span class="fc" id="L84">			return (WeightsImpl&lt;E&gt;) new ImmutableView.Int((Weights.Int) weights);</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">		if (weights instanceof Weights.Long)</span>
<span class="fc" id="L86">			return (WeightsImpl&lt;E&gt;) new ImmutableView.Long((Weights.Long) weights);</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">		if (weights instanceof Weights.Float)</span>
<span class="fc" id="L88">			return (WeightsImpl&lt;E&gt;) new ImmutableView.Float((Weights.Float) weights);</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">		if (weights instanceof Weights.Double)</span>
<span class="fc" id="L90">			return (WeightsImpl&lt;E&gt;) new ImmutableView.Double((Weights.Double) weights);</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">		if (weights instanceof Weights.Bool)</span>
<span class="fc" id="L92">			return (WeightsImpl&lt;E&gt;) new ImmutableView.Bool((Weights.Bool) weights);</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">		if (weights instanceof Weights.Char)</span>
<span class="fc" id="L94">			return (WeightsImpl&lt;E&gt;) new ImmutableView.Char((Weights.Char) weights);</span>
<span class="fc" id="L95">		return new ImmutableView.Obj&lt;&gt;(weights);</span>
	}

	static interface Index&lt;E&gt; extends WeightsImpl&lt;E&gt; {

		Collection&lt;E&gt; values();

		Class&lt;E&gt; getTypeClass();

		static abstract class Abstract&lt;E&gt; implements WeightsImpl.Index&lt;E&gt; {

			final IdStrategy idStrat;

<span class="fc" id="L108">			Abstract(IdStrategy idStrat) {</span>
<span class="fc" id="L109">				this.idStrat = Objects.requireNonNull(idStrat);</span>
<span class="fc" id="L110">			}</span>

			@Override
			public int size() {
<span class="fc" id="L114">				return idStrat.size();</span>
			}

			@Override
			public int hashCode() {
<span class="nc" id="L119">				return values().hashCode();</span>
			}

			@Override
			public String toString() {
<span class="nc" id="L124">				return values().toString();</span>
			}

			void checkIdx(int idx) {
<span class="fc" id="L128">				Assertions.Graphs.checkId(idx, idStrat.size());</span>
<span class="fc" id="L129">			}</span>
		}

		static abstract class Obj&lt;E&gt; extends WeightsImpl.Index.Abstract&lt;E&gt; {

			Object[] weights;
			final E defaultWeight;
			private final ObjectCollection&lt;E&gt; values;
			private final Class&lt;E&gt; type;

			Obj(IdStrategy idStrat, E defVal, Class&lt;E&gt; type) {
<span class="fc" id="L140">				super(idStrat);</span>

<span class="fc" id="L142">				defaultWeight = defVal;</span>
<span class="fc" id="L143">				weights = ObjectArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L144">				Arrays.fill(weights, defaultWeight);</span>

<span class="fc" id="L146">				this.type = Objects.requireNonNull(type);</span>
<span class="fc" id="L147">				values = new AbstractObjectList&lt;&gt;() {</span>
					@Override
					public int size() {
<span class="nc" id="L150">						return WeightsImpl.Index.Obj.super.size();</span>
					}

					@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
					@Override
					public ObjectListIterator&lt;E&gt; iterator() {
<span class="nc" id="L156">						return (ObjectListIterator) ObjectIterators.wrap(weights, 0, size());</span>
					}

					@SuppressWarnings(&quot;unchecked&quot;)
					@Override
					public E get(int index) {
<span class="nc" id="L162">						checkIdx(index);</span>
<span class="nc" id="L163">						return (E) weights[index];</span>
					}
				};
<span class="fc" id="L166">			}</span>

			Obj(WeightsImpl.Index.Obj&lt;E&gt; orig, IdStrategy idStrat) {
<span class="fc" id="L169">				this(idStrat, orig.defaultWeight, orig.type);</span>
<span class="fc" id="L170">				checkSameSize(idStrat, orig.idStrat);</span>
<span class="fc" id="L171">				weights = Arrays.copyOf(orig.weights, idStrat.size());</span>
<span class="fc" id="L172">			}</span>

			Obj(WeightsImpl.Index.Obj&lt;E&gt; orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="fc" id="L175">				this(idStrat, orig.defaultWeight, orig.type);</span>
<span class="fc" id="L176">				checkSameSize(idStrat, orig.idStrat);</span>
<span class="fc" id="L177">				weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="fc" id="L178">				final int s = idStrat.size();</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">				for (int i = 0; i &lt; s; i++)</span>
<span class="fc" id="L180">					weights[reIndexMap.origToReIndexed(i)] = orig.weights[i];</span>
<span class="fc" id="L181">			}</span>

			@Override
			@SuppressWarnings(&quot;unchecked&quot;)
			public E get(int idx) {
<span class="fc" id="L186">				checkIdx(idx);</span>
<span class="fc" id="L187">				return (E) weights[idx];</span>
			}

			@Override
			public E defaultWeight() {
<span class="fc" id="L192">				return defaultWeight;</span>
			}

			@Override
			public Collection&lt;E&gt; values() {
<span class="nc" id="L197">				return values;</span>
			}

			@Override
			public Class&lt;E&gt; getTypeClass() {
<span class="nc" id="L202">				return type;</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">				if (other == this)</span>
<span class="nc" id="L208">					return true;</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">				if (!(other instanceof WeightsImpl.Index.Obj&lt;?&gt;))</span>
<span class="nc" id="L210">					return false;</span>
<span class="fc" id="L211">				WeightsImpl.Index.Obj&lt;?&gt; o = (WeightsImpl.Index.Obj&lt;?&gt;) other;</span>
<span class="fc" id="L212">				return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
			}
		}

		static abstract class Byte extends WeightsImpl.Index.Abstract&lt;java.lang.Byte&gt; implements Weights.Byte {

			byte[] weights;
			final byte defaultWeight;
			private final ByteCollection values;

			Byte(IdStrategy idStrat, byte defVal) {
<span class="fc" id="L223">				super(idStrat);</span>

<span class="fc" id="L225">				weights = ByteArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L226">				defaultWeight = defVal;</span>
<span class="fc" id="L227">				values = new AbstractByteList() {</span>

					@Override
					public int size() {
<span class="nc" id="L231">						return WeightsImpl.Index.Byte.super.size();</span>
					}

					@Override
					public ByteListIterator iterator() {
<span class="nc" id="L236">						return ByteIterators.wrap(weights, 0, size());</span>
					}

					@Override
					public byte getByte(int index) {
<span class="nc" id="L241">						checkIdx(index);</span>
<span class="nc" id="L242">						return weights[index];</span>
					}
				};
<span class="fc" id="L245">			}</span>

			Byte(WeightsImpl.Index.Byte orig, IdStrategy idStrat) {
<span class="fc" id="L248">				this(idStrat, orig.defaultWeight);</span>
<span class="fc" id="L249">				checkSameSize(idStrat, orig.idStrat);</span>
<span class="fc" id="L250">				weights = Arrays.copyOf(orig.weights, idStrat.size());</span>
<span class="fc" id="L251">			}</span>

			Byte(WeightsImpl.Index.Byte orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="fc" id="L254">				this(idStrat, orig.defaultWeight);</span>
<span class="fc" id="L255">				checkSameSize(idStrat, orig.idStrat);</span>
<span class="fc" id="L256">				weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="fc" id="L257">				final int s = idStrat.size();</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">				for (int i = 0; i &lt; s; i++)</span>
<span class="fc" id="L259">					weights[reIndexMap.origToReIndexed(i)] = orig.weights[i];</span>
<span class="fc" id="L260">			}</span>

			@Override
			public byte getByte(int idx) {
<span class="fc" id="L264">				checkIdx(idx);</span>
<span class="fc" id="L265">				return weights[idx];</span>
			}

			@Override
			public byte defaultWeightByte() {
<span class="fc" id="L270">				return defaultWeight;</span>
			}

			@Override
			public ByteCollection values() {
<span class="nc" id="L275">				return values;</span>
			}

			@Override
			public Class&lt;java.lang.Byte&gt; getTypeClass() {
<span class="nc" id="L280">				return byte.class;</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">				if (this == other)</span>
<span class="nc" id="L286">					return true;</span>
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">				if (!(other instanceof WeightsImpl.Index.Byte))</span>
<span class="nc" id="L288">					return false;</span>
<span class="fc" id="L289">				WeightsImpl.Index.Byte o = (WeightsImpl.Index.Byte) other;</span>
<span class="fc" id="L290">				return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
			}
		}

		static abstract class Short extends WeightsImpl.Index.Abstract&lt;java.lang.Short&gt; implements Weights.Short {

			short[] weights;
			final short defaultWeight;
			private final ShortCollection values;

			Short(IdStrategy idStrat, short defVal) {
<span class="fc" id="L301">				super(idStrat);</span>

<span class="fc" id="L303">				weights = ShortArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L304">				defaultWeight = defVal;</span>
<span class="fc" id="L305">				values = new AbstractShortList() {</span>

					@Override
					public int size() {
<span class="nc" id="L309">						return WeightsImpl.Index.Short.super.size();</span>
					}

					@Override
					public ShortListIterator iterator() {
<span class="nc" id="L314">						return ShortIterators.wrap(weights, 0, size());</span>
					}

					@Override
					public short getShort(int index) {
<span class="nc" id="L319">						checkIdx(index);</span>
<span class="nc" id="L320">						return weights[index];</span>
					}
				};
<span class="fc" id="L323">			}</span>

			Short(WeightsImpl.Index.Short orig, IdStrategy idStrat) {
<span class="fc" id="L326">				this(idStrat, orig.defaultWeight);</span>
<span class="fc" id="L327">				checkSameSize(idStrat, orig.idStrat);</span>
<span class="fc" id="L328">				weights = Arrays.copyOf(orig.weights, idStrat.size());</span>
<span class="fc" id="L329">			}</span>

			Short(WeightsImpl.Index.Short orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="fc" id="L332">				this(idStrat, orig.defaultWeight);</span>
<span class="fc" id="L333">				checkSameSize(idStrat, orig.idStrat);</span>
<span class="fc" id="L334">				weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="fc" id="L335">				final int s = idStrat.size();</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">				for (int i = 0; i &lt; s; i++)</span>
<span class="fc" id="L337">					weights[reIndexMap.origToReIndexed(i)] = orig.weights[i];</span>
<span class="fc" id="L338">			}</span>

			@Override
			public short getShort(int idx) {
<span class="fc" id="L342">				checkIdx(idx);</span>
<span class="fc" id="L343">				return weights[idx];</span>
			}

			@Override
			public short defaultWeightShort() {
<span class="fc" id="L348">				return defaultWeight;</span>
			}

			@Override
			public ShortCollection values() {
<span class="nc" id="L353">				return values;</span>
			}

			@Override
			public Class&lt;java.lang.Short&gt; getTypeClass() {
<span class="nc" id="L358">				return short.class;</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">				if (this == other)</span>
<span class="nc" id="L364">					return true;</span>
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">				if (!(other instanceof WeightsImpl.Index.Short))</span>
<span class="nc" id="L366">					return false;</span>
<span class="fc" id="L367">				WeightsImpl.Index.Short o = (WeightsImpl.Index.Short) other;</span>
<span class="fc" id="L368">				return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
			}
		}

		static abstract class Int extends WeightsImpl.Index.Abstract&lt;Integer&gt; implements Weights.Int {

			int[] weights;
			final int defaultWeight;
			private final IntCollection values;

			Int(IdStrategy idStrat, int defVal) {
<span class="fc" id="L379">				super(idStrat);</span>

<span class="fc" id="L381">				weights = IntArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L382">				defaultWeight = defVal;</span>
<span class="fc" id="L383">				values = new AbstractIntList() {</span>

					@Override
					public int size() {
<span class="nc" id="L387">						return WeightsImpl.Index.Int.super.size();</span>
					}

					@Override
					public IntListIterator iterator() {
<span class="nc" id="L392">						return IntIterators.wrap(weights, 0, size());</span>
					}

					@Override
					public int getInt(int index) {
<span class="nc" id="L397">						checkIdx(index);</span>
<span class="nc" id="L398">						return weights[index];</span>
					}
				};
<span class="fc" id="L401">			}</span>

			Int(WeightsImpl.Index.Int orig, IdStrategy idStrat) {
<span class="fc" id="L404">				this(idStrat, orig.defaultWeight);</span>
<span class="fc" id="L405">				checkSameSize(idStrat, orig.idStrat);</span>
<span class="fc" id="L406">				weights = Arrays.copyOf(orig.weights, idStrat.size());</span>
<span class="fc" id="L407">			}</span>

			Int(WeightsImpl.Index.Int orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="fc" id="L410">				this(idStrat, orig.defaultWeight);</span>
<span class="fc" id="L411">				checkSameSize(idStrat, orig.idStrat);</span>
<span class="fc" id="L412">				weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="fc" id="L413">				final int s = idStrat.size();</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">				for (int i = 0; i &lt; s; i++)</span>
<span class="fc" id="L415">					weights[reIndexMap.origToReIndexed(i)] = orig.weights[i];</span>
<span class="fc" id="L416">			}</span>

			@Override
			public int getInt(int idx) {
<span class="fc" id="L420">				checkIdx(idx);</span>
<span class="fc" id="L421">				return weights[idx];</span>
			}

			@Override
			public int defaultWeightInt() {
<span class="fc" id="L426">				return defaultWeight;</span>
			}

			@Override
			public IntCollection values() {
<span class="nc" id="L431">				return values;</span>
			}

			@Override
			public Class&lt;Integer&gt; getTypeClass() {
<span class="nc" id="L436">				return int.class;</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">				if (this == other)</span>
<span class="nc" id="L442">					return true;</span>
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">				if (!(other instanceof WeightsImpl.Index.Int))</span>
<span class="nc" id="L444">					return false;</span>
<span class="fc" id="L445">				WeightsImpl.Index.Int o = (WeightsImpl.Index.Int) other;</span>
<span class="fc" id="L446">				return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
			}
		}

		static abstract class Long extends WeightsImpl.Index.Abstract&lt;java.lang.Long&gt; implements Weights.Long {

			long[] weights;
			final long defaultWeight;
<span class="fc" id="L454">			private final LongCollection values = new AbstractLongList() {</span>

				@Override
				public int size() {
<span class="nc" id="L458">					return WeightsImpl.Index.Long.super.size();</span>
				}

				@Override
				public LongListIterator iterator() {
<span class="nc" id="L463">					return LongIterators.wrap(weights, 0, size());</span>
				}

				@Override
				public long getLong(int index) {
<span class="nc" id="L468">					checkIdx(index);</span>
<span class="nc" id="L469">					return weights[index];</span>
				}
			};

			Long(IdStrategy idStrat, long defVal) {
<span class="fc" id="L474">				super(idStrat);</span>

<span class="fc" id="L476">				weights = LongArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L477">				defaultWeight = defVal;</span>
<span class="fc" id="L478">			}</span>

			Long(WeightsImpl.Index.Long orig, IdStrategy idStrat) {
<span class="fc" id="L481">				this(idStrat, orig.defaultWeight);</span>
<span class="fc" id="L482">				checkSameSize(idStrat, orig.idStrat);</span>
<span class="fc" id="L483">				weights = Arrays.copyOf(orig.weights, idStrat.size());</span>
<span class="fc" id="L484">			}</span>

			Long(WeightsImpl.Index.Long orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="fc" id="L487">				this(idStrat, orig.defaultWeight);</span>
<span class="fc" id="L488">				checkSameSize(idStrat, orig.idStrat);</span>
<span class="fc" id="L489">				weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="fc" id="L490">				final int s = idStrat.size();</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">				for (int i = 0; i &lt; s; i++)</span>
<span class="fc" id="L492">					weights[reIndexMap.origToReIndexed(i)] = orig.weights[i];</span>
<span class="fc" id="L493">			}</span>

			@Override
			public long getLong(int idx) {
<span class="fc" id="L497">				checkIdx(idx);</span>
<span class="fc" id="L498">				return weights[idx];</span>
			}

			@Override
			public long defaultWeightLong() {
<span class="fc" id="L503">				return defaultWeight;</span>
			}

			@Override
			public LongCollection values() {
<span class="nc" id="L508">				return values;</span>
			}

			@Override
			public Class&lt;java.lang.Long&gt; getTypeClass() {
<span class="nc" id="L513">				return long.class;</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">				if (this == other)</span>
<span class="nc" id="L519">					return true;</span>
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">				if (!(other instanceof WeightsImpl.Index.Long))</span>
<span class="nc" id="L521">					return false;</span>
<span class="fc" id="L522">				WeightsImpl.Index.Long o = (WeightsImpl.Index.Long) other;</span>
<span class="fc" id="L523">				return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
			}
		}

		static abstract class Float extends WeightsImpl.Index.Abstract&lt;java.lang.Float&gt; implements Weights.Float {

			float[] weights;
			final float defaultWeight;
			private final FloatCollection values;

			Float(IdStrategy idStrat, float defVal) {
<span class="fc" id="L534">				super(idStrat);</span>

<span class="fc" id="L536">				weights = FloatArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L537">				defaultWeight = defVal;</span>
<span class="fc" id="L538">				values = new AbstractFloatList() {</span>

					@Override
					public int size() {
<span class="nc" id="L542">						return WeightsImpl.Index.Float.super.size();</span>
					}

					@Override
					public FloatListIterator iterator() {
<span class="nc" id="L547">						return FloatIterators.wrap(weights, 0, size());</span>
					}

					@Override
					public float getFloat(int index) {
<span class="nc" id="L552">						checkIdx(index);</span>
<span class="nc" id="L553">						return weights[index];</span>
					}
				};
<span class="fc" id="L556">			}</span>

			Float(WeightsImpl.Index.Float orig, IdStrategy idStrat) {
<span class="fc" id="L559">				this(idStrat, orig.defaultWeight);</span>
<span class="fc" id="L560">				checkSameSize(idStrat, orig.idStrat);</span>
<span class="fc" id="L561">				weights = Arrays.copyOf(orig.weights, idStrat.size());</span>
<span class="fc" id="L562">			}</span>

			Float(WeightsImpl.Index.Float orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="fc" id="L565">				this(idStrat, orig.defaultWeight);</span>
<span class="fc" id="L566">				checkSameSize(idStrat, orig.idStrat);</span>
<span class="fc" id="L567">				weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="fc" id="L568">				final int s = idStrat.size();</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">				for (int i = 0; i &lt; s; i++)</span>
<span class="fc" id="L570">					weights[reIndexMap.origToReIndexed(i)] = orig.weights[i];</span>
<span class="fc" id="L571">			}</span>

			@Override
			public float getFloat(int idx) {
<span class="fc" id="L575">				checkIdx(idx);</span>
<span class="fc" id="L576">				return weights[idx];</span>
			}

			@Override
			public float defaultWeightFloat() {
<span class="fc" id="L581">				return defaultWeight;</span>
			}

			@Override
			public FloatCollection values() {
<span class="nc" id="L586">				return values;</span>
			}

			@Override
			public Class&lt;java.lang.Float&gt; getTypeClass() {
<span class="nc" id="L591">				return float.class;</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">				if (this == other)</span>
<span class="nc" id="L597">					return true;</span>
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">				if (!(other instanceof WeightsImpl.Index.Float))</span>
<span class="nc" id="L599">					return false;</span>
<span class="fc" id="L600">				WeightsImpl.Index.Float o = (WeightsImpl.Index.Float) other;</span>
<span class="fc" id="L601">				return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
			}
		}

		static abstract class Double extends WeightsImpl.Index.Abstract&lt;java.lang.Double&gt; implements Weights.Double {

			double[] weights;
			final double defaultWeight;
			private final DoubleCollection values;

			Double(IdStrategy idStrat, double defVal) {
<span class="fc" id="L612">				super(idStrat);</span>

<span class="fc" id="L614">				weights = DoubleArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L615">				defaultWeight = defVal;</span>
<span class="fc" id="L616">				values = new AbstractDoubleList() {</span>

					@Override
					public int size() {
<span class="nc" id="L620">						return WeightsImpl.Index.Double.super.size();</span>
					}

					@Override
					public DoubleListIterator iterator() {
<span class="nc" id="L625">						return DoubleIterators.wrap(weights, 0, size());</span>
					}

					@Override
					public double getDouble(int index) {
<span class="nc" id="L630">						checkIdx(index);</span>
<span class="nc" id="L631">						return weights[index];</span>
					}
				};
<span class="fc" id="L634">			}</span>

			Double(WeightsImpl.Index.Double orig, IdStrategy idStrat) {
<span class="fc" id="L637">				this(idStrat, orig.defaultWeight);</span>
<span class="fc" id="L638">				checkSameSize(idStrat, orig.idStrat);</span>
<span class="fc" id="L639">				weights = Arrays.copyOf(orig.weights, idStrat.size());</span>
<span class="fc" id="L640">			}</span>

			Double(WeightsImpl.Index.Double orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="fc" id="L643">				this(idStrat, orig.defaultWeight);</span>
<span class="fc" id="L644">				checkSameSize(idStrat, orig.idStrat);</span>
<span class="fc" id="L645">				weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="fc" id="L646">				final int s = idStrat.size();</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">				for (int i = 0; i &lt; s; i++)</span>
<span class="fc" id="L648">					weights[reIndexMap.origToReIndexed(i)] = orig.weights[i];</span>
<span class="fc" id="L649">			}</span>

			@Override
			public double getDouble(int idx) {
<span class="fc" id="L653">				checkIdx(idx);</span>
<span class="fc" id="L654">				return weights[idx];</span>
			}

			@Override
			public double defaultWeightDouble() {
<span class="fc" id="L659">				return defaultWeight;</span>
			}

			@Override
			public DoubleCollection values() {
<span class="nc" id="L664">				return values;</span>
			}

			@Override
			public Class&lt;java.lang.Double&gt; getTypeClass() {
<span class="nc" id="L669">				return double.class;</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="pc bpc" id="L674" title="1 of 2 branches missed.">				if (this == other)</span>
<span class="nc" id="L675">					return true;</span>
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">				if (!(other instanceof WeightsImpl.Index.Double))</span>
<span class="nc" id="L677">					return false;</span>
<span class="fc" id="L678">				WeightsImpl.Index.Double o = (WeightsImpl.Index.Double) other;</span>
<span class="fc" id="L679">				return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
			}
		}

		static abstract class Bool extends WeightsImpl.Index.Abstract&lt;Boolean&gt; implements Weights.Bool {

			final BitSet weights;
			int capacity;
			final boolean defaultWeight;
<span class="fc" id="L688">			private final BooleanCollection values = new AbstractBooleanList() {</span>

				@Override
				public int size() {
<span class="nc" id="L692">					return WeightsImpl.Index.Bool.super.size();</span>
				}

				@Override
				public BooleanListIterator iterator() {
<span class="nc" id="L697">					return new BooleanListIterator() {</span>
<span class="nc" id="L698">						int idx = 0;</span>

						@Override
						public boolean hasNext() {
<span class="nc bnc" id="L702" title="All 2 branches missed.">							return idx &lt; size();</span>
						}

						@Override
						public boolean nextBoolean() {
<span class="nc" id="L707">							Assertions.Iters.hasNext(this);</span>
<span class="nc" id="L708">							return weights.get(idx++);</span>
						}

						@Override
						public boolean previousBoolean() {
<span class="nc" id="L713">							Assertions.Iters.hasPrevious(this);</span>
<span class="nc" id="L714">							return weights.get(--idx);</span>
						}

						@Override
						public boolean hasPrevious() {
<span class="nc bnc" id="L719" title="All 2 branches missed.">							return idx &gt; 0;</span>
						}

						@Override
						public int nextIndex() {
<span class="nc" id="L724">							return idx;</span>
						}

						@Override
						public int previousIndex() {
<span class="nc" id="L729">							return idx - 1;</span>
						}
					};
				}

				@Override
				public boolean getBoolean(int index) {
<span class="nc" id="L736">					checkIdx(index);</span>
<span class="nc" id="L737">					return weights.get(index);</span>
				}
			};

			Bool(IdStrategy idStrat, boolean defVal) {
<span class="fc" id="L742">				super(idStrat);</span>

<span class="fc" id="L744">				defaultWeight = defVal;</span>
<span class="fc" id="L745">				weights = new BitSet();</span>
<span class="fc" id="L746">			}</span>

			Bool(WeightsImpl.Index.Bool orig, IdStrategy idStrat) {
<span class="fc" id="L749">				super(idStrat);</span>
<span class="fc" id="L750">				checkSameSize(idStrat, orig.idStrat);</span>
<span class="fc" id="L751">				defaultWeight = orig.defaultWeight;</span>
<span class="fc bfc" id="L752" title="All 2 branches covered.">				if (defaultWeight) {</span>
<span class="fc" id="L753">					weights = orig.weights.get(0, idStrat.size());</span>
				} else {
<span class="fc" id="L755">					weights = orig.weights.get(0, orig.weights.previousSetBit(idStrat.size() - 1) + 1);</span>
				}
<span class="fc" id="L757">			}</span>

			Bool(WeightsImpl.Index.Bool orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="fc" id="L760">				this(idStrat, orig.defaultWeight);</span>
<span class="fc" id="L761">				checkSameSize(idStrat, orig.idStrat);</span>
<span class="fc" id="L762">				final int s = idStrat.size();</span>
<span class="fc bfc" id="L763" title="All 2 branches covered.">				for (int i = 0; i &lt; s; i++)</span>
<span class="fc" id="L764">					weights.set(reIndexMap.origToReIndexed(i), orig.weights.get(i));</span>
<span class="fc" id="L765">			}</span>

			@Override
			public boolean getBool(int idx) {
<span class="fc" id="L769">				checkIdx(idx);</span>
<span class="fc" id="L770">				return weights.get(idx);</span>
			}

			@Override
			public boolean defaultWeightBool() {
<span class="fc" id="L775">				return defaultWeight;</span>
			}

			@Override
			public BooleanCollection values() {
<span class="nc" id="L780">				return values;</span>
			}

			@Override
			public Class&lt;Boolean&gt; getTypeClass() {
<span class="nc" id="L785">				return boolean.class;</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="pc bpc" id="L790" title="1 of 2 branches missed.">				if (this == other)</span>
<span class="nc" id="L791">					return true;</span>
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">				if (!(other instanceof WeightsImpl.Index.Bool))</span>
<span class="nc" id="L793">					return false;</span>
<span class="fc" id="L794">				WeightsImpl.Index.Bool o = (WeightsImpl.Index.Bool) other;</span>
<span class="fc" id="L795">				final int s = size();</span>
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">				if (s != o.size())</span>
<span class="nc" id="L797">					return false;</span>
<span class="fc bfc" id="L798" title="All 2 branches covered.">				for (int i = 0; i &lt; s; i++)</span>
<span class="pc bpc" id="L799" title="1 of 2 branches missed.">					if (weights.get(i) != o.weights.get(i))</span>
<span class="nc" id="L800">						return false;</span>
<span class="fc" id="L801">				return true;</span>
			}
		}

		static abstract class Char extends WeightsImpl.Index.Abstract&lt;Character&gt; implements Weights.Char {

			char[] weights;
			final char defaultWeight;
			private final CharCollection values;

			Char(IdStrategy idStrat, char defVal) {
<span class="fc" id="L812">				super(idStrat);</span>

<span class="fc" id="L814">				weights = CharArrays.EMPTY_ARRAY;</span>
<span class="fc" id="L815">				defaultWeight = defVal;</span>
<span class="fc" id="L816">				values = new AbstractCharList() {</span>

					@Override
					public int size() {
<span class="nc" id="L820">						return WeightsImpl.Index.Char.super.size();</span>
					}

					@Override
					public CharListIterator iterator() {
<span class="nc" id="L825">						return CharIterators.wrap(weights, 0, size());</span>
					}

					@Override
					public char getChar(int index) {
<span class="nc" id="L830">						checkIdx(index);</span>
<span class="nc" id="L831">						return weights[index];</span>
					}
				};
<span class="fc" id="L834">			}</span>

			Char(WeightsImpl.Index.Char orig, IdStrategy idStrat) {
<span class="fc" id="L837">				this(idStrat, orig.defaultWeight);</span>
<span class="fc" id="L838">				checkSameSize(idStrat, orig.idStrat);</span>
<span class="fc" id="L839">				weights = Arrays.copyOf(orig.weights, idStrat.size());</span>
<span class="fc" id="L840">			}</span>

			Char(WeightsImpl.Index.Char orig, IdStrategy idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="fc" id="L843">				this(idStrat, orig.defaultWeight);</span>
<span class="fc" id="L844">				checkSameSize(idStrat, orig.idStrat);</span>
<span class="fc" id="L845">				weights = Arrays.copyOf(weights, idStrat.size());</span>
<span class="fc" id="L846">				final int s = idStrat.size();</span>
<span class="fc bfc" id="L847" title="All 2 branches covered.">				for (int i = 0; i &lt; s; i++)</span>
<span class="fc" id="L848">					weights[reIndexMap.origToReIndexed(i)] = orig.weights[i];</span>
<span class="fc" id="L849">			}</span>

			@Override
			public char getChar(int idx) {
<span class="fc" id="L853">				checkIdx(idx);</span>
<span class="fc" id="L854">				return weights[idx];</span>
			}

			@Override
			public char defaultWeightChar() {
<span class="fc" id="L859">				return defaultWeight;</span>
			}

			@Override
			public CharCollection values() {
<span class="nc" id="L864">				return values;</span>
			}

			@Override
			public Class&lt;Character&gt; getTypeClass() {
<span class="nc" id="L869">				return char.class;</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="pc bpc" id="L874" title="1 of 2 branches missed.">				if (this == other)</span>
<span class="nc" id="L875">					return true;</span>
<span class="pc bpc" id="L876" title="1 of 2 branches missed.">				if (!(other instanceof WeightsImpl.Index.Char))</span>
<span class="nc" id="L877">					return false;</span>
<span class="fc" id="L878">				WeightsImpl.Index.Char o = (WeightsImpl.Index.Char) other;</span>
<span class="fc" id="L879">				return Arrays.equals(weights, 0, size(), o.weights, 0, o.size());</span>
			}
		}

	}

	static interface IndexImmutable&lt;E&gt; extends WeightsImpl.Index&lt;E&gt; {

		static WeightsImpl.IndexImmutable&lt;?&gt; copyOf(Weights&lt;?&gt; weights, IdStrategy.FixedSize idStart) {
<span class="pc bpc" id="L888" title="1 of 2 branches missed.">			if (weights instanceof WeightsImpl.ImmutableView&lt;?&gt;)</span>
<span class="nc" id="L889">				weights = ((WeightsImpl.ImmutableView&lt;?&gt;) weights).weights;</span>
<span class="fc bfc" id="L890" title="All 2 branches covered.">			if (weights instanceof WeightsImpl.Index.Byte) {</span>
<span class="fc" id="L891">				return new WeightsImpl.IndexImmutable.Byte((WeightsImpl.Index.Byte) weights, idStart);</span>
<span class="fc bfc" id="L892" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Short) {</span>
<span class="fc" id="L893">				return new WeightsImpl.IndexImmutable.Short((WeightsImpl.Index.Short) weights, idStart);</span>
<span class="fc bfc" id="L894" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Int) {</span>
<span class="fc" id="L895">				return new WeightsImpl.IndexImmutable.Int((WeightsImpl.Index.Int) weights, idStart);</span>
<span class="fc bfc" id="L896" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Long) {</span>
<span class="fc" id="L897">				return new WeightsImpl.IndexImmutable.Long((WeightsImpl.Index.Long) weights, idStart);</span>
<span class="fc bfc" id="L898" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Float) {</span>
<span class="fc" id="L899">				return new WeightsImpl.IndexImmutable.Float((WeightsImpl.Index.Float) weights, idStart);</span>
<span class="fc bfc" id="L900" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Double) {</span>
<span class="fc" id="L901">				return new WeightsImpl.IndexImmutable.Double((WeightsImpl.Index.Double) weights, idStart);</span>
<span class="fc bfc" id="L902" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Bool) {</span>
<span class="fc" id="L903">				return new WeightsImpl.IndexImmutable.Bool((WeightsImpl.Index.Bool) weights, idStart);</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Char) {</span>
<span class="fc" id="L905">				return new WeightsImpl.IndexImmutable.Char((WeightsImpl.Index.Char) weights, idStart);</span>
<span class="pc bpc" id="L906" title="1 of 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Obj) {</span>
<span class="fc" id="L907">				return new WeightsImpl.IndexImmutable.Obj&lt;&gt;((WeightsImpl.Index.Obj&lt;?&gt;) weights, idStart);</span>
			} else {
<span class="nc" id="L909">				throw new IllegalArgumentException(&quot;unknown weights implementation: &quot; + weights.getClass());</span>
			}
		}

		static WeightsImpl.IndexImmutable&lt;?&gt; copyOfReindexed(Weights&lt;?&gt; weights, IdStrategy.FixedSize idStart,
				IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="pc bpc" id="L915" title="1 of 2 branches missed.">			if (weights instanceof WeightsImpl.ImmutableView&lt;?&gt;)</span>
<span class="nc" id="L916">				weights = ((WeightsImpl.ImmutableView&lt;?&gt;) weights).weights;</span>
<span class="fc bfc" id="L917" title="All 2 branches covered.">			if (weights instanceof WeightsImpl.Index.Byte) {</span>
<span class="fc" id="L918">				return new WeightsImpl.IndexImmutable.Byte((WeightsImpl.Index.Byte) weights, idStart, reIndexMap);</span>
<span class="fc bfc" id="L919" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Short) {</span>
<span class="fc" id="L920">				return new WeightsImpl.IndexImmutable.Short((WeightsImpl.Index.Short) weights, idStart, reIndexMap);</span>
<span class="fc bfc" id="L921" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Int) {</span>
<span class="fc" id="L922">				return new WeightsImpl.IndexImmutable.Int((WeightsImpl.Index.Int) weights, idStart, reIndexMap);</span>
<span class="fc bfc" id="L923" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Long) {</span>
<span class="fc" id="L924">				return new WeightsImpl.IndexImmutable.Long((WeightsImpl.Index.Long) weights, idStart, reIndexMap);</span>
<span class="fc bfc" id="L925" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Float) {</span>
<span class="fc" id="L926">				return new WeightsImpl.IndexImmutable.Float((WeightsImpl.Index.Float) weights, idStart, reIndexMap);</span>
<span class="fc bfc" id="L927" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Double) {</span>
<span class="fc" id="L928">				return new WeightsImpl.IndexImmutable.Double((WeightsImpl.Index.Double) weights, idStart, reIndexMap);</span>
<span class="fc bfc" id="L929" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Bool) {</span>
<span class="fc" id="L930">				return new WeightsImpl.IndexImmutable.Bool((WeightsImpl.Index.Bool) weights, idStart, reIndexMap);</span>
<span class="fc bfc" id="L931" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Char) {</span>
<span class="fc" id="L932">				return new WeightsImpl.IndexImmutable.Char((WeightsImpl.Index.Char) weights, idStart, reIndexMap);</span>
<span class="pc bpc" id="L933" title="1 of 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Obj) {</span>
<span class="fc" id="L934">				return new WeightsImpl.IndexImmutable.Obj&lt;&gt;((WeightsImpl.Index.Obj&lt;?&gt;) weights, idStart, reIndexMap);</span>
			} else {
<span class="nc" id="L936">				throw new IllegalArgumentException(&quot;unknown weights implementation: &quot; + weights.getClass());</span>
			}
		}

		static class Obj&lt;E&gt; extends WeightsImpl.Index.Obj&lt;E&gt; implements WeightsImpl.IndexImmutable&lt;E&gt; {

			Obj(WeightsImpl.Index.Obj&lt;E&gt; orig, IdStrategy.FixedSize idStrat) {
<span class="fc" id="L943">				super(orig, idStrat);</span>
<span class="fc" id="L944">			}</span>

			Obj(WeightsImpl.Index.Obj&lt;E&gt; orig, IdStrategy.FixedSize idStrat,
					IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="fc" id="L948">				super(orig, idStrat, reIndexMap);</span>
<span class="fc" id="L949">			}</span>

			@Override
			public void set(int idx, E weight) {
<span class="fc" id="L953">				throw new UnsupportedOperationException();</span>
			}
		}

		static class Byte extends WeightsImpl.Index.Byte implements WeightsImpl.IndexImmutable&lt;java.lang.Byte&gt; {

			Byte(WeightsImpl.Index.Byte orig, IdStrategy.FixedSize idStrat) {
<span class="fc" id="L960">				super(orig, idStrat);</span>
<span class="fc" id="L961">			}</span>

			Byte(WeightsImpl.Index.Byte orig, IdStrategy.FixedSize idStrat,
					IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="fc" id="L965">				super(orig, idStrat, reIndexMap);</span>
<span class="fc" id="L966">			}</span>

			@Override
			public void set(int idx, byte weight) {
<span class="fc" id="L970">				throw new UnsupportedOperationException();</span>
			}
		}

		static class Short extends WeightsImpl.Index.Short implements WeightsImpl.IndexImmutable&lt;java.lang.Short&gt; {

			Short(WeightsImpl.Index.Short orig, IdStrategy.FixedSize idStrat) {
<span class="fc" id="L977">				super(orig, idStrat);</span>
<span class="fc" id="L978">			}</span>

			Short(WeightsImpl.Index.Short orig, IdStrategy.FixedSize idStrat,
					IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="fc" id="L982">				super(orig, idStrat, reIndexMap);</span>
<span class="fc" id="L983">			}</span>

			@Override
			public void set(int idx, short weight) {
<span class="fc" id="L987">				throw new UnsupportedOperationException();</span>
			}
		}

		static class Int extends WeightsImpl.Index.Int implements WeightsImpl.IndexImmutable&lt;Integer&gt; {

			Int(WeightsImpl.Index.Int orig, IdStrategy.FixedSize idStrat) {
<span class="fc" id="L994">				super(orig, idStrat);</span>
<span class="fc" id="L995">			}</span>

			Int(WeightsImpl.Index.Int orig, IdStrategy.FixedSize idStrat, IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="fc" id="L998">				super(orig, idStrat, reIndexMap);</span>
<span class="fc" id="L999">			}</span>

			@Override
			public void set(int idx, int weight) {
<span class="fc" id="L1003">				throw new UnsupportedOperationException();</span>
			}
		}

		static class Long extends WeightsImpl.Index.Long implements WeightsImpl.IndexImmutable&lt;java.lang.Long&gt; {

			Long(WeightsImpl.Index.Long orig, IdStrategy.FixedSize idStrat) {
<span class="fc" id="L1010">				super(orig, idStrat);</span>
<span class="fc" id="L1011">			}</span>

			Long(WeightsImpl.Index.Long orig, IdStrategy.FixedSize idStrat,
					IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="fc" id="L1015">				super(orig, idStrat, reIndexMap);</span>
<span class="fc" id="L1016">			}</span>

			@Override
			public void set(int idx, long weight) {
<span class="fc" id="L1020">				throw new UnsupportedOperationException();</span>
			}
		}

		static class Float extends WeightsImpl.Index.Float implements WeightsImpl.IndexImmutable&lt;java.lang.Float&gt; {

			Float(WeightsImpl.Index.Float orig, IdStrategy.FixedSize idStrat) {
<span class="fc" id="L1027">				super(orig, idStrat);</span>
<span class="fc" id="L1028">			}</span>

			Float(WeightsImpl.Index.Float orig, IdStrategy.FixedSize idStrat,
					IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="fc" id="L1032">				super(orig, idStrat, reIndexMap);</span>
<span class="fc" id="L1033">			}</span>

			@Override
			public void set(int idx, float weight) {
<span class="fc" id="L1037">				throw new UnsupportedOperationException();</span>
			}
		}

		static class Double extends WeightsImpl.Index.Double implements WeightsImpl.IndexImmutable&lt;java.lang.Double&gt; {

			Double(WeightsImpl.Index.Double orig, IdStrategy.FixedSize idStrat) {
<span class="fc" id="L1044">				super(orig, idStrat);</span>
<span class="fc" id="L1045">			}</span>

			Double(WeightsImpl.Index.Double orig, IdStrategy.FixedSize idStrat,
					IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="fc" id="L1049">				super(orig, idStrat, reIndexMap);</span>
<span class="fc" id="L1050">			}</span>

			@Override
			public void set(int idx, double weight) {
<span class="fc" id="L1054">				throw new UnsupportedOperationException();</span>
			}
		}

		static class Bool extends WeightsImpl.Index.Bool implements WeightsImpl.IndexImmutable&lt;Boolean&gt; {

			Bool(WeightsImpl.Index.Bool orig, IdStrategy.FixedSize idStrat) {
<span class="fc" id="L1061">				super(orig, idStrat);</span>
<span class="fc" id="L1062">			}</span>

			Bool(WeightsImpl.Index.Bool orig, IdStrategy.FixedSize idStrat,
					IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="fc" id="L1066">				super(orig, idStrat, reIndexMap);</span>
<span class="fc" id="L1067">			}</span>

			@Override
			public void set(int idx, boolean weight) {
<span class="fc" id="L1071">				throw new UnsupportedOperationException();</span>
			}
		}

		static class Char extends WeightsImpl.Index.Char implements WeightsImpl.IndexImmutable&lt;Character&gt; {

			Char(WeightsImpl.Index.Char orig, IdStrategy.FixedSize idStrat) {
<span class="fc" id="L1078">				super(orig, idStrat);</span>
<span class="fc" id="L1079">			}</span>

			Char(WeightsImpl.Index.Char orig, IdStrategy.FixedSize idStrat,
					IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="fc" id="L1083">				super(orig, idStrat, reIndexMap);</span>
<span class="fc" id="L1084">			}</span>

			@Override
			public void set(int idx, char weight) {
<span class="fc" id="L1088">				throw new UnsupportedOperationException();</span>
			}
		}

		static class Builder {

			private final IdStrategy.FixedSize idStrat;
			private final Map&lt;Object, WeightsImpl.IndexImmutable&lt;?&gt;&gt; weights;

<span class="fc" id="L1097">			Builder(IdStrategy.FixedSize idStrat) {</span>
<span class="fc" id="L1098">				this.idStrat = Objects.requireNonNull(idStrat);</span>
<span class="fc" id="L1099">				weights = new Object2ObjectArrayMap&lt;&gt;();</span>
<span class="fc" id="L1100">			}</span>

			void copyAndAddWeights(Object key, Weights&lt;?&gt; weights) {
<span class="fc" id="L1103">				Object oldWeights = this.weights.put(key, WeightsImpl.IndexImmutable.copyOf(weights, idStrat));</span>
<span class="pc bpc" id="L1104" title="1 of 2 branches missed.">				if (oldWeights != null)</span>
<span class="nc" id="L1105">					throw new IllegalArgumentException(&quot;duplicate key: &quot; + key);</span>
<span class="fc" id="L1106">			}</span>

			void copyAndAddWeightsReindexed(Object key, Weights&lt;?&gt; weights,
					IndexGraphBuilder.ReIndexingMap reIndexMap) {
<span class="fc" id="L1110">				Object oldWeights =</span>
<span class="fc" id="L1111">						this.weights.put(key, WeightsImpl.IndexImmutable.copyOfReindexed(weights, idStrat, reIndexMap));</span>
<span class="pc bpc" id="L1112" title="1 of 2 branches missed.">				if (oldWeights != null)</span>
<span class="nc" id="L1113">					throw new IllegalArgumentException(&quot;duplicate key: &quot; + key);</span>
<span class="fc" id="L1114">			}</span>

			Map&lt;Object, WeightsImpl.IndexImmutable&lt;?&gt;&gt; build() {
<span class="fc" id="L1117">				return Map.copyOf(weights);</span>
			}
		}
	}

	static interface IndexMutable&lt;E&gt; extends WeightsImpl.Index&lt;E&gt; {

		int capacity();

		void expand(int newCapacity);

		void clear(int idx);

		void clear();

		void swap(int idx1, int idx2);

		static &lt;D&gt; WeightsImpl.IndexMutable&lt;D&gt; newInstance(IdStrategy idStart, Class&lt;? super D&gt; type, D defVal) {
			@SuppressWarnings(&quot;rawtypes&quot;)
			WeightsImpl container;
<span class="fc bfc" id="L1137" title="All 2 branches covered.">			if (type == byte.class) {</span>
<span class="fc bfc" id="L1138" title="All 2 branches covered.">				byte defVal0 = defVal != null ? ((java.lang.Byte) defVal).byteValue() : 0;</span>
<span class="fc" id="L1139">				container = new WeightsImpl.IndexMutable.Byte(idStart, defVal0);</span>

<span class="fc bfc" id="L1141" title="All 2 branches covered.">			} else if (type == short.class) {</span>
<span class="fc bfc" id="L1142" title="All 2 branches covered.">				short defVal0 = defVal != null ? ((java.lang.Short) defVal).shortValue() : 0;</span>
<span class="fc" id="L1143">				container = new WeightsImpl.IndexMutable.Short(idStart, defVal0);</span>

<span class="fc bfc" id="L1145" title="All 2 branches covered.">			} else if (type == int.class) {</span>
<span class="fc bfc" id="L1146" title="All 2 branches covered.">				int defVal0 = defVal != null ? ((Integer) defVal).intValue() : 0;</span>
<span class="fc" id="L1147">				container = new WeightsImpl.IndexMutable.Int(idStart, defVal0);</span>

<span class="fc bfc" id="L1149" title="All 2 branches covered.">			} else if (type == long.class) {</span>
<span class="fc bfc" id="L1150" title="All 2 branches covered.">				long defVal0 = defVal != null ? ((java.lang.Long) defVal).longValue() : 0;</span>
<span class="fc" id="L1151">				container = new WeightsImpl.IndexMutable.Long(idStart, defVal0);</span>

<span class="fc bfc" id="L1153" title="All 2 branches covered.">			} else if (type == float.class) {</span>
<span class="fc bfc" id="L1154" title="All 2 branches covered.">				float defVal0 = defVal != null ? ((java.lang.Float) defVal).floatValue() : 0;</span>
<span class="fc" id="L1155">				container = new WeightsImpl.IndexMutable.Float(idStart, defVal0);</span>

<span class="fc bfc" id="L1157" title="All 2 branches covered.">			} else if (type == double.class) {</span>
<span class="fc bfc" id="L1158" title="All 2 branches covered.">				double defVal0 = defVal != null ? ((java.lang.Double) defVal).doubleValue() : 0;</span>
<span class="fc" id="L1159">				container = new WeightsImpl.IndexMutable.Double(idStart, defVal0);</span>

<span class="fc bfc" id="L1161" title="All 2 branches covered.">			} else if (type == boolean.class) {</span>
<span class="fc bfc" id="L1162" title="All 2 branches covered.">				boolean defVal0 = defVal != null ? ((Boolean) defVal).booleanValue() : false;</span>
<span class="fc" id="L1163">				container = new WeightsImpl.IndexMutable.Bool(idStart, defVal0);</span>

<span class="fc bfc" id="L1165" title="All 2 branches covered.">			} else if (type == char.class) {</span>
<span class="fc bfc" id="L1166" title="All 2 branches covered.">				char defVal0 = defVal != null ? ((Character) defVal).charValue() : 0;</span>
<span class="fc" id="L1167">				container = new WeightsImpl.IndexMutable.Char(idStart, defVal0);</span>

<span class="fc" id="L1169">			} else {</span>
<span class="fc" id="L1170">				container = new WeightsImpl.IndexMutable.Obj&lt;&gt;(idStart, defVal, type);</span>
			}
			@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1173">			WeightsImpl.IndexMutable&lt;D&gt; container0 = (WeightsImpl.IndexMutable&lt;D&gt;) container;</span>
<span class="fc" id="L1174">			return container0;</span>
		}

		static WeightsImpl.IndexMutable&lt;?&gt; copyOf(Weights&lt;?&gt; weights, IdStrategy idStart) {
<span class="pc bpc" id="L1178" title="1 of 2 branches missed.">			if (weights instanceof WeightsImpl.ImmutableView&lt;?&gt;)</span>
<span class="nc" id="L1179">				weights = ((WeightsImpl.ImmutableView&lt;?&gt;) weights).weights;</span>
<span class="fc bfc" id="L1180" title="All 2 branches covered.">			if (weights instanceof WeightsImpl.Index.Byte) {</span>
<span class="fc" id="L1181">				return new WeightsImpl.IndexMutable.Byte((WeightsImpl.Index.Byte) weights, idStart);</span>
<span class="fc bfc" id="L1182" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Short) {</span>
<span class="fc" id="L1183">				return new WeightsImpl.IndexMutable.Short((WeightsImpl.Index.Short) weights, idStart);</span>
<span class="fc bfc" id="L1184" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Int) {</span>
<span class="fc" id="L1185">				return new WeightsImpl.IndexMutable.Int((WeightsImpl.Index.Int) weights, idStart);</span>
<span class="fc bfc" id="L1186" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Long) {</span>
<span class="fc" id="L1187">				return new WeightsImpl.IndexMutable.Long((WeightsImpl.Index.Long) weights, idStart);</span>
<span class="fc bfc" id="L1188" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Float) {</span>
<span class="fc" id="L1189">				return new WeightsImpl.IndexMutable.Float((WeightsImpl.Index.Float) weights, idStart);</span>
<span class="fc bfc" id="L1190" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Double) {</span>
<span class="fc" id="L1191">				return new WeightsImpl.IndexMutable.Double((WeightsImpl.Index.Double) weights, idStart);</span>
<span class="fc bfc" id="L1192" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Bool) {</span>
<span class="fc" id="L1193">				return new WeightsImpl.IndexMutable.Bool((WeightsImpl.Index.Bool) weights, idStart);</span>
<span class="fc bfc" id="L1194" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Char) {</span>
<span class="fc" id="L1195">				return new WeightsImpl.IndexMutable.Char((WeightsImpl.Index.Char) weights, idStart);</span>
<span class="pc bpc" id="L1196" title="1 of 2 branches missed.">			} else if (weights instanceof WeightsImpl.Index.Obj) {</span>
<span class="fc" id="L1197">				return new WeightsImpl.IndexMutable.Obj&lt;&gt;((WeightsImpl.Index.Obj&lt;?&gt;) weights, idStart);</span>
			} else {
<span class="nc" id="L1199">				throw new IllegalArgumentException(&quot;unknown weights implementation: &quot; + weights.getClass());</span>
			}
		}

<span class="fc" id="L1203">		static class Obj&lt;E&gt; extends WeightsImpl.Index.Obj&lt;E&gt; implements WeightsImpl.IndexMutable&lt;E&gt; {</span>

			Obj(IdStrategy idStrat, E defVal, Class&lt;E&gt; type) {
<span class="fc" id="L1206">				super(idStrat, defVal, type);</span>
<span class="fc" id="L1207">			}</span>

			Obj(WeightsImpl.Index.Obj&lt;E&gt; orig, IdStrategy idStrat) {
<span class="fc" id="L1210">				super(orig, idStrat);</span>
<span class="fc" id="L1211">			}</span>

			@Override
			public void set(int idx, E weight) {
<span class="fc" id="L1215">				checkIdx(idx);</span>
<span class="fc" id="L1216">				weights[idx] = weight;</span>
<span class="fc" id="L1217">			}</span>

			@Override
			public int capacity() {
<span class="fc" id="L1221">				return weights.length;</span>
			}

			@Override
			public void expand(int newCapacity) {
<span class="fc" id="L1226">				int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L1227" title="1 of 2 branches missed.">				assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L1228">				weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L1229">				Arrays.fill(weights, oldCapacity, newCapacity, defaultWeight);</span>
<span class="fc" id="L1230">			}</span>

			@Override
			public void swap(int idx1, int idx2) {
<span class="fc" id="L1234">				checkIdx(idx1);</span>
<span class="fc" id="L1235">				checkIdx(idx2);</span>
<span class="fc" id="L1236">				ObjectArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L1237">			}</span>

			@Override
			public void clear(int idx) {
				// checkIdx(idx);
<span class="fc" id="L1242">				weights[idx] = defaultWeight;</span>
<span class="fc" id="L1243">			}</span>

			@Override
			public void clear() {
<span class="nc" id="L1247">				Arrays.fill(weights, 0, size(), defaultWeight);</span>
<span class="nc" id="L1248">			}</span>
		}

<span class="fc" id="L1251">		static class Byte extends WeightsImpl.Index.Byte implements WeightsImpl.IndexMutable&lt;java.lang.Byte&gt; {</span>

			Byte(IdStrategy idStrat, byte defVal) {
<span class="fc" id="L1254">				super(idStrat, defVal);</span>
<span class="fc" id="L1255">			}</span>

			Byte(WeightsImpl.Index.Byte orig, IdStrategy idStrat) {
<span class="fc" id="L1258">				super(orig, idStrat);</span>
<span class="fc" id="L1259">			}</span>

			@Override
			public void set(int idx, byte weight) {
<span class="fc" id="L1263">				checkIdx(idx);</span>
<span class="fc" id="L1264">				weights[idx] = weight;</span>
<span class="fc" id="L1265">			}</span>

			@Override
			public int capacity() {
<span class="fc" id="L1269">				return weights.length;</span>
			}

			@Override
			public void expand(int newCapacity) {
<span class="fc" id="L1274">				int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L1275" title="1 of 2 branches missed.">				assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L1276">				weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L1277">				Arrays.fill(weights, oldCapacity, newCapacity, defaultWeight);</span>
<span class="fc" id="L1278">			}</span>

			@Override
			public void swap(int idx1, int idx2) {
<span class="fc" id="L1282">				checkIdx(idx1);</span>
<span class="fc" id="L1283">				checkIdx(idx2);</span>
<span class="fc" id="L1284">				ByteArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L1285">			}</span>

			@Override
			public void clear(int idx) {
				// checkIdx(idx);
<span class="fc" id="L1290">				weights[idx] = defaultWeight;</span>
<span class="fc" id="L1291">			}</span>

			@Override
			public void clear() {
<span class="nc" id="L1295">				Arrays.fill(weights, 0, size(), defaultWeight);</span>
<span class="nc" id="L1296">			}</span>
		}

<span class="fc" id="L1299">		static class Short extends WeightsImpl.Index.Short implements WeightsImpl.IndexMutable&lt;java.lang.Short&gt; {</span>

			Short(IdStrategy idStrat, short defVal) {
<span class="fc" id="L1302">				super(idStrat, defVal);</span>
<span class="fc" id="L1303">			}</span>

			Short(WeightsImpl.Index.Short orig, IdStrategy idStrat) {
<span class="fc" id="L1306">				super(orig, idStrat);</span>
<span class="fc" id="L1307">			}</span>

			@Override
			public void set(int idx, short weight) {
<span class="fc" id="L1311">				checkIdx(idx);</span>
<span class="fc" id="L1312">				weights[idx] = weight;</span>
<span class="fc" id="L1313">			}</span>

			@Override
			public int capacity() {
<span class="fc" id="L1317">				return weights.length;</span>
			}

			@Override
			public void expand(int newCapacity) {
<span class="fc" id="L1322">				int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L1323" title="1 of 2 branches missed.">				assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L1324">				weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L1325">				Arrays.fill(weights, oldCapacity, newCapacity, defaultWeight);</span>
<span class="fc" id="L1326">			}</span>

			@Override
			public void swap(int idx1, int idx2) {
<span class="fc" id="L1330">				checkIdx(idx1);</span>
<span class="fc" id="L1331">				checkIdx(idx2);</span>
<span class="fc" id="L1332">				ShortArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L1333">			}</span>

			@Override
			public void clear(int idx) {
				// checkIdx(idx);
<span class="fc" id="L1338">				weights[idx] = defaultWeight;</span>
<span class="fc" id="L1339">			}</span>

			@Override
			public void clear() {
<span class="nc" id="L1343">				Arrays.fill(weights, 0, size(), defaultWeight);</span>
<span class="nc" id="L1344">			}</span>
		}

<span class="fc" id="L1347">		static class Int extends WeightsImpl.Index.Int implements WeightsImpl.IndexMutable&lt;Integer&gt; {</span>

			Int(IdStrategy idStrat, int defVal) {
<span class="fc" id="L1350">				super(idStrat, defVal);</span>
<span class="fc" id="L1351">			}</span>

			Int(WeightsImpl.Index.Int orig, IdStrategy idStrat) {
<span class="fc" id="L1354">				super(orig, idStrat);</span>
<span class="fc" id="L1355">			}</span>

			@Override
			public void set(int idx, int weight) {
<span class="fc" id="L1359">				checkIdx(idx);</span>
<span class="fc" id="L1360">				weights[idx] = weight;</span>
<span class="fc" id="L1361">			}</span>

			@Override
			public int capacity() {
<span class="fc" id="L1365">				return weights.length;</span>
			}

			@Override
			public void expand(int newCapacity) {
<span class="fc" id="L1370">				int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L1371" title="1 of 2 branches missed.">				assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L1372">				weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L1373">				Arrays.fill(weights, oldCapacity, newCapacity, defaultWeight);</span>
<span class="fc" id="L1374">			}</span>

			@Override
			public void swap(int idx1, int idx2) {
<span class="fc" id="L1378">				checkIdx(idx1);</span>
<span class="fc" id="L1379">				checkIdx(idx2);</span>
<span class="fc" id="L1380">				IntArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L1381">			}</span>

			@Override
			public void clear(int idx) {
				// checkIdx(idx);
<span class="fc" id="L1386">				weights[idx] = defaultWeight;</span>
<span class="fc" id="L1387">			}</span>

			@Override
			public void clear() {
<span class="fc" id="L1391">				Arrays.fill(weights, 0, size(), defaultWeight);</span>
<span class="fc" id="L1392">			}</span>
		}

<span class="fc" id="L1395">		static class Long extends WeightsImpl.Index.Long implements WeightsImpl.IndexMutable&lt;java.lang.Long&gt; {</span>

			Long(IdStrategy idStrat, long defVal) {
<span class="fc" id="L1398">				super(idStrat, defVal);</span>
<span class="fc" id="L1399">			}</span>

			Long(WeightsImpl.Index.Long orig, IdStrategy idStrat) {
<span class="fc" id="L1402">				super(orig, idStrat);</span>
<span class="fc" id="L1403">			}</span>

			@Override
			public void set(int idx, long weight) {
<span class="fc" id="L1407">				checkIdx(idx);</span>
<span class="fc" id="L1408">				weights[idx] = weight;</span>
<span class="fc" id="L1409">			}</span>

			@Override
			public int capacity() {
<span class="fc" id="L1413">				return weights.length;</span>
			}

			@Override
			public void expand(int newCapacity) {
<span class="fc" id="L1418">				int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L1419" title="1 of 2 branches missed.">				assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L1420">				weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L1421">				Arrays.fill(weights, oldCapacity, newCapacity, defaultWeight);</span>
<span class="fc" id="L1422">			}</span>

			@Override
			public void swap(int idx1, int idx2) {
<span class="fc" id="L1426">				checkIdx(idx1);</span>
<span class="fc" id="L1427">				checkIdx(idx2);</span>
<span class="fc" id="L1428">				LongArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L1429">			}</span>

			@Override
			public void clear(int idx) {
				// checkIdx(idx);
<span class="fc" id="L1434">				weights[idx] = defaultWeight;</span>
<span class="fc" id="L1435">			}</span>

			@Override
			public void clear() {
<span class="nc" id="L1439">				Arrays.fill(weights, 0, size(), defaultWeight);</span>
<span class="nc" id="L1440">			}</span>
		}

<span class="fc" id="L1443">		static class Float extends WeightsImpl.Index.Float implements WeightsImpl.IndexMutable&lt;java.lang.Float&gt; {</span>

			Float(IdStrategy idStrat, float defVal) {
<span class="fc" id="L1446">				super(idStrat, defVal);</span>
<span class="fc" id="L1447">			}</span>

			Float(WeightsImpl.Index.Float orig, IdStrategy idStrat) {
<span class="fc" id="L1450">				super(orig, idStrat);</span>
<span class="fc" id="L1451">			}</span>

			@Override
			public void set(int idx, float weight) {
<span class="fc" id="L1455">				checkIdx(idx);</span>
<span class="fc" id="L1456">				weights[idx] = weight;</span>
<span class="fc" id="L1457">			}</span>

			@Override
			public int capacity() {
<span class="fc" id="L1461">				return weights.length;</span>
			}

			@Override
			public void expand(int newCapacity) {
<span class="fc" id="L1466">				int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L1467" title="1 of 2 branches missed.">				assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L1468">				weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L1469">				Arrays.fill(weights, oldCapacity, newCapacity, defaultWeight);</span>
<span class="fc" id="L1470">			}</span>

			@Override
			public void swap(int idx1, int idx2) {
<span class="fc" id="L1474">				checkIdx(idx1);</span>
<span class="fc" id="L1475">				checkIdx(idx2);</span>
<span class="fc" id="L1476">				FloatArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L1477">			}</span>

			@Override
			public void clear(int idx) {
				// checkIdx(idx);
<span class="fc" id="L1482">				weights[idx] = defaultWeight;</span>
<span class="fc" id="L1483">			}</span>

			@Override
			public void clear() {
<span class="nc" id="L1487">				Arrays.fill(weights, 0, size(), defaultWeight);</span>
<span class="nc" id="L1488">			}</span>
		}

<span class="fc" id="L1491">		static class Double extends WeightsImpl.Index.Double implements WeightsImpl.IndexMutable&lt;java.lang.Double&gt; {</span>

			Double(IdStrategy idStrat, double defVal) {
<span class="fc" id="L1494">				super(idStrat, defVal);</span>
<span class="fc" id="L1495">			}</span>

			Double(WeightsImpl.Index.Double orig, IdStrategy idStrat) {
<span class="fc" id="L1498">				super(orig, idStrat);</span>
<span class="fc" id="L1499">			}</span>

			@Override
			public void set(int idx, double weight) {
<span class="fc" id="L1503">				checkIdx(idx);</span>
<span class="fc" id="L1504">				weights[idx] = weight;</span>
<span class="fc" id="L1505">			}</span>

			@Override
			public int capacity() {
<span class="fc" id="L1509">				return weights.length;</span>
			}

			@Override
			public void expand(int newCapacity) {
<span class="fc" id="L1514">				int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L1515" title="1 of 2 branches missed.">				assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L1516">				weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L1517">				Arrays.fill(weights, oldCapacity, newCapacity, defaultWeight);</span>
<span class="fc" id="L1518">			}</span>

			@Override
			public void swap(int idx1, int idx2) {
<span class="fc" id="L1522">				checkIdx(idx1);</span>
<span class="fc" id="L1523">				checkIdx(idx2);</span>
<span class="fc" id="L1524">				DoubleArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L1525">			}</span>

			@Override
			public void clear(int idx) {
				// checkIdx(idx);
<span class="fc" id="L1530">				weights[idx] = defaultWeight;</span>
<span class="fc" id="L1531">			}</span>

			@Override
			public void clear() {
<span class="fc" id="L1535">				Arrays.fill(weights, 0, size(), defaultWeight);</span>
<span class="fc" id="L1536">			}</span>
		}

<span class="fc" id="L1539">		static class Bool extends WeightsImpl.Index.Bool implements WeightsImpl.IndexMutable&lt;Boolean&gt; {</span>

			Bool(IdStrategy idStrat, boolean defVal) {
<span class="fc" id="L1542">				super(idStrat, defVal);</span>
<span class="fc" id="L1543">			}</span>

			Bool(WeightsImpl.Index.Bool orig, IdStrategy idStrat) {
<span class="fc" id="L1546">				super(orig, idStrat);</span>
<span class="fc" id="L1547">			}</span>

			@Override
			public void set(int idx, boolean weight) {
<span class="fc" id="L1551">				checkIdx(idx);</span>
<span class="fc" id="L1552">				weights.set(idx, weight);</span>
<span class="fc" id="L1553">			}</span>

			@Override
			public int capacity() {
<span class="fc" id="L1557">				return capacity;</span>
			}

			@Override
			public void expand(int newCapacity) {
<span class="fc" id="L1562">				int oldCapacity = capacity;</span>
<span class="pc bpc" id="L1563" title="1 of 2 branches missed.">				assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L1564">				capacity = newCapacity;</span>
<span class="fc bfc" id="L1565" title="All 2 branches covered.">				if (defaultWeight)</span>
<span class="fc" id="L1566">					weights.set(oldCapacity, newCapacity);</span>
<span class="fc" id="L1567">			}</span>

			@Override
			public void swap(int idx1, int idx2) {
<span class="fc" id="L1571">				checkIdx(idx1);</span>
<span class="fc" id="L1572">				checkIdx(idx2);</span>
<span class="fc" id="L1573">				boolean temp = weights.get(idx1);</span>
<span class="fc" id="L1574">				weights.set(idx1, weights.get(idx2));</span>
<span class="fc" id="L1575">				weights.set(idx2, temp);</span>
<span class="fc" id="L1576">			}</span>

			@Override
			public void clear(int idx) {
				// checkIdx(idx);
<span class="fc" id="L1581">				weights.set(idx, defaultWeight);</span>
<span class="fc" id="L1582">			}</span>

			@Override
			public void clear() {
<span class="nc" id="L1586">				weights.set(0, capacity, defaultWeight);</span>
<span class="nc" id="L1587">			}</span>
		}

<span class="fc" id="L1590">		static class Char extends WeightsImpl.Index.Char implements WeightsImpl.IndexMutable&lt;Character&gt; {</span>

			Char(IdStrategy idStrat, char defVal) {
<span class="fc" id="L1593">				super(idStrat, defVal);</span>
<span class="fc" id="L1594">			}</span>

			Char(WeightsImpl.Index.Char orig, IdStrategy idStrat) {
<span class="fc" id="L1597">				super(orig, idStrat);</span>
<span class="fc" id="L1598">			}</span>

			@Override
			public void set(int idx, char weight) {
<span class="fc" id="L1602">				checkIdx(idx);</span>
<span class="fc" id="L1603">				weights[idx] = weight;</span>
<span class="fc" id="L1604">			}</span>

			@Override
			public int capacity() {
<span class="fc" id="L1608">				return weights.length;</span>
			}

			@Override
			public void expand(int newCapacity) {
<span class="fc" id="L1613">				int oldCapacity = weights.length;</span>
<span class="pc bpc" id="L1614" title="1 of 2 branches missed.">				assert oldCapacity &lt; newCapacity;</span>
<span class="fc" id="L1615">				weights = Arrays.copyOf(weights, newCapacity);</span>
<span class="fc" id="L1616">				Arrays.fill(weights, oldCapacity, newCapacity, defaultWeight);</span>
<span class="fc" id="L1617">			}</span>

			@Override
			public void swap(int idx1, int idx2) {
<span class="fc" id="L1621">				checkIdx(idx1);</span>
<span class="fc" id="L1622">				checkIdx(idx2);</span>
<span class="fc" id="L1623">				CharArrays.swap(weights, idx1, idx2);</span>
<span class="fc" id="L1624">			}</span>

			@Override
			public void clear(int idx) {
				// checkIdx(idx);
<span class="fc" id="L1629">				weights[idx] = defaultWeight;</span>
<span class="fc" id="L1630">			}</span>

			@Override
			public void clear() {
<span class="nc" id="L1634">				Arrays.fill(weights, 0, size(), defaultWeight);</span>
<span class="nc" id="L1635">			}</span>
		}

		static class Manager {

<span class="fc" id="L1640">			final Map&lt;Object, WeightsImpl.IndexMutable&lt;?&gt;&gt; weights = new Object2ObjectArrayMap&lt;&gt;();</span>
			private int weightsCapacity;

<span class="fc" id="L1643">			Manager(int initCapacity) {</span>
<span class="fc" id="L1644">				weightsCapacity = initCapacity;</span>
<span class="fc" id="L1645">			}</span>

			Manager(Manager orig, IdStrategy idStrat) {
<span class="fc" id="L1648">				this(idStrat.size());</span>
<span class="fc bfc" id="L1649" title="All 2 branches covered.">				for (var entry : orig.weights.entrySet())</span>
<span class="fc" id="L1650">					weights.put(entry.getKey(), WeightsImpl.IndexMutable.copyOf(entry.getValue(), idStrat));</span>
<span class="fc" id="L1651">			}</span>

			void addWeights(Object key, WeightsImpl.IndexMutable&lt;?&gt; weight) {
<span class="fc" id="L1654">				WeightsImpl.IndexMutable&lt;?&gt; oldContainer = weights.put(key, weight);</span>
<span class="pc bpc" id="L1655" title="1 of 2 branches missed.">				if (oldContainer != null)</span>
<span class="nc" id="L1656">					throw new IllegalArgumentException(&quot;Two weights types with the same key: &quot; + key);</span>
<span class="fc bfc" id="L1657" title="All 2 branches covered.">				if (weightsCapacity &gt; weight.capacity())</span>
<span class="fc" id="L1658">					weight.expand(weightsCapacity);</span>
<span class="fc" id="L1659">			}</span>

			void removeWeights(Object key) {
<span class="fc" id="L1662">				weights.remove(key);</span>
<span class="fc" id="L1663">			}</span>

			@SuppressWarnings(&quot;unchecked&quot;)
			&lt;E, WeightsT extends Weights&lt;E&gt;&gt; WeightsT getWeights(Object key) {
<span class="fc" id="L1667">				return (WeightsT) weights.get(key);</span>
			}

			Set&lt;Object&gt; weightsKeys() {
<span class="fc" id="L1671">				return Collections.unmodifiableSet(weights.keySet());</span>
			}

			void ensureCapacity(int capacity) {
<span class="fc bfc" id="L1675" title="All 2 branches covered.">				if (capacity &lt;= weightsCapacity)</span>
<span class="fc" id="L1676">					return;</span>
<span class="fc" id="L1677">				int newCapacity = Math.max(Math.max(2, 2 * weightsCapacity), capacity);</span>
<span class="fc bfc" id="L1678" title="All 2 branches covered.">				for (WeightsImpl.IndexMutable&lt;?&gt; container : weights.values())</span>
<span class="fc" id="L1679">					container.expand(newCapacity);</span>
<span class="fc" id="L1680">				weightsCapacity = newCapacity;</span>
<span class="fc" id="L1681">			}</span>

			void swapElements(int idx1, int idx2) {
<span class="fc bfc" id="L1684" title="All 2 branches covered.">				for (WeightsImpl.IndexMutable&lt;?&gt; container : weights.values())</span>
<span class="fc" id="L1685">					container.swap(idx1, idx2);</span>
<span class="fc" id="L1686">			}</span>

			void clearElement(int idx) {
<span class="fc bfc" id="L1689" title="All 2 branches covered.">				for (WeightsImpl.IndexMutable&lt;?&gt; container : weights.values())</span>
<span class="fc" id="L1690">					container.clear(idx);</span>
<span class="fc" id="L1691">			}</span>

			void clearContainers() {
<span class="fc bfc" id="L1694" title="All 2 branches covered.">				for (WeightsImpl.IndexMutable&lt;?&gt; container : weights.values())</span>
<span class="fc" id="L1695">					container.clear();</span>
<span class="fc" id="L1696">			}</span>
		}
	}

	static abstract class Mapped&lt;E&gt; implements WeightsImpl&lt;E&gt; {

		final WeightsImpl.Index.Abstract&lt;E&gt; weights;
		final IndexIdMap indexMap;

<span class="fc" id="L1705">		private Mapped(WeightsImpl.Index&lt;E&gt; weights, IndexIdMap indexMap) {</span>
<span class="fc" id="L1706">			this.weights = (WeightsImpl.Index.Abstract&lt;E&gt;) Objects.requireNonNull(weights);</span>
<span class="fc" id="L1707">			this.indexMap = indexMap;</span>
<span class="fc" id="L1708">		}</span>

		WeightsImpl.Index.Abstract&lt;E&gt; weights() {
<span class="fc" id="L1711">			return weights;</span>
		}

		@Override
		public int size() {
<span class="fc" id="L1716">			return weights.size();</span>
		}

		static WeightsImpl.Mapped&lt;?&gt; newInstance(WeightsImpl.Index&lt;?&gt; weights, IndexIdMap indexMap) {
<span class="fc bfc" id="L1720" title="All 2 branches covered.">			if (weights instanceof WeightsImpl.Index.Byte) {</span>
<span class="fc" id="L1721">				return new WeightsImpl.Mapped.Byte((WeightsImpl.Index.Byte) weights, indexMap);</span>
<span class="fc bfc" id="L1722" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Short) {</span>
<span class="fc" id="L1723">				return new WeightsImpl.Mapped.Short((WeightsImpl.Index.Short) weights, indexMap);</span>
<span class="fc bfc" id="L1724" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Int) {</span>
<span class="fc" id="L1725">				return new WeightsImpl.Mapped.Int((WeightsImpl.Index.Int) weights, indexMap);</span>
<span class="fc bfc" id="L1726" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Long) {</span>
<span class="fc" id="L1727">				return new WeightsImpl.Mapped.Long((WeightsImpl.Index.Long) weights, indexMap);</span>
<span class="fc bfc" id="L1728" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Float) {</span>
<span class="fc" id="L1729">				return new WeightsImpl.Mapped.Float((WeightsImpl.Index.Float) weights, indexMap);</span>
<span class="fc bfc" id="L1730" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Double) {</span>
<span class="fc" id="L1731">				return new WeightsImpl.Mapped.Double((WeightsImpl.Index.Double) weights, indexMap);</span>
<span class="fc bfc" id="L1732" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Bool) {</span>
<span class="fc" id="L1733">				return new WeightsImpl.Mapped.Bool((WeightsImpl.Index.Bool) weights, indexMap);</span>
<span class="fc bfc" id="L1734" title="All 2 branches covered.">			} else if (weights instanceof WeightsImpl.Index.Char) {</span>
<span class="fc" id="L1735">				return new WeightsImpl.Mapped.Char((WeightsImpl.Index.Char) weights, indexMap);</span>
			} else {
<span class="fc" id="L1737">				return new WeightsImpl.Mapped.Obj&lt;&gt;(weights, indexMap);</span>
			}
		}

		static class Obj&lt;E&gt; extends Mapped&lt;E&gt; {
			Obj(WeightsImpl.Index&lt;E&gt; weights, IndexIdMap indexMap) {
<span class="fc" id="L1743">				super(weights, indexMap);</span>
<span class="fc" id="L1744">			}</span>

			@Override
			public WeightsImpl.Index.Obj&lt;E&gt; weights() {
<span class="fc" id="L1748">				return (WeightsImpl.Index.Obj&lt;E&gt;) super.weights();</span>
			}

			@Override
			public E get(int id) {
<span class="fc" id="L1753">				return weights().get(indexMap.idToIndex(id));</span>
			}

			@Override
			public void set(int id, E val) {
<span class="fc" id="L1758">				weights().set(indexMap.idToIndex(id), val);</span>
<span class="fc" id="L1759">			}</span>

			@Override
			public E defaultWeight() {
<span class="fc" id="L1763">				return weights().defaultWeight();</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="fc bfc" id="L1768" title="All 2 branches covered.">				if (other == this)</span>
<span class="fc" id="L1769">					return true;</span>
<span class="fc bfc" id="L1770" title="All 2 branches covered.">				if (!(other instanceof WeightsImpl))</span>
<span class="fc" id="L1771">					return false;</span>
<span class="fc" id="L1772">				WeightsImpl&lt;?&gt; o = (WeightsImpl&lt;?&gt;) other;</span>

<span class="fc" id="L1774">				WeightsImpl.Index.Obj&lt;E&gt; w = weights();</span>
<span class="fc" id="L1775">				int size = w.size();</span>
<span class="pc bpc" id="L1776" title="1 of 2 branches missed.">				if (size != ((WeightsImpl&lt;?&gt;) other).size())</span>
<span class="nc" id="L1777">					return false;</span>
				try {
<span class="fc bfc" id="L1779" title="All 2 branches covered.">					for (int idx = 0; idx &lt; size; idx++)</span>
<span class="pc bpc" id="L1780" title="1 of 2 branches missed.">						if (!Objects.equals(w.get(idx), o.get(indexMap.indexToId(idx))))</span>
<span class="nc" id="L1781">							return false;</span>
<span class="nc" id="L1782">				} catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L1783">					return false;</span>
<span class="fc" id="L1784">				}</span>
<span class="fc" id="L1785">				return true;</span>
			}

			@Override
			public int hashCode() {
<span class="nc" id="L1790">				int h = 0;</span>
<span class="nc" id="L1791">				WeightsImpl.Index.Obj&lt;E&gt; w = weights();</span>
<span class="nc" id="L1792">				int size = w.size();</span>
<span class="nc bnc" id="L1793" title="All 2 branches missed.">				for (int idx = 0; idx &lt; size; idx++)</span>
					/* we must use addition, order shouldn't matter */
<span class="nc" id="L1795">					h += Objects.hashCode(w.get(idx));</span>
<span class="nc" id="L1796">				return h;</span>
			}

			@Override
			public String toString() {
<span class="nc" id="L1801">				WeightsImpl.Index.Obj&lt;E&gt; w = weights();</span>
<span class="nc" id="L1802">				int size = w.size();</span>
<span class="nc bnc" id="L1803" title="All 2 branches missed.">				if (size == 0)</span>
<span class="nc" id="L1804">					return &quot;[]&quot;;</span>
<span class="nc" id="L1805">				StringBuilder s = new StringBuilder().append('[');</span>
<span class="nc" id="L1806">				for (int idx = 0;; idx++) {</span>
<span class="nc" id="L1807">					int id = indexMap.indexToId(idx);</span>
<span class="nc" id="L1808">					s.append(id).append('=').append(w.get(idx));</span>
<span class="nc bnc" id="L1809" title="All 2 branches missed.">					if (idx == size - 1)</span>
<span class="nc" id="L1810">						break;</span>
<span class="nc" id="L1811">					s.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L1813">				return s.append(']').toString();</span>
			}
		}

		static class Byte extends Mapped&lt;java.lang.Byte&gt; implements Weights.Byte {
			Byte(WeightsImpl.Index.Byte weights, IndexIdMap indexMap) {
<span class="fc" id="L1819">				super(weights, indexMap);</span>
<span class="fc" id="L1820">			}</span>

			@Override
			public WeightsImpl.Index.Byte weights() {
<span class="fc" id="L1824">				return (WeightsImpl.Index.Byte) super.weights();</span>
			}

			@Override
			public byte getByte(int id) {
<span class="fc" id="L1829">				return weights().getByte(indexMap.idToIndex(id));</span>
			}

			@Override
			public void set(int id, byte weight) {
<span class="fc" id="L1834">				weights().set(indexMap.idToIndex(id), weight);</span>
<span class="fc" id="L1835">			}</span>

			@Override
			public byte defaultWeightByte() {
<span class="fc" id="L1839">				return weights().defaultWeightByte();</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="fc bfc" id="L1844" title="All 2 branches covered.">				if (other == this)</span>
<span class="fc" id="L1845">					return true;</span>
<span class="pc bpc" id="L1846" title="1 of 4 branches missed.">				if (!(other instanceof WeightsImpl &amp;&amp; other instanceof Weights.Byte))</span>
<span class="fc" id="L1847">					return false;</span>
<span class="fc" id="L1848">				Weights.Byte o = (Weights.Byte) other;</span>

<span class="fc" id="L1850">				WeightsImpl.Index.Byte w = weights();</span>
<span class="fc" id="L1851">				int size = w.size();</span>
<span class="pc bpc" id="L1852" title="1 of 2 branches missed.">				if (size != ((WeightsImpl&lt;?&gt;) other).size())</span>
<span class="nc" id="L1853">					return false;</span>
				try {
<span class="fc bfc" id="L1855" title="All 2 branches covered.">					for (int idx = 0; idx &lt; size; idx++)</span>
<span class="pc bpc" id="L1856" title="1 of 2 branches missed.">						if (w.getByte(idx) != o.getByte(indexMap.indexToId(idx)))</span>
<span class="nc" id="L1857">							return false;</span>
<span class="nc" id="L1858">				} catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L1859">					return false;</span>
<span class="fc" id="L1860">				}</span>
<span class="fc" id="L1861">				return true;</span>
			}

			@Override
			public int hashCode() {
<span class="nc" id="L1866">				int h = 0;</span>
<span class="nc" id="L1867">				WeightsImpl.Index.Byte w = weights();</span>
<span class="nc" id="L1868">				int size = w.size();</span>
<span class="nc bnc" id="L1869" title="All 2 branches missed.">				for (int idx = 0; idx &lt; size; idx++)</span>
					/* we must use addition, order shouldn't matter */
<span class="nc" id="L1871">					h += w.getByte(idx);</span>
<span class="nc" id="L1872">				return h;</span>
			}

			@Override
			public String toString() {
<span class="nc" id="L1877">				WeightsImpl.Index.Byte w = weights();</span>
<span class="nc" id="L1878">				int size = w.size();</span>
<span class="nc bnc" id="L1879" title="All 2 branches missed.">				if (size == 0)</span>
<span class="nc" id="L1880">					return &quot;[]&quot;;</span>
<span class="nc" id="L1881">				StringBuilder s = new StringBuilder().append('[');</span>
<span class="nc" id="L1882">				for (int idx = 0;; idx++) {</span>
<span class="nc" id="L1883">					int id = indexMap.indexToId(idx);</span>
<span class="nc" id="L1884">					s.append(id).append('=').append(w.getByte(idx));</span>
<span class="nc bnc" id="L1885" title="All 2 branches missed.">					if (idx == size - 1)</span>
<span class="nc" id="L1886">						break;</span>
<span class="nc" id="L1887">					s.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L1889">				return s.append(']').toString();</span>
			}
		}

		static class Short extends Mapped&lt;java.lang.Short&gt; implements Weights.Short {
			Short(WeightsImpl.Index.Short container, IndexIdMap indexMap) {
<span class="fc" id="L1895">				super(container, indexMap);</span>
<span class="fc" id="L1896">			}</span>

			@Override
			public WeightsImpl.Index.Short weights() {
<span class="fc" id="L1900">				return (WeightsImpl.Index.Short) super.weights();</span>
			}

			@Override
			public short getShort(int id) {
<span class="fc" id="L1905">				return weights().getShort(indexMap.idToIndex(id));</span>
			}

			@Override
			public void set(int id, short weight) {
<span class="fc" id="L1910">				weights().set(indexMap.idToIndex(id), weight);</span>
<span class="fc" id="L1911">			}</span>

			@Override
			public short defaultWeightShort() {
<span class="fc" id="L1915">				return weights().defaultWeightShort();</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="fc bfc" id="L1920" title="All 2 branches covered.">				if (other == this)</span>
<span class="fc" id="L1921">					return true;</span>
<span class="pc bpc" id="L1922" title="1 of 4 branches missed.">				if (!(other instanceof WeightsImpl &amp;&amp; other instanceof Weights.Short))</span>
<span class="fc" id="L1923">					return false;</span>
<span class="fc" id="L1924">				Weights.Short o = (Weights.Short) other;</span>

<span class="fc" id="L1926">				WeightsImpl.Index.Short w = weights();</span>
<span class="fc" id="L1927">				int size = w.size();</span>
<span class="pc bpc" id="L1928" title="1 of 2 branches missed.">				if (size != ((WeightsImpl&lt;?&gt;) other).size())</span>
<span class="nc" id="L1929">					return false;</span>
				try {
<span class="fc bfc" id="L1931" title="All 2 branches covered.">					for (int idx = 0; idx &lt; size; idx++)</span>
<span class="pc bpc" id="L1932" title="1 of 2 branches missed.">						if (w.getShort(idx) != o.getShort(indexMap.indexToId(idx)))</span>
<span class="nc" id="L1933">							return false;</span>
<span class="nc" id="L1934">				} catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L1935">					return false;</span>
<span class="fc" id="L1936">				}</span>
<span class="fc" id="L1937">				return true;</span>
			}

			@Override
			public int hashCode() {
<span class="nc" id="L1942">				int h = 0;</span>
<span class="nc" id="L1943">				WeightsImpl.Index.Short w = weights();</span>
<span class="nc" id="L1944">				int size = w.size();</span>
<span class="nc bnc" id="L1945" title="All 2 branches missed.">				for (int idx = 0; idx &lt; size; idx++)</span>
					/* we must use addition, order shouldn't matter */
<span class="nc" id="L1947">					h += w.getShort(idx);</span>
<span class="nc" id="L1948">				return h;</span>
			}

			@Override
			public String toString() {
<span class="nc" id="L1953">				WeightsImpl.Index.Short w = weights();</span>
<span class="nc" id="L1954">				int size = w.size();</span>
<span class="nc bnc" id="L1955" title="All 2 branches missed.">				if (size == 0)</span>
<span class="nc" id="L1956">					return &quot;[]&quot;;</span>
<span class="nc" id="L1957">				StringBuilder s = new StringBuilder().append('[');</span>
<span class="nc" id="L1958">				for (int idx = 0;; idx++) {</span>
<span class="nc" id="L1959">					int id = indexMap.indexToId(idx);</span>
<span class="nc" id="L1960">					s.append(id).append('=').append(w.getShort(idx));</span>
<span class="nc bnc" id="L1961" title="All 2 branches missed.">					if (idx == size - 1)</span>
<span class="nc" id="L1962">						break;</span>
<span class="nc" id="L1963">					s.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L1965">				return s.append(']').toString();</span>
			}
		}

		static class Int extends Mapped&lt;Integer&gt; implements Weights.Int {
			Int(WeightsImpl.Index.Int container, IndexIdMap indexMap) {
<span class="fc" id="L1971">				super(container, indexMap);</span>
<span class="fc" id="L1972">			}</span>

			@Override
			public WeightsImpl.Index.Int weights() {
<span class="fc" id="L1976">				return (WeightsImpl.Index.Int) super.weights();</span>
			}

			@Override
			public int getInt(int id) {
<span class="fc" id="L1981">				return weights().getInt(indexMap.idToIndex(id));</span>
			}

			@Override
			public void set(int id, int weight) {
<span class="fc" id="L1986">				weights().set(indexMap.idToIndex(id), weight);</span>
<span class="fc" id="L1987">			}</span>

			@Override
			public int defaultWeightInt() {
<span class="fc" id="L1991">				return weights().defaultWeightInt();</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="fc bfc" id="L1996" title="All 2 branches covered.">				if (other == this)</span>
<span class="fc" id="L1997">					return true;</span>
<span class="pc bpc" id="L1998" title="1 of 4 branches missed.">				if (!(other instanceof WeightsImpl &amp;&amp; other instanceof Weights.Int))</span>
<span class="fc" id="L1999">					return false;</span>
<span class="fc" id="L2000">				Weights.Int o = (Weights.Int) other;</span>

<span class="fc" id="L2002">				WeightsImpl.Index.Int w = weights();</span>
<span class="fc" id="L2003">				int size = w.size();</span>
<span class="pc bpc" id="L2004" title="1 of 2 branches missed.">				if (size != ((WeightsImpl&lt;?&gt;) other).size())</span>
<span class="nc" id="L2005">					return false;</span>
				try {
<span class="fc bfc" id="L2007" title="All 2 branches covered.">					for (int idx = 0; idx &lt; size; idx++)</span>
<span class="pc bpc" id="L2008" title="1 of 2 branches missed.">						if (w.getInt(idx) != o.getInt(indexMap.indexToId(idx)))</span>
<span class="nc" id="L2009">							return false;</span>
<span class="nc" id="L2010">				} catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L2011">					return false;</span>
<span class="fc" id="L2012">				}</span>
<span class="fc" id="L2013">				return true;</span>
			}

			@Override
			public int hashCode() {
<span class="nc" id="L2018">				int h = 0;</span>
<span class="nc" id="L2019">				WeightsImpl.Index.Int w = weights();</span>
<span class="nc" id="L2020">				int size = w.size();</span>
<span class="nc bnc" id="L2021" title="All 2 branches missed.">				for (int idx = 0; idx &lt; size; idx++)</span>
					/* we must use addition, order shouldn't matter */
<span class="nc" id="L2023">					h += w.getInt(idx);</span>
<span class="nc" id="L2024">				return h;</span>
			}

			@Override
			public String toString() {
<span class="nc" id="L2029">				WeightsImpl.Index.Int w = weights();</span>
<span class="nc" id="L2030">				int size = w.size();</span>
<span class="nc bnc" id="L2031" title="All 2 branches missed.">				if (size == 0)</span>
<span class="nc" id="L2032">					return &quot;[]&quot;;</span>
<span class="nc" id="L2033">				StringBuilder s = new StringBuilder().append('[');</span>
<span class="nc" id="L2034">				for (int idx = 0;; idx++) {</span>
<span class="nc" id="L2035">					int id = indexMap.indexToId(idx);</span>
<span class="nc" id="L2036">					s.append(id).append('=').append(w.getInt(idx));</span>
<span class="nc bnc" id="L2037" title="All 2 branches missed.">					if (idx == size - 1)</span>
<span class="nc" id="L2038">						break;</span>
<span class="nc" id="L2039">					s.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L2041">				return s.append(']').toString();</span>
			}
		}

		static class Long extends Mapped&lt;java.lang.Long&gt; implements Weights.Long {
			Long(WeightsImpl.Index.Long container, IndexIdMap indexMap) {
<span class="fc" id="L2047">				super(container, indexMap);</span>
<span class="fc" id="L2048">			}</span>

			@Override
			public WeightsImpl.Index.Long weights() {
<span class="fc" id="L2052">				return (WeightsImpl.Index.Long) super.weights();</span>
			}

			@Override
			public long getLong(int id) {
<span class="fc" id="L2057">				return weights().getLong(indexMap.idToIndex(id));</span>
			}

			@Override
			public void set(int id, long weight) {
<span class="fc" id="L2062">				weights().set(indexMap.idToIndex(id), weight);</span>
<span class="fc" id="L2063">			}</span>

			@Override
			public long defaultWeightLong() {
<span class="fc" id="L2067">				return weights().defaultWeightLong();</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="fc bfc" id="L2072" title="All 2 branches covered.">				if (other == this)</span>
<span class="fc" id="L2073">					return true;</span>
<span class="pc bpc" id="L2074" title="1 of 4 branches missed.">				if (!(other instanceof WeightsImpl &amp;&amp; other instanceof Weights.Long))</span>
<span class="fc" id="L2075">					return false;</span>
<span class="fc" id="L2076">				Weights.Long o = (Weights.Long) other;</span>

<span class="fc" id="L2078">				WeightsImpl.Index.Long w = weights();</span>
<span class="fc" id="L2079">				int size = w.size();</span>
<span class="pc bpc" id="L2080" title="1 of 2 branches missed.">				if (size != ((WeightsImpl&lt;?&gt;) other).size())</span>
<span class="nc" id="L2081">					return false;</span>
				try {
<span class="fc bfc" id="L2083" title="All 2 branches covered.">					for (int idx = 0; idx &lt; size; idx++)</span>
<span class="pc bpc" id="L2084" title="1 of 2 branches missed.">						if (w.getLong(idx) != o.getLong(indexMap.indexToId(idx)))</span>
<span class="nc" id="L2085">							return false;</span>
<span class="nc" id="L2086">				} catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L2087">					return false;</span>
<span class="fc" id="L2088">				}</span>
<span class="fc" id="L2089">				return true;</span>
			}

			@Override
			public int hashCode() {
<span class="nc" id="L2094">				int h = 0;</span>
<span class="nc" id="L2095">				WeightsImpl.Index.Long w = weights();</span>
<span class="nc" id="L2096">				int size = w.size();</span>
<span class="nc bnc" id="L2097" title="All 2 branches missed.">				for (int idx = 0; idx &lt; size; idx++)</span>
					/* we must use addition, order shouldn't matter */
<span class="nc" id="L2099">					h += java.lang.Long.hashCode(w.getLong(idx));</span>
<span class="nc" id="L2100">				return h;</span>
			}

			@Override
			public String toString() {
<span class="nc" id="L2105">				WeightsImpl.Index.Long w = weights();</span>
<span class="nc" id="L2106">				int size = w.size();</span>
<span class="nc bnc" id="L2107" title="All 2 branches missed.">				if (size == 0)</span>
<span class="nc" id="L2108">					return &quot;[]&quot;;</span>
<span class="nc" id="L2109">				StringBuilder s = new StringBuilder().append('[');</span>
<span class="nc" id="L2110">				for (int idx = 0;; idx++) {</span>
<span class="nc" id="L2111">					int id = indexMap.indexToId(idx);</span>
<span class="nc" id="L2112">					s.append(id).append('=').append(w.getLong(idx));</span>
<span class="nc bnc" id="L2113" title="All 2 branches missed.">					if (idx == size - 1)</span>
<span class="nc" id="L2114">						break;</span>
<span class="nc" id="L2115">					s.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L2117">				return s.append(']').toString();</span>
			}
		}

		static class Float extends Mapped&lt;java.lang.Float&gt; implements Weights.Float {
			Float(WeightsImpl.Index.Float container, IndexIdMap indexMap) {
<span class="fc" id="L2123">				super(container, indexMap);</span>
<span class="fc" id="L2124">			}</span>

			@Override
			public WeightsImpl.Index.Float weights() {
<span class="fc" id="L2128">				return (WeightsImpl.Index.Float) super.weights();</span>
			}

			@Override
			public float getFloat(int id) {
<span class="fc" id="L2133">				return weights().getFloat(indexMap.idToIndex(id));</span>
			}

			@Override
			public void set(int id, float weight) {
<span class="fc" id="L2138">				weights().set(indexMap.idToIndex(id), weight);</span>
<span class="fc" id="L2139">			}</span>

			@Override
			public float defaultWeightFloat() {
<span class="fc" id="L2143">				return weights().defaultWeightFloat();</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="fc bfc" id="L2148" title="All 2 branches covered.">				if (other == this)</span>
<span class="fc" id="L2149">					return true;</span>
<span class="pc bpc" id="L2150" title="1 of 4 branches missed.">				if (!(other instanceof WeightsImpl &amp;&amp; other instanceof Weights.Float))</span>
<span class="fc" id="L2151">					return false;</span>
<span class="fc" id="L2152">				Weights.Float o = (Weights.Float) other;</span>

<span class="fc" id="L2154">				WeightsImpl.Index.Float w = weights();</span>
<span class="fc" id="L2155">				int size = w.size();</span>
<span class="pc bpc" id="L2156" title="1 of 2 branches missed.">				if (size != ((WeightsImpl&lt;?&gt;) other).size())</span>
<span class="nc" id="L2157">					return false;</span>
				try {
<span class="fc bfc" id="L2159" title="All 2 branches covered.">					for (int idx = 0; idx &lt; size; idx++)</span>
<span class="pc bpc" id="L2160" title="1 of 2 branches missed.">						if (w.getFloat(idx) != o.getFloat(indexMap.indexToId(idx)))</span>
<span class="nc" id="L2161">							return false;</span>
<span class="nc" id="L2162">				} catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L2163">					return false;</span>
<span class="fc" id="L2164">				}</span>
<span class="fc" id="L2165">				return true;</span>
			}

			@Override
			public int hashCode() {
<span class="nc" id="L2170">				int h = 0;</span>
<span class="nc" id="L2171">				WeightsImpl.Index.Float w = weights();</span>
<span class="nc" id="L2172">				int size = w.size();</span>
<span class="nc bnc" id="L2173" title="All 2 branches missed.">				for (int idx = 0; idx &lt; size; idx++)</span>
					/* we must use addition, order shouldn't matter */
<span class="nc" id="L2175">					h += java.lang.Float.hashCode(w.getFloat(idx));</span>
<span class="nc" id="L2176">				return h;</span>
			}

			@Override
			public String toString() {
<span class="nc" id="L2181">				WeightsImpl.Index.Float w = weights();</span>
<span class="nc" id="L2182">				int size = w.size();</span>
<span class="nc bnc" id="L2183" title="All 2 branches missed.">				if (size == 0)</span>
<span class="nc" id="L2184">					return &quot;[]&quot;;</span>
<span class="nc" id="L2185">				StringBuilder s = new StringBuilder().append('[');</span>
<span class="nc" id="L2186">				for (int idx = 0;; idx++) {</span>
<span class="nc" id="L2187">					int id = indexMap.indexToId(idx);</span>
<span class="nc" id="L2188">					s.append(id).append('=').append(w.getFloat(idx));</span>
<span class="nc bnc" id="L2189" title="All 2 branches missed.">					if (idx == size - 1)</span>
<span class="nc" id="L2190">						break;</span>
<span class="nc" id="L2191">					s.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L2193">				return s.append(']').toString();</span>
			}
		}

		static class Double extends Mapped&lt;java.lang.Double&gt; implements Weights.Double {
			Double(WeightsImpl.Index.Double container, IndexIdMap indexMap) {
<span class="fc" id="L2199">				super(container, indexMap);</span>
<span class="fc" id="L2200">			}</span>

			@Override
			WeightsImpl.Index.Double weights() {
<span class="fc" id="L2204">				return (WeightsImpl.Index.Double) super.weights();</span>
			}

			@Override
			public double getDouble(int id) {
<span class="fc" id="L2209">				return weights().getDouble(indexMap.idToIndex(id));</span>
			}

			@Override
			public void set(int id, double weight) {
<span class="fc" id="L2214">				weights().set(indexMap.idToIndex(id), weight);</span>
<span class="fc" id="L2215">			}</span>

			@Override
			public double defaultWeightDouble() {
<span class="fc" id="L2219">				return weights().defaultWeightDouble();</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="fc bfc" id="L2224" title="All 2 branches covered.">				if (other == this)</span>
<span class="fc" id="L2225">					return true;</span>
<span class="pc bpc" id="L2226" title="1 of 4 branches missed.">				if (!(other instanceof WeightsImpl &amp;&amp; other instanceof Weights.Double))</span>
<span class="fc" id="L2227">					return false;</span>
<span class="fc" id="L2228">				Weights.Double o = (Weights.Double) other;</span>

<span class="fc" id="L2230">				WeightsImpl.Index.Double w = weights();</span>
<span class="fc" id="L2231">				int size = w.size();</span>
<span class="pc bpc" id="L2232" title="1 of 2 branches missed.">				if (size != ((WeightsImpl&lt;?&gt;) other).size())</span>
<span class="nc" id="L2233">					return false;</span>
				try {
<span class="fc bfc" id="L2235" title="All 2 branches covered.">					for (int idx = 0; idx &lt; size; idx++)</span>
<span class="pc bpc" id="L2236" title="1 of 2 branches missed.">						if (w.getDouble(idx) != o.getDouble(indexMap.indexToId(idx)))</span>
<span class="nc" id="L2237">							return false;</span>
<span class="nc" id="L2238">				} catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L2239">					return false;</span>
<span class="fc" id="L2240">				}</span>
<span class="fc" id="L2241">				return true;</span>
			}

			@Override
			public int hashCode() {
<span class="nc" id="L2246">				int h = 0;</span>
<span class="nc" id="L2247">				WeightsImpl.Index.Double w = weights();</span>
<span class="nc" id="L2248">				int size = w.size();</span>
<span class="nc bnc" id="L2249" title="All 2 branches missed.">				for (int idx = 0; idx &lt; size; idx++)</span>
					/* we must use addition, order shouldn't matter */
<span class="nc" id="L2251">					h += java.lang.Double.hashCode(w.getDouble(idx));</span>
<span class="nc" id="L2252">				return h;</span>
			}

			@Override
			public String toString() {
<span class="nc" id="L2257">				WeightsImpl.Index.Double w = weights();</span>
<span class="nc" id="L2258">				int size = w.size();</span>
<span class="nc bnc" id="L2259" title="All 2 branches missed.">				if (size == 0)</span>
<span class="nc" id="L2260">					return &quot;[]&quot;;</span>
<span class="nc" id="L2261">				StringBuilder s = new StringBuilder().append('[');</span>
<span class="nc" id="L2262">				for (int idx = 0;; idx++) {</span>
<span class="nc" id="L2263">					int id = indexMap.indexToId(idx);</span>
<span class="nc" id="L2264">					s.append(id).append('=').append(w.getDouble(idx));</span>
<span class="nc bnc" id="L2265" title="All 2 branches missed.">					if (idx == size - 1)</span>
<span class="nc" id="L2266">						break;</span>
<span class="nc" id="L2267">					s.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L2269">				return s.append(']').toString();</span>
			}
		}

		static class Bool extends Mapped&lt;Boolean&gt; implements Weights.Bool {
			Bool(WeightsImpl.Index.Bool container, IndexIdMap indexMap) {
<span class="fc" id="L2275">				super(container, indexMap);</span>
<span class="fc" id="L2276">			}</span>

			@Override
			WeightsImpl.Index.Bool weights() {
<span class="fc" id="L2280">				return (WeightsImpl.Index.Bool) super.weights();</span>
			}

			@Override
			public boolean getBool(int id) {
<span class="fc" id="L2285">				return weights().getBool(indexMap.idToIndex(id));</span>
			}

			@Override
			public void set(int id, boolean weight) {
<span class="fc" id="L2290">				weights().set(indexMap.idToIndex(id), weight);</span>
<span class="fc" id="L2291">			}</span>

			@Override
			public boolean defaultWeightBool() {
<span class="fc" id="L2295">				return weights().defaultWeightBool();</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="fc bfc" id="L2300" title="All 2 branches covered.">				if (other == this)</span>
<span class="fc" id="L2301">					return true;</span>
<span class="pc bpc" id="L2302" title="1 of 4 branches missed.">				if (!(other instanceof WeightsImpl &amp;&amp; other instanceof Weights.Bool))</span>
<span class="fc" id="L2303">					return false;</span>
<span class="fc" id="L2304">				Weights.Bool o = (Weights.Bool) other;</span>

<span class="fc" id="L2306">				WeightsImpl.Index.Bool w = weights();</span>
<span class="fc" id="L2307">				int size = w.size();</span>
<span class="pc bpc" id="L2308" title="1 of 2 branches missed.">				if (size != ((WeightsImpl&lt;?&gt;) other).size())</span>
<span class="nc" id="L2309">					return false;</span>
				try {
<span class="fc bfc" id="L2311" title="All 2 branches covered.">					for (int idx = 0; idx &lt; size; idx++)</span>
<span class="pc bpc" id="L2312" title="1 of 2 branches missed.">						if (w.getBool(idx) != o.getBool(indexMap.indexToId(idx)))</span>
<span class="nc" id="L2313">							return false;</span>
<span class="nc" id="L2314">				} catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L2315">					return false;</span>
<span class="fc" id="L2316">				}</span>
<span class="fc" id="L2317">				return true;</span>
			}

			@Override
			public int hashCode() {
<span class="nc" id="L2322">				int h = 0;</span>
<span class="nc" id="L2323">				WeightsImpl.Index.Bool w = weights();</span>
<span class="nc" id="L2324">				int size = w.size();</span>
<span class="nc bnc" id="L2325" title="All 2 branches missed.">				for (int idx = 0; idx &lt; size; idx++)</span>
					/* we must use addition, order shouldn't matter */
<span class="nc" id="L2327">					h += Boolean.hashCode(w.getBool(idx));</span>
<span class="nc" id="L2328">				return h;</span>
			}

			@Override
			public String toString() {
<span class="nc" id="L2333">				WeightsImpl.Index.Bool w = weights();</span>
<span class="nc" id="L2334">				int size = w.size();</span>
<span class="nc bnc" id="L2335" title="All 2 branches missed.">				if (size == 0)</span>
<span class="nc" id="L2336">					return &quot;[]&quot;;</span>
<span class="nc" id="L2337">				StringBuilder s = new StringBuilder().append('[');</span>
<span class="nc" id="L2338">				for (int idx = 0;; idx++) {</span>
<span class="nc" id="L2339">					int id = indexMap.indexToId(idx);</span>
<span class="nc" id="L2340">					s.append(id).append('=').append(w.getBool(idx));</span>
<span class="nc bnc" id="L2341" title="All 2 branches missed.">					if (idx == size - 1)</span>
<span class="nc" id="L2342">						break;</span>
<span class="nc" id="L2343">					s.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L2345">				return s.append(']').toString();</span>
			}
		}

		static class Char extends Mapped&lt;Character&gt; implements Weights.Char {
			Char(WeightsImpl.Index.Char container, IndexIdMap indexMap) {
<span class="fc" id="L2351">				super(container, indexMap);</span>
<span class="fc" id="L2352">			}</span>

			@Override
			WeightsImpl.Index.Char weights() {
<span class="fc" id="L2356">				return (WeightsImpl.Index.Char) super.weights();</span>
			}

			@Override
			public char getChar(int id) {
<span class="fc" id="L2361">				return weights().getChar(indexMap.idToIndex(id));</span>
			}

			@Override
			public void set(int id, char weight) {
<span class="fc" id="L2366">				weights().set(indexMap.idToIndex(id), weight);</span>
<span class="fc" id="L2367">			}</span>

			@Override
			public char defaultWeightChar() {
<span class="fc" id="L2371">				return weights().defaultWeightChar();</span>
			}

			@Override
			public boolean equals(Object other) {
<span class="fc bfc" id="L2376" title="All 2 branches covered.">				if (other == this)</span>
<span class="fc" id="L2377">					return true;</span>
<span class="pc bpc" id="L2378" title="1 of 4 branches missed.">				if (!(other instanceof WeightsImpl &amp;&amp; other instanceof Weights.Char))</span>
<span class="fc" id="L2379">					return false;</span>
<span class="fc" id="L2380">				Weights.Char o = (Weights.Char) other;</span>

<span class="fc" id="L2382">				WeightsImpl.Index.Char w = weights();</span>
<span class="fc" id="L2383">				int size = w.size();</span>
<span class="pc bpc" id="L2384" title="1 of 2 branches missed.">				if (size != ((WeightsImpl&lt;?&gt;) other).size())</span>
<span class="nc" id="L2385">					return false;</span>
				try {
<span class="fc bfc" id="L2387" title="All 2 branches covered.">					for (int idx = 0; idx &lt; size; idx++)</span>
<span class="pc bpc" id="L2388" title="1 of 2 branches missed.">						if (w.getChar(idx) != o.getChar(indexMap.indexToId(idx)))</span>
<span class="nc" id="L2389">							return false;</span>
<span class="nc" id="L2390">				} catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L2391">					return false;</span>
<span class="fc" id="L2392">				}</span>
<span class="fc" id="L2393">				return true;</span>
			}

			@Override
			public int hashCode() {
<span class="nc" id="L2398">				int h = 0;</span>
<span class="nc" id="L2399">				WeightsImpl.Index.Char w = weights();</span>
<span class="nc" id="L2400">				int size = w.size();</span>
<span class="nc bnc" id="L2401" title="All 2 branches missed.">				for (int idx = 0; idx &lt; size; idx++)</span>
					/* we must use addition, order shouldn't matter */
<span class="nc" id="L2403">					h += w.getChar(idx);</span>
<span class="nc" id="L2404">				return h;</span>
			}

			@Override
			public String toString() {
<span class="nc" id="L2409">				WeightsImpl.Index.Char w = weights();</span>
<span class="nc" id="L2410">				int size = w.size();</span>
<span class="nc bnc" id="L2411" title="All 2 branches missed.">				if (size == 0)</span>
<span class="nc" id="L2412">					return &quot;[]&quot;;</span>
<span class="nc" id="L2413">				StringBuilder s = new StringBuilder().append('[');</span>
<span class="nc" id="L2414">				for (int idx = 0;; idx++) {</span>
<span class="nc" id="L2415">					int id = indexMap.indexToId(idx);</span>
<span class="nc" id="L2416">					s.append(id).append('=').append(w.getChar(idx));</span>
<span class="nc bnc" id="L2417" title="All 2 branches missed.">					if (idx == size - 1)</span>
<span class="nc" id="L2418">						break;</span>
<span class="nc" id="L2419">					s.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L2421">				return s.append(']').toString();</span>
			}
		}
	}

	/**
	 * Tag interface for graphs that can not be muted/changed/altered
	 *
	 * @author Barak Ugav
	 */
	static interface Immutable&lt;E&gt; extends WeightsImpl&lt;E&gt; {
	}

	static abstract class ImmutableView&lt;E&gt; implements Immutable&lt;E&gt; {

		final WeightsImpl&lt;E&gt; weights;

<span class="fc" id="L2438">		ImmutableView(Weights&lt;E&gt; w) {</span>
<span class="fc" id="L2439">			this.weights = (WeightsImpl&lt;E&gt;) Objects.requireNonNull(w);</span>
<span class="fc" id="L2440">		}</span>

		Weights&lt;E&gt; weights() {
<span class="fc" id="L2443">			return weights;</span>
		}

		@Override
		public int size() {
<span class="fc" id="L2448">			return weights.size();</span>
		}

		static class Obj&lt;E&gt; extends ImmutableView&lt;E&gt; {

			Obj(Weights&lt;E&gt; w) {
<span class="fc" id="L2454">				super(w);</span>
<span class="fc" id="L2455">			}</span>

			@Override
			public E get(int id) {
<span class="fc" id="L2459">				return weights().get(id);</span>
			}

			@Override
			public void set(int id, E weight) {
<span class="fc" id="L2464">				throw new UnsupportedOperationException();</span>
			}

			@Override
			public E defaultWeight() {
<span class="fc" id="L2469">				return weights().defaultWeight();</span>
			}
		}

		static class Byte extends ImmutableView&lt;java.lang.Byte&gt; implements Weights.Byte {
			Byte(Weights.Byte w) {
<span class="fc" id="L2475">				super(w);</span>
<span class="fc" id="L2476">			}</span>

			@Override
			Weights.Byte weights() {
<span class="fc" id="L2480">				return (Weights.Byte) super.weights();</span>
			}

			@Override
			public byte getByte(int id) {
<span class="fc" id="L2485">				return weights().getByte(id);</span>
			}

			@Override
			public void set(int id, byte weight) {
<span class="fc" id="L2490">				throw new UnsupportedOperationException();</span>
			}

			@Override
			public byte defaultWeightByte() {
<span class="fc" id="L2495">				return weights().defaultWeightByte();</span>
			}
		}

		static class Short extends ImmutableView&lt;java.lang.Short&gt; implements Weights.Short {
			Short(Weights.Short w) {
<span class="fc" id="L2501">				super(w);</span>
<span class="fc" id="L2502">			}</span>

			@Override
			Weights.Short weights() {
<span class="fc" id="L2506">				return (Weights.Short) super.weights();</span>
			}

			@Override
			public short getShort(int id) {
<span class="fc" id="L2511">				return weights().getShort(id);</span>
			}

			@Override
			public void set(int id, short weight) {
<span class="fc" id="L2516">				throw new UnsupportedOperationException();</span>
			}

			@Override
			public short defaultWeightShort() {
<span class="fc" id="L2521">				return weights().defaultWeightShort();</span>
			}
		}

		static class Int extends ImmutableView&lt;Integer&gt; implements Weights.Int {
			Int(Weights.Int w) {
<span class="fc" id="L2527">				super(w);</span>
<span class="fc" id="L2528">			}</span>

			@Override
			Weights.Int weights() {
<span class="fc" id="L2532">				return (Weights.Int) super.weights();</span>
			}

			@Override
			public int getInt(int id) {
<span class="fc" id="L2537">				return weights().getInt(id);</span>
			}

			@Override
			public void set(int id, int weight) {
<span class="fc" id="L2542">				throw new UnsupportedOperationException();</span>
			}

			@Override
			public int defaultWeightInt() {
<span class="fc" id="L2547">				return weights().defaultWeightInt();</span>
			}
		}

		static class Long extends ImmutableView&lt;java.lang.Long&gt; implements Weights.Long {
			Long(Weights.Long w) {
<span class="fc" id="L2553">				super(w);</span>
<span class="fc" id="L2554">			}</span>

			@Override
			Weights.Long weights() {
<span class="fc" id="L2558">				return (Weights.Long) super.weights();</span>
			}

			@Override
			public long getLong(int id) {
<span class="fc" id="L2563">				return weights().getLong(id);</span>
			}

			@Override
			public void set(int id, long weight) {
<span class="fc" id="L2568">				throw new UnsupportedOperationException();</span>
			}

			@Override
			public long defaultWeightLong() {
<span class="fc" id="L2573">				return weights().defaultWeightLong();</span>
			}
		}

		static class Float extends ImmutableView&lt;java.lang.Float&gt; implements Weights.Float {
			Float(Weights.Float w) {
<span class="fc" id="L2579">				super(w);</span>
<span class="fc" id="L2580">			}</span>

			@Override
			Weights.Float weights() {
<span class="fc" id="L2584">				return (Weights.Float) super.weights();</span>
			}

			@Override
			public float getFloat(int id) {
<span class="fc" id="L2589">				return weights().getFloat(id);</span>
			}

			@Override
			public void set(int id, float weight) {
<span class="fc" id="L2594">				throw new UnsupportedOperationException();</span>
			}

			@Override
			public float defaultWeightFloat() {
<span class="fc" id="L2599">				return weights().defaultWeightFloat();</span>
			}
		}

		static class Double extends ImmutableView&lt;java.lang.Double&gt; implements Weights.Double {
			Double(Weights.Double w) {
<span class="fc" id="L2605">				super(w);</span>
<span class="fc" id="L2606">			}</span>

			@Override
			Weights.Double weights() {
<span class="fc" id="L2610">				return (Weights.Double) super.weights();</span>
			}

			@Override
			public double getDouble(int id) {
<span class="fc" id="L2615">				return weights().getDouble(id);</span>
			}

			@Override
			public void set(int id, double weight) {
<span class="fc" id="L2620">				throw new UnsupportedOperationException();</span>
			}

			@Override
			public double defaultWeightDouble() {
<span class="fc" id="L2625">				return weights().defaultWeightDouble();</span>
			}
		}

		static class Bool extends ImmutableView&lt;Boolean&gt; implements Weights.Bool {
			Bool(Weights.Bool w) {
<span class="fc" id="L2631">				super(w);</span>
<span class="fc" id="L2632">			}</span>

			@Override
			Weights.Bool weights() {
<span class="fc" id="L2636">				return (Weights.Bool) super.weights();</span>
			}

			@Override
			public boolean getBool(int id) {
<span class="fc" id="L2641">				return weights().getBool(id);</span>
			}

			@Override
			public void set(int id, boolean weight) {
<span class="fc" id="L2646">				throw new UnsupportedOperationException();</span>
			}

			@Override
			public boolean defaultWeightBool() {
<span class="fc" id="L2651">				return weights().defaultWeightBool();</span>
			}
		}

		static class Char extends ImmutableView&lt;Character&gt; implements Weights.Char {
			Char(Weights.Char w) {
<span class="fc" id="L2657">				super(w);</span>
<span class="fc" id="L2658">			}</span>

			@Override
			Weights.Char weights() {
<span class="fc" id="L2662">				return (Weights.Char) super.weights();</span>
			}

			@Override
			public char getChar(int id) {
<span class="fc" id="L2667">				return weights().getChar(id);</span>
			}

			@Override
			public void set(int id, char weight) {
<span class="fc" id="L2672">				throw new UnsupportedOperationException();</span>
			}

			@Override
			public char defaultWeightChar() {
<span class="fc" id="L2677">				return weights().defaultWeightChar();</span>
			}
		}
	}

	private static void checkSameSize(IdStrategy i1, IdStrategy i2) {
<span class="pc bpc" id="L2683" title="1 of 2 branches missed.">		if (i1.size() != i2.size())</span>
<span class="nc" id="L2684">			throw new IllegalArgumentException(&quot;IdStrategy size mismatch: &quot; + i1.size() + &quot; != &quot; + i2.size());</span>
<span class="fc" id="L2685">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>