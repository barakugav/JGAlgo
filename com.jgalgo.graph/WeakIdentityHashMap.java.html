<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WeakIdentityHashMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.graph</a> &gt; <span class="el_source">WeakIdentityHashMap.java</span></div><h1>WeakIdentityHashMap.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.graph;

import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;
import java.util.AbstractCollection;
import java.util.AbstractMap;
import java.util.AbstractSet;
import java.util.Arrays;
import java.util.Collection;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Set;
import java.util.WeakHashMap;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import it.unimi.dsi.fastutil.objects.ObjectArrayList;

/**
 * Identity hash map with weak keys.
 * &lt;p&gt;
 * Copied of {@link WeakHashMap} with modifications for identify keys.
 *
 * @author Barak Ugav
 */
class WeakIdentityHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; {

	/**
	 * The default initial capacity -- MUST be a power of two.
	 */
	private static final int DEFAULT_INITIAL_CAPACITY = 16;

	/**
	 * The maximum capacity, used if a higher value is implicitly specified by either of the constructors with
	 * arguments. MUST be a power of two &lt;= 1&lt;&lt;30.
	 */
	private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

	/**
	 * The load factor used when none specified in constructor.
	 */
	private static final float DEFAULT_LOAD_FACTOR = 0.75f;

	/**
	 * The table, resized as necessary. Length MUST Always be a power of two.
	 */
	Entry&lt;K, V&gt;[] table;

	/**
	 * The number of key-value mappings contained in this weak hash map.
	 */
	private int size;

	/**
	 * The next size value at which to resize (capacity * load factor).
	 */
	private int threshold;

	/**
	 * The load factor for the hash table.
	 */
	private final float loadFactor;

	/**
	 * Reference queue for cleared WeakEntries
	 */
<span class="fc" id="L85">	private final ReferenceQueue&lt;Object&gt; queue = new ReferenceQueue&lt;&gt;();</span>

	/**
	 * The number of times this WeakIdentityHashMap has been structurally modified. Structural modifications are those
	 * that change the number of mappings in the map or otherwise modify its internal structure (e.g., rehash). This
	 * field is used to make iterators on Collection-views of the map fail-fast.
	 *
	 * @see ConcurrentModificationException
	 */
	int modCount;

	@SuppressWarnings(&quot;unchecked&quot;)
	private Entry&lt;K, V&gt;[] newTable(int n) {
<span class="fc" id="L98">		return (Entry&lt;K, V&gt;[]) new Entry&lt;?, ?&gt;[n];</span>
	}

	/**
	 * Constructs a new, empty {@code WeakIdentityHashMap} with the given initial capacity and the given load factor.
	 *
	 * @param  initialCapacity          The initial capacity of the {@code WeakIdentityHashMap}
	 * @param  loadFactor               The load factor of the {@code WeakIdentityHashMap}
	 * @throws IllegalArgumentException if the initial capacity is negative, or if the load factor is nonpositive.
	 */
<span class="fc" id="L108">	public WeakIdentityHashMap(int initialCapacity, float loadFactor) {</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">		if (initialCapacity &lt; 0)</span>
<span class="nc" id="L110">			throw new IllegalArgumentException(&quot;Illegal Initial Capacity: &quot; + initialCapacity);</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">		if (initialCapacity &gt; MAXIMUM_CAPACITY)</span>
<span class="nc" id="L112">			initialCapacity = MAXIMUM_CAPACITY;</span>

<span class="pc bpc" id="L114" title="2 of 4 branches missed.">		if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span>
<span class="nc" id="L115">			throw new IllegalArgumentException(&quot;Illegal Load factor: &quot; + loadFactor);</span>
<span class="fc" id="L116">		int capacity = 1;</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">		while (capacity &lt; initialCapacity)</span>
<span class="fc" id="L118">			capacity &lt;&lt;= 1;</span>
<span class="fc" id="L119">		table = newTable(capacity);</span>
<span class="fc" id="L120">		this.loadFactor = loadFactor;</span>
<span class="fc" id="L121">		threshold = (int) (capacity * loadFactor);</span>
<span class="fc" id="L122">	}</span>

	/**
	 * Constructs a new, empty {@code WeakIdentityHashMap} with the given initial capacity and the default load factor
	 * (0.75).
	 *
	 * @param  initialCapacity          The initial capacity of the {@code WeakIdentityHashMap}
	 * @throws IllegalArgumentException if the initial capacity is negative
	 */
	public WeakIdentityHashMap(int initialCapacity) {
<span class="nc" id="L132">		this(initialCapacity, DEFAULT_LOAD_FACTOR);</span>
<span class="nc" id="L133">	}</span>

	/**
	 * Constructs a new, empty {@code WeakIdentityHashMap} with the default initial capacity (16) and load factor
	 * (0.75).
	 */
	public WeakIdentityHashMap() {
<span class="fc" id="L140">		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span>
<span class="fc" id="L141">	}</span>

	/**
	 * Constructs a new {@code WeakIdentityHashMap} with the same mappings as the specified map. The
	 * {@code WeakIdentityHashMap} is created with the default load factor (0.75) and an initial capacity sufficient to
	 * hold the mappings in the specified map.
	 *
	 * @param  m                    the map whose mappings are to be placed in this map
	 * @throws NullPointerException if the specified map is null
	 * @since                       1.3
	 */
	public WeakIdentityHashMap(Map&lt;? extends K, ? extends V&gt; m) {
<span class="nc" id="L153">		this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span>
<span class="nc" id="L154">		putAll(m);</span>
<span class="nc" id="L155">	}</span>

	// internal utilities

	/**
	 * Value representing null keys inside tables.
	 */
<span class="fc" id="L162">	private static final Object NULL_KEY = new Object();</span>

	/**
	 * Use NULL_KEY for key if it is null.
	 */
	private static Object maskNull(Object key) {
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">		return (key == null) ? NULL_KEY : key;</span>
	}

	/**
	 * Returns internal representation of null key back to caller as null.
	 */
	static Object unmaskNull(Object key) {
<span class="nc bnc" id="L175" title="All 2 branches missed.">		return (key == NULL_KEY) ? null : key;</span>
	}

	/**
	 * Checks for equality of non-null reference x and possibly-null y. By default uses Object.equals.
	 */
	private static boolean eq(Object x, Object y) {
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">		return x == y;</span>
	}

	/**
	 * Retrieve object hash code and applies a supplemental hash function to the result hash, which defends against poor
	 * quality hash functions. This is critical because HashMap uses power-of-two length hash tables, that otherwise
	 * encounter collisions for hashCodes that do not differ in lower bits.
	 */
	static final int hash(Object k) {
<span class="fc" id="L191">		int h = System.identityHashCode(k);</span>

		// This function ensures that hashCodes that differ only by
		// constant multiples at each bit position have a bounded
		// number of collisions (approximately 8 at default load factor).
<span class="fc" id="L196">		h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span>
<span class="fc" id="L197">		return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span>
	}

	/**
	 * Returns index for hash code h.
	 */
	private static int indexFor(int h, int length) {
<span class="fc" id="L204">		return h &amp; (length - 1);</span>
	}

	/**
	 * Expunges stale entries from the table.
	 */
	private void expungeStaleEntries() {
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">		for (Object x; (x = queue.poll()) != null;) {</span>
<span class="nc" id="L212">			synchronized (queue) {</span>
				@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L214">				Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) x;</span>
<span class="nc" id="L215">				int i = indexFor(e.hash, table.length);</span>

<span class="nc" id="L217">				Entry&lt;K, V&gt; prev = table[i];</span>
<span class="nc" id="L218">				Entry&lt;K, V&gt; p = prev;</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">				while (p != null) {</span>
<span class="nc" id="L220">					Entry&lt;K, V&gt; next = p.next;</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">					if (p == e) {</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">						if (prev == e)</span>
<span class="nc" id="L223">							table[i] = next;</span>
						else
<span class="nc" id="L225">							prev.next = next;</span>
						// Must not null out e.next;
						// stale entries may be in use by a HashIterator
<span class="nc" id="L228">						e.value = null; // Help GC</span>
<span class="nc" id="L229">						size--;</span>
<span class="nc" id="L230">						break;</span>
					}
<span class="nc" id="L232">					prev = p;</span>
<span class="nc" id="L233">					p = next;</span>
<span class="nc" id="L234">				}</span>
<span class="nc" id="L235">			}</span>
		}
<span class="fc" id="L237">	}</span>

	/**
	 * Returns the table after first expunging stale entries.
	 */
	private Entry&lt;K, V&gt;[] getTable() {
<span class="fc" id="L243">		expungeStaleEntries();</span>
<span class="fc" id="L244">		return table;</span>
	}

	/**
	 * Returns the number of key-value mappings in this map. This result is a snapshot, and may not reflect unprocessed
	 * entries that will be removed before next attempted access because they are no longer referenced.
	 */
	@Override
	public int size() {
<span class="nc bnc" id="L253" title="All 2 branches missed.">		if (size == 0)</span>
<span class="nc" id="L254">			return 0;</span>
<span class="nc" id="L255">		expungeStaleEntries();</span>
<span class="nc" id="L256">		return size;</span>
	}

	/**
	 * Returns {@code true} if this map contains no key-value mappings. This result is a snapshot, and may not reflect
	 * unprocessed entries that will be removed before next attempted access because they are no longer referenced.
	 */
	@Override
	public boolean isEmpty() {
<span class="nc bnc" id="L265" title="All 2 branches missed.">		return size() == 0;</span>
	}

	/**
	 * Returns the value to which the specified key is mapped, or {@code null} if this map contains no mapping for the
	 * key.
	 * &lt;p&gt;
	 * More formally, if this map contains a mapping from a key {@code k} to a value {@code v} such that
	 * {@code key == k}, then this method returns {@code v}; otherwise it returns {@code null}. (There can be at most
	 * one such mapping.)
	 * &lt;p&gt;
	 * A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt; indicate that the map contains no mapping for the key;
	 * it's also possible that the map explicitly maps the key to {@code null}. The {@link #containsKey containsKey}
	 * operation may be used to distinguish these two cases.
	 *
	 * @see #put(Object, Object)
	 */
	@Override
	public V get(Object key) {
<span class="fc" id="L284">		Object k = maskNull(key);</span>
<span class="fc" id="L285">		int h = hash(k);</span>
<span class="fc" id="L286">		Entry&lt;K, V&gt;[] tab = getTable();</span>
<span class="fc" id="L287">		int index = indexFor(h, tab.length);</span>
<span class="fc" id="L288">		Entry&lt;K, V&gt; e = tab[index];</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">		while (e != null) {</span>
<span class="pc bpc" id="L290" title="1 of 4 branches missed.">			if (e.hash == h &amp;&amp; eq(k, e.get()))</span>
<span class="fc" id="L291">				return e.value;</span>
<span class="fc" id="L292">			e = e.next;</span>
		}
<span class="fc" id="L294">		return null;</span>
	}

	/**
	 * Returns {@code true} if this map contains a mapping for the specified key.
	 *
	 * @param  key The key whose presence in this map is to be tested
	 * @return     {@code true} if there is a mapping for {@code key}; {@code false} otherwise
	 */
	@Override
	public boolean containsKey(Object key) {
<span class="nc bnc" id="L305" title="All 2 branches missed.">		return getEntry(key) != null;</span>
	}

	/**
	 * Returns the entry associated with the specified key in this map. Returns null if the map contains no mapping for
	 * this key.
	 */
	Entry&lt;K, V&gt; getEntry(Object key) {
<span class="nc" id="L313">		Object k = maskNull(key);</span>
<span class="nc" id="L314">		int h = hash(k);</span>
<span class="nc" id="L315">		Entry&lt;K, V&gt;[] tab = getTable();</span>
<span class="nc" id="L316">		int index = indexFor(h, tab.length);</span>
<span class="nc" id="L317">		Entry&lt;K, V&gt; e = tab[index];</span>
<span class="nc bnc" id="L318" title="All 6 branches missed.">		while (e != null &amp;&amp; !(e.hash == h &amp;&amp; eq(k, e.get())))</span>
<span class="nc" id="L319">			e = e.next;</span>
<span class="nc" id="L320">		return e;</span>
	}

	/**
	 * Associates the specified value with the specified key in this map. If the map previously contained a mapping for
	 * this key, the old value is replaced.
	 *
	 * @param  key   key with which the specified value is to be associated.
	 * @param  value value to be associated with the specified key.
	 * @return       the previous value associated with {@code key}, or {@code null} if there was no mapping for
	 *               {@code key}. (A {@code null} return can also indicate that the map previously associated
	 *               {@code null} with {@code key}.)
	 */
	@Override
	public V put(K key, V value) {
<span class="fc" id="L335">		Object k = maskNull(key);</span>
<span class="fc" id="L336">		int h = hash(k);</span>
<span class="fc" id="L337">		Entry&lt;K, V&gt;[] tab = getTable();</span>
<span class="fc" id="L338">		int i = indexFor(h, tab.length);</span>

<span class="fc bfc" id="L340" title="All 2 branches covered.">		for (Entry&lt;K, V&gt; e = tab[i]; e != null; e = e.next) {</span>
<span class="pc bpc" id="L341" title="3 of 4 branches missed.">			if (h == e.hash &amp;&amp; eq(k, e.get())) {</span>
<span class="nc" id="L342">				V oldValue = e.value;</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">				if (value != oldValue)</span>
<span class="nc" id="L344">					e.value = value;</span>
<span class="nc" id="L345">				return oldValue;</span>
			}
		}

<span class="fc" id="L349">		modCount++;</span>
<span class="fc" id="L350">		Entry&lt;K, V&gt; e = tab[i];</span>
<span class="fc" id="L351">		tab[i] = new Entry&lt;&gt;(k, value, queue, h, e);</span>
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">		if (++size &gt;= threshold)</span>
<span class="nc" id="L353">			resize(tab.length * 2);</span>
<span class="fc" id="L354">		return null;</span>
	}

	/**
	 * Rehashes the contents of this map into a new array with a larger capacity. This method is called automatically
	 * when the number of keys in this map reaches its threshold.
	 *
	 * If current capacity is MAXIMUM_CAPACITY, this method does not resize the map, but sets threshold to
	 * Integer.MAX_VALUE. This has the effect of preventing future calls.
	 *
	 * @param newCapacity the new capacity, MUST be a power of two; must be greater than current capacity unless current
	 *                        capacity is MAXIMUM_CAPACITY (in which case value is irrelevant).
	 */
	void resize(int newCapacity) {
<span class="nc" id="L368">		Entry&lt;K, V&gt;[] oldTable = getTable();</span>
<span class="nc" id="L369">		int oldCapacity = oldTable.length;</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">		if (oldCapacity == MAXIMUM_CAPACITY) {</span>
<span class="nc" id="L371">			threshold = Integer.MAX_VALUE;</span>
<span class="nc" id="L372">			return;</span>
		}

<span class="nc" id="L375">		Entry&lt;K, V&gt;[] newTable = newTable(newCapacity);</span>
<span class="nc" id="L376">		transfer(oldTable, newTable);</span>
<span class="nc" id="L377">		table = newTable;</span>

		/*
		 * If ignoring null elements and processing ref queue caused massive shrinkage, then restore old table. This
		 * should be rare, but avoids unbounded expansion of garbage-filled tables.
		 */
<span class="nc bnc" id="L383" title="All 2 branches missed.">		if (size &gt;= threshold / 2) {</span>
<span class="nc" id="L384">			threshold = (int) (newCapacity * loadFactor);</span>
		} else {
<span class="nc" id="L386">			expungeStaleEntries();</span>
<span class="nc" id="L387">			transfer(newTable, oldTable);</span>
<span class="nc" id="L388">			table = oldTable;</span>
		}
<span class="nc" id="L390">	}</span>

	/** Transfers all entries from src to dest tables */
	private void transfer(Entry&lt;K, V&gt;[] src, Entry&lt;K, V&gt;[] dest) {
<span class="nc bnc" id="L394" title="All 2 branches missed.">		for (int j = 0; j &lt; src.length; ++j) {</span>
<span class="nc" id="L395">			Entry&lt;K, V&gt; e = src[j];</span>
<span class="nc" id="L396">			src[j] = null;</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">			while (e != null) {</span>
<span class="nc" id="L398">				Entry&lt;K, V&gt; next = e.next;</span>
<span class="nc" id="L399">				Object key = e.get();</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">				if (key == null) {</span>
<span class="nc" id="L401">					e.next = null; // Help GC</span>
<span class="nc" id="L402">					e.value = null; // &quot; &quot;</span>
<span class="nc" id="L403">					size--;</span>
				} else {
<span class="nc" id="L405">					int i = indexFor(e.hash, dest.length);</span>
<span class="nc" id="L406">					e.next = dest[i];</span>
<span class="nc" id="L407">					dest[i] = e;</span>
				}
<span class="nc" id="L409">				e = next;</span>
<span class="nc" id="L410">			}</span>
		}
<span class="nc" id="L412">	}</span>

	/**
	 * Copies all of the mappings from the specified map to this map. These mappings will replace any mappings that this
	 * map had for any of the keys currently in the specified map.
	 *
	 * @param  m                    mappings to be stored in this map.
	 * @throws NullPointerException if the specified map is null.
	 */
	@Override
	public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
<span class="nc" id="L423">		int numKeysToBeAdded = m.size();</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">		if (numKeysToBeAdded == 0)</span>
<span class="nc" id="L425">			return;</span>

		/*
		 * Expand the map if the map if the number of mappings to be added is greater than or equal to threshold. This
		 * is conservative; the obvious condition is (m.size() + size) &gt;= threshold, but this condition could result in
		 * a map with twice the appropriate capacity, if the keys to be added overlap with the keys already in this map.
		 * By using the conservative calculation, we subject ourself to at most one extra resize.
		 */
<span class="nc bnc" id="L433" title="All 2 branches missed.">		if (numKeysToBeAdded &gt; threshold) {</span>
<span class="nc" id="L434">			int targetCapacity = (int) (numKeysToBeAdded / loadFactor + 1);</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">			if (targetCapacity &gt; MAXIMUM_CAPACITY)</span>
<span class="nc" id="L436">				targetCapacity = MAXIMUM_CAPACITY;</span>
<span class="nc" id="L437">			int newCapacity = table.length;</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">			while (newCapacity &lt; targetCapacity)</span>
<span class="nc" id="L439">				newCapacity &lt;&lt;= 1;</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">			if (newCapacity &gt; table.length)</span>
<span class="nc" id="L441">				resize(newCapacity);</span>
		}

<span class="nc bnc" id="L444" title="All 2 branches missed.">		for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span>
<span class="nc" id="L445">			put(e.getKey(), e.getValue());</span>
<span class="nc" id="L446">	}</span>

	/**
	 * Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a
	 * mapping from key {@code k} to value {@code v} such that &lt;code&gt;(key==k)&lt;/code&gt;, that mapping is removed. (The map
	 * can contain at most one such mapping.)
	 * &lt;p&gt;
	 * Returns the value to which this map previously associated the key, or {@code null} if the map contained no
	 * mapping for the key. A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt; indicate that the map contained
	 * no mapping for the key; it's also possible that the map explicitly mapped the key to {@code null}.
	 * &lt;p&gt;
	 * The map will not contain a mapping for the specified key once the call returns.
	 *
	 * @param  key key whose mapping is to be removed from the map
	 * @return     the previous value associated with {@code key}, or {@code null} if there was no mapping for
	 *             {@code key}
	 */
	@Override
	public V remove(Object key) {
<span class="nc" id="L465">		Object k = maskNull(key);</span>
<span class="nc" id="L466">		int h = hash(k);</span>
<span class="nc" id="L467">		Entry&lt;K, V&gt;[] tab = getTable();</span>
<span class="nc" id="L468">		int i = indexFor(h, tab.length);</span>
<span class="nc" id="L469">		Entry&lt;K, V&gt; prev = tab[i];</span>
<span class="nc" id="L470">		Entry&lt;K, V&gt; e = prev;</span>

<span class="nc bnc" id="L472" title="All 2 branches missed.">		while (e != null) {</span>
<span class="nc" id="L473">			Entry&lt;K, V&gt; next = e.next;</span>
<span class="nc bnc" id="L474" title="All 4 branches missed.">			if (h == e.hash &amp;&amp; eq(k, e.get())) {</span>
<span class="nc" id="L475">				modCount++;</span>
<span class="nc" id="L476">				size--;</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">				if (prev == e)</span>
<span class="nc" id="L478">					tab[i] = next;</span>
				else
<span class="nc" id="L480">					prev.next = next;</span>
<span class="nc" id="L481">				return e.value;</span>
			}
<span class="nc" id="L483">			prev = e;</span>
<span class="nc" id="L484">			e = next;</span>
<span class="nc" id="L485">		}</span>

<span class="nc" id="L487">		return null;</span>
	}

	/** Special version of remove needed by Entry set */
	boolean removeMapping(Object o) {
<span class="nc bnc" id="L492" title="All 2 branches missed.">		if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L493">			return false;</span>
<span class="nc" id="L494">		Entry&lt;K, V&gt;[] tab = getTable();</span>
<span class="nc" id="L495">		Map.Entry&lt;?, ?&gt; entry = (Map.Entry&lt;?, ?&gt;) o;</span>
<span class="nc" id="L496">		Object k = maskNull(entry.getKey());</span>
<span class="nc" id="L497">		int h = hash(k);</span>
<span class="nc" id="L498">		int i = indexFor(h, tab.length);</span>
<span class="nc" id="L499">		Entry&lt;K, V&gt; prev = tab[i];</span>
<span class="nc" id="L500">		Entry&lt;K, V&gt; e = prev;</span>

<span class="nc bnc" id="L502" title="All 2 branches missed.">		while (e != null) {</span>
<span class="nc" id="L503">			Entry&lt;K, V&gt; next = e.next;</span>
<span class="nc bnc" id="L504" title="All 4 branches missed.">			if (h == e.hash &amp;&amp; e.equals(entry)) {</span>
<span class="nc" id="L505">				modCount++;</span>
<span class="nc" id="L506">				size--;</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">				if (prev == e)</span>
<span class="nc" id="L508">					tab[i] = next;</span>
				else
<span class="nc" id="L510">					prev.next = next;</span>
<span class="nc" id="L511">				return true;</span>
			}
<span class="nc" id="L513">			prev = e;</span>
<span class="nc" id="L514">			e = next;</span>
<span class="nc" id="L515">		}</span>

<span class="nc" id="L517">		return false;</span>
	}

	/**
	 * Removes all of the mappings from this map. The map will be empty after this call returns.
	 */
	@Override
	public void clear() {
		// clear out ref queue. We don't need to expunge entries
		// since table is getting cleared.
<span class="nc bnc" id="L527" title="All 2 branches missed.">		while (queue.poll() != null);</span>

<span class="nc" id="L529">		modCount++;</span>
<span class="nc" id="L530">		Arrays.fill(table, null);</span>
<span class="nc" id="L531">		size = 0;</span>

		// Allocation of array may have caused GC, which may have caused
		// additional entries to go stale. Removing these entries from the
		// reference queue will make them eligible for reclamation.
<span class="nc bnc" id="L536" title="All 2 branches missed.">		while (queue.poll() != null);</span>
<span class="nc" id="L537">	}</span>

	/**
	 * Returns {@code true} if this map maps one or more keys to the specified value.
	 *
	 * @param  value value whose presence in this map is to be tested
	 * @return       {@code true} if this map maps one or more keys to the specified value
	 */
	@Override
	public boolean containsValue(Object value) {
<span class="nc bnc" id="L547" title="All 2 branches missed.">		if (value == null)</span>
<span class="nc" id="L548">			return containsNullValue();</span>

<span class="nc" id="L550">		Entry&lt;K, V&gt;[] tab = getTable();</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">		for (int i = tab.length; i-- &gt; 0;)</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">			for (Entry&lt;K, V&gt; e = tab[i]; e != null; e = e.next)</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">				if (value.equals(e.value))</span>
<span class="nc" id="L554">					return true;</span>
<span class="nc" id="L555">		return false;</span>
	}

	/**
	 * Special-case code for containsValue with null argument
	 */
	private boolean containsNullValue() {
<span class="nc" id="L562">		Entry&lt;K, V&gt;[] tab = getTable();</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">		for (int i = tab.length; i-- &gt; 0;)</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">			for (Entry&lt;K, V&gt; e = tab[i]; e != null; e = e.next)</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">				if (e.value == null)</span>
<span class="nc" id="L566">					return true;</span>
<span class="nc" id="L567">		return false;</span>
	}

	/**
	 * The entries in this hash table extend WeakReference, using its main ref field as the key.
	 */
	private static class Entry&lt;K, V&gt; extends WeakReference&lt;Object&gt; implements Map.Entry&lt;K, V&gt; {
		V value;
		final int hash;
		Entry&lt;K, V&gt; next;

		/**
		 * Creates new entry.
		 */
		Entry(Object key, V value, ReferenceQueue&lt;Object&gt; queue, int hash, Entry&lt;K, V&gt; next) {
<span class="fc" id="L582">			super(key, queue);</span>
<span class="fc" id="L583">			this.value = value;</span>
<span class="fc" id="L584">			this.hash = hash;</span>
<span class="fc" id="L585">			this.next = next;</span>
<span class="fc" id="L586">		}</span>

		@Override
		@SuppressWarnings(&quot;unchecked&quot;)
		public K getKey() {
<span class="nc" id="L591">			return (K) WeakIdentityHashMap.unmaskNull(get());</span>
		}

		@Override
		public V getValue() {
<span class="nc" id="L596">			return value;</span>
		}

		@Override
		public V setValue(V newValue) {
<span class="nc" id="L601">			V oldValue = value;</span>
<span class="nc" id="L602">			value = newValue;</span>
<span class="nc" id="L603">			return oldValue;</span>
		}

		@Override
		public boolean equals(Object o) {
<span class="nc bnc" id="L608" title="All 2 branches missed.">			if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L609">				return false;</span>
<span class="nc" id="L610">			Map.Entry&lt;?, ?&gt; e = (Map.Entry&lt;?, ?&gt;) o;</span>
<span class="nc" id="L611">			K k1 = getKey();</span>
<span class="nc" id="L612">			Object k2 = e.getKey();</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">			if (k1 == k2) {</span>
<span class="nc" id="L614">				V v1 = getValue();</span>
<span class="nc" id="L615">				Object v2 = e.getValue();</span>
<span class="nc bnc" id="L616" title="All 6 branches missed.">				if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))</span>
<span class="nc" id="L617">					return true;</span>
			}
<span class="nc" id="L619">			return false;</span>
		}

		@Override
		public int hashCode() {
<span class="nc" id="L624">			K k = getKey();</span>
<span class="nc" id="L625">			V v = getValue();</span>
<span class="nc" id="L626">			return System.identityHashCode(k) ^ Objects.hashCode(v);</span>
		}

		@Override
		public String toString() {
<span class="nc" id="L631">			return getKey() + &quot;=&quot; + getValue();</span>
		}
	}

	private abstract class HashIterator&lt;T&gt; implements Iterator&lt;T&gt; {
		private int index;
		private Entry&lt;K, V&gt; entry;
		private Entry&lt;K, V&gt; lastReturned;
<span class="nc" id="L639">		private int expectedModCount = modCount;</span>

		/**
		 * Strong reference needed to avoid disappearance of key between hasNext and next
		 */
		private Object nextKey;

		/**
		 * Strong reference needed to avoid disappearance of key between nextEntry() and any use of the entry
		 */
		private Object currentKey;

<span class="nc" id="L651">		HashIterator() {</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">			index = isEmpty() ? 0 : table.length;</span>
<span class="nc" id="L653">		}</span>

		@Override
		public boolean hasNext() {
<span class="nc" id="L657">			Entry&lt;K, V&gt;[] t = table;</span>

<span class="nc bnc" id="L659" title="All 2 branches missed.">			while (nextKey == null) {</span>
<span class="nc" id="L660">				Entry&lt;K, V&gt; e = entry;</span>
<span class="nc" id="L661">				int i = index;</span>
<span class="nc bnc" id="L662" title="All 4 branches missed.">				while (e == null &amp;&amp; i &gt; 0)</span>
<span class="nc" id="L663">					e = t[--i];</span>
<span class="nc" id="L664">				entry = e;</span>
<span class="nc" id="L665">				index = i;</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">				if (e == null) {</span>
<span class="nc" id="L667">					currentKey = null;</span>
<span class="nc" id="L668">					return false;</span>
				}
<span class="nc" id="L670">				nextKey = e.get(); // hold on to key in strong ref</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">				if (nextKey == null)</span>
<span class="nc" id="L672">					entry = entry.next;</span>
<span class="nc" id="L673">			}</span>
<span class="nc" id="L674">			return true;</span>
		}

		/** The common parts of next() across different types of iterators */
		protected Entry&lt;K, V&gt; nextEntry() {
<span class="nc bnc" id="L679" title="All 2 branches missed.">			if (modCount != expectedModCount)</span>
<span class="nc" id="L680">				throw new ConcurrentModificationException();</span>
<span class="nc bnc" id="L681" title="All 4 branches missed.">			if (nextKey == null &amp;&amp; !hasNext())</span>
<span class="nc" id="L682">				throw new NoSuchElementException();</span>

<span class="nc" id="L684">			lastReturned = entry;</span>
<span class="nc" id="L685">			entry = entry.next;</span>
<span class="nc" id="L686">			currentKey = nextKey;</span>
<span class="nc" id="L687">			nextKey = null;</span>
<span class="nc" id="L688">			return lastReturned;</span>
		}

		@Override
		public void remove() {
<span class="nc bnc" id="L693" title="All 2 branches missed.">			if (lastReturned == null)</span>
<span class="nc" id="L694">				throw new IllegalStateException();</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">			if (modCount != expectedModCount)</span>
<span class="nc" id="L696">				throw new ConcurrentModificationException();</span>

<span class="nc" id="L698">			WeakIdentityHashMap.this.remove(currentKey);</span>
<span class="nc" id="L699">			expectedModCount = modCount;</span>
<span class="nc" id="L700">			lastReturned = null;</span>
<span class="nc" id="L701">			currentKey = null;</span>
<span class="nc" id="L702">		}</span>

	}

<span class="nc" id="L706">	private class ValueIterator extends HashIterator&lt;V&gt; {</span>
		@Override
		public V next() {
<span class="nc" id="L709">			return nextEntry().value;</span>
		}
	}

<span class="nc" id="L713">	private class KeyIterator extends HashIterator&lt;K&gt; {</span>
		@Override
		public K next() {
<span class="nc" id="L716">			return nextEntry().getKey();</span>
		}
	}

<span class="nc" id="L720">	private class EntryIterator extends HashIterator&lt;Map.Entry&lt;K, V&gt;&gt; {</span>
		@Override
		public Map.Entry&lt;K, V&gt; next() {
<span class="nc" id="L723">			return nextEntry();</span>
		}
	}

	// Views

	private transient Set&lt;K&gt; keySet;
	private transient Collection&lt;V&gt; values;
	private transient Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet;

	/**
	 * Returns a {@link Set} view of the keys contained in this map. The set is backed by the map, so changes to the map
	 * are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress
	 * (except through the iterator's own {@code remove} operation), the results of the iteration are undefined. The set
	 * supports element removal, which removes the corresponding mapping from the map, via the {@code Iterator.remove},
	 * {@code Set.remove}, {@code removeAll}, {@code retainAll}, and {@code clear} operations. It does not support the
	 * {@code add} or {@code addAll} operations.
	 */
	@Override
	public Set&lt;K&gt; keySet() {
<span class="nc" id="L743">		Set&lt;K&gt; ks = keySet;</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">		if (ks == null) {</span>
<span class="nc" id="L745">			ks = new KeySet();</span>
<span class="nc" id="L746">			keySet = ks;</span>
		}
<span class="nc" id="L748">		return ks;</span>
	}

<span class="nc" id="L751">	private class KeySet extends AbstractSet&lt;K&gt; {</span>
		@Override
		public Iterator&lt;K&gt; iterator() {
<span class="nc" id="L754">			return new KeyIterator();</span>
		}

		@Override
		public int size() {
<span class="nc" id="L759">			return WeakIdentityHashMap.this.size();</span>
		}

		@Override
		public boolean contains(Object o) {
<span class="nc" id="L764">			return containsKey(o);</span>
		}

		@Override
		public boolean remove(Object o) {
<span class="nc bnc" id="L769" title="All 2 branches missed.">			if (containsKey(o)) {</span>
<span class="nc" id="L770">				WeakIdentityHashMap.this.remove(o);</span>
<span class="nc" id="L771">				return true;</span>
			} else
<span class="nc" id="L773">				return false;</span>
		}

		@Override
		public void clear() {
<span class="nc" id="L778">			WeakIdentityHashMap.this.clear();</span>
<span class="nc" id="L779">		}</span>
	}

	/**
	 * Returns a {@link Collection} view of the values contained in this map. The collection is backed by the map, so
	 * changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration
	 * over the collection is in progress (except through the iterator's own {@code remove} operation), the results of
	 * the iteration are undefined. The collection supports element removal, which removes the corresponding mapping
	 * from the map, via the {@code Iterator.remove}, {@code Collection.remove}, {@code removeAll}, {@code retainAll}
	 * and {@code clear} operations. It does not support the {@code add} or {@code addAll} operations.
	 */
	@Override
	public Collection&lt;V&gt; values() {
<span class="nc" id="L792">		Collection&lt;V&gt; vs = values;</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">		if (vs == null) {</span>
<span class="nc" id="L794">			vs = new Values();</span>
<span class="nc" id="L795">			values = vs;</span>
		}
<span class="nc" id="L797">		return vs;</span>
	}

<span class="nc" id="L800">	private class Values extends AbstractCollection&lt;V&gt; {</span>
		@Override
		public Iterator&lt;V&gt; iterator() {
<span class="nc" id="L803">			return new ValueIterator();</span>
		}

		@Override
		public int size() {
<span class="nc" id="L808">			return WeakIdentityHashMap.this.size();</span>
		}

		@Override
		public boolean contains(Object o) {
<span class="nc" id="L813">			return containsValue(o);</span>
		}

		@Override
		public void clear() {
<span class="nc" id="L818">			WeakIdentityHashMap.this.clear();</span>
<span class="nc" id="L819">		}</span>
	}

	/**
	 * Returns a {@link Set} view of the mappings contained in this map. The set is backed by the map, so changes to the
	 * map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in
	 * progress (except through the iterator's own {@code remove} operation, or through the {@code setValue} operation
	 * on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element
	 * removal, which removes the corresponding mapping from the map, via the {@code Iterator.remove},
	 * {@code Set.remove}, {@code removeAll}, {@code retainAll} and {@code clear} operations. It does not support the
	 * {@code add} or {@code addAll} operations.
	 */
	@Override
	public Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() {
<span class="nc" id="L833">		Set&lt;Map.Entry&lt;K, V&gt;&gt; es = entrySet;</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">		return es != null ? es : (entrySet = new EntrySet());</span>
	}

<span class="nc" id="L837">	private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K, V&gt;&gt; {</span>
		@Override
		public Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator() {
<span class="nc" id="L840">			return new EntryIterator();</span>
		}

		@Override
		public boolean contains(Object o) {
<span class="nc bnc" id="L845" title="All 2 branches missed.">			if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L846">				return false;</span>
<span class="nc" id="L847">			Map.Entry&lt;?, ?&gt; e = (Map.Entry&lt;?, ?&gt;) o;</span>
<span class="nc" id="L848">			Entry&lt;K, V&gt; candidate = getEntry(e.getKey());</span>
<span class="nc bnc" id="L849" title="All 4 branches missed.">			return candidate != null &amp;&amp; candidate.equals(e);</span>
		}

		@Override
		public boolean remove(Object o) {
<span class="nc" id="L854">			return removeMapping(o);</span>
		}

		@Override
		public int size() {
<span class="nc" id="L859">			return WeakIdentityHashMap.this.size();</span>
		}

		@Override
		public void clear() {
<span class="nc" id="L864">			WeakIdentityHashMap.this.clear();</span>
<span class="nc" id="L865">		}</span>

		private List&lt;Map.Entry&lt;K, V&gt;&gt; deepCopy() {
<span class="nc" id="L868">			List&lt;Map.Entry&lt;K, V&gt;&gt; list = new ObjectArrayList&lt;&gt;(size());</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">			for (Map.Entry&lt;K, V&gt; e : this)</span>
<span class="nc" id="L870">				list.add(new AbstractMap.SimpleEntry&lt;&gt;(e));</span>
<span class="nc" id="L871">			return list;</span>
		}

		@Override
		public Object[] toArray() {
<span class="nc" id="L876">			return deepCopy().toArray();</span>
		}

		@Override
		public &lt;T&gt; T[] toArray(T[] a) {
<span class="nc" id="L881">			return deepCopy().toArray(a);</span>
		}
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	@Override
	public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
<span class="nc" id="L888">		Objects.requireNonNull(action);</span>
<span class="nc" id="L889">		int expectedModCount = modCount;</span>

<span class="nc" id="L891">		Entry&lt;K, V&gt;[] tab = getTable();</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">		for (Entry&lt;K, V&gt; entry : tab) {</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">			while (entry != null) {</span>
<span class="nc" id="L894">				Object key = entry.get();</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">				if (key != null) {</span>
<span class="nc" id="L896">					action.accept((K) WeakIdentityHashMap.unmaskNull(key), entry.value);</span>
				}
<span class="nc" id="L898">				entry = entry.next;</span>

<span class="nc bnc" id="L900" title="All 2 branches missed.">				if (expectedModCount != modCount) {</span>
<span class="nc" id="L901">					throw new ConcurrentModificationException();</span>
				}
<span class="nc" id="L903">			}</span>
		}
<span class="nc" id="L905">	}</span>

	@SuppressWarnings(&quot;unchecked&quot;)
	@Override
	public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {
<span class="nc" id="L910">		Objects.requireNonNull(function);</span>
<span class="nc" id="L911">		int expectedModCount = modCount;</span>

<span class="nc" id="L913">		Entry&lt;K, V&gt;[] tab = getTable();;</span>
<span class="nc bnc" id="L914" title="All 2 branches missed.">		for (Entry&lt;K, V&gt; entry : tab) {</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">			while (entry != null) {</span>
<span class="nc" id="L916">				Object key = entry.get();</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">				if (key != null) {</span>
<span class="nc" id="L918">					entry.value = function.apply((K) WeakIdentityHashMap.unmaskNull(key), entry.value);</span>
				}
<span class="nc" id="L920">				entry = entry.next;</span>

<span class="nc bnc" id="L922" title="All 2 branches missed.">				if (expectedModCount != modCount) {</span>
<span class="nc" id="L923">					throw new ConcurrentModificationException();</span>
				}
<span class="nc" id="L925">			}</span>
		}
<span class="nc" id="L927">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>