<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IntGraph.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.graph</a> &gt; <span class="el_source">IntGraph.java</span></div><h1>IntGraph.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jgalgo.graph;

import java.util.Collection;
import java.util.Map;
import it.unimi.dsi.fastutil.ints.Int2IntMap;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntSet;

/**
 * A discrete graph with {@code int} vertices and edges.
 *
 * &lt;p&gt;
 * This interface is a specification of {@link Graph} for graphs with {@code int} vertices and edges, similarly how
 * {@link Int2IntMap} is a specification of {@link Map} for maps with {@code int} keys and values. Methods that accept a
 * primitive {@code int} as an identifier are provided, and the original ones that accept a {@link Integer} are
 * deprecated. Specific {@link IEdgeSet} and {@link IEdgeIter} are returned for edges queries, avoiding boxing of
 * integers. Similarly, the {@link IWeights} interface is used for weights containers, which accept primitive
 * {@code int} as identifiers.
 *
 * &lt;p&gt;
 * Each vertex and edge in the graph is identified by a unique non negative {@code int} identifier. Vertices and edges
 * may be created by {@link #addVertexInt()} and {@link #addEdge(int, int)}, in which case the graph implementation will
 * choose the {@code int} identifier and will return it to the user. Alternatively, the methods {@link #addVertex(int)}
 * and {@link #addEdge(int, int, int)} (similar the regular {@link Graph} methods) can be used to add new vertices and
 * edges with user chosen identifiers.
 *
 * &lt;p&gt;
 * Implementations of this interface are more efficient than the generic {@link Graph} interface, and should be used for
 * better performance if its needed. For even better performance, consider using {@link IndexGraph}, which does violate
 * the {@link Graph} interface as its vertices and edges may change during the lifetime of the graph and therefore less
 * user friendly, but is even more efficient.
 *
 * &lt;p&gt;
 * To create a new empty graph, use {@link #newUndirected()} or {@link #newDirected()}. The returned graph will use the
 * default implementation. For more control over the graph details, see {@link IntGraphFactory}. To construct an
 * immutable graph, use {@link IntGraphBuilder}.
 *
 * &lt;pre&gt; {@code
 * // Create a directed graph with three vertices and edges between them
 * IntGraph g = IntGraph.newDirected();
 * int v1 = g.addVertex();
 * int v2 = g.addVertex();
 * int v3 = g.addVertex();
 * int e1 = g.addEdge(v1, v2);
 * int e2 = g.addEdge(v2, v3);
 * int e3 = g.addEdge(v1, v3);
 *
 * // Assign some weights to the edges
 * IWeightsDouble weights = g.addEdgesWeights(&quot;weightsKey&quot;, double.class);
 * weights.set(e1, 1.2);
 * weights.set(e2, 3.1);
 * weights.set(e3, 15.1);
 * IWeightFunction weightFunc = weights;
 *
 * // Calculate the shortest paths from v1 to all other vertices
 * ShortestPathSingleSource ssspAlgo = ShortestPathSingleSource.newInstance();
 * ShortestPathSingleSource.Result ssspRes = ssspAlgo.computeShortestPaths(g, weightFunc, v1);
 *
 * // Print the shortest path from v1 to v3
 * assert ssspRes.distance(v3) == 4.3;
 * assert ssspRes.getPath(v3).edges().equals(IntList.of(e1, e2));
 * System.out.println(&quot;Distance from v1 to v3 is: &quot; + ssspRes.distance(v3));
 * System.out.println(&quot;The shortest path from v1 to v3 is:&quot;);
 * for (int e : ssspRes.getPath(v3).edges()) {
 * 	int u = g.edgeSource(e), v = g.edgeTarget(e);
 * 	System.out.println(&quot; &quot; + e + &quot;(&quot; + u + &quot;, &quot; + v + &quot;)&quot;);
 * }
 * }&lt;/pre&gt;
 *
 * @see    IntGraphFactory
 * @see    IntGraphBuilder
 * @see    IndexGraph
 * @author Barak Ugav
 */
public interface IntGraph extends Graph&lt;Integer, Integer&gt; {

	@Override
	IntSet vertices();

	@Override
	IntSet edges();

	/**
	 * Add a new vertex to the graph.
	 *
	 * &lt;p&gt;
	 * Vertices must be non negative integers.
	 *
	 * &lt;p&gt;
	 * If the graph have a vertex builder, namely if {@link #vertexBuilder()} does not return {@code null}, the method
	 * {@link #addVertexInt()} can be used, which uses the vertex builder to create the new vertex object instead of
	 * requiring the user to provide it.
	 *
	 * @param  vertex                   new vertex
	 * @throws IllegalArgumentException if the provided identifier is already used as identifier of one of the graph
	 *                                      vertices, or if its negative
	 */
	void addVertex(int vertex);

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use {@link #addVertex(int)} instead to avoid un/boxing.
	 */
	@Deprecated
	@Override
	default void addVertex(Integer vertex) {
<span class="fc" id="L124">		addVertex(vertex.intValue());</span>
<span class="fc" id="L125">	}</span>

	/**
	 * Add a new vertex to the graph, using the vertex builder.
	 *
	 * &lt;p&gt;
	 * Unlike {@link #addVertex(int)} in which the vertex is provided by the user, this method uses the vertex builder
	 * obtained by {@link #vertexBuilder()} to create the new vertex object and adds it to the graph.
	 *
	 * &lt;p&gt;
	 * This method is equivalent to:
	 *
	 * &lt;pre&gt; {@code
	 * int vertex = vertexBuilder().build(vertices());
	 * addVertex(vertex);
	 * return vertex;
	 * }&lt;/pre&gt;
	 *
	 * @return                               the new vertex
	 * @throws UnsupportedOperationException if the graph does not have a vertex builder, namely if
	 *                                           {@link #vertexBuilder()} returns {@code null}
	 */
	default int addVertexInt() {
<span class="fc" id="L148">		IdBuilderInt vertexBuilder = vertexBuilder();</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">		if (vertexBuilder == null)</span>
<span class="fc" id="L150">			throw new UnsupportedOperationException(&quot;No vertex builder&quot;);</span>
<span class="fc" id="L151">		int vertex = vertexBuilder.build(vertices());</span>
<span class="fc" id="L152">		addVertex(vertex);</span>
<span class="fc" id="L153">		return vertex;</span>
	}

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use {@link #addVertexInt()} instead to avoid un/boxing.
	 */
	@Deprecated
	@Override
	default Integer addVertex() {
<span class="fc" id="L164">		return Integer.valueOf(addVertexInt());</span>
	}

	/**
	 * {@inheritDoc}
	 *
	 * &lt;p&gt;
	 * Prefer to pass {@link IntCollection} instead of {@link Collection}&amp;lt;{@link Integer}&amp;gt; as collection of
	 * vertices.
	 */
	@Override
	void addVertices(Collection&lt;? extends Integer&gt; vertices);

	/**
	 * Remove a vertex and all its edges from the graph.
	 *
	 * @param  vertex                the vertex identifier to remove
	 * @throws NoSuchVertexException if {@code vertex} is not a valid vertex identifier
	 */
	void removeVertex(int vertex);

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use {@link #removeVertex(int)} instead to avoid un/boxing.
	 */
	@Deprecated
	@Override
	default void removeVertex(Integer vertex) {
<span class="fc" id="L193">		removeVertex(vertex.intValue());</span>
<span class="fc" id="L194">	}</span>

	/**
	 * Set a new identifier for an existing vertex.
	 *
	 * &lt;p&gt;
	 * This method changes the identifier of an existing vertex, while keeping the edges connecting to it, along with
	 * the weights associated with it.
	 *
	 * @param  vertex                   an existing vertex in the graph
	 * @param  newId                    the new vertex identifier
	 * @throws NoSuchVertexException    if {@code vertex} is not a valid vertex identifier
	 * @throws IllegalArgumentException if {@code newId} is already in the graph or if {@code newId} is {@code null}
	 */
	void renameVertex(int vertex, int newId);

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use {@link #renameVertex(int, int)} instead to avoid un/boxing.
	 */
	@Deprecated
	@Override
	default void renameVertex(Integer vertex, Integer newId) {
<span class="fc" id="L218">		renameVertex(vertex.intValue(), newId.intValue());</span>
<span class="fc" id="L219">	}</span>

	/**
	 * Get the edges whose source is {@code source}.
	 *
	 * &lt;p&gt;
	 * In case the graph is undirected, the set will contain all edges whose {@code source} is one of their end points.
	 *
	 * &lt;p&gt;
	 * The graph object does not expose an explicit method to get the (out) degree of a vertex, but it can accessed
	 * using this method by {@code g.outEdges(vertex).size()}.
	 *
	 * @param  source                a source vertex
	 * @return                       all the edges whose source is {@code source}
	 * @throws NoSuchVertexException if {@code source} is not a valid vertex identifier
	 */
	IEdgeSet outEdges(int source);

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use {@link #outEdges(int)} instead to avoid un/boxing.
	 */
	@Deprecated
	@Override
	default IEdgeSet outEdges(Integer source) {
<span class="fc" id="L245">		return outEdges(source.intValue());</span>
	}

	/**
	 * Get the edges whose target is {@code target}.
	 *
	 * &lt;p&gt;
	 * In case the graph is undirected, the set will contain all edges whose {@code target} is one of their end points.
	 *
	 * &lt;p&gt;
	 * The graph object does not expose an explicit method to get the (in) degree of a vertex, but it can accessed using
	 * this method by {@code g.inEdges(vertex).size()}.
	 *
	 * @param  target                a target vertex
	 * @return                       all the edges whose target is {@code target}
	 * @throws NoSuchVertexException if {@code target} is not a valid vertex identifier
	 */
	IEdgeSet inEdges(int target);

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use {@link #inEdges(int)} instead to avoid un/boxing.
	 */
	@Deprecated
	@Override
	default IEdgeSet inEdges(Integer target) {
<span class="fc" id="L272">		return inEdges(target.intValue());</span>
	}

	/**
	 * Check whether the graph contains an edge with the given source and target.
	 *
	 * &lt;p&gt;
	 * If the graph is undirected, the method will return {@code true} if there is an edge whose end-points are
	 * {@code source} and {@code target}, regardless of which is the source and which is the target.
	 *
	 * @param  source                the source vertex
	 * @param  target                the target vertex
	 * @return                       {@code true} if the graph contains an edge with the given source and target,
	 *                               {@code false} otherwise
	 * @throws NoSuchVertexException if {@code source} or {@code target} are not valid vertices identifiers
	 */
	default boolean containsEdge(int source, int target) {
<span class="fc bfc" id="L289" title="All 2 branches covered.">		return getEdge(source, target) != -1;</span>
	}

	@Deprecated
	@Override
	default boolean containsEdge(Integer source, Integer target) {
<span class="fc bfc" id="L295" title="All 2 branches covered.">		return getEdge(source.intValue(), target.intValue()) != -1;</span>
	}

	/**
	 * Get the edge whose source is {@code source} and target is {@code target}.
	 *
	 * &lt;p&gt;
	 * If the graph is not directed, the return edge is an edge that its end-points are {@code source} and
	 * {@code target}.
	 *
	 * &lt;p&gt;
	 * In case there are multiple (parallel) edges between {@code source} and {@code target}, a single arbitrary one is
	 * returned.
	 *
	 * @param  source                a source vertex
	 * @param  target                a target vertex
	 * @return                       id of the edge or {@code -1} if no such edge exists
	 * @throws NoSuchVertexException if {@code source} or {@code target} are not valid vertices identifiers
	 */
	int getEdge(int source, int target);

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use {@link #getEdge(int, int)} instead to avoid un/boxing.
	 */
	@Deprecated
	@Override
	default Integer getEdge(Integer source, Integer target) {
<span class="fc" id="L324">		int e = getEdge(source.intValue(), target.intValue());</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">		return e == -1 ? null : Integer.valueOf(e);</span>
	}

	/**
	 * Get the edges whose source is {@code source} and target is {@code target}.
	 *
	 * @param  source                a source vertex
	 * @param  target                a target vertex
	 * @return                       all the edges whose source is {@code source} and target is {@code target}
	 * @throws NoSuchVertexException if {@code source} or {@code target} are not valid vertices identifiers
	 */
	IEdgeSet getEdges(int source, int target);

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use {@link #getEdges(int, int)} instead to avoid un/boxing.
	 */
	@Deprecated
	@Override
	default IEdgeSet getEdges(Integer source, Integer target) {
<span class="fc" id="L346">		return getEdges(source.intValue(), target.intValue());</span>
	}

	/**
	 * Add a new edge to the graph.
	 *
	 * &lt;p&gt;
	 * If the graph does not support parallel edges, and an edge between {@code source} and {@code target} already
	 * exists, an exception will be raised. If the graph does not support self edges, and {@code source} and
	 * {@code target} are the same vertex, an exception will be raised.
	 *
	 * &lt;p&gt;
	 * Edges must be non negative integers.
	 *
	 * &lt;p&gt;
	 * If the graph have an edge builder, namely if {@link #edgeBuilder()} does not return {@code null}, the method
	 * {@link #addEdge(int, int)} can be used, which uses the edge builder to create the new edge object instead of
	 * requiring the user to provide it.
	 *
	 * @param  source                   a source vertex
	 * @param  target                   a target vertex
	 * @param  edge                     a new edge identifier
	 * @throws IllegalArgumentException if {@code edge} is already in the graph or if the graph does not support
	 *                                      parallel edges and an edge between {@code source} and {@code target} already
	 *                                      exists or if the graph does not support self edges and {@code source} and
	 *                                      {@code target} are the same vertex
	 * @throws NullPointerException     if {@code edge} is {@code null}
	 * @throws NoSuchVertexException    if {@code source} or {@code target} are not valid vertices identifiers
	 */
	void addEdge(int source, int target, int edge);

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use {@link #addEdge(int, int, int)} instead to avoid un/boxing.
	 */
	@Deprecated
	@Override
	default void addEdge(Integer source, Integer target, Integer edge) {
<span class="fc" id="L385">		addEdge(source.intValue(), target.intValue(), edge.intValue());</span>
<span class="fc" id="L386">	}</span>

	/**
	 * Add a new edge to the graph, using the edge builder.
	 *
	 * &lt;p&gt;
	 * Unlike {@link #addEdge(int, int, int)} in which the edge (identifier) is provided by the user, this method uses
	 * the edge builder obtained by {@link #edgeBuilder()} to create the new edge object and adds it to the graph.
	 *
	 * &lt;p&gt;
	 * If the graph does not support parallel edges, and an edge between {@code source} and {@code target} already
	 * exists, an exception will be raised. If the graph does not support self edges, and {@code source} and
	 * {@code target} are the same vertex, an exception will be raised.
	 *
	 * &lt;p&gt;
	 * This method is equivalent to:
	 *
	 * &lt;pre&gt; {@code
	 * int edge = edgeBuilder().build(edges());
	 * addEdge(source, target, edge);
	 * return edge;
	 * }&lt;/pre&gt;
	 *
	 * @param  source                        a source vertex
	 * @param  target                        a target vertex
	 * @return                               the new edge
	 * @throws UnsupportedOperationException if the graph does not have an edge builder, namely if
	 *                                           {@link #edgeBuilder()} returns {@code null}
	 * @throws IllegalArgumentException      if the graph does not support parallel edges and an edge between
	 *                                           {@code source} and {@code target} already exists or if the graph does
	 *                                           not support self edges and {@code source} and {@code target} are the
	 *                                           same vertex
	 * @throws NoSuchVertexException         if {@code source} or {@code target} are not valid vertices identifiers
	 */
	default int addEdge(int source, int target) {
<span class="fc" id="L421">		IdBuilderInt edgeBuilder = edgeBuilder();</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">		if (edgeBuilder == null)</span>
<span class="fc" id="L423">			throw new UnsupportedOperationException(&quot;No edge builder&quot;);</span>
<span class="fc" id="L424">		int edge = edgeBuilder.build(edges());</span>
<span class="fc" id="L425">		addEdge(source, target, edge);</span>
<span class="fc" id="L426">		return edge;</span>
	}

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use {@link #addEdge(int, int)} instead to avoid un/boxing.
	 */
	@Deprecated
	@Override
	default Integer addEdge(Integer source, Integer target) {
<span class="fc" id="L437">		return Integer.valueOf(addEdge(source.intValue(), target.intValue()));</span>
	}

	/**
	 * {@inheritDoc}
	 *
	 * &lt;p&gt;
	 * Prefer to pass {@link IEdgeSet} instead of {@link EdgeSet}&amp;lt;{@link Integer}, {@link Integer}&amp;gt; as set of
	 * edges. See {@link IEdgeSet#of(IntSet, IntGraph)}.
	 */
	@Override
	void addEdges(EdgeSet&lt;? extends Integer, ? extends Integer&gt; edges);

	/**
	 * Remove an edge from the graph.
	 *
	 * @param  edge                the edge identifier
	 * @throws NoSuchEdgeException if {@code edge} is not a valid edge identifier
	 */
	void removeEdge(int edge);

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use {@link #removeEdge(int)} instead to avoid un/boxing.
	 */
	@Deprecated
	@Override
	default void removeEdge(Integer edge) {
<span class="fc" id="L466">		removeEdge(edge.intValue());</span>
<span class="fc" id="L467">	}</span>

	/**
	 * Remove all the edges of a vertex.
	 *
	 * @param  vertex                a vertex in the graph
	 * @throws NoSuchVertexException if {@code vertex} is not a valid vertex identifier
	 */
	void removeEdgesOf(int vertex);

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use {@link #removeEdgesOf(int)} instead to avoid un/boxing.
	 */
	@Deprecated
	@Override
	default void removeEdgesOf(Integer vertex) {
<span class="fc" id="L485">		removeEdgesOf(vertex.intValue());</span>
<span class="fc" id="L486">	}</span>

	/**
	 * Remove all edges whose source is {@code source}.
	 *
	 * @param  source                a vertex in the graph
	 * @throws NoSuchVertexException if {@code source} is not a valid vertex identifier
	 */
	void removeOutEdgesOf(int source);

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use {@link #removeOutEdgesOf(int)} instead to avoid un/boxing.
	 */
	@Deprecated
	@Override
	default void removeOutEdgesOf(Integer vertex) {
<span class="fc" id="L504">		removeOutEdgesOf(vertex.intValue());</span>
<span class="fc" id="L505">	}</span>

	/**
	 * Remove all edges whose target is {@code target}.
	 *
	 * @param  target                a vertex in the graph
	 * @throws NoSuchVertexException if {@code target} is not a valid vertex identifier
	 */
	void removeInEdgesOf(int target);

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use {@link #removeInEdgesOf(int)} instead to avoid un/boxing.
	 */
	@Deprecated
	@Override
	default void removeInEdgesOf(Integer vertex) {
<span class="fc" id="L523">		removeInEdgesOf(vertex.intValue());</span>
<span class="fc" id="L524">	}</span>

	/**
	 * Set a new identifier for an existing edge.
	 *
	 * &lt;p&gt;
	 * This method changes the identifier of an existing edge, while keeping the source and target of the edge, along
	 * with the weights associated with it.
	 *
	 * @param  edge                     an existing edge in the graph
	 * @param  newId                    the new edge identifier
	 * @throws NoSuchEdgeException      if {@code edge} is not a valid edge identifier
	 * @throws IllegalArgumentException if {@code newId} is already in the graph or if {@code newId} is negative
	 */
	void renameEdge(int edge, int newId);

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use {@link #renameEdge(int, int)} instead to avoid un/boxing.
	 */
	@Deprecated
	@Override
	default void renameEdge(Integer edge, Integer newId) {
<span class="fc" id="L548">		renameEdge(edge.intValue(), newId.intValue());</span>
<span class="fc" id="L549">	}</span>

	/**
	 * Move an existing edge to new source and target vertices.
	 *
	 * &lt;p&gt;
	 * This method changes the source and target of an existing edge, while keeping the identifier of the edge and the
	 * weights associated with it.
	 *
	 * @param  edge                     an existing edge in the graph
	 * @param  newSource                the new source vertex
	 * @param  newTarget                the new target vertex
	 * @throws NoSuchEdgeException      if {@code edge} is not a valid edge identifier
	 * @throws NoSuchVertexException    if {@code newSource} or {@code newTarget} are not valid vertices identifiers
	 * @throws IllegalArgumentException if {@code newSource} and {@code newTarget} are the same vertex and the graph
	 *                                      does not support self edges, or if the graph does not support parallel edges
	 *                                      and an edge between {@code newSource} and {@code newTarget} already exists
	 */
	void moveEdge(int edge, int newSource, int newTarget);

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use {@link #moveEdge(int, int, int)} instead to avoid un/boxing.
	 */
	@Deprecated
	@Override
	default void moveEdge(Integer edge, Integer newSource, Integer newTarget) {
<span class="fc" id="L577">		moveEdge(edge.intValue(), newSource.intValue(), newTarget.intValue());</span>
<span class="fc" id="L578">	}</span>

	/**
	 * Reverse an edge by switching its source and target.
	 *
	 * @param  edge                     an existing edge in the graph
	 * @throws NoSuchEdgeException      if {@code edge} is not a valid edge identifier
	 * @throws IllegalArgumentException if the graph does not support parallel edges and another edge which is the
	 *                                      reverse of {@code edge} already exists in the graph
	 */
	default void reverseEdge(int edge) {
<span class="fc" id="L589">		moveEdge(edge, edgeTarget(edge), edgeSource(edge));</span>
<span class="fc" id="L590">	}</span>

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use {@link #reverseEdge(int)} instead to avoid un/boxing.
	 */
	@Deprecated
	@Override
	default void reverseEdge(Integer edge) {
<span class="fc" id="L600">		reverseEdge(edge.intValue());</span>
<span class="fc" id="L601">	}</span>

	/**
	 * Get the source vertex of an edge.
	 *
	 * &lt;p&gt;
	 * If the graph is undirected, this function return an arbitrary end-point of the edge, but always other end-point
	 * than {@link #edgeTarget(int)} returns.
	 *
	 * @param  edge                the edge identifier
	 * @return                     the edge source vertex
	 * @throws NoSuchEdgeException if {@code edge} is not a valid edge identifier
	 */
	int edgeSource(int edge);

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use {@link #edgeSource(int)} instead to avoid un/boxing.
	 */
	@Deprecated
	@Override
	default Integer edgeSource(Integer edge) {
<span class="fc" id="L624">		return Integer.valueOf(edgeSource(edge.intValue()));</span>
	}

	/**
	 * Get the target vertex of an edge.
	 *
	 * &lt;p&gt;
	 * If the graph is undirected, this function return an arbitrary end-point of the edge, but always the other
	 * end-point than {@link #edgeSource(int)} returns.
	 *
	 * @param  edge                the edge identifier
	 * @return                     the edge target vertex
	 * @throws NoSuchEdgeException if {@code edge} is not a valid edge identifier
	 */
	int edgeTarget(int edge);

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use {@link #edgeTarget(int)} instead to avoid un/boxing.
	 */
	@Deprecated
	@Override
	default Integer edgeTarget(Integer edge) {
<span class="fc" id="L648">		return Integer.valueOf(edgeTarget(edge.intValue()));</span>
	}

	/**
	 * Get the other end-point of an edge.
	 *
	 * &lt;p&gt;
	 * Given an edge \((u,v)\) and a vertex \(w\), assuming \(w\) is an endpoint of the edge, namely that \(w\) is
	 * either \(u\) or \(v\), the method will return the &lt;i&gt;other&lt;/i&gt; endpoint which is not \(w\). If \(w=u\) the method
	 * will return \(v\), if \(w=v\) the method will return \(u\).
	 *
	 * @param  edge                     an edge identifier
	 * @param  endpoint                 one of the edge end-point
	 * @return                          the other end-point of the edge
	 * @throws NoSuchEdgeException      if {@code edge} is not a valid edge identifier
	 * @throws NoSuchVertexException    if {@code endpoint} is not a valid vertex identifier
	 * @throws IllegalArgumentException if {@code endpoint} is not an endpoint of the edge
	 */
	int edgeEndpoint(int edge, int endpoint);

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Please use {@link #edgeEndpoint(int, int)} instead to avoid un/boxing.
	 */
	@Deprecated
	@Override
	default Integer edgeEndpoint(Integer edge, Integer endpoint) {
<span class="fc" id="L676">		return Integer.valueOf(edgeEndpoint(edge.intValue(), endpoint.intValue()));</span>
	}

	@Override
	IdBuilderInt vertexBuilder();

	@Override
	IdBuilderInt edgeBuilder();

	/**
	 * {@inheritDoc}
	 *
	 * The return object is always some sub class of {@link IWeights}, such as {@link IWeightsInt} or
	 * {@link IWeightsDouble}.
	 */
	@Override
	&lt;T, WeightsT extends Weights&lt;Integer, T&gt;&gt; WeightsT getVerticesWeights(String key);

	/**
	 * {@inheritDoc}
	 *
	 * The return object is always some sub class of {@link IWeights}, such as {@link IWeightsInt} or
	 * {@link IWeightsDouble}.
	 */
	@Override
	&lt;T, WeightsT extends Weights&lt;Integer, T&gt;&gt; WeightsT getEdgesWeights(String key);

	@Override
	IndexIntIdMap indexGraphVerticesMap();

	@Override
	IndexIntIdMap indexGraphEdgesMap();

	@Override
	default IntGraph copy() {
<span class="fc" id="L711">		return (IntGraph) Graph.super.copy();</span>
	}

	@Override
	default IntGraph copy(boolean copyVerticesWeights, boolean copyEdgesWeights) {
<span class="fc" id="L716">		return (IntGraph) Graph.super.copy(copyVerticesWeights, copyEdgesWeights);</span>
	}

	@Override
	default IntGraph immutableCopy() {
<span class="fc" id="L721">		return (IntGraph) Graph.super.immutableCopy();</span>
	}

	@Override
	default IntGraph immutableCopy(boolean copyVerticesWeights, boolean copyEdgesWeights) {
<span class="fc" id="L726">		return (IntGraph) Graph.super.immutableCopy(copyVerticesWeights, copyEdgesWeights);</span>
	}

	@Override
	default IntGraph immutableView() {
<span class="fc" id="L731">		return (IntGraph) Graph.super.immutableView();</span>
	}

	@Override
	default IntGraph reverseView() {
<span class="fc" id="L736">		return (IntGraph) Graph.super.reverseView();</span>
	}

	@Override
	default IntGraph undirectedView() {
<span class="fc" id="L741">		return (IntGraph) Graph.super.undirectedView();</span>
	}

	/**
	 * {@inheritDoc}
	 *
	 * &lt;p&gt;
	 * Prefer to pass a IntCollection instead of Collection&amp;lt;Integer&amp;gt; as collections of vertices and edges.
	 */
	@Override
	default IntGraph subGraphCopy(Collection&lt;Integer&gt; vertices, Collection&lt;Integer&gt; edges) {
<span class="fc" id="L752">		return (IntGraph) Graph.super.subGraphCopy(vertices, edges);</span>
	}

	/**
	 * Create a new undirected empty int graph.
	 *
	 * &lt;p&gt;
	 * The returned graph will be implemented using the default implementation. For more control over the graph details,
	 * see {@link IntGraphFactory}.
	 *
	 * @return a new undirected empty graph
	 */
	static IntGraph newUndirected() {
<span class="fc" id="L765">		return IntGraphFactory.undirected().newGraph();</span>
	}

	/**
	 * Create a new directed empty int graph.
	 *
	 * &lt;p&gt;
	 * The returned graph will be implemented using the default implementation. For more control over the graph details,
	 * see {@link IntGraphFactory}.
	 *
	 * @return a new directed empty graph
	 */
	static IntGraph newDirected() {
<span class="fc" id="L778">		return IntGraphFactory.directed().newGraph();</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>