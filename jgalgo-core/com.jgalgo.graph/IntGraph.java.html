<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IntGraph.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.graph</a> &gt; <span class="el_source">IntGraph.java</span></div><h1>IntGraph.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jgalgo.graph;

import java.util.Collection;
import java.util.Optional;
import it.unimi.dsi.fastutil.ints.IntSet;

/**
 * A discrete graph with vertices and edges.
 *
 * &lt;p&gt;
 * A graph consist of a finite set of vertices \(V\) and edges \(E\). Vertices are some abstract entities, and edges are
 * connections between the vertices, for example vertices can be cities and edges could be the roads between them, or
 * vertices can be people the edges are the relation of &quot;friends&quot;. Edges could be directed or undirected. Weights may be
 * assigned to vertices or edges, for example the length of a road might be a weight of an edge. Than, questions such as
 * &quot;what is the shortest path between two cities?&quot; might be answered using graph algorithms.
 *
 * &lt;p&gt;
 * Each edge \(e=(u, v)\) in the graph has a &lt;i&gt;source&lt;/i&gt; vertex, \(u\), and a &lt;i&gt;target&lt;/i&gt; vertex, \(v\). In
 * undirected graphs the 'source' and 'target' can be switched, as the edge is not directed, and we treat the source and
 * target as interchangeable &lt;i&gt;end points&lt;/i&gt;. If an edge \((u,v)\) exist in the graph, we say the vertices \(u\) and
 * \(v\) and &lt;i&gt;neighbors&lt;/i&gt;, or &lt;i&gt;adjacent&lt;/i&gt;. The edges are usually stored in some list for each vertex, allowing
 * efficient iteration of its edges. The &lt;i&gt;degree&lt;/i&gt; of a vertex is the number of its edges. In directed graph, we
 * have both &lt;i&gt;in-degree&lt;/i&gt; and &lt;i&gt;out-degree&lt;/i&gt;, which are the number of edges going in and out the vertex,
 * respectively.
 *
 * &lt;p&gt;
 * Vertices can be added or removed. When a vertex \(v\) is removed, all the edges with \(v\) as one of their end points
 * are removed as well. Edges can be added as connection to existing vertices, or removed.
 *
 * &lt;p&gt;
 * A directed graph and an undirected graph both implement this interface. In a directed graph, the edges are
 * &lt;i&gt;directed&lt;/i&gt;, namely an edge \(e(u, v)\) will be contained in {@code outEdges(u)} and in {@code inEdges(v)} and
 * will not be contained in {@code outEdges(v)} and {@code inEdges(u)}. In an undirected graph, the edges are
 * undirected, namely an edge \(e(u, v)\) will be contained in {@code outEdges(u)}, {@code inEdges(v)},
 * {@code outEdges(v)} and in {@code inEdges(u)}. Also {@link #removeEdgesOf(int)}, {@link #removeInEdgesOf(int)} and
 * {@link #removeOutEdgesOf(int)} are equivalent for the same vertex in an undirected graph. To check if a graph is
 * directed or not, use the {@link #isDirected()} method.
 *
 * &lt;p&gt;
 * Each vertex and edge in the graph is identified by a unique non negative {@code int} ID. The existing vertices and
 * edges of the graph can be retrieved using {@link #vertices()} and {@link #edges()}. Vertices and edges may be created
 * by {@link #addVertex()} and {@link #addEdge(int, int)}, in which case the graph implementation will choose the
 * {@code int} ID and will return it to the user. Alternatively, the methods {@link #addVertex(int)} and
 * {@link #addEdge(int, int, int)} can be used to add new vertices and edges with user chosen identifiers.
 *
 * &lt;p&gt;
 * Weights may be assigned to the graph vertices and/or edges. A &lt;i&gt;weight&lt;/i&gt; is some value such as any primitive (for
 * example {@code double}, {@code int} or {@code boolean} flag) or an Object. Multiple different weights can be added to
 * the vertices and/or edges, each is identified by some key. When a new weights type is added to a graph, it is added
 * to &lt;i&gt;all&lt;/i&gt; the vertices/edges, with either user provided default weight value, or {@code null} ({@code 0} in case
 * the weight type is primitive). The weights are accessed via the {@link IWeights} container, which can be used to get
 * or set a vertex/edge weight, and can be passed to algorithms as a {@link IWeightFunction} for example. See
 * {@link #addVerticesWeights(String, Class)} and {@link #addEdgesWeights(String, Class)}, or {@link IWeights} for the
 * full weights documentation.
 *
 * &lt;p&gt;
 * Each graph expose an &lt;i&gt;Index&lt;/i&gt; view on itself via the {@link #indexGraph()} method. The returned
 * {@link IndexGraph} is a graph in which the identifiers of the vertices are always {@code (0,1,2, ...,verticesNum-1)},
 * and the identifiers of the edges are always {@code (0,1,2, ...,edgesNum-1)}. To maintain this, the index graph
 * implementation may rename existing vertices or edges along the graph lifetime. This rename behavior is less user
 * friendly, but allow for high performance boost as no hash tables are needed, a simple array or bitmap can be used to
 * map each vertex/edge to a value/weight/flag. See {@link IndexGraph} for more information. The {@link IndexGraph}
 * should not be used in scenarios where performance does not matter.
 *
 * &lt;p&gt;
 * The number of vertices and edges can be read via {@code g.vertices().size()} and {@code g.edges().size()}. The out or
 * in degree of a vertex is exposed by {@code g.outEdges(vertex).size()} and {@code g.inEdges(vertex).size()}.
 *
 * &lt;p&gt;
 * The number of vertices, \(|V|\), is usually denoted as \(n\) in algorithms time and space complexities, and
 * similarly, the number of edges, \(|E|\), is usually denoted as \(m\).
 *
 * &lt;p&gt;
 * To create a new empty graph, use {@link #newUndirected()} or {@link #newDirected()}. The returned graph will use the
 * default implementation. For more control over the graph details, see {@link IntGraphFactory}. To construct an
 * immutable graph, use {@link IntGraphBuilder}.
 *
 * &lt;pre&gt; {@code
 * // Create a directed graph with three vertices and edges between them
 * IntGraph g = IntGraph.newDirected();
 * int v1 = g.addVertex();
 * int v2 = g.addVertex();
 * int v3 = g.addVertex();
 * int e1 = g.addEdge(v1, v2);
 * int e2 = g.addEdge(v2, v3);
 * int e3 = g.addEdge(v1, v3);
 *
 * // Assign some weights to the edges
 * IWeightsDouble weights = g.addEdgesWeights(&quot;weightsKey&quot;, double.class);
 * weights.set(e1, 1.2);
 * weights.set(e2, 3.1);
 * weights.set(e3, 15.1);
 * IWeightFunction weightFunc = weights;
 *
 * // Calculate the shortest paths from v1 to all other vertices
 * ShortestPathSingleSource ssspAlgo = ShortestPathSingleSource.newInstance();
 * ShortestPathSingleSource.Result ssspRes = ssspAlgo.computeShortestPaths(g, weightFunc, v1);
 *
 * // Print the shortest path from v1 to v3
 * assert ssspRes.distance(v3) == 4.3;
 * assert ssspRes.getPath(v3).edges().equals(IntList.of(e1, e2));
 * System.out.println(&quot;Distance from v1 to v3 is: &quot; + ssspRes.distance(v3));
 * System.out.println(&quot;The shortest path from v1 to v3 is:&quot;);
 * for (int e : ssspRes.getPath(v3).edges()) {
 * 	int u = g.edgeSource(e), v = g.edgeTarget(e);
 * 	System.out.println(&quot; &quot; + e + &quot;(&quot; + u + &quot;, &quot; + v + &quot;)&quot;);
 * }
 * }&lt;/pre&gt;
 *
 * @see    IntGraphFactory
 * @see    IntGraphBuilder
 * @see    IndexGraph
 * @author Barak Ugav
 */
public interface IntGraph extends Graph&lt;Integer, Integer&gt; {

	@Override
	IntSet vertices();

	@Override
	IntSet edges();

	/**
	 * Add a new vertex to the graph.
	 *
	 * &lt;p&gt;
	 * The graph implementation will choose a new {@code int} identifier which is not currently used as one of the graph
	 * edges, and will return it as the new vertex ID.
	 *
	 * @return the new vertex identifier
	 */
	int addVertex();

	/**
	 * Add a new vertex to the graph with user chosen ID.
	 *
	 * &lt;p&gt;
	 * In contrast to {@link #addVertex()}, in which the implementation chooses ,the new vertex identifier, the user can
	 * specified what {@code int} ID the new vertex should be assigned. The set of graph vertices must not contain
	 * duplications, therefore the provided identifier must not be currently used as one of the graph vertices IDs.
	 *
	 * &lt;p&gt;
	 * Note that vertices IDs must be non negative.
	 *
	 * @param  vertex                   a user chosen identifier for the new vertex
	 * @throws IllegalArgumentException if the provided identifier is already used as identifier of one of the graph
	 *                                      vertices, or if its negative
	 */
	void addVertex(int vertex);

	@Deprecated
	@Override
	default void addVertex(Integer vertex) {
<span class="fc" id="L170">		addVertex(vertex.intValue());</span>
<span class="fc" id="L171">	}</span>

	/**
	 * Remove a vertex and all its edges from the graph.
	 *
	 * @param  vertex                    the vertex identifier to remove
	 * @throws IndexOutOfBoundsException if {@code vertex} is not a valid vertex identifier
	 */
	void removeVertex(int vertex);

	@Deprecated
	@Override
	default void removeVertex(Integer vertex) {
<span class="fc" id="L184">		removeVertex(vertex.intValue());</span>
<span class="fc" id="L185">	}</span>

	/**
	 * Get the edges whose source is {@code source}.
	 *
	 * &lt;p&gt;
	 * In case the graph is undirected, the set will contain all edges whose {@code source} is one of their end points.
	 *
	 * &lt;p&gt;
	 * The graph object does not expose an explicit method to get the (out) degree of a vertex, but it can accessed
	 * using this method by {@code g.outEdges(vertex).size()}.
	 *
	 * @param  source                    a source vertex
	 * @return                           all the edges whose source is {@code source}
	 * @throws IndexOutOfBoundsException if {@code source} is not a valid vertex identifier
	 */
	IEdgeSet outEdges(int source);

	@Deprecated
	@Override
	default EdgeSet&lt;Integer, Integer&gt; outEdges(Integer source) {
<span class="fc" id="L206">		return outEdges(source.intValue());</span>
	}

	/**
	 * Get the edges whose target is {@code target}.
	 *
	 * &lt;p&gt;
	 * In case the graph is undirected, the set will contain all edges whose {@code target} is one of their end points.
	 *
	 * &lt;p&gt;
	 * The graph object does not expose an explicit method to get the (in) degree of a vertex, but it can accessed using
	 * this method by {@code g.inEdges(vertex).size()}.
	 *
	 * @param  target                    a target vertex
	 * @return                           all the edges whose target is {@code target}
	 * @throws IndexOutOfBoundsException if {@code target} is not a valid vertex identifier
	 */
	IEdgeSet inEdges(int target);

	@Deprecated
	@Override
	default EdgeSet&lt;Integer, Integer&gt; inEdges(Integer target) {
<span class="fc" id="L228">		return inEdges(target.intValue());</span>
	}

	/**
	 * Get the edge whose source is {@code source} and target is {@code target}.
	 *
	 * &lt;p&gt;
	 * If the graph is not directed, the return edge is an edge that its end-points are {@code source} and
	 * {@code target}.
	 *
	 * &lt;p&gt;
	 * In case there are multiple (parallel) edges between {@code source} and {@code target}, a single arbitrary one is
	 * returned.
	 *
	 * @param  source                    a source vertex
	 * @param  target                    a target vertex
	 * @return                           id of the edge or {@code -1} if no such edge exists
	 * @throws IndexOutOfBoundsException if {@code source} or {@code target} are not valid vertices identifiers
	 */
	default int getEdge(int source, int target) {
<span class="fc bfc" id="L248" title="All 2 branches covered.">		for (IEdgeIter it = outEdges(source).iterator(); it.hasNext();) {</span>
<span class="fc" id="L249">			int e = it.nextInt();</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">			if (it.targetInt() == target)</span>
<span class="fc" id="L251">				return e;</span>
<span class="fc" id="L252">		}</span>
<span class="fc" id="L253">		return -1;</span>
	}

	@Deprecated
	@Override
	default Integer getEdge(Integer source, Integer target) {
<span class="fc" id="L259">		int e = getEdge(source.intValue(), target.intValue());</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">		return e == -1 ? null : Integer.valueOf(e);</span>
	}

	/**
	 * Get the edges whose source is {@code source} and target is {@code target}.
	 *
	 * @param  source                    a source vertex
	 * @param  target                    a target vertex
	 * @return                           all the edges whose source is {@code source} and target is {@code target}
	 * @throws IndexOutOfBoundsException if {@code source} or {@code target} are not valid vertices identifiers
	 */
	IEdgeSet getEdges(int source, int target);

	@Deprecated
	@Override
	default EdgeSet&lt;Integer, Integer&gt; getEdges(Integer source, Integer target) {
<span class="fc" id="L276">		return getEdges(source.intValue(), target.intValue());</span>
	}

	/**
	 * Add a new edge to the graph.
	 *
	 * &lt;p&gt;
	 * The graph implementation will choose a new {@code int} identifier which is not currently used as one of the graph
	 * edges, and will return it as the new edge ID.
	 *
	 * @param  source                    a source vertex
	 * @param  target                    a target vertex
	 * @return                           the new edge identifier
	 * @throws IndexOutOfBoundsException if {@code source} or {@code target} are not valid vertices identifiers
	 */
	int addEdge(int source, int target);

	/**
	 * Add a new edge to the graph with user chosen ID.
	 *
	 * &lt;p&gt;
	 * In contrast to {@link #addEdge(int, int)}, in which the implementation chooses the new edge identifier, the user
	 * can specified what {@code int} ID the new edge should be assigned. The set of graph edges must not contain
	 * duplications, therefore the provided identifier must not be currently used as one of the graph edges IDs.
	 *
	 * @param  source                   a source vertex
	 * @param  target                   a target vertex
	 * @param  edge                     a user chosen identifier for the new edge
	 * @throws IllegalArgumentException if the provided identifier is already used as identifier of one of the graph
	 *                                      edges, or if its negative
	 */
	void addEdge(int source, int target, int edge);

	@Deprecated
	@Override
	default void addEdge(Integer source, Integer target, Integer edge) {
<span class="fc" id="L312">		addEdge(source.intValue(), target.intValue(), edge.intValue());</span>
<span class="fc" id="L313">	}</span>

	/**
	 * Remove an edge from the graph.
	 *
	 * @param  edge                      the edge identifier
	 * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge identifier
	 */
	void removeEdge(int edge);

	@Deprecated
	@Override
	default void removeEdge(Integer edge) {
<span class="fc" id="L326">		removeEdge(edge.intValue());</span>
<span class="fc" id="L327">	}</span>

	/**
	 * Remove all the edges of a vertex.
	 *
	 * @param  vertex                    a vertex in the graph
	 * @throws IndexOutOfBoundsException if {@code vertex} is not a valid vertex identifier
	 */
	default void removeEdgesOf(int vertex) {
<span class="fc" id="L336">		removeOutEdgesOf(vertex);</span>
<span class="fc" id="L337">		removeInEdgesOf(vertex);</span>
<span class="fc" id="L338">	}</span>

	@Deprecated
	@Override
	default void removeEdgesOf(Integer vertex) {
<span class="fc" id="L343">		removeEdgesOf(vertex.intValue());</span>
<span class="fc" id="L344">	}</span>

	/**
	 * Remove all edges whose source is {@code source}.
	 *
	 * @param  source                    a vertex in the graph
	 * @throws IndexOutOfBoundsException if {@code source} is not a valid vertex identifier
	 */
	default void removeOutEdgesOf(int source) {
<span class="fc bfc" id="L353" title="All 2 branches covered.">		for (IEdgeIter eit = outEdges(source).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L354">			eit.nextInt();</span>
<span class="fc" id="L355">			eit.remove();</span>
		}
<span class="fc" id="L357">	}</span>

	@Deprecated
	@Override
	default void removeOutEdgesOf(Integer vertex) {
<span class="fc" id="L362">		removeOutEdgesOf(vertex.intValue());</span>
<span class="fc" id="L363">	}</span>

	/**
	 * Remove all edges whose target is {@code target}.
	 *
	 * @param  target                    a vertex in the graph
	 * @throws IndexOutOfBoundsException if {@code target} is not a valid vertex identifier
	 */
	default void removeInEdgesOf(int target) {
<span class="fc bfc" id="L372" title="All 2 branches covered.">		for (IEdgeIter eit = inEdges(target).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L373">			eit.nextInt();</span>
<span class="fc" id="L374">			eit.remove();</span>
		}
<span class="fc" id="L376">	}</span>

	@Deprecated
	@Override
	default void removeInEdgesOf(Integer vertex) {
<span class="fc" id="L381">		removeInEdgesOf(vertex.intValue());</span>
<span class="fc" id="L382">	}</span>

	/**
	 * Reverse an edge by switching its source and target.
	 *
	 * &lt;p&gt;
	 * If the graph is undirected, this method does nothing.
	 *
	 * @param  edge                      an existing edge in the graph
	 * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge identifier
	 */
	void reverseEdge(int edge);

	@Deprecated
	@Override
	default void reverseEdge(Integer edge) {
<span class="fc" id="L398">		reverseEdge(edge.intValue());</span>
<span class="fc" id="L399">	}</span>

	/**
	 * Get the source vertex of an edge.
	 *
	 * &lt;p&gt;
	 * If the graph is undirected, this function return an arbitrary end-point of the edge, but always other end-point
	 * than {@link #edgeTarget(int)} returns.
	 *
	 * @param  edge                      the edge identifier
	 * @return                           the edge source vertex
	 * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge identifier
	 */
	int edgeSource(int edge);

	@Deprecated
	@Override
	default Integer edgeSource(Integer edge) {
<span class="fc" id="L417">		return Integer.valueOf(edgeSource(edge.intValue()));</span>
	}

	/**
	 * Get the target vertex of an edge.
	 *
	 * &lt;p&gt;
	 * If the graph is undirected, this function return an arbitrary end-point of the edge, but always the other
	 * end-point than {@link #edgeSource(int)} returns.
	 *
	 * @param  edge                      the edge identifier
	 * @return                           the edge target vertex
	 * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge identifier
	 */
	int edgeTarget(int edge);

	@Deprecated
	@Override
	default Integer edgeTarget(Integer edge) {
<span class="fc" id="L436">		return Integer.valueOf(edgeTarget(edge.intValue()));</span>
	}

	/**
	 * Get the other end-point of an edge.
	 *
	 * &lt;p&gt;
	 * Given an edge \((u,v)\) and a vertex \(w\), assuming \(w\) is an endpoint of the edge, namely that \(w\) is
	 * either \(u\) or \(v\), the method will return the &lt;i&gt;other&lt;/i&gt; endpoint which is not \(w\). If \(w=u\) the method
	 * will return \(v\), if \(w=v\) the method will return \(u\).
	 *
	 * @param  edge                      an edge identifier
	 * @param  endpoint                  one of the edge end-point
	 * @return                           the other end-point of the edge
	 * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge identifier
	 * @throws IllegalArgumentException  if {@code endpoint} is not an endpoint of the edge
	 */
	default int edgeEndpoint(int edge, int endpoint) {
<span class="fc" id="L454">		int u = edgeSource(edge);</span>
<span class="fc" id="L455">		int v = edgeTarget(edge);</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">		if (endpoint == u) {</span>
<span class="fc" id="L457">			return v;</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">		} else if (endpoint == v) {</span>
<span class="fc" id="L459">			return u;</span>
		} else {
<span class="nc" id="L461">			throw new IllegalArgumentException(&quot;The given vertex (idx=&quot; + endpoint</span>
					+ &quot;) is not an endpoint of the edge (idx=&quot; + u + &quot;, idx=&quot; + v + &quot;)&quot;);
		}
	}

	@Deprecated
	@Override
	default Integer edgeEndpoint(Integer edge, Integer endpoint) {
<span class="fc" id="L469">		return Integer.valueOf(edgeEndpoint(edge.intValue(), endpoint.intValue()));</span>
	}

	// TODO
	&lt;T, WeightsT extends IWeights&lt;T&gt;&gt; WeightsT getVerticesIWeights(String key);

	@Override
	default &lt;T, WeightsT extends Weights&lt;Integer, T&gt;&gt; WeightsT getVerticesWeights(String key) {
<span class="fc" id="L477">		return getVerticesIWeights(key);</span>
	}

	// TODO
	&lt;T, WeightsT extends IWeights&lt;T&gt;&gt; WeightsT getEdgesIWeights(String key);

	@Override
	default &lt;T, WeightsT extends Weights&lt;Integer, T&gt;&gt; WeightsT getEdgesWeights(String key) {
<span class="fc" id="L485">		return getEdgesIWeights(key);</span>
	}

	@Override
	IndexIntIdMap indexGraphVerticesMap();

	@Override
	IndexIntIdMap indexGraphEdgesMap();

	@Override
	default IntGraph copy() {
<span class="fc" id="L496">		return (IntGraph) Graph.super.copy();</span>
	}

	@Override
	default IntGraph copy(boolean copyWeights) {
<span class="fc" id="L501">		return IntGraphFactory.newFrom(this).newCopyOf(this, copyWeights);</span>
	}

	@Override
	default IntGraph immutableCopy() {
<span class="fc" id="L506">		return IntGraphBuilder.newFrom(this).build();</span>
	}

	@Override
	default IntGraph immutableCopy(boolean copyWeights) {
<span class="fc" id="L511">		IndexIntIdMap viMap = indexGraphVerticesMap();</span>
<span class="fc" id="L512">		IndexIntIdMap eiMap = indexGraphEdgesMap();</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">		if (isDirected()) {</span>
<span class="fc" id="L514">			IndexGraphBuilder.ReIndexedGraph reIndexedGraph =</span>
<span class="fc" id="L515">					GraphCSRDirectedReindexed.newInstance(indexGraph(), copyWeights);</span>
<span class="fc" id="L516">			IndexGraph iGraph = reIndexedGraph.graph();</span>
<span class="fc" id="L517">			Optional&lt;IndexGraphBuilder.ReIndexingMap&gt; vReIndexing = reIndexedGraph.verticesReIndexing();</span>
<span class="fc" id="L518">			Optional&lt;IndexGraphBuilder.ReIndexingMap&gt; eReIndexing = reIndexedGraph.edgesReIndexing();</span>
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">			viMap = vReIndexing.isEmpty() ? viMap</span>
<span class="pc" id="L520">					: IntGraphBuilderImpl.Directed.reIndexedIdMap(viMap, vReIndexing.get());</span>
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">			eiMap = eReIndexing.isEmpty() ? eiMap</span>
<span class="fc" id="L522">					: IntGraphBuilderImpl.Directed.reIndexedIdMap(eiMap, eReIndexing.get());</span>
<span class="fc" id="L523">			return new IntGraphImpl.Directed(iGraph, viMap, eiMap);</span>
		} else {
<span class="fc" id="L525">			IndexGraph iGraph = new GraphCSRUndirected(indexGraph(), copyWeights);</span>
<span class="fc" id="L526">			return new IntGraphImpl.Undirected(iGraph, viMap, eiMap);</span>
		}
	}

	@Override
	default IntGraph immutableView() {
<span class="fc" id="L532">		return (IntGraph) Graph.super.immutableView();</span>
	}

	@Override
	default IntGraph reverseView() {
<span class="fc" id="L537">		return (IntGraph) Graph.super.reverseView();</span>
	}

	/**
	 * {@inheritDoc}
	 *
	 * &lt;p&gt;
	 * Prefer to pass a IntCollection instead of Collection&amp;lt;Integer&amp;gt; as collections of vertices and edges.
	 */
	@Override
	default IntGraph subGraphCopy(Collection&lt;Integer&gt; vertices, Collection&lt;Integer&gt; edges) {
<span class="fc" id="L548">		return (IntGraph) Graphs.subGraph(this, vertices, edges);</span>
	}

	/**
	 * Create a new undirected empty int graph.
	 *
	 * &lt;p&gt;
	 * The returned graph will be implemented using the default implementation. For more control over the graph details,
	 * see {@link IntGraphFactory}.
	 *
	 * @return a new undirected empty graph
	 */
	static IntGraph newUndirected() {
<span class="fc" id="L561">		return IntGraphFactory.newUndirected().newGraph();</span>
	}

	/**
	 * Create a new directed empty int graph.
	 *
	 * &lt;p&gt;
	 * The returned graph will be implemented using the default implementation. For more control over the graph details,
	 * see {@link IntGraphFactory}.
	 *
	 * @return a new directed empty graph
	 */
	static IntGraph newDirected() {
<span class="fc" id="L574">		return IntGraphFactory.newDirected().newGraph();</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>