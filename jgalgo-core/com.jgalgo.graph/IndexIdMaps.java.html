<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IndexIdMaps.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.graph</a> &gt; <span class="el_source">IndexIdMaps.java</span></div><h1>IndexIdMaps.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.graph;

import java.util.AbstractCollection;
import java.util.AbstractList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Objects;
import java.util.Set;
import com.jgalgo.internal.util.IntAdapters;
import com.jgalgo.internal.util.JGAlgoUtils;
import it.unimi.dsi.fastutil.ints.AbstractIntCollection;
import it.unimi.dsi.fastutil.ints.AbstractIntList;
import it.unimi.dsi.fastutil.ints.AbstractIntSet;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntIterator;
import it.unimi.dsi.fastutil.ints.IntList;
import it.unimi.dsi.fastutil.ints.IntListIterator;
import it.unimi.dsi.fastutil.ints.IntSet;
import it.unimi.dsi.fastutil.objects.AbstractObjectSet;
import it.unimi.dsi.fastutil.objects.ObjectIterator;

/**
 * Static methods class for {@linkplain IndexIntIdMap index-id maps}.
 *
 * @author Barak Ugav
 */
public class IndexIdMaps {

	private IndexIdMaps() {}

	/**
	 * Create an IDs iterator from an iterator of indices.
	 *
	 * @param  &lt;K&gt;       the type of IDs
	 * @param  indexIter an iterator of indices
	 * @param  map       index-id mapping
	 * @return           an iterator that iterate over the IDs matching the indices iterated by the original
	 *                   index-iterator
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public static &lt;K&gt; Iterator&lt;K&gt; indexToIdIterator(IntIterator indexIter, IndexIdMap&lt;K&gt; map) {
<span class="fc bfc" id="L59" title="All 2 branches covered.">		if (map instanceof IndexIntIdMap)</span>
<span class="fc" id="L60">			return (Iterator&lt;K&gt;) indexToIdIterator(indexIter, (IndexIntIdMap) map);</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">		if (indexIter instanceof IdToIndexIterator) {</span>
<span class="fc" id="L62">			IdToIndexIterator&lt;K&gt; indexIter0 = (IdToIndexIterator&lt;K&gt;) indexIter;</span>
<span class="fc bfc" id="L63" title="All 2 branches covered.">			if (indexIter0.map == map)</span>
<span class="fc" id="L64">				return indexIter0.idIt;</span>
		}
<span class="fc" id="L66">		return new IndexToIdIterator&lt;&gt;(indexIter, map);</span>
	}

	/**
	 * Create an IDs iterator from an iterator of indices.
	 *
	 * @param  indexIter an iterator of indices
	 * @param  map       index-id mapping
	 * @return           an iterator that iterate over the IDs matching the indices iterated by the original
	 *                   index-iterator
	 */
	public static IntIterator indexToIdIterator(IntIterator indexIter, IndexIntIdMap map) {
<span class="fc bfc" id="L78" title="All 2 branches covered.">		if (indexIter instanceof IntIdToIndexIterator) {</span>
<span class="fc" id="L79">			IntIdToIndexIterator indexIter0 = (IntIdToIndexIterator) indexIter;</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">			if (indexIter0.map == map)</span>
<span class="fc" id="L81">				return indexIter0.idIt;</span>
		}
<span class="fc" id="L83">		return new IndexToIntIdIterator(indexIter, map);</span>
	}

	/**
	 * Create an indices iterator from an iterator of IDs.
	 *
	 * @param  &lt;K&gt;    the type of IDs
	 * @param  idIter an iterator of IDs
	 * @param  map    index-id mapping
	 * @return        an iterator that iterate over the indices matching the IDs iterated by the original ID-iterator
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public static &lt;K&gt; IntIterator idToIndexIterator(Iterator&lt;K&gt; idIter, IndexIdMap&lt;K&gt; map) {
<span class="fc bfc" id="L96" title="All 2 branches covered.">		if (map instanceof IndexIntIdMap) {</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">			if (idIter instanceof IndexToIntIdIterator) {</span>
<span class="fc" id="L98">				IndexToIntIdIterator idIter0 = (IndexToIntIdIterator) idIter;</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">				if (idIter0.map == map)</span>
<span class="fc" id="L100">					return idIter0.indexIt;</span>
			}
<span class="fc" id="L102">			return new IntIdToIndexIterator(IntAdapters.asIntIterator((Iterator&lt;Integer&gt;) idIter), (IndexIntIdMap) map);</span>
		} else {
<span class="fc bfc" id="L104" title="All 2 branches covered.">			if (idIter instanceof IndexToIdIterator) {</span>
<span class="fc" id="L105">				IndexToIdIterator&lt;K&gt; idIter0 = (IndexToIdIterator&lt;K&gt;) idIter;</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">				if (idIter0.map == map)</span>
<span class="fc" id="L107">					return idIter0.indexIt;</span>
			}
<span class="fc" id="L109">			return new IdToIndexIterator&lt;&gt;(idIter, map);</span>
		}
	}

	private static class IndexToIdIterator&lt;K&gt; implements ObjectIterator&lt;K&gt; {

		private final IntIterator indexIt;
		private final IndexIdMap&lt;K&gt; map;

<span class="fc" id="L118">		IndexToIdIterator(IntIterator idxIt, IndexIdMap&lt;K&gt; map) {</span>
<span class="fc" id="L119">			this.indexIt = Objects.requireNonNull(idxIt);</span>
<span class="fc" id="L120">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L121">		}</span>

		IntIterator indexIt() {
<span class="fc" id="L124">			return indexIt;</span>
		}

		IndexIdMap&lt;K&gt; map() {
<span class="fc" id="L128">			return map;</span>
		}

		@Override
		public boolean hasNext() {
<span class="fc" id="L133">			return indexIt.hasNext();</span>
		}

		@Override
		public K next() {
<span class="fc" id="L138">			return map.indexToId(indexIt.nextInt());</span>
		}

		@Override
		public void remove() {
<span class="fc" id="L143">			indexIt.remove();</span>
<span class="fc" id="L144">		}</span>

		@Override
		public int skip(int n) {
<span class="fc" id="L148">			return indexIt.skip(n);</span>
		}
	}

	private static class IndexToIntIdIterator implements IntIterator {

		private final IntIterator indexIt;
		private final IndexIntIdMap map;

<span class="fc" id="L157">		IndexToIntIdIterator(IntIterator idxIt, IndexIntIdMap map) {</span>
<span class="fc" id="L158">			this.indexIt = Objects.requireNonNull(idxIt);</span>
<span class="fc" id="L159">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L160">		}</span>

		IntIterator indexIt() {
<span class="fc" id="L163">			return indexIt;</span>
		}

		IndexIntIdMap map() {
<span class="fc" id="L167">			return map;</span>
		}

		@Override
		public boolean hasNext() {
<span class="fc" id="L172">			return indexIt.hasNext();</span>
		}

		@Override
		public int nextInt() {
<span class="fc" id="L177">			return map.indexToIdInt(indexIt.nextInt());</span>
		}

		@Override
		public void remove() {
<span class="fc" id="L182">			indexIt.remove();</span>
<span class="fc" id="L183">		}</span>

		@Override
		public int skip(int n) {
<span class="fc" id="L187">			return indexIt.skip(n);</span>
		}
	}

	private static class IdToIndexIterator&lt;K&gt; implements IntIterator {

		final Iterator&lt;K&gt; idIt;
		final IndexIdMap&lt;K&gt; map;

<span class="fc" id="L196">		IdToIndexIterator(Iterator&lt;K&gt; idIt, IndexIdMap&lt;K&gt; map) {</span>
<span class="fc" id="L197">			this.idIt = Objects.requireNonNull(idIt);</span>
<span class="fc" id="L198">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L199">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc" id="L203">			return idIt.hasNext();</span>
		}

		@Override
		public int nextInt() {
<span class="fc" id="L208">			return map.idToIndex(idIt.next());</span>
		}

		@Override
		public void remove() {
<span class="fc" id="L213">			idIt.remove();</span>
<span class="fc" id="L214">		}</span>

		@Override
		public int skip(int n) {
<span class="fc" id="L218">			return JGAlgoUtils.objIterSkip(idIt, n);</span>
		}
	}

	private static class IntIdToIndexIterator implements IntIterator {

		final IntIterator idIt;
		final IndexIntIdMap map;

<span class="fc" id="L227">		IntIdToIndexIterator(IntIterator idIt, IndexIntIdMap map) {</span>
<span class="fc" id="L228">			this.idIt = Objects.requireNonNull(idIt);</span>
<span class="fc" id="L229">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L230">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc" id="L234">			return idIt.hasNext();</span>
		}

		@Override
		public int nextInt() {
<span class="fc" id="L239">			return map.idToIndex(idIt.nextInt());</span>
		}

		@Override
		public void remove() {
<span class="fc" id="L244">			idIt.remove();</span>
<span class="fc" id="L245">		}</span>

		@Override
		public int skip(int n) {
<span class="fc" id="L249">			return idIt.skip(n);</span>
		}
	}

	private static class IdToIndexListIterator&lt;K&gt; extends IdToIndexIterator&lt;K&gt; implements IntListIterator {

		IdToIndexListIterator(ListIterator&lt;K&gt; idIt, IndexIdMap&lt;K&gt; map) {
<span class="fc" id="L256">			super(idIt, map);</span>
<span class="fc" id="L257">		}</span>

		ListIterator&lt;K&gt; idIt() {
<span class="fc" id="L260">			return (ListIterator&lt;K&gt;) idIt;</span>
		}

		@Override
		public boolean hasPrevious() {
<span class="fc" id="L265">			return idIt().hasPrevious();</span>
		}

		@Override
		public int previousInt() {
<span class="fc" id="L270">			return map.idToIndex(idIt().previous());</span>
		}

		@Override
		public int nextIndex() {
<span class="fc" id="L275">			return idIt().nextIndex();</span>
		}

		@Override
		public int previousIndex() {
<span class="fc" id="L280">			return idIt().previousIndex();</span>
		}

		@Override
		public int back(int n) {
<span class="fc" id="L285">			return JGAlgoUtils.objIterBack(idIt(), n);</span>
		}
	}

	private static class IntIdToIndexListIterator extends IntIdToIndexIterator implements IntListIterator {

		IntIdToIndexListIterator(IntListIterator idIt, IndexIntIdMap map) {
<span class="fc" id="L292">			super(idIt, map);</span>
<span class="fc" id="L293">		}</span>

		IntListIterator idIt() {
<span class="fc" id="L296">			return (IntListIterator) idIt;</span>
		}

		@Override
		public boolean hasPrevious() {
<span class="fc" id="L301">			return idIt().hasPrevious();</span>
		}

		@Override
		public int previousInt() {
<span class="fc" id="L306">			return map.idToIndex(idIt().previousInt());</span>
		}

		@Override
		public int nextIndex() {
<span class="fc" id="L311">			return idIt().nextIndex();</span>
		}

		@Override
		public int previousIndex() {
<span class="fc" id="L316">			return idIt().previousIndex();</span>
		}

		@Override
		public int back(int n) {
<span class="fc" id="L321">			return idIt().back(n);</span>
		}
	}

	/**
	 * Create an {@link IEdgeIter} that return IDs of vertices and edges from an {@link IEdgeIter} that return indices
	 * of vertices and edges.
	 *
	 * @param  &lt;V&gt;       the vertices type
	 * @param  &lt;E&gt;       the edges type
	 * @param  g         the graph
	 * @param  indexIter an {@link IEdgeIter} that return indices of vertices and edges
	 * @return           {@link IEdgeIter} that return IDs of vertices and edges matching the indices of vertices and
	 *                   edges returned by the original index-iterator
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public static &lt;V, E&gt; EdgeIter&lt;V, E&gt; indexToIdEdgeIter(Graph&lt;V, E&gt; g, IEdgeIter indexIter) {
<span class="fc bfc" id="L338" title="All 2 branches covered.">		if (g instanceof IntGraph) {</span>
<span class="fc" id="L339">			return (EdgeIter&lt;V, E&gt;) indexToIdEdgeIter((IntGraph) g, indexIter);</span>
		} else {
<span class="fc" id="L341">			return new IndexToIdEdgeIter&lt;&gt;(g, indexIter);</span>
		}
	}

	/**
	 * Create an {@link IEdgeIter} that return IDs of vertices and edges from an {@link IEdgeIter} that return indices
	 * of vertices and edges.
	 *
	 * @param  g         the graph
	 * @param  indexIter an {@link IEdgeIter} that return indices of vertices and edges
	 * @return           {@link IEdgeIter} that return IDs of vertices and edges matching the indices of vertices and
	 *                   edges returned by the original index-iterator
	 */
	public static IEdgeIter indexToIdEdgeIter(IntGraph g, IEdgeIter indexIter) {
<span class="fc" id="L355">		return new IndexToIntIdEdgeIter(g, indexIter);</span>
	}

	private static class IndexToIdEdgeIter&lt;V, E&gt; extends IndexToIdIterator&lt;E&gt; implements EdgeIter&lt;V, E&gt; {
		private final IndexIdMap&lt;V&gt; viMap;

		IndexToIdEdgeIter(Graph&lt;V, E&gt; g, IEdgeIter indexIt) {
<span class="fc" id="L362">			super(indexIt, g.indexGraphEdgesMap());</span>
<span class="fc" id="L363">			this.viMap = g.indexGraphVerticesMap();</span>
<span class="fc" id="L364">		}</span>

		@Override
		IEdgeIter indexIt() {
<span class="fc" id="L368">			return (IEdgeIter) super.indexIt();</span>
		}

		IndexIdMap&lt;E&gt; eiMap() {
<span class="fc" id="L372">			return super.map();</span>
		}

		@Override
		public E peekNext() {
<span class="fc" id="L377">			return eiMap().indexToId(indexIt().peekNextInt());</span>
		}

		@Override
		public V source() {
<span class="fc" id="L382">			return viMap.indexToId(indexIt().sourceInt());</span>
		}

		@Override
		public V target() {
<span class="fc" id="L387">			return viMap.indexToId(indexIt().targetInt());</span>
		}
	}

	private static class IndexToIntIdEdgeIter extends IndexToIntIdIterator implements IEdgeIter {
		private final IndexIntIdMap viMap;

		IndexToIntIdEdgeIter(IntGraph g, IEdgeIter indexIt) {
<span class="fc" id="L395">			super(indexIt, g.indexGraphEdgesMap());</span>
<span class="fc" id="L396">			this.viMap = g.indexGraphVerticesMap();</span>
<span class="fc" id="L397">		}</span>

		@Override
		IEdgeIter indexIt() {
<span class="fc" id="L401">			return (IEdgeIter) super.indexIt();</span>
		}

		IndexIntIdMap eiMap() {
<span class="fc" id="L405">			return super.map();</span>
		}

		@Override
		public int peekNextInt() {
<span class="fc" id="L410">			return eiMap().indexToIdInt(indexIt().peekNextInt());</span>
		}

		@Override
		public int sourceInt() {
<span class="fc" id="L415">			return viMap.indexToIdInt(indexIt().sourceInt());</span>
		}

		@Override
		public int targetInt() {
<span class="fc" id="L420">			return viMap.indexToIdInt(indexIt().targetInt());</span>
		}
	}

	private static class IndexToIdEdgeSet&lt;V, E&gt; extends IndexToIdSet&lt;E&gt; implements EdgeSet&lt;V, E&gt; {

		private final Graph&lt;V, E&gt; g;

		IndexToIdEdgeSet(IEdgeSet indexSet, Graph&lt;V, E&gt; g) {
<span class="fc" id="L429">			super(indexSet, g.indexGraphEdgesMap());</span>
<span class="fc" id="L430">			this.g = g;</span>
<span class="fc" id="L431">		}</span>

		@Override
		public IndexToIdEdgeIter&lt;V, E&gt; iterator() {
<span class="fc" id="L435">			return new IndexToIdEdgeIter&lt;&gt;(g, ((IEdgeSet) idxSet).iterator());</span>
		}
	}

	static class IndexToIntIdEdgeSet extends AbstractIntSet implements IEdgeSet {

		private final IEdgeSet indexSet;
		private final IntGraph g;
		private final IndexIntIdMap eiMap;

<span class="fc" id="L445">		IndexToIntIdEdgeSet(IEdgeSet indexSet, IntGraph g) {</span>
<span class="fc" id="L446">			this.indexSet = Objects.requireNonNull(indexSet);</span>
<span class="fc" id="L447">			this.g = g;</span>
<span class="fc" id="L448">			this.eiMap = g.indexGraphEdgesMap();</span>
<span class="fc" id="L449">		}</span>

		@Override
		public boolean remove(int edge) {
<span class="fc" id="L453">			return indexSet.remove(eiMap.idToIndexIfExist(edge));</span>
		}

		@Override
		public boolean contains(int edge) {
<span class="fc" id="L458">			return indexSet.contains(eiMap.idToIndexIfExist(edge));</span>
		}

		@Override
		public int size() {
<span class="fc" id="L463">			return indexSet.size();</span>
		}

		@Override
		public boolean isEmpty() {
<span class="fc" id="L468">			return indexSet.isEmpty();</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L473">			indexSet.clear();</span>
<span class="fc" id="L474">		}</span>

		@Override
		public IEdgeIter iterator() {
<span class="fc" id="L478">			return indexToIdEdgeIter(g, indexSet.iterator());</span>
		}
	}

	/**
	 * Create an edge set of IDs from an edge set of indices.
	 *
	 * @param  &lt;V&gt;      the vertices type
	 * @param  &lt;E&gt;      the edges type
	 * @param  indexSet an indices edge set
	 * @param  g        the graph
	 * @return          an edge set of IDs matching the indices contained in the original index-set
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public static &lt;V, E&gt; EdgeSet&lt;V, E&gt; indexToIdEdgeSet(IEdgeSet indexSet, Graph&lt;V, E&gt; g) {
<span class="fc bfc" id="L493" title="All 2 branches covered.">		if (g instanceof IntGraph) {</span>
<span class="fc" id="L494">			return (EdgeSet&lt;V, E&gt;) indexToIdEdgeSet(indexSet, (IntGraph) g);</span>
		} else {
<span class="fc" id="L496">			return new IndexToIdEdgeSet&lt;&gt;(indexSet, g);</span>
		}
	}

	/**
	 * Create an edge set of IDs from an edge set of indices in an {@link IntGraph}.
	 *
	 * @param  indexSet an indices edge set
	 * @param  g        the graph
	 * @return          an edge set of IDs matching the indices contained in the original index-set
	 */
	public static IEdgeSet indexToIdEdgeSet(IEdgeSet indexSet, IntGraph g) {
<span class="fc" id="L508">		return new IndexToIntIdEdgeSet(indexSet, g);</span>
	}

	/**
	 * Create an IDs collection from a collection of indices.
	 *
	 * @param  &lt;K&gt;             the type of IDs
	 * @param  indexCollection a collection of indices
	 * @param  map             index-id mapping
	 * @return                 a collection that contain IDs matching the indices contained in the original
	 *                         index-collection
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public static &lt;K&gt; Collection&lt;K&gt; indexToIdCollection(IntCollection indexCollection, IndexIdMap&lt;K&gt; map) {
<span class="fc bfc" id="L522" title="All 2 branches covered.">		if (indexCollection instanceof IntSet) {</span>
<span class="fc" id="L523">			return indexToIdSet((IntSet) indexCollection, map);</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">		} else if (indexCollection instanceof IntList) {</span>
<span class="fc" id="L525">			return indexToIdList((IntList) indexCollection, map);</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">		} else if (map instanceof IndexIntIdMap) {</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">			if (indexCollection instanceof IntIdToIndexCollection) {</span>
<span class="fc" id="L528">				IntIdToIndexCollection indexCollection0 = (IntIdToIndexCollection) indexCollection;</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">				if (indexCollection0.map == map)</span>
<span class="fc" id="L530">					return (Collection&lt;K&gt;) indexCollection0.idC;</span>
			}
<span class="fc" id="L532">			return (Collection&lt;K&gt;) new IndexToIntIdCollection(indexCollection, (IndexIntIdMap) map);</span>
		} else {
<span class="fc bfc" id="L534" title="All 2 branches covered.">			if (indexCollection instanceof IdToIndexCollection) {</span>
<span class="fc" id="L535">				IdToIndexCollection&lt;K&gt; indexCollection0 = (IdToIndexCollection&lt;K&gt;) indexCollection;</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">				if (indexCollection0.map == map)</span>
<span class="fc" id="L537">					return indexCollection0.idC;</span>
			}
<span class="fc" id="L539">			return new IndexToIdCollection&lt;&gt;(indexCollection, map);</span>
		}
	}

	/**
	 * Create an int IDs collection from a collection of indices.
	 *
	 * @param  indexCollection a collection of indices
	 * @param  map             index-id mapping
	 * @return                 a collection that contain IDs matching the indices contained in the original
	 *                         index-collection
	 */
	public static IntCollection indexToIdCollection(IntCollection indexCollection, IndexIntIdMap map) {
<span class="fc" id="L552">		return (IntCollection) indexToIdCollection(indexCollection, (IndexIdMap&lt;Integer&gt;) map);</span>
	}

	private static class IndexToIdCollection&lt;K&gt; extends AbstractCollection&lt;K&gt; {

		final IntCollection indexC;
		final IndexIdMap&lt;K&gt; map;

<span class="fc" id="L560">		IndexToIdCollection(IntCollection indexC, IndexIdMap&lt;K&gt; map) {</span>
<span class="fc" id="L561">			this.indexC = Objects.requireNonNull(indexC);</span>
<span class="fc" id="L562">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L563">		}</span>

		@Override
		public int size() {
<span class="fc" id="L567">			return indexC.size();</span>
		}

		@Override
		public boolean isEmpty() {
<span class="fc" id="L572">			return indexC.isEmpty();</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L577">			indexC.clear();</span>
<span class="fc" id="L578">		}</span>

		@Override
		public Iterator&lt;K&gt; iterator() {
<span class="fc" id="L582">			return new IndexToIdIterator&lt;&gt;(indexC.iterator(), map);</span>
		}

		@SuppressWarnings(&quot;unchecked&quot;)
		@Override
		public boolean contains(Object key) {
<span class="fc" id="L588">			return indexC.contains(map.idToIndexIfExist((K) key));</span>
		}

		@SuppressWarnings(&quot;unchecked&quot;)
		@Override
		public boolean remove(Object key) {
<span class="fc" id="L594">			return indexC.rem(map.idToIndexIfExist((K) key));</span>
		}
	}

	private static class IndexToIntIdCollection extends AbstractIntCollection {

		final IntCollection indexC;
		final IndexIntIdMap map;

<span class="fc" id="L603">		IndexToIntIdCollection(IntCollection indexC, IndexIntIdMap map) {</span>
<span class="fc" id="L604">			this.indexC = Objects.requireNonNull(indexC);</span>
<span class="fc" id="L605">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L606">		}</span>

		@Override
		public int size() {
<span class="fc" id="L610">			return indexC.size();</span>
		}

		@Override
		public boolean isEmpty() {
<span class="fc" id="L615">			return indexC.isEmpty();</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L620">			indexC.clear();</span>
<span class="fc" id="L621">		}</span>

		@Override
		public IntIterator iterator() {
<span class="fc" id="L625">			return new IndexToIntIdIterator(indexC.iterator(), map);</span>
		}

		@Override
		public boolean contains(int key) {
<span class="fc" id="L630">			return indexC.contains(map.idToIndexIfExist(key));</span>
		}

		@Override
		public boolean rem(int key) {
<span class="fc" id="L635">			return indexC.rem(map.idToIndexIfExist(key));</span>
		}
	}

	/**
	 * Create an IDs set from a set of indices.
	 *
	 * @param  &lt;K&gt;      the type of IDs
	 * @param  indexSet a set of indices
	 * @param  map      index-id mapping
	 * @return          a set that contain IDs matching the indices contained in the original index-set
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public static &lt;K&gt; Set&lt;K&gt; indexToIdSet(IntSet indexSet, IndexIdMap&lt;K&gt; map) {
<span class="fc bfc" id="L649" title="All 2 branches covered.">		if (map instanceof IndexIntIdMap)</span>
<span class="fc" id="L650">			return (Set&lt;K&gt;) indexToIdSet(indexSet, (IndexIntIdMap) map);</span>
<span class="fc bfc" id="L651" title="All 2 branches covered.">		if (indexSet instanceof IdToIndexSet) {</span>
<span class="fc" id="L652">			IdToIndexSet&lt;K&gt; indexSet0 = (IdToIndexSet&lt;K&gt;) indexSet;</span>
<span class="fc bfc" id="L653" title="All 2 branches covered.">			if (indexSet0.map == map)</span>
<span class="fc" id="L654">				return indexSet0.idC;</span>
		}
<span class="fc" id="L656">		return new IndexToIdSet&lt;&gt;(indexSet, map);</span>
	}

	/**
	 * Create an IDs set from a set of indices.
	 *
	 * @param  indexSet a set of indices
	 * @param  map      index-id mapping
	 * @return          a set that contain IDs matching the indices contained in the original index-set
	 */
	public static IntSet indexToIdSet(IntSet indexSet, IndexIntIdMap map) {
<span class="fc bfc" id="L667" title="All 2 branches covered.">		if (indexSet instanceof IntIdToIndexSet) {</span>
<span class="fc" id="L668">			IntIdToIndexSet indexSet0 = (IntIdToIndexSet) indexSet;</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">			if (indexSet0.map == map)</span>
<span class="fc" id="L670">				return indexSet0.idC;</span>
		}
<span class="fc" id="L672">		return new IndexToIntIdSet(indexSet, map);</span>
	}

	private static class IndexToIdSet&lt;K&gt; extends AbstractObjectSet&lt;K&gt; {

		final IntSet idxSet;
		final IndexIdMap&lt;K&gt; map;

<span class="fc" id="L680">		IndexToIdSet(IntSet idxSet, IndexIdMap&lt;K&gt; map) {</span>
<span class="fc" id="L681">			this.idxSet = Objects.requireNonNull(idxSet);</span>
<span class="fc" id="L682">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L683">		}</span>

		@Override
		public int size() {
<span class="fc" id="L687">			return idxSet.size();</span>
		}

		@Override
		public boolean isEmpty() {
<span class="fc" id="L692">			return idxSet.isEmpty();</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L697">			idxSet.clear();</span>
<span class="fc" id="L698">		}</span>

		@Override
		public ObjectIterator&lt;K&gt; iterator() {
<span class="fc" id="L702">			return new IndexToIdIterator&lt;&gt;(idxSet.iterator(), map);</span>
		}

		@SuppressWarnings(&quot;unchecked&quot;)
		@Override
		public boolean contains(Object key) {
<span class="fc" id="L708">			return idxSet.contains(map.idToIndexIfExist((K) key));</span>
		}

		@SuppressWarnings(&quot;unchecked&quot;)
		@Override
		public boolean remove(Object key) {
<span class="fc" id="L714">			return idxSet.remove(map.idToIndexIfExist((K) key));</span>
		}
	}

	private static class IndexToIntIdSet extends AbstractIntSet {

		final IntSet idxSet;
		final IndexIntIdMap map;

<span class="fc" id="L723">		IndexToIntIdSet(IntSet idxSet, IndexIntIdMap map) {</span>
<span class="fc" id="L724">			this.idxSet = Objects.requireNonNull(idxSet);</span>
<span class="fc" id="L725">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L726">		}</span>

		@Override
		public int size() {
<span class="fc" id="L730">			return idxSet.size();</span>
		}

		@Override
		public boolean isEmpty() {
<span class="fc" id="L735">			return idxSet.isEmpty();</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L740">			idxSet.clear();</span>
<span class="fc" id="L741">		}</span>

		@Override
		public IntIterator iterator() {
<span class="fc" id="L745">			return new IndexToIntIdIterator(idxSet.iterator(), map);</span>
		}

		@Override
		public boolean contains(int key) {
<span class="fc" id="L750">			return idxSet.contains(map.idToIndexIfExist(key));</span>
		}
	}

	/**
	 * Create an indices collection from a collection of IDs.
	 *
	 * @param  &lt;K&gt;          the type of IDs
	 * @param  idCollection a collection of IDs
	 * @param  map          index-id mapping
	 * @return              a collection that contain indices matching the IDs contained in the original ID-collection
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public static &lt;K&gt; IntCollection idToIndexCollection(Collection&lt;K&gt; idCollection, IndexIdMap&lt;K&gt; map) {
<span class="fc bfc" id="L764" title="All 2 branches covered.">		if (idCollection instanceof Set)</span>
<span class="fc" id="L765">			return idToIndexSet((Set&lt;K&gt;) idCollection, map);</span>

<span class="fc bfc" id="L767" title="All 2 branches covered.">		if (idCollection instanceof List)</span>
<span class="fc" id="L768">			return idToIndexList((List&lt;K&gt;) idCollection, map);</span>

<span class="fc bfc" id="L770" title="All 2 branches covered.">		if (map instanceof IndexIntIdMap) {</span>
<span class="fc bfc" id="L771" title="All 2 branches covered.">			if (idCollection instanceof IndexToIntIdCollection) {</span>
<span class="fc" id="L772">				IndexToIntIdCollection idCollection0 = (IndexToIntIdCollection) idCollection;</span>
<span class="fc bfc" id="L773" title="All 2 branches covered.">				if (idCollection0.map == map)</span>
<span class="fc" id="L774">					return idCollection0.indexC;</span>
			}
<span class="fc" id="L776">			return new IntIdToIndexCollection(IntAdapters.asIntCollection((Collection&lt;Integer&gt;) idCollection),</span>
					(IndexIntIdMap) map);
		} else {
<span class="fc bfc" id="L779" title="All 2 branches covered.">			if (idCollection instanceof IndexToIdCollection) {</span>
<span class="fc" id="L780">				IndexToIdCollection&lt;K&gt; idCollection0 = (IndexToIdCollection&lt;K&gt;) idCollection;</span>
<span class="fc bfc" id="L781" title="All 2 branches covered.">				if (idCollection0.map == map)</span>
<span class="fc" id="L782">					return idCollection0.indexC;</span>
			}
<span class="fc" id="L784">			return new IdToIndexCollection&lt;&gt;(idCollection, map);</span>
		}
	}

	/**
	 * Create an indices set from a set of IDs.
	 *
	 * @param  &lt;K&gt;   the type of IDs
	 * @param  idSet a set of IDs
	 * @param  map   index-id mapping
	 * @return       a set that contain indices matching the IDs contained in the original ID-set
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public static &lt;K&gt; IntSet idToIndexSet(Set&lt;K&gt; idSet, IndexIdMap&lt;K&gt; map) {
<span class="fc bfc" id="L798" title="All 2 branches covered.">		if (map instanceof IndexIntIdMap) {</span>
<span class="fc bfc" id="L799" title="All 2 branches covered.">			if (idSet instanceof IndexToIntIdSet) {</span>
<span class="fc" id="L800">				IndexToIntIdSet idSet0 = (IndexToIntIdSet) idSet;</span>
<span class="fc bfc" id="L801" title="All 2 branches covered.">				if (idSet0.map == map)</span>
<span class="fc" id="L802">					return idSet0.idxSet;</span>
			}
<span class="fc" id="L804">			return new IntIdToIndexSet(IntAdapters.asIntSet((Set&lt;Integer&gt;) idSet), (IndexIntIdMap) map);</span>
		} else {
<span class="fc bfc" id="L806" title="All 2 branches covered.">			if (idSet instanceof IndexToIdSet) {</span>
<span class="fc" id="L807">				IndexToIdSet&lt;K&gt; idSet0 = (IndexToIdSet&lt;K&gt;) idSet;</span>
<span class="fc bfc" id="L808" title="All 2 branches covered.">				if (idSet0.map == map)</span>
<span class="fc" id="L809">					return idSet0.idxSet;</span>
			}
<span class="fc" id="L811">			return new IdToIndexSet&lt;&gt;(idSet, map);</span>
		}
	}

	/**
	 * Create an indices list from a list of IDs.
	 *
	 * @param  &lt;K&gt;    the type of IDs
	 * @param  idList a list of IDs
	 * @param  map    index-id mapping
	 * @return        a list that contain indices matching the IDs contained in the original ID-list
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public static &lt;K&gt; IntList idToIndexList(List&lt;K&gt; idList, IndexIdMap&lt;K&gt; map) {
<span class="fc bfc" id="L825" title="All 2 branches covered.">		if (map instanceof IndexIntIdMap) {</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">			if (idList instanceof IndexToIntIdList) {</span>
<span class="fc" id="L827">				IndexToIntIdList idList0 = (IndexToIntIdList) idList;</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">				if (idList0.map == map)</span>
<span class="fc" id="L829">					return idList0.indexList;</span>
			}
<span class="fc" id="L831">			return new IntIdToIndexList(IntAdapters.asIntList((List&lt;Integer&gt;) idList), (IndexIntIdMap) map);</span>
		} else {
<span class="fc bfc" id="L833" title="All 2 branches covered.">			if (idList instanceof IndexToIdList) {</span>
<span class="fc" id="L834">				IndexToIdList&lt;K&gt; idList0 = (IndexToIdList&lt;K&gt;) idList;</span>
<span class="fc bfc" id="L835" title="All 2 branches covered.">				if (idList0.map == map)</span>
<span class="fc" id="L836">					return idList0.indexList;</span>
			}
<span class="fc" id="L838">			return new IdToIndexList&lt;&gt;(idList, map);</span>
		}
	}

	private static class IdToIndexCollection&lt;K&gt; extends AbstractIntCollection {

		private final Collection&lt;K&gt; idC;
		private final IndexIdMap&lt;K&gt; map;

<span class="fc" id="L847">		IdToIndexCollection(Collection&lt;K&gt; idC, IndexIdMap&lt;K&gt; map) {</span>
<span class="fc" id="L848">			this.idC = Objects.requireNonNull(idC);</span>
<span class="fc" id="L849">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L850">		}</span>

		@Override
		public int size() {
<span class="fc" id="L854">			return idC.size();</span>
		}

		@Override
		public boolean isEmpty() {
<span class="fc" id="L859">			return idC.isEmpty();</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L864">			idC.clear();</span>
<span class="fc" id="L865">		}</span>

		@Override
		public IntIterator iterator() {
<span class="fc" id="L869">			return new IdToIndexIterator&lt;&gt;(idC.iterator(), map);</span>
		}

		@Override
		public boolean contains(int idx) {
<span class="fc" id="L874">			return idC.contains(map.indexToIdIfExist(idx));</span>
		}

		@Override
		public boolean rem(int idx) {
<span class="fc" id="L879">			return idC.remove(map.indexToIdIfExist(idx));</span>
		}
	}

	private static class IntIdToIndexCollection extends AbstractIntCollection {

		private final IntCollection idC;
		private final IndexIntIdMap map;

<span class="fc" id="L888">		IntIdToIndexCollection(IntCollection idC, IndexIntIdMap map) {</span>
<span class="fc" id="L889">			this.idC = Objects.requireNonNull(idC);</span>
<span class="fc" id="L890">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L891">		}</span>

		@Override
		public int size() {
<span class="fc" id="L895">			return idC.size();</span>
		}

		@Override
		public boolean isEmpty() {
<span class="fc" id="L900">			return idC.isEmpty();</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L905">			idC.clear();</span>
<span class="fc" id="L906">		}</span>

		@Override
		public IntIterator iterator() {
<span class="fc" id="L910">			return new IntIdToIndexIterator(idC.iterator(), map);</span>
		}

		@Override
		public boolean contains(int key) {
<span class="fc" id="L915">			return idC.contains(map.indexToIdIfExistInt(key));</span>
		}

		@Override
		public boolean rem(int key) {
<span class="fc" id="L920">			return idC.rem(map.indexToIdIfExistInt(key));</span>
		}
	}

	private static class IdToIndexSet&lt;K&gt; extends AbstractIntSet {

		private final Set&lt;K&gt; idC;
		private final IndexIdMap&lt;K&gt; map;

<span class="fc" id="L929">		IdToIndexSet(Set&lt;K&gt; idC, IndexIdMap&lt;K&gt; map) {</span>
<span class="fc" id="L930">			this.idC = Objects.requireNonNull(idC);</span>
<span class="fc" id="L931">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L932">		}</span>

		@Override
		public boolean contains(int key) {
<span class="fc" id="L936">			return idC.contains(map.indexToIdIfExist(key));</span>
		}

		@Override
		public int size() {
<span class="fc" id="L941">			return idC.size();</span>
		}

		@Override
		public boolean isEmpty() {
<span class="fc" id="L946">			return idC.isEmpty();</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L951">			idC.clear();</span>
<span class="fc" id="L952">		}</span>

		@Override
		public IntIterator iterator() {
<span class="fc" id="L956">			return new IdToIndexIterator&lt;&gt;(idC.iterator(), map);</span>
		}

		@Override
		public boolean remove(int key) {
<span class="fc" id="L961">			return idC.remove(map.indexToIdIfExist(key));</span>
		}
	}

	private static class IntIdToIndexSet extends AbstractIntSet {

		private final IntSet idC;
		private final IndexIntIdMap map;

<span class="fc" id="L970">		IntIdToIndexSet(IntSet idC, IndexIntIdMap map) {</span>
<span class="fc" id="L971">			this.idC = Objects.requireNonNull(idC);</span>
<span class="fc" id="L972">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L973">		}</span>

		@Override
		public boolean contains(int key) {
<span class="fc" id="L977">			return idC.contains(map.indexToIdIfExistInt(key));</span>
		}

		@Override
		public int size() {
<span class="fc" id="L982">			return idC.size();</span>
		}

		@Override
		public boolean isEmpty() {
<span class="fc" id="L987">			return idC.isEmpty();</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L992">			idC.clear();</span>
<span class="fc" id="L993">		}</span>

		@Override
		public IntIterator iterator() {
<span class="fc" id="L997">			return new IdToIndexIterator&lt;&gt;(idC.iterator(), map);</span>
		}

		@Override
		public boolean remove(int key) {
<span class="fc" id="L1002">			return idC.remove(map.indexToIdIfExistInt(key));</span>
		}
	}

	private static class IdToIndexList&lt;K&gt; extends AbstractIntList {

		private final List&lt;K&gt; idList;
		private final IndexIdMap&lt;K&gt; map;

<span class="fc" id="L1011">		IdToIndexList(List&lt;K&gt; idC, IndexIdMap&lt;K&gt; map) {</span>
<span class="fc" id="L1012">			this.idList = Objects.requireNonNull(idC);</span>
<span class="fc" id="L1013">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L1014">		}</span>

		@Override
		public int size() {
<span class="fc" id="L1018">			return idList.size();</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L1023">			idList.clear();</span>
<span class="fc" id="L1024">		}</span>

		@Override
		public boolean contains(int key) {
<span class="fc" id="L1028">			return idList.contains(map.indexToIdIfExist(key));</span>
		}

		@Override
		public boolean rem(int key) {
<span class="fc" id="L1033">			K id = map.indexToIdIfExist(key);</span>
<span class="fc bfc" id="L1034" title="All 4 branches covered.">			return id != null &amp;&amp; idList.remove(id);</span>
		}

		@Override
		public IntListIterator listIterator(int index) {
<span class="fc" id="L1039">			return new IdToIndexListIterator&lt;&gt;(idList.listIterator(index), map);</span>
		}

		@Override
		public int getInt(int index) {
<span class="fc" id="L1044">			return map.idToIndex(idList.get(index));</span>
		}

		@Override
		public int indexOf(int k) {
<span class="fc" id="L1049">			K id = map.indexToIdIfExist(k);</span>
<span class="fc bfc" id="L1050" title="All 2 branches covered.">			return id == null ? -1 : idList.indexOf(id);</span>
		}

		@Override
		public int lastIndexOf(int k) {
<span class="fc" id="L1055">			K id = map.indexToIdIfExist(k);</span>
<span class="fc bfc" id="L1056" title="All 2 branches covered.">			return id == null ? -1 : idList.lastIndexOf(id);</span>
		}

		@Override
		public int removeInt(int index) {
<span class="fc" id="L1061">			return map.idToIndex(idList.remove(index));</span>
		}
	}

	private static class IntIdToIndexList extends AbstractIntList {

		private final IntList idList;
		private final IndexIntIdMap map;

<span class="fc" id="L1070">		IntIdToIndexList(IntList idC, IndexIntIdMap map) {</span>
<span class="fc" id="L1071">			this.idList = Objects.requireNonNull(idC);</span>
<span class="fc" id="L1072">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L1073">		}</span>

		@Override
		public int size() {
<span class="fc" id="L1077">			return idList.size();</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L1082">			idList.clear();</span>
<span class="fc" id="L1083">		}</span>

		@Override
		public boolean contains(int key) {
<span class="fc" id="L1087">			return idList.contains(map.indexToIdIfExistInt(key));</span>
		}

		@Override
		public boolean rem(int key) {
<span class="fc" id="L1092">			int id = map.indexToIdIfExistInt(key);</span>
<span class="fc bfc" id="L1093" title="All 4 branches covered.">			return id &gt;= 0 &amp;&amp; idList.rem(id);</span>
		}

		@Override
		public IntListIterator listIterator(int index) {
<span class="fc" id="L1098">			return new IntIdToIndexListIterator(idList.listIterator(index), map);</span>
		}

		@Override
		public int getInt(int index) {
<span class="fc" id="L1103">			return map.idToIndex(idList.getInt(index));</span>
		}

		@Override
		public int indexOf(int k) {
<span class="fc" id="L1108">			int id = map.indexToIdIfExistInt(k);</span>
<span class="fc bfc" id="L1109" title="All 2 branches covered.">			return id &lt; 0 ? -1 : idList.indexOf(id);</span>
		}

		@Override
		public int lastIndexOf(int k) {
<span class="fc" id="L1114">			int id = map.indexToIdIfExistInt(k);</span>
<span class="fc bfc" id="L1115" title="All 2 branches covered.">			return id &lt; 0 ? -1 : idList.lastIndexOf(id);</span>
		}

		@Override
		public int removeInt(int index) {
<span class="fc" id="L1120">			return map.idToIndex(idList.removeInt(index));</span>
		}
	}

	/**
	 * Create an IDs list from a list of indices.
	 *
	 * @param  &lt;K&gt;       the type of IDs
	 * @param  indexList a list of indices
	 * @param  map       index-id mapping
	 * @return           a list that contain IDs matching the indices contained in the original index-list
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public static &lt;K&gt; List&lt;K&gt; indexToIdList(IntList indexList, IndexIdMap&lt;K&gt; map) {
<span class="fc bfc" id="L1134" title="All 2 branches covered.">		if (map instanceof IndexIntIdMap)</span>
<span class="fc" id="L1135">			return (List&lt;K&gt;) indexToIdList(indexList, (IndexIntIdMap) map);</span>
<span class="fc bfc" id="L1136" title="All 2 branches covered.">		if (indexList instanceof IdToIndexList) {</span>
<span class="fc" id="L1137">			IdToIndexList&lt;K&gt; indexList0 = (IdToIndexList&lt;K&gt;) indexList;</span>
<span class="fc bfc" id="L1138" title="All 2 branches covered.">			if (indexList0.map == map)</span>
<span class="fc" id="L1139">				return indexList0.idList;</span>
		}
<span class="fc" id="L1141">		return new IndexToIdList&lt;&gt;(indexList, map);</span>
	}

	/**
	 * Create an IDs list from a list of indices.
	 *
	 * @param  indexList a list of indices
	 * @param  map       index-id mapping
	 * @return           a list that contain IDs matching the indices contained in the original index-list
	 */
	public static IntList indexToIdList(IntList indexList, IndexIntIdMap map) {
<span class="fc bfc" id="L1152" title="All 2 branches covered.">		if (indexList instanceof IntIdToIndexList) {</span>
<span class="fc" id="L1153">			IntIdToIndexList indexList0 = (IntIdToIndexList) indexList;</span>
<span class="fc bfc" id="L1154" title="All 2 branches covered.">			if (indexList0.map == map)</span>
<span class="fc" id="L1155">				return indexList0.idList;</span>
		}
<span class="fc" id="L1157">		return new IndexToIntIdList(indexList, map);</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	private static class IndexToIdList&lt;K&gt; extends AbstractList&lt;K&gt; {

		private final IntList indexList;
		private final IndexIdMap&lt;K&gt; map;

<span class="fc" id="L1166">		IndexToIdList(IntList indexList, IndexIdMap&lt;K&gt; map) {</span>
<span class="fc" id="L1167">			this.indexList = Objects.requireNonNull(indexList);</span>
<span class="fc" id="L1168">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L1169">		}</span>

		@Override
		public int size() {
<span class="fc" id="L1173">			return indexList.size();</span>
		}

		@Override
		public boolean isEmpty() {
<span class="fc" id="L1178">			return indexList.isEmpty();</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L1183">			indexList.clear();</span>
<span class="fc" id="L1184">		}</span>

		@Override
		public boolean contains(Object key) {
<span class="fc" id="L1188">			return indexList.contains(map.idToIndexIfExist((K) key));</span>
		}

		@Override
		public boolean remove(Object key) {
<span class="fc" id="L1193">			return indexList.rem(map.idToIndexIfExist((K) key));</span>
		}

		@Override
		public K get(int index) {
<span class="fc" id="L1198">			return map.indexToId(indexList.getInt(index));</span>
		}

		@Override
		public int indexOf(Object k) {
<span class="fc" id="L1203">			int idx = map.idToIndexIfExist((K) k);</span>
<span class="fc bfc" id="L1204" title="All 2 branches covered.">			return idx &lt; 0 ? -1 : indexList.indexOf(idx);</span>
		}

		@Override
		public int lastIndexOf(Object k) {
<span class="fc" id="L1209">			int idx = map.idToIndexIfExist((K) k);</span>
<span class="fc bfc" id="L1210" title="All 2 branches covered.">			return idx &lt; 0 ? -1 : indexList.lastIndexOf(idx);</span>
		}

		@Override
		public K remove(int index) {
<span class="fc" id="L1215">			return map.indexToId(indexList.removeInt(index));</span>
		}
	}

	private static class IndexToIntIdList extends AbstractIntList {

		private final IntList indexList;
		private final IndexIntIdMap map;

<span class="fc" id="L1224">		IndexToIntIdList(IntList indexList, IndexIntIdMap map) {</span>
<span class="fc" id="L1225">			this.indexList = Objects.requireNonNull(indexList);</span>
<span class="fc" id="L1226">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L1227">		}</span>

		@Override
		public int size() {
<span class="fc" id="L1231">			return indexList.size();</span>
		}

		@Override
		public boolean isEmpty() {
<span class="fc" id="L1236">			return indexList.isEmpty();</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L1241">			indexList.clear();</span>
<span class="fc" id="L1242">		}</span>

		@Override
		public boolean contains(int key) {
<span class="fc" id="L1246">			return indexList.contains(map.idToIndexIfExist(key));</span>
		}

		@Override
		public boolean rem(int key) {
<span class="fc" id="L1251">			return indexList.rem(map.idToIndexIfExist(key));</span>
		}

		@Override
		public int getInt(int index) {
<span class="fc" id="L1256">			return map.indexToIdInt(indexList.getInt(index));</span>
		}

		@Override
		public int indexOf(int k) {
<span class="fc" id="L1261">			int idx = map.idToIndexIfExist(k);</span>
<span class="fc bfc" id="L1262" title="All 2 branches covered.">			return idx &lt; 0 ? -1 : indexList.indexOf(idx);</span>
		}

		@Override
		public int lastIndexOf(int k) {
<span class="fc" id="L1267">			int idx = map.idToIndexIfExist(k);</span>
<span class="fc bfc" id="L1268" title="All 2 branches covered.">			return idx &lt; 0 ? -1 : indexList.lastIndexOf(idx);</span>
		}

		@Override
		public int removeInt(int index) {
<span class="fc" id="L1273">			return map.indexToIdInt(indexList.removeInt(index));</span>
		}
	}

	private abstract static class IdToIndexWeights&lt;K, T&gt; implements IWeights&lt;T&gt; {

		private final Weights&lt;K, T&gt; idxWeights;
		private final IndexIdMap&lt;K&gt; map;

<span class="fc" id="L1282">		IdToIndexWeights(Weights&lt;K, T&gt; idxWeights, IndexIdMap&lt;K&gt; map) {</span>
<span class="fc" id="L1283">			this.idxWeights = Objects.requireNonNull(idxWeights);</span>
<span class="fc" id="L1284">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L1285">		}</span>

		Weights&lt;K, T&gt; idxWeights() {
<span class="fc" id="L1288">			return idxWeights;</span>
		}

		K id(int index) {
<span class="fc" id="L1292">			return map.indexToId(index);</span>
		}

		static class Obj&lt;K, T&gt; extends IdToIndexWeights&lt;K, T&gt; implements IWeightsObj&lt;T&gt; {

			Obj(WeightsObj&lt;K, T&gt; idxWeights, IndexIdMap&lt;K&gt; map) {
<span class="fc" id="L1298">				super(idxWeights, map);</span>
<span class="fc" id="L1299">			}</span>

			@Override
			WeightsObj&lt;K, T&gt; idxWeights() {
<span class="fc" id="L1303">				return (WeightsObj&lt;K, T&gt;) super.idxWeights();</span>
			}

			@Override
			public T get(int index) {
<span class="fc" id="L1308">				return idxWeights().get(id(index));</span>
			}

			@Override
			public void set(int index, T weight) {
<span class="fc" id="L1313">				idxWeights().set(id(index), weight);</span>
<span class="fc" id="L1314">			}</span>

			@Override
			public T defaultWeight() {
<span class="fc" id="L1318">				return idxWeights().defaultWeight();</span>
			}
		}

		static class Byte&lt;K&gt; extends IdToIndexWeights&lt;K, java.lang.Byte&gt; implements IWeightsByte {

			Byte(WeightsByte&lt;K&gt; idxWeights, IndexIdMap&lt;K&gt; map) {
<span class="fc" id="L1325">				super(idxWeights, map);</span>
<span class="fc" id="L1326">			}</span>

			@Override
			WeightsByte&lt;K&gt; idxWeights() {
<span class="fc" id="L1330">				return (WeightsByte&lt;K&gt;) super.idxWeights();</span>
			}

			@Override
			public byte get(int index) {
<span class="fc" id="L1335">				return idxWeights().get(id(index));</span>
			}

			@Override
			public void set(int index, byte weight) {
<span class="fc" id="L1340">				idxWeights().set(id(index), weight);</span>
<span class="fc" id="L1341">			}</span>

			@Override
			public byte defaultWeight() {
<span class="fc" id="L1345">				return idxWeights().defaultWeight();</span>
			}
		}

		static class Short&lt;K&gt; extends IdToIndexWeights&lt;K, java.lang.Short&gt; implements IWeightsShort {

			Short(WeightsShort&lt;K&gt; idxWeights, IndexIdMap&lt;K&gt; map) {
<span class="fc" id="L1352">				super(idxWeights, map);</span>
<span class="fc" id="L1353">			}</span>

			@Override
			WeightsShort&lt;K&gt; idxWeights() {
<span class="fc" id="L1357">				return (WeightsShort&lt;K&gt;) super.idxWeights();</span>
			}

			@Override
			public short get(int index) {
<span class="fc" id="L1362">				return idxWeights().get(id(index));</span>
			}

			@Override
			public void set(int index, short weight) {
<span class="fc" id="L1367">				idxWeights().set(id(index), weight);</span>
<span class="fc" id="L1368">			}</span>

			@Override
			public short defaultWeight() {
<span class="fc" id="L1372">				return idxWeights().defaultWeight();</span>
			}
		}

		static class Int&lt;K&gt; extends IdToIndexWeights&lt;K, Integer&gt; implements IWeightsInt {

			Int(WeightsInt&lt;K&gt; idxWeights, IndexIdMap&lt;K&gt; map) {
<span class="fc" id="L1379">				super(idxWeights, map);</span>
<span class="fc" id="L1380">			}</span>

			@Override
			WeightsInt&lt;K&gt; idxWeights() {
<span class="fc" id="L1384">				return (WeightsInt&lt;K&gt;) super.idxWeights();</span>
			}

			@Override
			public int get(int index) {
<span class="fc" id="L1389">				return idxWeights().get(id(index));</span>
			}

			@Override
			public void set(int index, int weight) {
<span class="fc" id="L1394">				idxWeights().set(id(index), weight);</span>
<span class="fc" id="L1395">			}</span>

			@Override
			public int defaultWeight() {
<span class="fc" id="L1399">				return idxWeights().defaultWeight();</span>
			}
		}

		static class Long&lt;K&gt; extends IdToIndexWeights&lt;K, java.lang.Long&gt; implements IWeightsLong {

			Long(WeightsLong&lt;K&gt; idxWeights, IndexIdMap&lt;K&gt; map) {
<span class="fc" id="L1406">				super(idxWeights, map);</span>
<span class="fc" id="L1407">			}</span>

			@Override
			WeightsLong&lt;K&gt; idxWeights() {
<span class="fc" id="L1411">				return (WeightsLong&lt;K&gt;) super.idxWeights();</span>
			}

			@Override
			public long get(int index) {
<span class="fc" id="L1416">				return idxWeights().get(id(index));</span>
			}

			@Override
			public void set(int index, long weight) {
<span class="fc" id="L1421">				idxWeights().set(id(index), weight);</span>
<span class="fc" id="L1422">			}</span>

			@Override
			public long defaultWeight() {
<span class="fc" id="L1426">				return idxWeights().defaultWeight();</span>
			}
		}

		static class Float&lt;K&gt; extends IdToIndexWeights&lt;K, java.lang.Float&gt; implements IWeightsFloat {

			Float(WeightsFloat&lt;K&gt; idxWeights, IndexIdMap&lt;K&gt; map) {
<span class="fc" id="L1433">				super(idxWeights, map);</span>
<span class="fc" id="L1434">			}</span>

			@Override
			WeightsFloat&lt;K&gt; idxWeights() {
<span class="fc" id="L1438">				return (WeightsFloat&lt;K&gt;) super.idxWeights();</span>
			}

			@Override
			public float get(int index) {
<span class="fc" id="L1443">				return idxWeights().get(id(index));</span>
			}

			@Override
			public void set(int index, float weight) {
<span class="fc" id="L1448">				idxWeights().set(id(index), weight);</span>
<span class="fc" id="L1449">			}</span>

			@Override
			public float defaultWeight() {
<span class="fc" id="L1453">				return idxWeights().defaultWeight();</span>
			}
		}

		static class Double&lt;K&gt; extends IdToIndexWeights&lt;K, java.lang.Double&gt; implements IWeightsDouble {

			Double(WeightsDouble&lt;K&gt; idxWeights, IndexIdMap&lt;K&gt; map) {
<span class="fc" id="L1460">				super(idxWeights, map);</span>
<span class="fc" id="L1461">			}</span>

			@Override
			WeightsDouble&lt;K&gt; idxWeights() {
<span class="fc" id="L1465">				return (WeightsDouble&lt;K&gt;) super.idxWeights();</span>
			}

			@Override
			public double get(int index) {
<span class="fc" id="L1470">				return idxWeights().get(id(index));</span>
			}

			@Override
			public void set(int index, double weight) {
<span class="fc" id="L1475">				idxWeights().set(id(index), weight);</span>
<span class="fc" id="L1476">			}</span>

			@Override
			public double defaultWeight() {
<span class="fc" id="L1480">				return idxWeights().defaultWeight();</span>
			}
		}

		static class Bool&lt;K&gt; extends IdToIndexWeights&lt;K, Boolean&gt; implements IWeightsBool {

			Bool(WeightsBool&lt;K&gt; idxWeights, IndexIdMap&lt;K&gt; map) {
<span class="fc" id="L1487">				super(idxWeights, map);</span>
<span class="fc" id="L1488">			}</span>

			@Override
			WeightsBool&lt;K&gt; idxWeights() {
<span class="fc" id="L1492">				return (WeightsBool&lt;K&gt;) super.idxWeights();</span>
			}

			@Override
			public boolean get(int index) {
<span class="fc" id="L1497">				return idxWeights().get(id(index));</span>
			}

			@Override
			public void set(int index, boolean weight) {
<span class="fc" id="L1502">				idxWeights().set(id(index), weight);</span>
<span class="fc" id="L1503">			}</span>

			@Override
			public boolean defaultWeight() {
<span class="fc" id="L1507">				return idxWeights().defaultWeight();</span>
			}
		}

		static class Char&lt;K&gt; extends IdToIndexWeights&lt;K, Character&gt; implements IWeightsChar {

			Char(WeightsChar&lt;K&gt; idxWeights, IndexIdMap&lt;K&gt; map) {
<span class="fc" id="L1514">				super(idxWeights, map);</span>
<span class="fc" id="L1515">			}</span>

			@Override
			WeightsChar&lt;K&gt; idxWeights() {
<span class="fc" id="L1519">				return (WeightsChar&lt;K&gt;) super.idxWeights();</span>
			}

			@Override
			public char get(int index) {
<span class="fc" id="L1524">				return idxWeights().get(id(index));</span>
			}

			@Override
			public void set(int index, char weight) {
<span class="fc" id="L1529">				idxWeights().set(id(index), weight);</span>
<span class="fc" id="L1530">			}</span>

			@Override
			public char defaultWeight() {
<span class="fc" id="L1534">				return idxWeights().defaultWeight();</span>
			}
		}

	}

	private abstract static class IntIdToIndexWeights&lt;T&gt; implements IWeights&lt;T&gt; {

		private final IWeights&lt;T&gt; idxWeights;
		private final IndexIntIdMap map;

<span class="fc" id="L1545">		IntIdToIndexWeights(IWeights&lt;T&gt; idxWeights, IndexIntIdMap map) {</span>
<span class="fc" id="L1546">			this.idxWeights = Objects.requireNonNull(idxWeights);</span>
<span class="fc" id="L1547">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L1548">		}</span>

		IWeights&lt;T&gt; idxWeights() {
<span class="fc" id="L1551">			return idxWeights;</span>
		}

		int id(int index) {
<span class="fc" id="L1555">			return map.indexToIdInt(index);</span>
		}

		static class Obj&lt;T&gt; extends IntIdToIndexWeights&lt;T&gt; implements IWeightsObj&lt;T&gt; {

			Obj(IWeightsObj&lt;T&gt; idxWeights, IndexIntIdMap map) {
<span class="fc" id="L1561">				super(idxWeights, map);</span>
<span class="fc" id="L1562">			}</span>

			@Override
			IWeightsObj&lt;T&gt; idxWeights() {
<span class="fc" id="L1566">				return (IWeightsObj&lt;T&gt;) super.idxWeights();</span>
			}

			@Override
			public T get(int index) {
<span class="fc" id="L1571">				return idxWeights().get(id(index));</span>
			}

			@Override
			public void set(int index, T weight) {
<span class="fc" id="L1576">				idxWeights().set(id(index), weight);</span>
<span class="fc" id="L1577">			}</span>

			@Override
			public T defaultWeight() {
<span class="fc" id="L1581">				return idxWeights().defaultWeight();</span>
			}
		}

		static class Byte extends IntIdToIndexWeights&lt;java.lang.Byte&gt; implements IWeightsByte {

			Byte(IWeightsByte idxWeights, IndexIntIdMap map) {
<span class="fc" id="L1588">				super(idxWeights, map);</span>
<span class="fc" id="L1589">			}</span>

			@Override
			IWeightsByte idxWeights() {
<span class="fc" id="L1593">				return (IWeightsByte) super.idxWeights();</span>
			}

			@Override
			public byte get(int index) {
<span class="fc" id="L1598">				return idxWeights().get(id(index));</span>
			}

			@Override
			public void set(int index, byte weight) {
<span class="fc" id="L1603">				idxWeights().set(id(index), weight);</span>
<span class="fc" id="L1604">			}</span>

			@Override
			public byte defaultWeight() {
<span class="fc" id="L1608">				return idxWeights().defaultWeight();</span>
			}
		}

		static class Short extends IntIdToIndexWeights&lt;java.lang.Short&gt; implements IWeightsShort {

			Short(IWeightsShort idxWeights, IndexIntIdMap map) {
<span class="fc" id="L1615">				super(idxWeights, map);</span>
<span class="fc" id="L1616">			}</span>

			@Override
			IWeightsShort idxWeights() {
<span class="fc" id="L1620">				return (IWeightsShort) super.idxWeights();</span>
			}

			@Override
			public short get(int index) {
<span class="fc" id="L1625">				return idxWeights().get(id(index));</span>
			}

			@Override
			public void set(int index, short weight) {
<span class="fc" id="L1630">				idxWeights().set(id(index), weight);</span>
<span class="fc" id="L1631">			}</span>

			@Override
			public short defaultWeight() {
<span class="fc" id="L1635">				return idxWeights().defaultWeight();</span>
			}
		}

		static class Int extends IntIdToIndexWeights&lt;Integer&gt; implements IWeightsInt {

			Int(IWeightsInt idxWeights, IndexIntIdMap map) {
<span class="fc" id="L1642">				super(idxWeights, map);</span>
<span class="fc" id="L1643">			}</span>

			@Override
			IWeightsInt idxWeights() {
<span class="fc" id="L1647">				return (IWeightsInt) super.idxWeights();</span>
			}

			@Override
			public int get(int index) {
<span class="fc" id="L1652">				return idxWeights().get(id(index));</span>
			}

			@Override
			public void set(int index, int weight) {
<span class="fc" id="L1657">				idxWeights().set(id(index), weight);</span>
<span class="fc" id="L1658">			}</span>

			@Override
			public int defaultWeight() {
<span class="fc" id="L1662">				return idxWeights().defaultWeight();</span>
			}
		}

		static class Long extends IntIdToIndexWeights&lt;java.lang.Long&gt; implements IWeightsLong {

			Long(IWeightsLong idxWeights, IndexIntIdMap map) {
<span class="fc" id="L1669">				super(idxWeights, map);</span>
<span class="fc" id="L1670">			}</span>

			@Override
			IWeightsLong idxWeights() {
<span class="fc" id="L1674">				return (IWeightsLong) super.idxWeights();</span>
			}

			@Override
			public long get(int index) {
<span class="fc" id="L1679">				return idxWeights().get(id(index));</span>
			}

			@Override
			public void set(int index, long weight) {
<span class="fc" id="L1684">				idxWeights().set(id(index), weight);</span>
<span class="fc" id="L1685">			}</span>

			@Override
			public long defaultWeight() {
<span class="fc" id="L1689">				return idxWeights().defaultWeight();</span>
			}
		}

		static class Float extends IntIdToIndexWeights&lt;java.lang.Float&gt; implements IWeightsFloat {

			Float(IWeightsFloat idxWeights, IndexIntIdMap map) {
<span class="fc" id="L1696">				super(idxWeights, map);</span>
<span class="fc" id="L1697">			}</span>

			@Override
			IWeightsFloat idxWeights() {
<span class="fc" id="L1701">				return (IWeightsFloat) super.idxWeights();</span>
			}

			@Override
			public float get(int index) {
<span class="fc" id="L1706">				return idxWeights().get(id(index));</span>
			}

			@Override
			public void set(int index, float weight) {
<span class="fc" id="L1711">				idxWeights().set(id(index), weight);</span>
<span class="fc" id="L1712">			}</span>

			@Override
			public float defaultWeight() {
<span class="fc" id="L1716">				return idxWeights().defaultWeight();</span>
			}
		}

		static class Double extends IntIdToIndexWeights&lt;java.lang.Double&gt; implements IWeightsDouble {

			Double(IWeightsDouble idxWeights, IndexIntIdMap map) {
<span class="fc" id="L1723">				super(idxWeights, map);</span>
<span class="fc" id="L1724">			}</span>

			@Override
			IWeightsDouble idxWeights() {
<span class="fc" id="L1728">				return (IWeightsDouble) super.idxWeights();</span>
			}

			@Override
			public double get(int index) {
<span class="fc" id="L1733">				return idxWeights().get(id(index));</span>
			}

			@Override
			public void set(int index, double weight) {
<span class="fc" id="L1738">				idxWeights().set(id(index), weight);</span>
<span class="fc" id="L1739">			}</span>

			@Override
			public double defaultWeight() {
<span class="fc" id="L1743">				return idxWeights().defaultWeight();</span>
			}
		}

		static class Bool extends IntIdToIndexWeights&lt;Boolean&gt; implements IWeightsBool {

			Bool(IWeightsBool idxWeights, IndexIntIdMap map) {
<span class="fc" id="L1750">				super(idxWeights, map);</span>
<span class="fc" id="L1751">			}</span>

			@Override
			IWeightsBool idxWeights() {
<span class="fc" id="L1755">				return (IWeightsBool) super.idxWeights();</span>
			}

			@Override
			public boolean get(int index) {
<span class="fc" id="L1760">				return idxWeights().get(id(index));</span>
			}

			@Override
			public void set(int index, boolean weight) {
<span class="fc" id="L1765">				idxWeights().set(id(index), weight);</span>
<span class="fc" id="L1766">			}</span>

			@Override
			public boolean defaultWeight() {
<span class="fc" id="L1770">				return idxWeights().defaultWeight();</span>
			}
		}

		static class Char extends IntIdToIndexWeights&lt;Character&gt; implements IWeightsChar {

			Char(IWeightsChar idxWeights, IndexIntIdMap map) {
<span class="fc" id="L1777">				super(idxWeights, map);</span>
<span class="fc" id="L1778">			}</span>

			@Override
			IWeightsChar idxWeights() {
<span class="fc" id="L1782">				return (IWeightsChar) super.idxWeights();</span>
			}

			@Override
			public char get(int index) {
<span class="fc" id="L1787">				return idxWeights().get(id(index));</span>
			}

			@Override
			public void set(int index, char weight) {
<span class="fc" id="L1792">				idxWeights().set(id(index), weight);</span>
<span class="fc" id="L1793">			}</span>

			@Override
			public char defaultWeight() {
<span class="fc" id="L1797">				return idxWeights().defaultWeight();</span>
			}
		}

	}

	@SuppressWarnings(&quot;unchecked&quot;)
	private static &lt;K, T, WeightsT extends IWeights&lt;T&gt;&gt; WeightsT idToIndexWeightsWrapper(Weights&lt;K, T&gt; weights,
			IndexIdMap&lt;K&gt; map) {
<span class="pc bpc" id="L1806" title="1 of 4 branches missed.">		if (weights instanceof IWeights &amp;&amp; map instanceof IndexIntIdMap) {</span>
<span class="fc" id="L1807">			IWeights&lt;T&gt; weights0 = (IWeights&lt;T&gt;) weights;</span>
<span class="fc" id="L1808">			IndexIntIdMap map0 = (IndexIntIdMap) map;</span>
<span class="fc bfc" id="L1809" title="All 2 branches covered.">			if (weights instanceof WeightsByte) {</span>
<span class="fc" id="L1810">				return (WeightsT) new IntIdToIndexWeights.Byte((IWeightsByte) weights0, map0);</span>
<span class="fc bfc" id="L1811" title="All 2 branches covered.">			} else if (weights instanceof WeightsShort) {</span>
<span class="fc" id="L1812">				return (WeightsT) new IntIdToIndexWeights.Short((IWeightsShort) weights0, map0);</span>
<span class="fc bfc" id="L1813" title="All 2 branches covered.">			} else if (weights instanceof WeightsInt) {</span>
<span class="fc" id="L1814">				return (WeightsT) new IntIdToIndexWeights.Int((IWeightsInt) weights0, map0);</span>
<span class="fc bfc" id="L1815" title="All 2 branches covered.">			} else if (weights instanceof WeightsLong) {</span>
<span class="fc" id="L1816">				return (WeightsT) new IntIdToIndexWeights.Long((IWeightsLong) weights0, map0);</span>
<span class="fc bfc" id="L1817" title="All 2 branches covered.">			} else if (weights instanceof WeightsFloat) {</span>
<span class="fc" id="L1818">				return (WeightsT) new IntIdToIndexWeights.Float((IWeightsFloat) weights0, map0);</span>
<span class="fc bfc" id="L1819" title="All 2 branches covered.">			} else if (weights instanceof WeightsDouble) {</span>
<span class="fc" id="L1820">				return (WeightsT) new IntIdToIndexWeights.Double((IWeightsDouble) weights0, map0);</span>
<span class="fc bfc" id="L1821" title="All 2 branches covered.">			} else if (weights instanceof WeightsBool) {</span>
<span class="fc" id="L1822">				return (WeightsT) new IntIdToIndexWeights.Bool((IWeightsBool) weights0, map0);</span>
<span class="fc bfc" id="L1823" title="All 2 branches covered.">			} else if (weights instanceof WeightsChar) {</span>
<span class="fc" id="L1824">				return (WeightsT) new IntIdToIndexWeights.Char((IWeightsChar) weights0, map0);</span>
<span class="pc bpc" id="L1825" title="1 of 2 branches missed.">			} else if (weights instanceof WeightsObj) {</span>
<span class="fc" id="L1826">				return (WeightsT) new IntIdToIndexWeights.Obj&lt;&gt;((IWeightsObj&lt;T&gt;) weights0, map0);</span>
			}
<span class="pc bfc" id="L1828" title="All 2 branches covered.">		} else if (weights instanceof WeightsByte) {</span>
<span class="fc" id="L1829">			return (WeightsT) new IdToIndexWeights.Byte&lt;&gt;((WeightsByte&lt;K&gt;) weights, map);</span>
<span class="fc bfc" id="L1830" title="All 2 branches covered.">		} else if (weights instanceof WeightsShort) {</span>
<span class="fc" id="L1831">			return (WeightsT) new IdToIndexWeights.Short&lt;&gt;((WeightsShort&lt;K&gt;) weights, map);</span>
<span class="fc bfc" id="L1832" title="All 2 branches covered.">		} else if (weights instanceof WeightsInt) {</span>
<span class="fc" id="L1833">			return (WeightsT) new IdToIndexWeights.Int&lt;&gt;((WeightsInt&lt;K&gt;) weights, map);</span>
<span class="fc bfc" id="L1834" title="All 2 branches covered.">		} else if (weights instanceof WeightsLong) {</span>
<span class="fc" id="L1835">			return (WeightsT) new IdToIndexWeights.Long&lt;&gt;((WeightsLong&lt;K&gt;) weights, map);</span>
<span class="fc bfc" id="L1836" title="All 2 branches covered.">		} else if (weights instanceof WeightsFloat) {</span>
<span class="fc" id="L1837">			return (WeightsT) new IdToIndexWeights.Float&lt;&gt;((WeightsFloat&lt;K&gt;) weights, map);</span>
<span class="fc bfc" id="L1838" title="All 2 branches covered.">		} else if (weights instanceof WeightsDouble) {</span>
<span class="fc" id="L1839">			return (WeightsT) new IdToIndexWeights.Double&lt;&gt;((WeightsDouble&lt;K&gt;) weights, map);</span>
<span class="fc bfc" id="L1840" title="All 2 branches covered.">		} else if (weights instanceof WeightsBool) {</span>
<span class="fc" id="L1841">			return (WeightsT) new IdToIndexWeights.Bool&lt;&gt;((WeightsBool&lt;K&gt;) weights, map);</span>
<span class="fc bfc" id="L1842" title="All 2 branches covered.">		} else if (weights instanceof WeightsChar) {</span>
<span class="fc" id="L1843">			return (WeightsT) new IdToIndexWeights.Char&lt;&gt;((WeightsChar&lt;K&gt;) weights, map);</span>
<span class="pc bpc" id="L1844" title="1 of 2 branches missed.">		} else if (weights instanceof WeightsObj) {</span>
<span class="fc" id="L1845">			return (WeightsT) new IdToIndexWeights.Obj&lt;&gt;((WeightsObj&lt;K, T&gt;) weights, map);</span>
		}
<span class="nc" id="L1847">		throw new AssertionError(&quot;unknown weights type: &quot; + weights.getClass().getName());</span>
	}

	/**
	 * Create a weights view that is accessed by the elements indices, given a weights container that is accessed by the
	 * element IDs.
	 *
	 * &lt;p&gt;
	 * The returned weights container is a view, namely modifying the original container change the new one, and vice
	 * versa.
	 *
	 * @param  &lt;K&gt;        the element (vertex or edge) identifiers type
	 * @param  &lt;T&gt;        the weight type
	 * @param  &lt;WeightsT&gt; the weights container, used to avoid casts of containers of primitive types such as
	 *                        {@link WeightsInt}, {@link WeightsDouble} ect. The user should expect
	 *                        {@link WeightsDouble} only if a {@link WeightsDouble} object was passed as an argument.
	 * @param  weights    a weights container that is accessed by the elements IDs
	 * @param  map        index-id map
	 * @return            a weights-view that is accessed by the elements indices
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public static &lt;K, T, WeightsT extends IWeights&lt;T&gt;&gt; WeightsT idToIndexWeights(Weights&lt;K, T&gt; weights,
			IndexIdMap&lt;K&gt; map) {
<span class="fc" id="L1870">		boolean immutableView = false;</span>
<span class="pc bpc" id="L1871" title="1 of 2 branches missed.">		while (weights instanceof WeightsImpl.ImmutableView) {</span>
<span class="nc" id="L1872">			weights = ((WeightsImpl.ImmutableView&lt;K, T&gt;) weights).weights();</span>
<span class="nc" id="L1873">			immutableView = true;</span>
		}

		IWeights&lt;T&gt; idxWeights;
<span class="fc bfc" id="L1877" title="All 2 branches covered.">		if (weights instanceof WeightsImpl.IntMapped) {</span>
<span class="pc bpc" id="L1878" title="1 of 2 branches missed.">			if (map != ((WeightsImpl.IntMapped&lt;?&gt;) weights).indexMap)</span>
<span class="nc" id="L1879">				throw new IllegalArgumentException(&quot;wrong index-id map is used with weights container&quot;);</span>
<span class="fc" id="L1880">			idxWeights = ((WeightsImpl.IntMapped&lt;T&gt;) weights).weights;</span>

<span class="fc bfc" id="L1882" title="All 2 branches covered.">		} else if (weights instanceof WeightsImpl.ObjMapped) {</span>
<span class="pc bpc" id="L1883" title="1 of 2 branches missed.">			if (map != ((WeightsImpl.ObjMapped&lt;?, ?&gt;) weights).indexMap)</span>
<span class="nc" id="L1884">				throw new IllegalArgumentException(&quot;wrong index-id map is used with weights container&quot;);</span>
<span class="fc" id="L1885">			idxWeights = ((WeightsImpl.ObjMapped&lt;K, T&gt;) weights).weights;</span>

		} else {
<span class="fc" id="L1888">			idxWeights = idToIndexWeightsWrapper(weights, map);</span>
		}

<span class="pc bpc" id="L1891" title="1 of 2 branches missed.">		if (immutableView)</span>
<span class="nc" id="L1892">			idxWeights = WeightsImpl.IntImmutableView.newInstance(idxWeights);</span>
<span class="fc" id="L1893">		return (WeightsT) idxWeights;</span>
	}

	/**
	 * Create a weight function that accept elements indices, given a weight function that accept elements IDs.
	 *
	 * @param  &lt;K&gt; the type of elements IDs
	 * @param  w   a weight function that accept by elements IDs
	 * @param  map index-id map
	 * @return     a weight function that accept elements indices
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public static &lt;K&gt; IWeightFunction idToIndexWeightFunc(WeightFunction&lt;K&gt; w, IndexIdMap&lt;K&gt; map) {
<span class="fc bfc" id="L1906" title="All 2 branches covered.">		if (WeightFunction.isCardinality(w)) {</span>
<span class="fc" id="L1907">			return null;</span>

<span class="fc bfc" id="L1909" title="All 2 branches covered.">		} else if (w instanceof Weights) {</span>
			/* The weight function is some implementation of a mapped weights container */
			/* Instead of re-mapping by wrapping the weight function, return the underlying index weights container */
<span class="fc" id="L1912">			return (IWeightFunction) idToIndexWeights((Weights&lt;K, ?&gt;) w, map);</span>

<span class="pc bpc" id="L1914" title="1 of 4 branches missed.">		} else if (WeightFunction.isInteger(w) &amp;&amp; map instanceof IndexIntIdMap) {</span>
			/* Unknown int weight function, return a mapped wrapper */
<span class="fc" id="L1916">			IWeightFunctionInt wInt = (IWeightFunctionInt) w;</span>
<span class="fc" id="L1917">			IndexIntIdMap map0 = (IndexIntIdMap) map;</span>
<span class="fc" id="L1918">			IWeightFunctionInt wIntMapped = idx -&gt; wInt.weightInt(map0.indexToIdInt(idx));</span>
<span class="fc" id="L1919">			return wIntMapped;</span>

<span class="pc bpc" id="L1921" title="1 of 4 branches missed.">		} else if (w instanceof IWeightFunction &amp;&amp; map instanceof IndexIntIdMap) {</span>
			/* Unknown weight function, return a mapped wrapper */
<span class="fc" id="L1923">			IWeightFunction wInt = (IWeightFunction) w;</span>
<span class="fc" id="L1924">			IndexIntIdMap map0 = (IndexIntIdMap) map;</span>
<span class="fc" id="L1925">			IWeightFunction wMapped = idx -&gt; wInt.weight(map0.indexToIdInt(idx));</span>
<span class="fc" id="L1926">			return wMapped;</span>

<span class="pc bpc" id="L1928" title="1 of 2 branches missed.">		} else if (WeightFunction.isInteger(w)) {</span>
			/* Unknown int weight function, return a mapped wrapper */
<span class="nc" id="L1930">			WeightFunctionInt&lt;K&gt; wInt = (WeightFunctionInt&lt;K&gt;) w;</span>
<span class="nc" id="L1931">			IWeightFunctionInt wIntMapped = idx -&gt; wInt.weightInt(map.indexToId(idx));</span>
<span class="nc" id="L1932">			return wIntMapped;</span>

		} else {
			/* Unknown weight function, return a mapped wrapper */
<span class="fc" id="L1936">			return idx -&gt; w.weight(map.indexToId(idx));</span>
		}
	}

	/**
	 * Create an integer weight function that accept elements indices, given a weight function that accept elements IDs.
	 *
	 * @param  &lt;K&gt; the type of elements IDs
	 * @param  w   an integer weight function that accept by elements IDs
	 * @param  map index-id map
	 * @return     an integer weight function that accept elements indices
	 */
	public static &lt;K&gt; IWeightFunctionInt idToIndexWeightFunc(WeightFunctionInt&lt;K&gt; w, IndexIdMap&lt;K&gt; map) {
<span class="nc" id="L1949">		return (IWeightFunctionInt) idToIndexWeightFunc((WeightFunction&lt;K&gt;) w, map);</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>