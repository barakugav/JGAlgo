<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IndexIdMaps.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.graph</a> &gt; <span class="el_source">IndexIdMaps.java</span></div><h1>IndexIdMaps.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.graph;

import java.util.Objects;
import it.unimi.dsi.fastutil.ints.AbstractIntCollection;
import it.unimi.dsi.fastutil.ints.AbstractIntList;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntIterator;
import it.unimi.dsi.fastutil.ints.IntList;
import it.unimi.dsi.fastutil.ints.IntSet;

/**
 * Static methods class for {@linkplain IndexIdMap index-id maps}.
 *
 * @author Barak Ugav
 */
public class IndexIdMaps {

	private IndexIdMaps() {}

	/**
	 * Create an IDs iterator from an iterator of indices.
	 *
	 * @param  indexIter an iterator of indices
	 * @param  map       index-id mapping
	 * @return           an iterator that iterate over the IDs matching the indices iterated by the original
	 *                   index-iterator
	 */
	public static IntIterator indexToIdIterator(IntIterator indexIter, IndexIdMap map) {
<span class="nc" id="L44">		return new IndexToIdIterator(indexIter, map);</span>
	}

	/**
	 * Create an indices iterator from an iterator of IDs.
	 *
	 * @param  idIter an iterator of IDs
	 * @param  map    index-id mapping
	 * @return        an iterator that iterate over the indices matching the IDs iterated by the original ID-iterator
	 */
	public static IntIterator idToIndexIterator(IntIterator idIter, IndexIdMap map) {
<span class="fc" id="L55">		return new IdToIndexIterator(idIter, map);</span>
	}

	private static class IndexToIdIterator implements IntIterator {

		private final IntIterator indexIt;
		private final IndexIdMap map;

<span class="fc" id="L63">		IndexToIdIterator(IntIterator idxIt, IndexIdMap map) {</span>
<span class="fc" id="L64">			this.indexIt = Objects.requireNonNull(idxIt);</span>
<span class="fc" id="L65">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L66">		}</span>

		IntIterator indexIt() {
<span class="nc" id="L69">			return indexIt;</span>
		}

		IndexIdMap map() {
<span class="nc" id="L73">			return map;</span>
		}

		@Override
		public boolean hasNext() {
<span class="fc" id="L78">			return indexIt.hasNext();</span>
		}

		@Override
		public int nextInt() {
<span class="fc" id="L83">			return map.indexToId(indexIt.nextInt());</span>
		}

		@Override
		public void remove() {
<span class="nc" id="L88">			indexIt.remove();</span>
<span class="nc" id="L89">		}</span>

	}

	/**
	 * Create an {@link EdgeIter} that return IDs of vertices and edges from an {@link EdgeIter} that return indices of
	 * vertices and edges.
	 *
	 * @param  indexIter   an {@link EdgeIter} that return indices of vertices and edges
	 * @param  verticesMap vertices index-id mapping
	 * @param  edgesMap    edges index-id mapping
	 * @return             {@link EdgeIter} that return IDs of vertices and edges matching the indices of vertices and
	 *                     edges returned by the original index-iterator
	 */
	public static EdgeIter indexToIdEdgeIter(EdgeIter indexIter, IndexIdMap verticesMap, IndexIdMap edgesMap) {
<span class="fc" id="L104">		return new IndexToIdEdgeIter(indexIter, verticesMap, edgesMap);</span>
	}

	private static class IndexToIdEdgeIter extends IndexToIdIterator implements EdgeIter {
		private final IndexIdMap viMap;

		IndexToIdEdgeIter(EdgeIter indexIt, IndexIdMap viMap, IndexIdMap eiMap) {
<span class="fc" id="L111">			super(indexIt, eiMap);</span>
<span class="fc" id="L112">			this.viMap = Objects.requireNonNull(viMap);</span>
<span class="fc" id="L113">		}</span>

		@Override
		EdgeIter indexIt() {
<span class="nc" id="L117">			return (EdgeIter) super.indexIt();</span>
		}

		IndexIdMap eiMap() {
<span class="nc" id="L121">			return super.map();</span>
		}

		@Override
		public int peekNext() {
<span class="nc" id="L126">			return eiMap().indexToId(indexIt().peekNext());</span>
		}

		@Override
		public int source() {
<span class="nc" id="L131">			return viMap.indexToId(indexIt().source());</span>
		}

		@Override
		public int target() {
<span class="nc" id="L136">			return viMap.indexToId(indexIt().target());</span>
		}
	}

	private static class IdToIndexIterator implements IntIterator {

		private final IntIterator idIt;
		private final IndexIdMap map;

<span class="fc" id="L145">		IdToIndexIterator(IntIterator idIt, IndexIdMap map) {</span>
<span class="fc" id="L146">			this.idIt = Objects.requireNonNull(idIt);</span>
<span class="fc" id="L147">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L148">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc" id="L152">			return idIt.hasNext();</span>
		}

		@Override
		public int nextInt() {
<span class="fc" id="L157">			return map.idToIndex(idIt.nextInt());</span>
		}

		@Override
		public void remove() {
<span class="nc" id="L162">			idIt.remove();</span>
<span class="nc" id="L163">		}</span>

	}

	/**
	 * Create an IDs collection from a collection of indices.
	 *
	 * @param  indexCollection a collection of indices
	 * @param  map             index-id mapping
	 * @return                 a collection that contain IDs matching the indices contained in the original
	 *                         index-collection
	 */
	public static IntCollection indexToIdCollection(IntCollection indexCollection, IndexIdMap map) {
<span class="fc" id="L176">		return new IndexToIdCollection(indexCollection, map);</span>
	}

	private static class IndexToIdCollection extends AbstractIntCollection {

		final IntCollection indexC;
		final IndexIdMap map;

<span class="fc" id="L184">		IndexToIdCollection(IntCollection indexC, IndexIdMap map) {</span>
<span class="fc" id="L185">			this.indexC = Objects.requireNonNull(indexC);</span>
<span class="fc" id="L186">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L187">		}</span>

		@Override
		public int size() {
<span class="fc" id="L191">			return indexC.size();</span>
		}

		@Override
		public boolean isEmpty() {
<span class="fc" id="L196">			return indexC.isEmpty();</span>
		}

		@Override
		public void clear() {
<span class="nc" id="L201">			indexC.clear();</span>
<span class="nc" id="L202">		}</span>

		@Override
		public IntIterator iterator() {
<span class="fc" id="L206">			return new IndexToIdIterator(indexC.iterator(), map);</span>
		}

		@Override
		public boolean contains(int key) {
<span class="nc" id="L211">			return indexC.contains(map.idToIndex(key));</span>
		}

		@Override
		public boolean rem(int key) {
<span class="nc" id="L216">			return indexC.rem(map.idToIndex(key));</span>
		}
	}

	/**
	 * Create an IDs set from a set of indices.
	 *
	 * @param  indexSet a set of indices
	 * @param  map      index-id mapping
	 * @return          a set that contain IDs matching the indices contained in the original index-set
	 */
	public static IntSet indexToIdSet(IntSet indexSet, IndexIdMap map) {
<span class="fc" id="L228">		return new IndexToIdSet(indexSet, map);</span>
	}

	private static class IndexToIdSet extends IndexToIdCollection implements IntSet {
		IndexToIdSet(IntSet indexSet, IndexIdMap map) {
<span class="fc" id="L233">			super(indexSet, map);</span>
<span class="fc" id="L234">		}</span>

		@Deprecated
		@Override
		public boolean remove(int k) {
<span class="nc" id="L239">			return indexC.rem(map.idToIndex(k));</span>
		}
	}

	/**
	 * Create an indices collection from a collection of IDs.
	 *
	 * @param  idCollection a collection of IDs
	 * @param  map          index-id mapping
	 * @return              a collection that contain indices matching the IDs contained in the original ID-collection
	 */
	public static IntCollection idToIndexCollection(IntCollection idCollection, IndexIdMap map) {
<span class="fc" id="L251">		return new IdToIndexCollection(idCollection, map);</span>
	}

	private static class IdToIndexCollection extends AbstractIntCollection {

		private final IntCollection idC;
		private final IndexIdMap map;

<span class="fc" id="L259">		IdToIndexCollection(IntCollection idC, IndexIdMap map) {</span>
<span class="fc" id="L260">			this.idC = Objects.requireNonNull(idC);</span>
<span class="fc" id="L261">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L262">		}</span>

		@Override
		public int size() {
<span class="fc" id="L266">			return idC.size();</span>
		}

		@Override
		public boolean isEmpty() {
<span class="fc" id="L271">			return idC.isEmpty();</span>
		}

		@Override
		public void clear() {
<span class="nc" id="L276">			idC.clear();</span>
<span class="nc" id="L277">		}</span>

		@Override
		public IntIterator iterator() {
<span class="fc" id="L281">			return new IdToIndexIterator(idC.iterator(), map);</span>
		}

		@Override
		public boolean contains(int key) {
<span class="nc" id="L286">			return idC.contains(map.indexToId(key));</span>
		}

		@Override
		public boolean rem(int key) {
<span class="nc" id="L291">			return idC.rem(map.indexToId(key));</span>
		}
	}

	/**
	 * Create an IDs list from a list of indices.
	 *
	 * @param  indexList a list of indices
	 * @param  map       index-id mapping
	 * @return           a list that contain IDs matching the indices contained in the original index-list
	 */
	public static IntList indexToIdList(IntList indexList, IndexIdMap map) {
<span class="fc" id="L303">		return new IndexToIdList(indexList, map);</span>
	}

	private static class IndexToIdList extends AbstractIntList {

		private final IntList indexList;
		private final IndexIdMap map;

<span class="fc" id="L311">		IndexToIdList(IntList indexList, IndexIdMap map) {</span>
<span class="fc" id="L312">			this.indexList = Objects.requireNonNull(indexList);</span>
<span class="fc" id="L313">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L314">		}</span>

		@Override
		public int size() {
<span class="fc" id="L318">			return indexList.size();</span>
		}

		@Override
		public boolean isEmpty() {
<span class="nc" id="L323">			return indexList.isEmpty();</span>
		}

		@Override
		public void clear() {
<span class="nc" id="L328">			indexList.clear();;</span>
<span class="nc" id="L329">		}</span>

		@Override
		public boolean contains(int key) {
<span class="nc" id="L333">			return indexList.contains(map.idToIndex(key));</span>
		}

		@Override
		public boolean rem(int key) {
<span class="nc" id="L338">			return indexList.rem(map.idToIndex(key));</span>
		}

		@Override
		public int getInt(int index) {
<span class="fc" id="L343">			return map.indexToId(indexList.getInt(index));</span>
		}

		@Override
		public int indexOf(int k) {
<span class="nc" id="L348">			return indexList.indexOf(map.idToIndex(k));</span>
		}

		@Override
		public int lastIndexOf(int k) {
<span class="nc" id="L353">			return indexList.lastIndexOf(map.idToIndex(k));</span>
		}

		@Override
		public int removeInt(int index) {
<span class="nc" id="L358">			return map.indexToId(indexList.removeInt(index));</span>
		}

	}

	private static abstract class IdToIndexWeights&lt;W&gt; implements Weights&lt;W&gt; {
		private final IndexIdMap map;

<span class="nc" id="L366">		IdToIndexWeights(IndexIdMap map) {</span>
<span class="nc" id="L367">			this.map = Objects.requireNonNull(map);</span>
<span class="nc" id="L368">		}</span>

		int id(int index) {
<span class="nc" id="L371">			return map.indexToId(index);</span>
		}

		static class Obj&lt;W&gt; extends IdToIndexWeights&lt;W&gt; implements WeightsObj&lt;W&gt; {

			private final WeightsObj&lt;W&gt; weights;

			Obj(WeightsObj&lt;W&gt; weights, IndexIdMap map) {
<span class="nc" id="L379">				super(map);</span>
<span class="nc" id="L380">				this.weights = Objects.requireNonNull(weights);</span>
<span class="nc" id="L381">			}</span>

			@Override
			public W get(int index) {
<span class="nc" id="L385">				return weights.get(id(index));</span>
			}

			@Override
			public void set(int index, W weight) {
<span class="nc" id="L390">				weights.set(id(index), weight);</span>
<span class="nc" id="L391">			}</span>

			@Override
			public W defaultWeight() {
<span class="nc" id="L395">				return weights.defaultWeight();</span>
			}
		}

		static class Byte extends IdToIndexWeights&lt;java.lang.Byte&gt; implements WeightsByte {

			private final WeightsByte weights;

			Byte(WeightsByte weights, IndexIdMap map) {
<span class="nc" id="L404">				super(map);</span>
<span class="nc" id="L405">				this.weights = Objects.requireNonNull(weights);</span>
<span class="nc" id="L406">			}</span>

			@Override
			public byte get(int index) {
<span class="nc" id="L410">				return weights.get(id(index));</span>
			}

			@Override
			public void set(int index, byte weight) {
<span class="nc" id="L415">				weights.set(id(index), weight);</span>
<span class="nc" id="L416">			}</span>

			@Override
			public byte defaultWeight() {
<span class="nc" id="L420">				return weights.defaultWeight();</span>
			}
		}

		static class Short extends IdToIndexWeights&lt;java.lang.Short&gt; implements WeightsShort {

			private final WeightsShort weights;

			Short(WeightsShort weights, IndexIdMap map) {
<span class="nc" id="L429">				super(map);</span>
<span class="nc" id="L430">				this.weights = Objects.requireNonNull(weights);</span>
<span class="nc" id="L431">			}</span>

			@Override
			public short get(int index) {
<span class="nc" id="L435">				return weights.get(id(index));</span>
			}

			@Override
			public void set(int index, short weight) {
<span class="nc" id="L440">				weights.set(id(index), weight);</span>
<span class="nc" id="L441">			}</span>

			@Override
			public short defaultWeight() {
<span class="nc" id="L445">				return weights.defaultWeight();</span>
			}
		}

		static class Int extends IdToIndexWeights&lt;Integer&gt; implements WeightsInt {

			private final WeightsInt weights;

			Int(WeightsInt weights, IndexIdMap map) {
<span class="nc" id="L454">				super(map);</span>
<span class="nc" id="L455">				this.weights = Objects.requireNonNull(weights);</span>
<span class="nc" id="L456">			}</span>

			@Override
			public int get(int index) {
<span class="nc" id="L460">				return weights.get(id(index));</span>
			}

			@Override
			public void set(int index, int weight) {
<span class="nc" id="L465">				weights.set(id(index), weight);</span>
<span class="nc" id="L466">			}</span>

			@Override
			public int defaultWeight() {
<span class="nc" id="L470">				return weights.defaultWeight();</span>
			}
		}

		static class Long extends IdToIndexWeights&lt;java.lang.Long&gt; implements WeightsLong {

			private final WeightsLong weights;

			Long(WeightsLong weights, IndexIdMap map) {
<span class="nc" id="L479">				super(map);</span>
<span class="nc" id="L480">				this.weights = Objects.requireNonNull(weights);</span>
<span class="nc" id="L481">			}</span>

			@Override
			public long get(int index) {
<span class="nc" id="L485">				return weights.get(id(index));</span>
			}

			@Override
			public void set(int index, long weight) {
<span class="nc" id="L490">				weights.set(id(index), weight);</span>
<span class="nc" id="L491">			}</span>

			@Override
			public long defaultWeight() {
<span class="nc" id="L495">				return weights.defaultWeight();</span>
			}
		}

		static class Float extends IdToIndexWeights&lt;java.lang.Float&gt; implements WeightsFloat {

			private final WeightsFloat weights;

			Float(WeightsFloat weights, IndexIdMap map) {
<span class="nc" id="L504">				super(map);</span>
<span class="nc" id="L505">				this.weights = Objects.requireNonNull(weights);</span>
<span class="nc" id="L506">			}</span>

			@Override
			public float get(int index) {
<span class="nc" id="L510">				return weights.get(id(index));</span>
			}

			@Override
			public void set(int index, float weight) {
<span class="nc" id="L515">				weights.set(id(index), weight);</span>
<span class="nc" id="L516">			}</span>

			@Override
			public float defaultWeight() {
<span class="nc" id="L520">				return weights.defaultWeight();</span>
			}
		}

		static class Double extends IdToIndexWeights&lt;java.lang.Double&gt; implements WeightsDouble {

			private final WeightsDouble weights;

			Double(WeightsDouble weights, IndexIdMap map) {
<span class="nc" id="L529">				super(map);</span>
<span class="nc" id="L530">				this.weights = Objects.requireNonNull(weights);</span>
<span class="nc" id="L531">			}</span>

			@Override
			public double get(int index) {
<span class="nc" id="L535">				return weights.get(id(index));</span>
			}

			@Override
			public void set(int index, double weight) {
<span class="nc" id="L540">				weights.set(id(index), weight);</span>
<span class="nc" id="L541">			}</span>

			@Override
			public double defaultWeight() {
<span class="nc" id="L545">				return weights.defaultWeight();</span>
			}
		}

		static class Bool extends IdToIndexWeights&lt;Boolean&gt; implements WeightsBool {

			private final WeightsBool weights;

			Bool(WeightsBool weights, IndexIdMap map) {
<span class="nc" id="L554">				super(map);</span>
<span class="nc" id="L555">				this.weights = Objects.requireNonNull(weights);</span>
<span class="nc" id="L556">			}</span>

			@Override
			public boolean get(int index) {
<span class="nc" id="L560">				return weights.get(id(index));</span>
			}

			@Override
			public void set(int index, boolean weight) {
<span class="nc" id="L565">				weights.set(id(index), weight);</span>
<span class="nc" id="L566">			}</span>

			@Override
			public boolean defaultWeight() {
<span class="nc" id="L570">				return weights.defaultWeight();</span>
			}
		}

		static class Char extends IdToIndexWeights&lt;Character&gt; implements WeightsChar {

			private final WeightsChar weights;

			Char(WeightsChar weights, IndexIdMap map) {
<span class="nc" id="L579">				super(map);</span>
<span class="nc" id="L580">				this.weights = Objects.requireNonNull(weights);</span>
<span class="nc" id="L581">			}</span>

			@Override
			public char get(int index) {
<span class="nc" id="L585">				return weights.get(id(index));</span>
			}

			@Override
			public void set(int index, char weight) {
<span class="nc" id="L590">				weights.set(id(index), weight);</span>
<span class="nc" id="L591">			}</span>

			@Override
			public char defaultWeight() {
<span class="nc" id="L595">				return weights.defaultWeight();</span>
			}
		}

	}

	private static &lt;V, WeightsT extends Weights&lt;V&gt;&gt; WeightsT idToIndexWeights0(WeightsImpl&lt;?&gt; weights, IndexIdMap map) {
<span class="fc" id="L602">		WeightsUnwrapper unwrapper = new WeightsUnwrapper();</span>
<span class="fc" id="L603">		Weights&lt;?&gt; weights0 = unwrapper.unwrap(weights);</span>

<span class="pc bpc" id="L605" title="1 of 2 branches missed.">		if (!(weights0 instanceof WeightsImpl.Mapped&lt;?&gt;))</span>
<span class="nc" id="L606">			throw new IllegalArgumentException(&quot;weights of index graph used with non index graph&quot;);</span>
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">		if (map != ((WeightsImpl.Mapped&lt;?&gt;) weights0).indexMap)</span>
<span class="nc" id="L608">			throw new IllegalArgumentException(&quot;wrong index-id map is used with weights container&quot;);</span>
<span class="fc" id="L609">		WeightsImpl.IndexAbstract&lt;?&gt; weights00 = ((WeightsImpl.Mapped&lt;?&gt;) weights0).weights;</span>

<span class="fc" id="L611">		return unwrapper.rewrap(weights00);</span>
	}

	/**
	 * Create a weights view that is accessed by the elements indices, given a weights container that is accessed by the
	 * element IDs.
	 * &lt;p&gt;
	 * The returned weights container is a view, namely modifying the original container change the new one, and vice
	 * versa.
	 *
	 * @param  &lt;W&gt;     the weight type
	 * @param  weights a weights container that is accessed by the elements IDs
	 * @param  map     index-id map
	 * @return         a weights-view that is accessed by the elements indices
	 */
	public static &lt;W&gt; WeightsObj&lt;W&gt; idToIndexWeights(WeightsObj&lt;W&gt; weights, IndexIdMap map) {
<span class="nc bnc" id="L627" title="All 2 branches missed.">		if (weights instanceof WeightsImpl&lt;?&gt;) {</span>
			/* The weights container is some implementation of a mapped weights container */
			/* Instead of re-mapping by wrapping the weights container, return the underlying index weights container */
<span class="nc" id="L630">			return idToIndexWeights0((WeightsImpl&lt;?&gt;) weights, map);</span>

		} else {
			/* Unknown weight container, return a mapped wrapper */
<span class="nc" id="L634">			return new IdToIndexWeights.Obj&lt;&gt;(weights, map);</span>
		}
	}

	/**
	 * Create a weights view that is accessed by the elements indices, given a weights container that is accessed by the
	 * element IDs.
	 * &lt;p&gt;
	 * The returned weights container is a view, namely modifying the original container change the new one, and vice
	 * versa.
	 *
	 * @param  weights a weights container that is accessed by the elements IDs
	 * @param  map     index-id map
	 * @return         a weights-view that is accessed by the elements indices
	 */
	public static WeightsByte idToIndexWeights(WeightsByte weights, IndexIdMap map) {
<span class="nc bnc" id="L650" title="All 2 branches missed.">		if (weights instanceof WeightsImpl&lt;?&gt;) {</span>
			/* The weights container is some implementation of a mapped weights container */
			/* Instead of re-mapping by wrapping the weights container, return the underlying index weights container */
<span class="nc" id="L653">			return idToIndexWeights0((WeightsImpl&lt;?&gt;) weights, map);</span>

		} else {
			/* Unknown weight container, return a mapped wrapper */
<span class="nc" id="L657">			return new IdToIndexWeights.Byte(weights, map);</span>
		}
	}

	/**
	 * Create a weights view that is accessed by the elements indices, given a weights container that is accessed by the
	 * element IDs.
	 * &lt;p&gt;
	 * The returned weights container is a view, namely modifying the original container change the new one, and vice
	 * versa.
	 *
	 * @param  weights a weights container that is accessed by the elements IDs
	 * @param  map     index-id map
	 * @return         a weights-view that is accessed by the elements indices
	 */
	public static WeightsShort idToIndexWeights(WeightsShort weights, IndexIdMap map) {
<span class="nc bnc" id="L673" title="All 2 branches missed.">		if (weights instanceof WeightsImpl&lt;?&gt;) {</span>
			/* The weights container is some implementation of a mapped weights container */
			/* Instead of re-mapping by wrapping the weights container, return the underlying index weights container */
<span class="nc" id="L676">			return idToIndexWeights0((WeightsImpl&lt;?&gt;) weights, map);</span>

		} else {
			/* Unknown weight container, return a mapped wrapper */
<span class="nc" id="L680">			return new IdToIndexWeights.Short(weights, map);</span>
		}
	}

	/**
	 * Create a weights view that is accessed by the elements indices, given a weights container that is accessed by the
	 * element IDs.
	 * &lt;p&gt;
	 * The returned weights container is a view, namely modifying the original container change the new one, and vice
	 * versa.
	 *
	 * @param  weights a weights container that is accessed by the elements IDs
	 * @param  map     index-id map
	 * @return         a weights-view that is accessed by the elements indices
	 */
	public static WeightsInt idToIndexWeights(WeightsInt weights, IndexIdMap map) {
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">		if (weights instanceof WeightsImpl&lt;?&gt;) {</span>
			/* The weights container is some implementation of a mapped weights container */
			/* Instead of re-mapping by wrapping the weights container, return the underlying index weights container */
<span class="fc" id="L699">			return idToIndexWeights0((WeightsImpl&lt;?&gt;) weights, map);</span>

		} else {
			/* Unknown weight container, return a mapped wrapper */
<span class="nc" id="L703">			return new IdToIndexWeights.Int(weights, map);</span>
		}
	}

	/**
	 * Create a weights view that is accessed by the elements indices, given a weights container that is accessed by the
	 * element IDs.
	 * &lt;p&gt;
	 * The returned weights container is a view, namely modifying the original container change the new one, and vice
	 * versa.
	 *
	 * @param  weights a weights container that is accessed by the elements IDs
	 * @param  map     index-id map
	 * @return         a weights-view that is accessed by the elements indices
	 */
	public static WeightsLong idToIndexWeights(WeightsLong weights, IndexIdMap map) {
<span class="nc bnc" id="L719" title="All 2 branches missed.">		if (weights instanceof WeightsImpl&lt;?&gt;) {</span>
			/* The weights container is some implementation of a mapped weights container */
			/* Instead of re-mapping by wrapping the weights container, return the underlying index weights container */
<span class="nc" id="L722">			return idToIndexWeights0((WeightsImpl&lt;?&gt;) weights, map);</span>

		} else {
			/* Unknown weight container, return a mapped wrapper */
<span class="nc" id="L726">			return new IdToIndexWeights.Long(weights, map);</span>
		}
	}

	/**
	 * Create a weights view that is accessed by the elements indices, given a weights container that is accessed by the
	 * element IDs.
	 * &lt;p&gt;
	 * The returned weights container is a view, namely modifying the original container change the new one, and vice
	 * versa.
	 *
	 * @param  weights a weights container that is accessed by the elements IDs
	 * @param  map     index-id map
	 * @return         a weights-view that is accessed by the elements indices
	 */
	public static WeightsFloat idToIndexWeights(WeightsFloat weights, IndexIdMap map) {
<span class="nc bnc" id="L742" title="All 2 branches missed.">		if (weights instanceof WeightsImpl&lt;?&gt;) {</span>
			/* The weights container is some implementation of a mapped weights container */
			/* Instead of re-mapping by wrapping the weights container, return the underlying index weights container */
<span class="nc" id="L745">			return idToIndexWeights0((WeightsImpl&lt;?&gt;) weights, map);</span>

		} else {
			/* Unknown weight container, return a mapped wrapper */
<span class="nc" id="L749">			return new IdToIndexWeights.Float(weights, map);</span>
		}
	}

	/**
	 * Create a weights view that is accessed by the elements indices, given a weights container that is accessed by the
	 * element IDs.
	 * &lt;p&gt;
	 * The returned weights container is a view, namely modifying the original container change the new one, and vice
	 * versa.
	 *
	 * @param  weights a weights container that is accessed by the elements IDs
	 * @param  map     index-id map
	 * @return         a weights-view that is accessed by the elements indices
	 */
	public static WeightsDouble idToIndexWeights(WeightsDouble weights, IndexIdMap map) {
<span class="pc bpc" id="L765" title="1 of 2 branches missed.">		if (weights instanceof WeightsImpl&lt;?&gt;) {</span>
			/* The weights container is some implementation of a mapped weights container */
			/* Instead of re-mapping by wrapping the weights container, return the underlying index weights container */
<span class="fc" id="L768">			return idToIndexWeights0((WeightsImpl&lt;?&gt;) weights, map);</span>

		} else {
			/* Unknown weight container, return a mapped wrapper */
<span class="nc" id="L772">			return new IdToIndexWeights.Double(weights, map);</span>
		}
	}

	/**
	 * Create a weights view that is accessed by the elements indices, given a weights container that is accessed by the
	 * element IDs.
	 * &lt;p&gt;
	 * The returned weights container is a view, namely modifying the original container change the new one, and vice
	 * versa.
	 *
	 * @param  weights a weights container that is accessed by the elements IDs
	 * @param  map     index-id map
	 * @return         a weights-view that is accessed by the elements indices
	 */
	public static WeightsBool indexWeightsFromWeights(WeightsBool weights, IndexIdMap map) {
<span class="nc bnc" id="L788" title="All 2 branches missed.">		if (weights instanceof WeightsImpl&lt;?&gt;) {</span>
			/* The weights container is some implementation of a mapped weights container */
			/* Instead of re-mapping by wrapping the weights container, return the underlying index weights container */
<span class="nc" id="L791">			return idToIndexWeights0((WeightsImpl&lt;?&gt;) weights, map);</span>

		} else {
			/* Unknown weight container, return a mapped wrapper */
<span class="nc" id="L795">			return new IdToIndexWeights.Bool(weights, map);</span>
		}
	}

	/**
	 * Create a weights view that is accessed by the elements indices, given a weights container that is accessed by the
	 * elements IDs.
	 * &lt;p&gt;
	 * The returned weights container is a view, namely modifying the original container change the new one, and vice
	 * versa.
	 *
	 * @param  weights a weights container that is accessed by the elements IDs
	 * @param  map     index-id map
	 * @return         a weights-view that is accessed by the elements indices
	 */
	public static WeightsChar idToIndexWeights(WeightsChar weights, IndexIdMap map) {
<span class="nc bnc" id="L811" title="All 2 branches missed.">		if (weights instanceof WeightsImpl&lt;?&gt;) {</span>
			/* The weights container is some implementation of a mapped weights container */
			/* Instead of re-mapping by wrapping the weights container, return the underlying index weights container */
<span class="nc" id="L814">			return idToIndexWeights0((WeightsImpl&lt;?&gt;) weights, map);</span>

		} else {
			/* Unknown weight container, return a mapped wrapper */
<span class="nc" id="L818">			return new IdToIndexWeights.Char(weights, map);</span>
		}
	}

	/**
	 * Create a weight function that accept elements indices, given a weight function that accept elements IDs.
	 *
	 * @param  w   a weight function that accept by elements IDs
	 * @param  map index-id map
	 * @return     a weight function that accept elements indices
	 */
	public static WeightFunction idToIndexWeightFunc(WeightFunction w, IndexIdMap map) {
<span class="pc bpc" id="L830" title="1 of 4 branches missed.">		if (w == null || w == WeightFunction.CardinalityWeightFunction) {</span>
<span class="fc" id="L831">			return w;</span>

<span class="fc bfc" id="L833" title="All 2 branches covered.">		} else if (w instanceof WeightsImpl&lt;?&gt;) {</span>
			/* The weight function is some implementation of a mapped weights container */
			/* Instead of re-mapping by wrapping the weight function, return the underlying index weights container */
<span class="fc" id="L836">			return (WeightFunction) idToIndexWeights0((WeightsImpl&lt;?&gt;) w, map);</span>

		} else {
			/* Unknown weight function, return a mapped wrapper */
<span class="pc bpc" id="L840" title="1 of 2 branches missed.">			if (w instanceof WeightFunctionInt) {</span>
<span class="nc" id="L841">				WeightFunctionInt wInt = (WeightFunctionInt) w;</span>
<span class="nc" id="L842">				WeightFunctionInt wIntMapped = idx -&gt; wInt.weightInt(map.indexToId(idx));</span>
<span class="nc" id="L843">				return wIntMapped;</span>
			} else {
<span class="fc" id="L845">				return idx -&gt; w.weight(map.indexToId(idx));</span>
			}
		}
	}

	/**
	 * Create a weight function that accept elements indices, given a weight function that accept elements IDs.
	 *
	 * @param  w   a weight function that accept by elements IDs
	 * @param  map index-id map
	 * @return     a weight function that accept elements indices
	 */
	public static WeightFunctionInt idToIndexWeightFunc(WeightFunctionInt w, IndexIdMap map) {
<span class="nc bnc" id="L858" title="All 4 branches missed.">		if (w == null || w == WeightFunction.CardinalityWeightFunction) {</span>
<span class="nc" id="L859">			return w;</span>

<span class="nc bnc" id="L861" title="All 2 branches missed.">		} else if (w instanceof WeightsImpl&lt;?&gt;) {</span>
			/* The weight function is some implementation of a mapped weights container */
			/* Instead of re-mapping by wrapping the weight function, return the underlying index weights container */
<span class="nc" id="L864">			return (WeightFunctionInt) idToIndexWeights0((WeightsImpl&lt;?&gt;) w, map);</span>

		} else {
			/* Unknown weight function, return a mapped wrapper */
<span class="nc" id="L868">			return idx -&gt; w.weightInt(map.indexToId(idx));</span>
		}
	}

	private static class WeightsUnwrapper {
		private boolean immutableView;

		@SuppressWarnings(&quot;unchecked&quot;)
		&lt;V, WeightsT extends Weights&lt;V&gt;&gt; WeightsT unwrap(WeightsImpl&lt;?&gt; weights) {
<span class="fc" id="L877">			Weights&lt;?&gt; weights0 = weights;</span>
<span class="fc" id="L878">			immutableView = weights0 instanceof WeightsImpl.ImmutableView&lt;?&gt;;</span>
<span class="pc bpc" id="L879" title="1 of 2 branches missed.">			if (immutableView)</span>
<span class="nc" id="L880">				weights0 = ((WeightsImpl.ImmutableView&lt;?&gt;) weights0).weights;</span>
<span class="fc" id="L881">			return (WeightsT) weights0;</span>
		}

		@SuppressWarnings(&quot;unchecked&quot;)
		&lt;V, WeightsT extends Weights&lt;V&gt;&gt; WeightsT rewrap(Weights&lt;?&gt; weights) {
<span class="pc bpc" id="L886" title="1 of 2 branches missed.">			if (immutableView)</span>
<span class="nc" id="L887">				weights = WeightsImpl.ImmutableView.newInstance(weights);</span>
<span class="fc" id="L888">			return (WeightsT) weights;</span>
		}

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>