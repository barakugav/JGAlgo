<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IEdgeSet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.graph</a> &gt; <span class="el_source">IEdgeSet.java</span></div><h1>IEdgeSet.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.graph;

import it.unimi.dsi.fastutil.ints.IntSet;

/**
 * Set of int graph edges.
 *
 * &lt;p&gt;
 * This interface is a specification of {@link EdgeSet} for {@link IntGraph}.
 *
 * &lt;p&gt;
 * A set of integers, each represent an edge ID in a graph
 *
 * &lt;pre&gt; {@code
 * IntGraph g = ...;
 * int vertex = ...;
 * for (IEdgeIter eit = g.outEdges(vertex).iterator(); eit.hasNext();) {
 * 	int e = eit.nextInt();
 * 	int u = eit.sourceInt();
 * 	int v = eit.targetInt();
 * 	assert vertex == u;
 * 	System.out.println(&quot;Out edge of &quot; + vertex + &quot;: &quot; + e + &quot;(&quot; + u + &quot;, &quot; + v + &quot;)&quot;);
 * }
 * }&lt;/pre&gt;
 *
 * @see    IEdgeIter
 * @author Barak Ugav
 */
public interface IEdgeSet extends EdgeSet&lt;Integer, Integer&gt;, IntSet {

	/**
	 * Return an edge iterator that iterate over the edges in this set.
	 */
	@Override
	IEdgeIter iterator();

	/**
	 * Return an edge iterator that iterate over the edges in this set.
	 */
	@Override
	default IEdgeIter intIterator() {
<span class="nc" id="L57">		return iterator();</span>
	}

	/**
	 * Create an edge set object from a plain set of edges.
	 *
	 * &lt;p&gt;
	 * A 'plain' set of edges is a set of the edges identifiers. It does not include any information about the endpoints
	 * (source and target) of each edge. This method creates an {@link IEdgeSet}, which does contains information about
	 * the endpoints, given a plain set of edges and the graph in which the edges are defined in.
	 *
	 * &lt;p&gt;
	 * The returned set is a view of the given set and graph. Namely, its updated when the original set is updated and
	 * visa vera, and the endpoints in the {@link IEdgeSet} will be up to date with the given graph.
	 *
	 * &lt;p&gt;
	 * No validation is performed to ensure that all the given edges are actually in the given graph. If this is not the
	 * case, an exception may be thrown later when the graph is queried for an edge source and target.
	 *
	 *
	 * &lt;p&gt;
	 * Usually an {@link IEdgeSet} object is obtained via one of the method of a {@link IntGraph}, and rarely a user
	 * need to a create one, but it may be used to add multiple edges to a graph using the
	 * {@link IntGraph#addEdges(EdgeSet)} method. In the following snippet, a maximum cardinality matching is computed
	 * on a graph, and a new graph containing only the matching edges is created:
	 *
	 * &lt;pre&gt; {@code
	 * IntGraph g = ...;
	 * IntSet matching = (IntSet) MatchingAlgo.newInstance().computeMaximumMatching(g, null).edges();
	 *
	 * IntGraph matchingGraph = IntGraph.newUndirected();
	 * matchingGraph.addVertices(g.vertices());
	 * matchingGraph.addEdges(IEdgeSet.of(matching, g));
	 * }&lt;/pre&gt;
	 *
	 * @param  edges a set of edges identifiers
	 * @param  g     the graph in which the edges are defined in, and from which the endpoints of the edges should be
	 *                   retrieved
	 * @return       an {@link IEdgeSet} with the given edges, containing the endpoints information from the graph
	 */
	static IEdgeSet of(IntSet edges, IntGraph g) {
<span class="fc" id="L98">		return (IEdgeSet) EdgeSet.of(edges, g);</span>
	}

	/**
	 * Create an edge set object of all the edges in a graph.
	 *
	 * &lt;p&gt;
	 * The edge set returned by {@link IntGraph#edges()} is a 'plain' set of edges, namely it is a set of the edge
	 * identifiers themselves but does not include any information about the endpoints (source and target) of each edge.
	 * This method creates an {@link IEdgeSet}, which does contains information about the endpoints, of all the edges in
	 * a given graph.
	 *
	 * &lt;p&gt;
	 * The returned set is a view of the given set and graph. Namely, its updated when the original set is updated and
	 * visa vera, and the endpoints in the {@link IEdgeSet} will be up to date with the given graph.
	 *
	 * &lt;p&gt;
	 * Usually an {@link IEdgeSet} object is obtained via one of the method of a {@link IntGraph}, and rarely a user
	 * need to a create one, but it may be used to add multiple edges to a graph using the
	 * {@link IntGraph#addEdges(EdgeSet)} method. In the following snippet, an auxillary graph is created which is a
	 * copy of an original graph {@code g} with additional vertex connected to all the original vertices, for shortest
	 * path potential function computation (used in Johnson APSP):
	 *
	 * &lt;pre&gt; {@code
	 * int auxillaryVertex = ...;
	 * IntGraph auxillaryGraph = IntGraph.newDirected();
	 * auxillaryGraph.addVertices(g.vertices());
	 * auxillaryGraph.addVertex(auxillaryVertex);
	 * auxillaryGraph.addEdges(IEdgeSet.allOf(g));
	 * for (int v : g.vertices())
	 * 	auxillaryGraph.addEdge(auxillaryVertex, v);
	 * }&lt;/pre&gt;
	 *
	 * @param  g a graph
	 * @return   an {@link IEdgeSet} of all the edges in the graph
	 */
	static IEdgeSet allOf(IntGraph g) {
<span class="fc" id="L135">		return (IEdgeSet) EdgeSet.allOf(g);</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>