<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Graphs.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.graph</a> &gt; <span class="el_source">Graphs.java</span></div><h1>Graphs.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.graph;

import java.util.Objects;
import java.util.Set;
import com.jgalgo.internal.util.Assertions;
import it.unimi.dsi.fastutil.ints.AbstractIntSet;
import it.unimi.dsi.fastutil.ints.IntSet;

/**
 * Static methods class for graphs.
 *
 * @author Barak Ugav
 */
public class Graphs {
	private Graphs() {}

	/**
	 * An undirected graphs with no vertices and no edges
	 */
<span class="fc" id="L35">	public static final IndexGraph EmptyGraphUndirected = IndexGraphBuilder.newUndirected().build();</span>

	/**
	 * A directed graphs with no vertices and no edges
	 */
<span class="fc" id="L40">	public static final IndexGraph EmptyGraphDirected = IndexGraphBuilder.newDirected().build();</span>

	private static class CompleteGraphUndirected extends CompleteGraph {

		CompleteGraphUndirected(int verticesNum) {
<span class="fc" id="L45">			super(verticesNum, verticesNum * (verticesNum - 1) / 2);</span>
<span class="fc" id="L46">		}</span>

		CompleteGraphUndirected(CompleteGraphUndirected g) {
<span class="nc" id="L49">			super(g);</span>
<span class="nc" id="L50">		}</span>

		@Override
		public int getEdge(int source, int target) {
<span class="fc" id="L54">			checkVertex(source);</span>
<span class="fc" id="L55">			checkVertex(target);</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">			if (source == target)</span>
<span class="fc" id="L57">				return -1;</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">			if (source &gt; target) {</span>
<span class="fc" id="L59">				int temp = source;</span>
<span class="fc" id="L60">				source = target;</span>
<span class="fc" id="L61">				target = temp;</span>
			}
<span class="pc bnc" id="L63" title="All 2 branches missed.">			assert source &lt; target;</span>

<span class="fc bfc" id="L65" title="All 2 branches covered.">			if (n % 2 == 0) {</span>
<span class="fc" id="L66">				final int edgesPerSource1 = n / 2;</span>
<span class="fc" id="L67">				final int edgesPerSource2 = n / 2 - 1;</span>
<span class="fc" id="L68">				final int sourcesNum1 = n / 2;</span>

<span class="fc bfc" id="L70" title="All 2 branches covered.">				boolean source1 = source &lt; sourcesNum1;</span>
<span class="fc bfc" id="L71" title="All 4 branches covered.">				boolean edgeIsSourcedAtSource = source + (source1 ? edgesPerSource1 : edgesPerSource2) &gt;= target;</span>
<span class="fc bfc" id="L72" title="All 4 branches covered.">				if (source1 &amp;&amp; edgeIsSourcedAtSource) {</span>
<span class="fc" id="L73">					int base = edgesPerSource1 * source;</span>
<span class="fc" id="L74">					int offset = target - source - 1;</span>
<span class="fc" id="L75">					return base + offset;</span>

<span class="pc bpc" id="L77" title="1 of 4 branches missed.">				} else if (!source1 &amp;&amp; edgeIsSourcedAtSource) {</span>
<span class="fc" id="L78">					int base = sourcesNum1 * edgesPerSource1 + (source - sourcesNum1) * edgesPerSource2;</span>
<span class="fc" id="L79">					int offset = target - source - 1;</span>
<span class="fc" id="L80">					return base + offset;</span>

				} else {
<span class="pc bnc" id="L83" title="All 2 branches missed.">					assert !edgeIsSourcedAtSource;</span>
<span class="pc bnc" id="L84" title="All 2 branches missed.">					assert target + edgesPerSource2 &gt;= n;</span>
<span class="pc bnc" id="L85" title="All 2 branches missed.">					assert target + edgesPerSource2 - n &gt;= source;</span>
<span class="fc" id="L86">					int base = sourcesNum1 * edgesPerSource1 + (target - sourcesNum1) * edgesPerSource2;</span>
<span class="fc" id="L87">					int offset = source - target - 1 + n;</span>
<span class="pc bnc" id="L88" title="All 4 branches missed.">					assert 0 &lt;= offset &amp;&amp; offset &lt; edgesPerSource2;</span>
<span class="fc" id="L89">					return base + offset;</span>
				}
			} else {
<span class="fc" id="L92">				final int edgesPerSource = (n - 1) / 2;</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">				if (source + edgesPerSource &gt;= target) {</span>
<span class="fc" id="L94">					int base = edgesPerSource * source;</span>
<span class="fc" id="L95">					int offset = target - source - 1;</span>
<span class="pc bnc" id="L96" title="All 4 branches missed.">					assert 0 &lt;= offset &amp;&amp; offset &lt; edgesPerSource;</span>
<span class="fc" id="L97">					return base + offset;</span>
				} else {
<span class="pc bnc" id="L99" title="All 2 branches missed.">					assert target + edgesPerSource &gt;= n;</span>
<span class="pc bnc" id="L100" title="All 2 branches missed.">					assert target + edgesPerSource - n &gt;= source;</span>
<span class="fc" id="L101">					int base = edgesPerSource * target;</span>
<span class="fc" id="L102">					int offset = source - target - 1 + n;</span>
<span class="pc bnc" id="L103" title="All 4 branches missed.">					assert 0 &lt;= offset &amp;&amp; offset &lt; edgesPerSource;</span>
<span class="fc" id="L104">					return base + offset;</span>
				}
			}
		}

		@Override
		public int edgeSource(int edge) {
<span class="fc" id="L111">			checkEdge(edge);</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">			if (n % 2 == 0) {</span>
<span class="fc" id="L113">				final int edgesPerSource1 = n / 2;</span>
<span class="fc" id="L114">				final int edgesPerSource2 = n / 2 - 1;</span>
<span class="fc" id="L115">				final int sourcesNum1 = n / 2;</span>

<span class="fc" id="L117">				int threshold = sourcesNum1 * edgesPerSource1;</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">				if (edge &lt; threshold) {</span>
<span class="fc" id="L119">					return edge / edgesPerSource1;</span>
				} else {
<span class="fc" id="L121">					return sourcesNum1 + (edge - threshold) / edgesPerSource2;</span>
				}
			} else {
<span class="fc" id="L124">				final int edgesPerSource = (n - 1) / 2;</span>
<span class="fc" id="L125">				return edge / edgesPerSource;</span>
			}
		}

		@Override
		public int edgeTarget(int edge) {
<span class="fc" id="L131">			checkEdge(edge);</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">			if (n % 2 == 0) {</span>
<span class="fc" id="L133">				final int edgesPerSource1 = n / 2;</span>
<span class="fc" id="L134">				final int edgesPerSource2 = n / 2 - 1;</span>
<span class="fc" id="L135">				final int sourcesNum1 = n / 2;</span>

<span class="fc" id="L137">				int threshold = sourcesNum1 * edgesPerSource1;</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">				if (edge &lt; threshold) {</span>
<span class="fc" id="L139">					int source = edge / edgesPerSource1;</span>
<span class="fc" id="L140">					int offset = edge % edgesPerSource1;</span>
<span class="fc" id="L141">					return offset + source + 1;</span>
				} else {
<span class="fc" id="L143">					int source = sourcesNum1 + (edge - threshold) / edgesPerSource2;</span>
<span class="fc" id="L144">					int offset = (edge - threshold) % edgesPerSource2;</span>
<span class="fc" id="L145">					int target = offset + source + 1;</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">					return target &lt; n ? target : target - n;</span>
				}
			} else {
<span class="fc" id="L149">				final int edgesPerSource = (n - 1) / 2;</span>
<span class="fc" id="L150">				int source = edge / edgesPerSource;</span>
<span class="fc" id="L151">				int offset = edge % edgesPerSource;</span>
<span class="fc" id="L152">				int target = offset + source + 1;</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">				return target &lt; n ? target : target - n;</span>
			}
		}

		@Override
		public void reverseEdge(int edge) {
<span class="nc" id="L159">			checkEdge(edge);</span>
			// do nothing
<span class="nc" id="L161">		}</span>

		@Override
		public GraphCapabilities getCapabilities() {
<span class="fc" id="L165">			return Capabilities;</span>
		}

<span class="fc" id="L168">		private static final GraphCapabilities Capabilities =</span>
<span class="fc" id="L169">				GraphCapabilitiesBuilder.newUndirected().parallelEdges(false).selfEdges(false).build();</span>

		@Override
		public EdgeSet outEdges(int source) {
<span class="fc" id="L173">			checkVertex(source);</span>
<span class="fc" id="L174">			return new GraphBase.EdgeSetOutUndirected(source) {</span>
				@Override
				public EdgeIter iterator() {
<span class="fc" id="L177">					return outEdgesIter(source);</span>
				}

				@Override
				public int size() {
<span class="fc bfc" id="L182" title="All 2 branches covered.">					return n &lt;= 1 ? 0 : n - 1;</span>
				}

				@Override
				public boolean isEmpty() {
<span class="nc bnc" id="L187" title="All 2 branches missed.">					return size() == 0;</span>
				}
			};
		}

		@Override
		public EdgeSet inEdges(int target) {
<span class="fc" id="L194">			checkVertex(target);</span>
<span class="fc" id="L195">			return new GraphBase.EdgeSetInUndirected(target) {</span>
				@Override
				public EdgeIter iterator() {
<span class="fc" id="L198">					return inEdgesIter(target);</span>
				}

				@Override
				public int size() {
<span class="fc bfc" id="L203" title="All 2 branches covered.">					return n &lt;= 1 ? 0 : n - 1;</span>
				}

				@Override
				public boolean isEmpty() {
<span class="nc bnc" id="L208" title="All 2 branches missed.">					return size() == 0;</span>
				}
			};
		}
	}

	private static class CompleteGraphDirected extends CompleteGraph {

		CompleteGraphDirected(int verticesNum) {
<span class="fc" id="L217">			super(verticesNum, verticesNum * (verticesNum - 1));</span>
<span class="fc" id="L218">		}</span>

		CompleteGraphDirected(CompleteGraphDirected g) {
<span class="nc" id="L221">			super(g);</span>
<span class="nc" id="L222">		}</span>

		@Override
		public int getEdge(int source, int target) {
<span class="fc" id="L226">			checkVertex(source);</span>
<span class="fc" id="L227">			checkVertex(target);</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">			if (source == target)</span>
<span class="fc" id="L229">				return -1;</span>

<span class="fc" id="L231">			int base = source * (n - 1);</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">			int offset = target &lt; source ? target : target - 1;</span>
<span class="fc" id="L233">			return base + offset;</span>
		}

		@Override
		public int edgeSource(int edge) {
<span class="fc" id="L238">			checkEdge(edge);</span>
<span class="fc" id="L239">			return edge / (n - 1);</span>
		}

		@Override
		public int edgeTarget(int edge) {
<span class="fc" id="L244">			checkEdge(edge);</span>
<span class="fc" id="L245">			int source = edge / (n - 1);</span>
<span class="fc" id="L246">			int target = edge % (n - 1);</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">			return target &lt; source ? target : target + 1;</span>
		}

		@Override
		public void reverseEdge(int edge) {
<span class="fc" id="L252">			checkEdge(edge);</span>
<span class="fc" id="L253">			throw new UnsupportedOperationException();</span>
		}

		@Override
		public GraphCapabilities getCapabilities() {
<span class="fc" id="L258">			return Capabilities;</span>
		}

<span class="fc" id="L261">		private static final GraphCapabilities Capabilities =</span>
<span class="fc" id="L262">				GraphCapabilitiesBuilder.newDirected().parallelEdges(false).selfEdges(false).build();</span>

		@Override
		public EdgeSet outEdges(int source) {
<span class="fc" id="L266">			checkVertex(source);</span>
<span class="fc" id="L267">			return new GraphBase.EdgeSetOutDirected(source) {</span>
				@Override
				public EdgeIter iterator() {
<span class="fc" id="L270">					return outEdgesIter(source);</span>
				}

				@Override
				public int size() {
<span class="fc bfc" id="L275" title="All 2 branches covered.">					return n &lt;= 1 ? 0 : n - 1;</span>
				}

				@Override
				public boolean isEmpty() {
<span class="nc bnc" id="L280" title="All 2 branches missed.">					return size() == 0;</span>
				}
			};
		}

		@Override
		public EdgeSet inEdges(int target) {
<span class="fc" id="L287">			checkVertex(target);</span>
<span class="fc" id="L288">			return new GraphBase.EdgeSetInDirected(target) {</span>
				@Override
				public EdgeIter iterator() {
<span class="fc" id="L291">					return inEdgesIter(target);</span>
				}

				@Override
				public int size() {
<span class="fc bfc" id="L296" title="All 2 branches covered.">					return n &lt;= 1 ? 0 : n - 1;</span>
				}

				@Override
				public boolean isEmpty() {
<span class="nc bnc" id="L301" title="All 2 branches missed.">					return size() == 0;</span>
				}
			};
		}

	}

	private static abstract class CompleteGraph extends GraphBase implements IndexGraphImpl {

		final int n, m;
		private final GraphElementSet vertices;
		private final GraphElementSet edges;
		private final WeightsImpl.IndexMutable.Manager verticesWeights;
		private final WeightsImpl.IndexMutable.Manager edgesWeights;

<span class="fc" id="L316">		CompleteGraph(int n, int m) {</span>
<span class="fc" id="L317">			vertices = new GraphElementSet.Default(n, false);</span>
<span class="fc" id="L318">			edges = new GraphElementSet.Default(m, true);</span>
<span class="pc bpc" id="L319" title="2 of 4 branches missed.">			if (n &lt; 0 || m &lt; 0)</span>
<span class="nc" id="L320">				throw new IllegalArgumentException();</span>
<span class="fc" id="L321">			this.n = n;</span>
<span class="fc" id="L322">			this.m = m;</span>
<span class="fc" id="L323">			verticesWeights = new WeightsImpl.IndexMutable.Manager(n);</span>
<span class="fc" id="L324">			edgesWeights = new WeightsImpl.IndexMutable.Manager(m);</span>
<span class="fc" id="L325">		}</span>

<span class="nc" id="L327">		CompleteGraph(CompleteGraph g) {</span>
<span class="nc" id="L328">			vertices = new GraphElementSet.Default(g.n, false);</span>
<span class="nc" id="L329">			edges = new GraphElementSet.Default(g.m, true);</span>
<span class="nc" id="L330">			this.n = g.n;</span>
<span class="nc" id="L331">			this.m = g.m;</span>
<span class="nc" id="L332">			verticesWeights = new WeightsImpl.IndexMutable.Manager(g.verticesWeights, vertices);</span>
<span class="nc" id="L333">			edgesWeights = new WeightsImpl.IndexMutable.Manager(g.edgesWeights, edges);</span>
<span class="nc" id="L334">		}</span>

		@Override
		public GraphElementSet vertices() {
<span class="fc" id="L338">			return vertices;</span>
		}

		@Override
		public GraphElementSet edges() {
<span class="fc" id="L343">			return edges;</span>
		}

		void checkVertex(int vertex) {
<span class="fc" id="L347">			Assertions.Graphs.checkVertex(vertex, n);</span>
<span class="fc" id="L348">		}</span>

		void checkEdge(int edge) {
<span class="fc" id="L351">			Assertions.Graphs.checkEdge(edge, m);</span>
<span class="fc" id="L352">		}</span>

		@Override
		public int addVertex() {
<span class="fc" id="L356">			throw new UnsupportedOperationException(&quot;graph is complete, cannot add vertices&quot;);</span>
		}

		@Override
		public void removeVertex(int vertex) {
<span class="fc" id="L361">			checkVertex(vertex);</span>
<span class="fc" id="L362">			throw new UnsupportedOperationException(&quot;graph is complete, cannot remove vertices&quot;);</span>
		}

		EdgeIter outEdgesIter(int source) {
<span class="fc" id="L366">			checkVertex(source);</span>
<span class="fc" id="L367">			return new EdgeIter() {</span>
<span class="fc" id="L368">				int nextTarget = 0;</span>
<span class="fc" id="L369">				int target = -1;</span>
				{
<span class="fc" id="L371">					advance();</span>
<span class="fc" id="L372">				}</span>

				private void advance() {
<span class="fc bfc" id="L375" title="All 2 branches covered.">					for (; nextTarget &lt; n; nextTarget++)</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">						if (nextTarget != source)</span>
<span class="fc" id="L377">							return;</span>
<span class="fc" id="L378">				}</span>

				@Override
				public boolean hasNext() {
<span class="fc bfc" id="L382" title="All 2 branches covered.">					return nextTarget &lt; n;</span>
				}

				@Override
				public int nextInt() {
<span class="fc" id="L387">					Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L388">					target = nextTarget;</span>
<span class="fc" id="L389">					nextTarget++;</span>
<span class="fc" id="L390">					advance();</span>
<span class="fc" id="L391">					return getEdge(source, target);</span>
				}

				@Override
				public int peekNext() {
<span class="fc" id="L396">					Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L397">					return getEdge(source, nextTarget);</span>
				}

				@Override
				public int source() {
<span class="fc" id="L402">					return source;</span>
				}

				@Override
				public int target() {
<span class="fc" id="L407">					return target;</span>
				}
			};
		}

		EdgeIter inEdgesIter(int target) {
<span class="fc" id="L413">			checkVertex(target);</span>
<span class="fc" id="L414">			return new EdgeIter() {</span>
<span class="fc" id="L415">				int nextSource = 0;</span>
<span class="fc" id="L416">				int source = -1;</span>

				{
<span class="fc" id="L419">					advance();</span>
<span class="fc" id="L420">				}</span>

				private void advance() {
<span class="fc bfc" id="L423" title="All 2 branches covered.">					for (; nextSource &lt; n; nextSource++)</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">						if (nextSource != target)</span>
<span class="fc" id="L425">							return;</span>
<span class="fc" id="L426">				}</span>

				@Override
				public boolean hasNext() {
<span class="fc bfc" id="L430" title="All 2 branches covered.">					return nextSource &lt; n;</span>
				}

				@Override
				public int nextInt() {
<span class="fc" id="L435">					Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L436">					source = nextSource;</span>
<span class="fc" id="L437">					nextSource++;</span>
<span class="fc" id="L438">					advance();</span>
<span class="fc" id="L439">					return getEdge(source, target);</span>
				}

				@Override
				public int peekNext() {
<span class="fc" id="L444">					Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L445">					return getEdge(nextSource, target);</span>
				}

				@Override
				public int source() {
<span class="fc" id="L450">					return source;</span>
				}

				@Override
				public int target() {
<span class="fc" id="L455">					return target;</span>
				}
			};
		}

		private class EdgeSetSourceTarget extends AbstractIntSet implements EdgeSet {

			private final int source, target;

<span class="fc" id="L464">			EdgeSetSourceTarget(int source, int target) {</span>
<span class="fc" id="L465">				this.source = source;</span>
<span class="fc" id="L466">				this.target = target;</span>
<span class="fc" id="L467">			}</span>

			@Override
			public boolean contains(int edge) {
<span class="nc bnc" id="L471" title="All 2 branches missed.">				return getEdge(source, target) == edge;</span>
			}

			@Override
			public int size() {
<span class="fc" id="L476">				return 1;</span>
			}

			@Override
			public EdgeIter iterator() {
<span class="fc" id="L481">				return new EdgeIter() {</span>

<span class="fc" id="L483">					boolean beforeNext = true;</span>

					@Override
					public boolean hasNext() {
<span class="fc" id="L487">						return beforeNext;</span>
					}

					@Override
					public int nextInt() {
<span class="fc" id="L492">						Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L493">						beforeNext = false;</span>
<span class="fc" id="L494">						return getEdge(source, target);</span>
					}

					@Override
					public int peekNext() {
<span class="fc" id="L499">						Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L500">						return getEdge(source, target);</span>
					}

					@Override
					public int source() {
<span class="fc" id="L505">						return source;</span>
					}

					@Override
					public int target() {
<span class="fc" id="L510">						return target;</span>
					}
				};
			}

		}

		@Override
		public EdgeSet getEdges(int source, int target) {
<span class="fc" id="L519">			checkVertex(source);</span>
<span class="fc" id="L520">			checkVertex(target);</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">			if (source == target)</span>
<span class="fc" id="L522">				return Edges.EmptyEdgeSet;</span>
<span class="fc" id="L523">			return new EdgeSetSourceTarget(source, target);</span>
		}

		@Override
		public int addEdge(int source, int target) {
<span class="fc" id="L528">			checkVertex(source);</span>
<span class="fc" id="L529">			checkVertex(target);</span>
<span class="fc" id="L530">			throw new UnsupportedOperationException(&quot;graph is complete, cannot add edges&quot;);</span>
		}

		@Override
		public void removeEdge(int edge) {
<span class="fc" id="L535">			checkEdge(edge);</span>
<span class="fc" id="L536">			throw new UnsupportedOperationException(&quot;graph is complete, cannot remove edges&quot;);</span>
		}

		@Override
		public void removeEdgesOf(int vertex) {
<span class="fc" id="L541">			checkVertex(vertex);</span>
<span class="fc" id="L542">			throw new UnsupportedOperationException(&quot;graph is complete, cannot remove edges&quot;);</span>
		}

		@Override
		public void removeOutEdgesOf(int vertex) {
<span class="fc" id="L547">			checkVertex(vertex);</span>
<span class="fc" id="L548">			throw new UnsupportedOperationException(&quot;graph is complete, cannot remove edges&quot;);</span>
		}

		@Override
		public void removeInEdgesOf(int vertex) {
<span class="fc" id="L553">			checkVertex(vertex);</span>
<span class="fc" id="L554">			throw new UnsupportedOperationException(&quot;graph is complete, cannot remove edges&quot;);</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L559">			throw new UnsupportedOperationException(&quot;graph is complete, cannot remove edges&quot;);</span>
		}

		@Override
		public void clearEdges() {
<span class="fc" id="L564">			throw new UnsupportedOperationException(&quot;graph is complete, cannot remove edges&quot;);</span>
		}

		@Override
		public &lt;V, WeightsT extends Weights&lt;V&gt;&gt; WeightsT getVerticesWeights(Object key) {
<span class="nc" id="L569">			return verticesWeights.getWeights(key);</span>
		}

		@Override
		public Set&lt;Object&gt; getVerticesWeightsKeys() {
<span class="nc" id="L574">			return verticesWeights.weightsKeys();</span>
		}

		@Override
		public void removeVerticesWeights(Object key) {
<span class="nc" id="L579">			verticesWeights.removeWeights(key);</span>
<span class="nc" id="L580">		}</span>

		@Override
		public &lt;E, WeightsT extends Weights&lt;E&gt;&gt; WeightsT getEdgesWeights(Object key) {
<span class="nc" id="L584">			return edgesWeights.getWeights(key);</span>
		}

		@Override
		public &lt;V, WeightsT extends Weights&lt;V&gt;&gt; WeightsT addVerticesWeights(Object key, Class&lt;? super V&gt; type,
				V defVal) {
<span class="nc" id="L590">			WeightsImpl.IndexMutable&lt;V&gt; weights = WeightsImpl.IndexMutable.newInstance(vertices, type, defVal);</span>
<span class="nc" id="L591">			verticesWeights.addWeights(key, weights);</span>
			@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L593">			WeightsT weights0 = (WeightsT) weights;</span>
<span class="nc" id="L594">			return weights0;</span>
		}

		@Override
		public &lt;E, WeightsT extends Weights&lt;E&gt;&gt; WeightsT addEdgesWeights(Object key, Class&lt;? super E&gt; type, E defVal) {
<span class="nc" id="L599">			WeightsImpl.IndexMutable&lt;E&gt; weights = WeightsImpl.IndexMutable.newInstance(edges, type, defVal);</span>
<span class="nc" id="L600">			edgesWeights.addWeights(key, weights);</span>
			@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L602">			WeightsT weights0 = (WeightsT) weights;</span>
<span class="nc" id="L603">			return weights0;</span>
		}

		@Override
		public Set&lt;Object&gt; getEdgesWeightsKeys() {
<span class="nc" id="L608">			return edgesWeights.weightsKeys();</span>
		}

		@Override
		public void removeEdgesWeights(Object key) {
<span class="nc" id="L613">			edgesWeights.removeWeights(key);</span>
<span class="nc" id="L614">		}</span>
	}

	/**
	 * Create a new undirected complete graph with a fixed number of vertices.
	 * &lt;p&gt;
	 * Given a set of vertices \(V\), the complete graph \(G=(V,E)\) is the graph with the edges set \(E=\{\{u,v\} \mid
	 * u,v \in V, u \neq v \}\), namely there is a single edge between any pair of vertices \(u,v\). The created graph
	 * will have a fixed number of vertices \(n\), and a fixed number of edges \({n \choose 2}\). No vertex or edge can
	 * be removed or added, but weights can be added. This graph is useful in cases where all edges exists, but we want
	 * to avoid using \(O(n^2)\) memory, for example for metric TSP, where each two vertices (points in a 2D world) are
	 * connected by an edge.
	 *
	 * @param  numberOfVertices the number of vertices in the graph. Note that its impossible to change the number of
	 *                              vertices after the graph was created.
	 * @return                  a new undirected complete graph
	 */
	public static IndexGraph newCompleteGraphUndirected(int numberOfVertices) {
<span class="fc" id="L632">		return new CompleteGraphUndirected(numberOfVertices);</span>
	}

	/**
	 * Create a new directed complete graph with a fixed number of vertices.
	 * &lt;p&gt;
	 * Given a set of vertices \(V\), the complete graph \(G=(V,E)\) is the graph with the edges set \(E=\{(u,v) \mid
	 * u,v \in V, u \neq v \}\), namely there are two edges between any pair of vertices \(u,v\) where one is the
	 * reverse of the other. The created graph will have a fixed number of vertices \(n\), and a fixed number of edges
	 * \(2 {n \choose 2}\) (the additional factor of \(2\) is due to the directiveness of the edges). No vertex or edge
	 * can be removed or added, but weights can be added. This graph is useful in cases where all edges exists, but we
	 * want to avoid using \(O(n^2)\) memory, for example for metric TSP, where each two vertices (points in a 2D world)
	 * are connected by an edge.
	 *
	 * @param  numberOfVertices the number of vertices in the graph. Note that its impossible to change the number of
	 *                              vertices after the graph was created.
	 * @return                  a new directed complete graph
	 */
	public static IndexGraph newCompleteGraphDirected(int numberOfVertices) {
<span class="fc" id="L651">		return new CompleteGraphDirected(numberOfVertices);</span>
	}

	/**
	 * Tag interface for graphs that can not be muted/changed/altered
	 *
	 * @author Barak Ugav
	 */
	static interface ImmutableGraph {
	}

	private static class ImmutableGraphView extends GraphBase implements ImmutableGraph {

		private final Graph graph;

<span class="fc" id="L666">		ImmutableGraphView(Graph g) {</span>
<span class="fc" id="L667">			this.graph = Objects.requireNonNull(g);</span>
<span class="fc" id="L668">		}</span>

		@Override
		public IntSet vertices() {
<span class="fc" id="L672">			return graph.vertices();</span>
		}

		@Override
		public IntSet edges() {
<span class="fc" id="L677">			return graph.edges();</span>
		}

		@Override
		public int addVertex() {
<span class="fc" id="L682">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add vertices&quot;);</span>
		}

		@Override
		public void addVertex(int vertex) {
<span class="fc" id="L687">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add vertices&quot;);</span>
		}

		@Override
		public void removeVertex(int vertex) {
<span class="fc" id="L692">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove vertices&quot;);</span>
		}

		@Override
		public EdgeSet outEdges(int source) {
<span class="fc" id="L697">			return new ImmutableEdgeSet(graph.outEdges(source));</span>
		}

		@Override
		public EdgeSet inEdges(int target) {
<span class="fc" id="L702">			return new ImmutableEdgeSet(graph.inEdges(target));</span>
		}

		@Override
		public EdgeSet getEdges(int source, int target) {
<span class="fc" id="L707">			return new ImmutableEdgeSet(graph.getEdges(source, target));</span>
		}

		@Override
		public int addEdge(int source, int target) {
<span class="fc" id="L712">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add edges&quot;);</span>
		}

		@Override
		public void addEdge(int source, int target, int edge) {
<span class="fc" id="L717">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add edges&quot;);</span>
		}

		@Override
		public void removeEdge(int edge) {
<span class="fc" id="L722">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove edges&quot;);</span>
		}

		@Override
		public void reverseEdge(int edge) {
<span class="fc" id="L727">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove edges&quot;);</span>
		}

		@Override
		public int edgeSource(int edge) {
<span class="fc" id="L732">			return graph.edgeSource(edge);</span>
		}

		@Override
		public int edgeTarget(int edge) {
<span class="fc" id="L737">			return graph.edgeTarget(edge);</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L742">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove vertices and edges&quot;);</span>
		}

		@Override
		public void clearEdges() {
<span class="fc" id="L747">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove edges&quot;);</span>
		}

		@SuppressWarnings(&quot;unchecked&quot;)
		@Override
		public &lt;V, WeightsT extends Weights&lt;V&gt;&gt; WeightsT getVerticesWeights(Object key) {
<span class="fc" id="L753">			return (WeightsT) WeightsImpl.ImmutableView.newInstance(graph.getVerticesWeights(key));</span>
		}

		@Override
		public &lt;V, WeightsT extends Weights&lt;V&gt;&gt; WeightsT addVerticesWeights(Object key, Class&lt;? super V&gt; type,
				V defVal) {
<span class="fc" id="L759">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add vertices weights&quot;);</span>
		}

		@Override
		public void removeVerticesWeights(Object key) {
<span class="fc" id="L764">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove vertices weights&quot;);</span>
		}

		@Override
		public Set&lt;Object&gt; getVerticesWeightsKeys() {
<span class="fc" id="L769">			return graph.getVerticesWeightsKeys();</span>
		}

		@SuppressWarnings(&quot;unchecked&quot;)
		@Override
		public &lt;E, WeightsT extends Weights&lt;E&gt;&gt; WeightsT getEdgesWeights(Object key) {
<span class="fc" id="L775">			return (WeightsT) WeightsImpl.ImmutableView.newInstance(graph.getEdgesWeights(key));</span>
		}

		@Override
		public &lt;E, WeightsT extends Weights&lt;E&gt;&gt; WeightsT addEdgesWeights(Object key, Class&lt;? super E&gt; type, E defVal) {
<span class="fc" id="L780">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add edges weights&quot;);</span>
		}

		@Override
		public void removeEdgesWeights(Object key) {
<span class="fc" id="L785">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove edges weights&quot;);</span>
		}

		@Override
		public Set&lt;Object&gt; getEdgesWeightsKeys() {
<span class="fc" id="L790">			return graph.getEdgesWeightsKeys();</span>
		}

		@Override
		public GraphCapabilities getCapabilities() {
<span class="fc" id="L795">			return graph.getCapabilities();</span>
		}

		@Override
		public Graph copy() {
<span class="nc" id="L800">			return graph.copy();</span>
		}

		@Override
		public IndexGraph indexGraph() {
<span class="pc bpc" id="L805" title="1 of 2 branches missed.">			return this instanceof IndexGraph ? (IndexGraph) this : Graphs.immutableView(graph.indexGraph());</span>
		}

		@Override
		public IndexIdMap indexGraphVerticesMap() {
<span class="nc" id="L810">			return graph.indexGraphVerticesMap();</span>
		}

		@Override
		public IndexIdMap indexGraphEdgesMap() {
<span class="nc" id="L815">			return graph.indexGraphEdgesMap();</span>
		}

		Graph graph() {
<span class="fc" id="L819">			return graph;</span>
		}
	}

	private static class ImmutableIndexGraphView extends ImmutableGraphView implements IndexGraphImpl {

		ImmutableIndexGraphView(IndexGraph g) {
<span class="fc" id="L826">			super(g);</span>
<span class="pc bpc" id="L827" title="1 of 2 branches missed.">			if (!(g instanceof IndexGraphImpl))</span>
<span class="nc" id="L828">				throw new IllegalArgumentException(&quot;unknown graph implementation&quot;);</span>
<span class="fc" id="L829">		}</span>

		@Override
		IndexGraphImpl graph() {
<span class="fc" id="L833">			return (IndexGraphImpl) super.graph();</span>
		}

		@Override
		public IndexGraph copy() {
<span class="nc" id="L838">			return graph().copy();</span>
		}

		@Override
		public GraphElementSet vertices() {
<span class="fc" id="L843">			return graph().vertices();</span>
		}

		@Override
		public GraphElementSet edges() {
<span class="fc" id="L848">			return graph().edges();</span>
		}

		@Override
		@Deprecated
		public void addVertex(int vertex) {
<span class="nc" id="L854">			IndexGraphImpl.super.addVertex(vertex);</span>
<span class="nc" id="L855">		}</span>

		@Override
		@Deprecated
		public void addEdge(int source, int target, int edge) {
<span class="nc" id="L860">			IndexGraphImpl.super.addEdge(source, target, edge);</span>
<span class="nc" id="L861">		}</span>

	}

	private static class ImmutableEdgeSet extends AbstractIntSet implements EdgeSet {

		private final EdgeSet set;

<span class="fc" id="L869">		ImmutableEdgeSet(EdgeSet set) {</span>
<span class="fc" id="L870">			this.set = Objects.requireNonNull(set);</span>
<span class="fc" id="L871">		}</span>

		@Override
		public boolean contains(int edge) {
<span class="fc" id="L875">			return set.contains(edge);</span>
		}

		@Override
		public int size() {
<span class="fc" id="L880">			return set.size();</span>
		}

		@Override
		public EdgeIter iterator() {
<span class="fc" id="L885">			return new ImmutableEdgeIter(set.iterator());</span>
		}

	}

	private static class ImmutableEdgeIter implements EdgeIter {
		private final EdgeIter it;

<span class="fc" id="L893">		ImmutableEdgeIter(EdgeIter it) {</span>
<span class="fc" id="L894">			this.it = Objects.requireNonNull(it);</span>
<span class="fc" id="L895">		}</span>

		@Override
		public int source() {
<span class="fc" id="L899">			return it.source();</span>
		}

		@Override
		public int target() {
<span class="fc" id="L904">			return it.target();</span>
		}

		@Override
		public int nextInt() {
<span class="fc" id="L909">			return it.nextInt();</span>
		}

		@Override
		public boolean hasNext() {
<span class="fc" id="L914">			return it.hasNext();</span>
		}

		@Override
		public int peekNext() {
<span class="fc" id="L919">			return it.peekNext();</span>
		}
	}

	static Graph immutableView(Graph g) {
<span class="pc bpc" id="L924" title="1 of 2 branches missed.">		if (g instanceof IndexGraph)</span>
<span class="nc" id="L925">			return immutableView((IndexGraph) g);</span>
<span class="fc bfc" id="L926" title="All 2 branches covered.">		if (g instanceof GraphImpl)</span>
<span class="pc bpc" id="L927" title="1 of 2 branches missed.">			if (((GraphImpl) g).indexGraph instanceof ImmutableGraph)</span>
<span class="nc" id="L928">				return g;</span>
<span class="fc bfc" id="L929" title="All 2 branches covered.">		return g instanceof ImmutableGraph ? g : new ImmutableGraphView(g);</span>
	}

	static IndexGraph immutableView(IndexGraph g) {
<span class="fc bfc" id="L933" title="All 2 branches covered.">		return g instanceof ImmutableGraph ? g : new ImmutableIndexGraphView(g);</span>
	}

	private static class ReverseGraph extends GraphBase {

		private final Graph graph;

<span class="fc" id="L940">		ReverseGraph(Graph g) {</span>
<span class="fc" id="L941">			this.graph = Objects.requireNonNull(g);</span>
<span class="fc" id="L942">		}</span>

		Graph graph() {
<span class="fc" id="L945">			return graph;</span>
		}

		@Override
		public IntSet vertices() {
<span class="fc" id="L950">			return graph.vertices();</span>
		}

		@Override
		public IntSet edges() {
<span class="fc" id="L955">			return graph.edges();</span>
		}

		@Override
		public int addVertex() {
<span class="fc" id="L960">			return graph.addVertex();</span>
		}

		@Override
		public void addVertex(int vertex) {
<span class="fc" id="L965">			graph.addVertex(vertex);</span>
<span class="fc" id="L966">		}</span>

		@Override
		public void removeVertex(int vertex) {
<span class="fc" id="L970">			graph.removeVertex(vertex);</span>
<span class="fc" id="L971">		}</span>

		@Override
		public EdgeSet outEdges(int source) {
<span class="fc" id="L975">			return new ReversedEdgeSet(graph.inEdges(source));</span>
		}

		@Override
		public EdgeSet inEdges(int target) {
<span class="fc" id="L980">			return new ReversedEdgeSet(graph.outEdges(target));</span>
		}

		@Override
		public EdgeSet getEdges(int source, int target) {
<span class="fc" id="L985">			return new ReversedEdgeSet(graph.getEdges(target, source));</span>
		}

		@Override
		public int addEdge(int source, int target) {
<span class="fc" id="L990">			return graph.addEdge(target, source);</span>
		}

		@Override
		public void addEdge(int source, int target, int edge) {
<span class="fc" id="L995">			graph.addEdge(source, target, edge);</span>
<span class="fc" id="L996">		}</span>

		@Override
		public void removeEdge(int edge) {
<span class="fc" id="L1000">			graph.removeEdge(edge);</span>
<span class="fc" id="L1001">		}</span>

		@Override
		public int edgeSource(int edge) {
<span class="fc" id="L1005">			return graph.edgeTarget(edge);</span>
		}

		@Override
		public int edgeTarget(int edge) {
<span class="fc" id="L1010">			return graph.edgeSource(edge);</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L1015">			graph.clear();</span>
<span class="fc" id="L1016">		}</span>

		@Override
		public void clearEdges() {
<span class="fc" id="L1020">			graph.clearEdges();</span>
<span class="fc" id="L1021">		}</span>

		@Override
		public &lt;V, WeightsT extends Weights&lt;V&gt;&gt; WeightsT getVerticesWeights(Object key) {
<span class="fc" id="L1025">			return graph.getVerticesWeights(key);</span>
		}

		@Override
		public Set&lt;Object&gt; getVerticesWeightsKeys() {
<span class="fc" id="L1030">			return graph.getVerticesWeightsKeys();</span>
		}

		@Override
		public void removeVerticesWeights(Object key) {
<span class="fc" id="L1035">			graph.removeVerticesWeights(key);</span>
<span class="fc" id="L1036">		}</span>

		@Override
		public &lt;E, WeightsT extends Weights&lt;E&gt;&gt; WeightsT getEdgesWeights(Object key) {
<span class="fc" id="L1040">			return graph.getEdgesWeights(key);</span>
		}

		@Override
		public Set&lt;Object&gt; getEdgesWeightsKeys() {
<span class="fc" id="L1045">			return graph.getEdgesWeightsKeys();</span>
		}

		@Override
		public void removeEdgesWeights(Object key) {
<span class="fc" id="L1050">			graph.removeEdgesWeights(key);</span>
<span class="fc" id="L1051">		}</span>

		@Override
		public GraphCapabilities getCapabilities() {
<span class="fc" id="L1055">			return graph.getCapabilities();</span>
		}

		@Override
		public void reverseEdge(int edge) {
<span class="fc" id="L1060">			graph.reverseEdge(edge);</span>
<span class="fc" id="L1061">		}</span>

		@Override
		public &lt;V, WeightsT extends Weights&lt;V&gt;&gt; WeightsT addVerticesWeights(Object key, Class&lt;? super V&gt; type,
				V defVal) {
<span class="fc" id="L1066">			return graph.addVerticesWeights(key, type, defVal);</span>
		}

		@Override
		public &lt;E, WeightsT extends Weights&lt;E&gt;&gt; WeightsT addEdgesWeights(Object key, Class&lt;? super E&gt; type, E defVal) {
<span class="fc" id="L1071">			return graph.addEdgesWeights(key, type, defVal);</span>
		}

		@Override
		public IndexGraph indexGraph() {
<span class="pc bpc" id="L1076" title="1 of 2 branches missed.">			return this instanceof IndexGraph ? (IndexGraph) this : Graphs.reverseView(graph.indexGraph());</span>
		}

		@Override
		public IndexIdMap indexGraphVerticesMap() {
<span class="fc" id="L1081">			return graph.indexGraphVerticesMap();</span>
		}

		@Override
		public IndexIdMap indexGraphEdgesMap() {
<span class="fc" id="L1086">			return graph.indexGraphEdgesMap();</span>
		}

	}

	private static class ReverseIndexGraph extends ReverseGraph implements IndexGraphImpl {

		ReverseIndexGraph(IndexGraph g) {
<span class="fc" id="L1094">			super(g);</span>
<span class="pc bpc" id="L1095" title="1 of 2 branches missed.">			if (!(g instanceof IndexGraphImpl))</span>
<span class="nc" id="L1096">				throw new IllegalArgumentException(&quot;unknown graph implementation&quot;);</span>
<span class="fc" id="L1097">		}</span>

		@Override
		IndexGraphImpl graph() {
<span class="fc" id="L1101">			return (IndexGraphImpl) super.graph();</span>
		}

		@Override
		public GraphElementSet vertices() {
<span class="fc" id="L1106">			return graph().vertices();</span>
		}

		@Override
		public GraphElementSet edges() {
<span class="fc" id="L1111">			return graph().edges();</span>
		}

		@Override
		@Deprecated
		public void addVertex(int vertex) {
<span class="nc" id="L1117">			IndexGraphImpl.super.addVertex(vertex);</span>
<span class="nc" id="L1118">		}</span>

		@Override
		@Deprecated
		public void addEdge(int source, int target, int edge) {
<span class="nc" id="L1123">			IndexGraphImpl.super.addEdge(source, target, edge);</span>
<span class="nc" id="L1124">		}</span>

	}

	private static class ReversedEdgeSet extends AbstractIntSet implements EdgeSet {

		private final EdgeSet set;

<span class="fc" id="L1132">		ReversedEdgeSet(EdgeSet set) {</span>
<span class="fc" id="L1133">			this.set = Objects.requireNonNull(set);</span>
<span class="fc" id="L1134">		}</span>

		@Override
		public boolean contains(int edge) {
<span class="fc" id="L1138">			return set.contains(edge);</span>
		}

		@Override
		public int size() {
<span class="fc" id="L1143">			return set.size();</span>
		}

		@Override
		public boolean remove(int edge) {
<span class="nc" id="L1148">			return set.remove(edge);</span>
		}

		@Override
		public void clear() {
<span class="nc" id="L1153">			set.clear();</span>
<span class="nc" id="L1154">		}</span>

		@Override
		public EdgeIter iterator() {
<span class="fc" id="L1158">			return new ReversedEdgeIter(set.iterator());</span>
		}

	}

	private static class ReversedEdgeIter implements EdgeIter {
		final EdgeIter it;

<span class="fc" id="L1166">		ReversedEdgeIter(EdgeIter it) {</span>
<span class="fc" id="L1167">			this.it = it;</span>
<span class="fc" id="L1168">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc" id="L1172">			return it.hasNext();</span>
		}

		@Override
		public int nextInt() {
<span class="fc" id="L1177">			return it.nextInt();</span>
		}

		@Override
		public int peekNext() {
<span class="fc" id="L1182">			return it.peekNext();</span>
		}

		@Override
		public int source() {
<span class="fc" id="L1187">			return it.target();</span>
		}

		@Override
		public int target() {
<span class="fc" id="L1192">			return it.source();</span>
		}

		@Override
		public void remove() {
<span class="fc" id="L1197">			it.remove();</span>
<span class="fc" id="L1198">		}</span>
	}

	static Graph reverseView(Graph g) {
<span class="pc bpc" id="L1202" title="1 of 2 branches missed.">		if (g instanceof IndexGraph)</span>
<span class="nc" id="L1203">			return reverseView((IndexGraph) g);</span>
<span class="pc bpc" id="L1204" title="1 of 2 branches missed.">		return g instanceof ReverseGraph ? ((ReverseGraph) g).graph : new ReverseGraph(g);</span>
	}

	static IndexGraph reverseView(IndexGraph g) {
<span class="pc bpc" id="L1208" title="1 of 2 branches missed.">		return g instanceof ReverseGraph ? ((ReverseGraph) g).graph.indexGraph() : new ReverseIndexGraph(g);</span>
	}

	static String getIndexGraphImpl(IndexGraph g) {
		for (;;) {
<span class="fc" id="L1213">			IndexGraph g0 = g;</span>
<span class="pc bpc" id="L1214" title="1 of 2 branches missed.">			if (g instanceof ReverseIndexGraph)</span>
<span class="nc" id="L1215">				g = ((ReverseIndexGraph) g).graph();</span>
<span class="pc bpc" id="L1216" title="1 of 2 branches missed.">			if (g instanceof ImmutableIndexGraphView)</span>
<span class="nc" id="L1217">				g = ((ImmutableIndexGraphView) g).graph();</span>
<span class="fc bfc" id="L1218" title="All 2 branches covered.">			if (g instanceof GraphArrayAbstract)</span>
<span class="fc" id="L1219">				return &quot;array&quot;;</span>
<span class="fc bfc" id="L1220" title="All 2 branches covered.">			if (g instanceof GraphLinkedAbstract)</span>
<span class="fc" id="L1221">				return &quot;linked-list&quot;;</span>
<span class="fc bfc" id="L1222" title="All 2 branches covered.">			if (g instanceof GraphHashmapAbstract)</span>
<span class="fc" id="L1223">				return &quot;hashtable&quot;;</span>
<span class="fc bfc" id="L1224" title="All 2 branches covered.">			if (g instanceof GraphMatrixAbstract)</span>
<span class="fc" id="L1225">				return &quot;matrix&quot;;</span>
<span class="pc bpc" id="L1226" title="1 of 2 branches missed.">			if (g == g0)</span>
<span class="fc" id="L1227">				return null;</span>
<span class="nc" id="L1228">		}</span>
	}

	static class GraphCapabilitiesBuilder {

		private boolean parallelEdges;
		private boolean parallelEdgesValid;
		private boolean selfEdges;
		private boolean selfEdgesValid;
		private boolean directed;
		private boolean directedValid;

<span class="fc" id="L1240">		private GraphCapabilitiesBuilder(boolean directed) {</span>
<span class="fc" id="L1241">			this.directed = directed;</span>
<span class="fc" id="L1242">			directedValid = true;</span>
<span class="fc" id="L1243">		}</span>

		static GraphCapabilitiesBuilder newUndirected() {
<span class="fc" id="L1246">			return new GraphCapabilitiesBuilder(false);</span>
		}

		static GraphCapabilitiesBuilder newDirected() {
<span class="fc" id="L1250">			return new GraphCapabilitiesBuilder(true);</span>
		}

		GraphCapabilities build() {
<span class="pc bpc" id="L1254" title="3 of 6 branches missed.">			if (!parallelEdgesValid || !selfEdgesValid || !directedValid)</span>
<span class="nc" id="L1255">				throw new IllegalStateException();</span>
<span class="fc" id="L1256">			return new GraphCapabilitiesImpl(parallelEdges, selfEdges, directed);</span>
		}

		GraphCapabilitiesBuilder parallelEdges(boolean enable) {
<span class="fc" id="L1260">			parallelEdges = enable;</span>
<span class="fc" id="L1261">			parallelEdgesValid = true;</span>
<span class="fc" id="L1262">			return this;</span>
		}

		GraphCapabilitiesBuilder selfEdges(boolean enable) {
<span class="fc" id="L1266">			selfEdges = enable;</span>
<span class="fc" id="L1267">			selfEdgesValid = true;</span>
<span class="fc" id="L1268">			return this;</span>
		}

		GraphCapabilitiesBuilder directed(boolean enable) {
<span class="nc" id="L1272">			directed = enable;</span>
<span class="nc" id="L1273">			directedValid = true;</span>
<span class="nc" id="L1274">			return this;</span>
		}

	}

	private static class GraphCapabilitiesImpl implements GraphCapabilities {

		private final boolean parallelEdges;
		private final boolean selfEdges;
		private final boolean directed;

<span class="fc" id="L1285">		GraphCapabilitiesImpl(boolean parallelEdges, boolean selfEdges, boolean directed) {</span>
<span class="fc" id="L1286">			this.parallelEdges = parallelEdges;</span>
<span class="fc" id="L1287">			this.selfEdges = selfEdges;</span>
<span class="fc" id="L1288">			this.directed = directed;</span>
<span class="fc" id="L1289">		}</span>

		@Override
		public boolean parallelEdges() {
<span class="fc" id="L1293">			return parallelEdges;</span>
		}

		@Override
		public boolean selfEdges() {
<span class="fc" id="L1298">			return selfEdges;</span>
		}

		@Override
		public boolean directed() {
<span class="fc" id="L1303">			return directed;</span>
		}

		@Override
		public String toString() {
<span class="nc" id="L1308">			StringBuilder s = new StringBuilder().append('&lt;');</span>
<span class="nc bnc" id="L1309" title="All 2 branches missed.">			s.append(&quot; parallelEdges=&quot;).append(parallelEdges ? 'v' : 'x');</span>
<span class="nc bnc" id="L1310" title="All 2 branches missed.">			s.append(&quot; selfEdges=&quot;).append(selfEdges ? 'v' : 'x');</span>
<span class="nc bnc" id="L1311" title="All 2 branches missed.">			s.append(&quot; directed=&quot;).append(directed ? 'v' : 'x');</span>
<span class="nc" id="L1312">			return s.append('&gt;').toString();</span>
		}

		@Override
		public boolean equals(Object other) {
<span class="nc bnc" id="L1317" title="All 2 branches missed.">			if (other == this)</span>
<span class="nc" id="L1318">				return true;</span>
<span class="nc bnc" id="L1319" title="All 2 branches missed.">			if (!(other instanceof GraphCapabilities))</span>
<span class="nc" id="L1320">				return false;</span>
<span class="nc" id="L1321">			GraphCapabilities o = (GraphCapabilities) other;</span>
<span class="nc bnc" id="L1322" title="All 6 branches missed.">			return parallelEdges == o.parallelEdges() &amp;&amp; selfEdges == o.selfEdges() &amp;&amp; directed == o.directed();</span>
		}

		@Override
		public int hashCode() {
<span class="nc" id="L1327">			int h = 0;</span>
			/* we must use addition as the order shouldn't matter */
<span class="nc bnc" id="L1329" title="All 2 branches missed.">			h += parallelEdges ? 1 : 0;</span>
<span class="nc bnc" id="L1330" title="All 2 branches missed.">			h += selfEdges ? 1 : 0;</span>
<span class="nc bnc" id="L1331" title="All 2 branches missed.">			h += directed ? 1 : 0;</span>
<span class="nc" id="L1332">			return h;</span>
		}
	}

<span class="fc" id="L1336">	static final IndexIdMap IndexIdMapIdentify = new IndexGraphMapIdentify();</span>

	private static class IndexGraphMapIdentify implements IndexIdMap {
		@Override
		public int indexToId(int index) {
<span class="fc" id="L1341">			return index;</span>
		}

		@Override
		public int idToIndex(int id) {
<span class="fc" id="L1346">			return id;</span>
		}
	}

	static class EdgeSetSourceTargetSingleton extends AbstractIntSet implements EdgeSet {

		private final Graph g;
		private final int source, target;
		private int edge;
		private static final int EdgeNone = -1;

<span class="fc" id="L1357">		EdgeSetSourceTargetSingleton(Graph g, int source, int target, int edge) {</span>
<span class="fc" id="L1358">			this.g = g;</span>
<span class="fc" id="L1359">			this.source = source;</span>
<span class="fc" id="L1360">			this.target = target;</span>
<span class="fc" id="L1361">			this.edge = edge;</span>
<span class="fc" id="L1362">		}</span>

		@Override
		public boolean remove(int edge) {
<span class="pc bpc" id="L1366" title="1 of 2 branches missed.">			if (this.edge != edge)</span>
<span class="nc" id="L1367">				return false;</span>
<span class="fc" id="L1368">			g.removeEdge(edge);</span>
<span class="fc" id="L1369">			this.edge = EdgeNone;</span>
<span class="fc" id="L1370">			return true;</span>
		}

		@Override
		public boolean contains(int edge) {
<span class="pc bpc" id="L1375" title="2 of 4 branches missed.">			return this.edge != EdgeNone &amp;&amp; this.edge == edge;</span>
		}

		@Override
		public int size() {
<span class="pc bpc" id="L1380" title="1 of 2 branches missed.">			return edge != EdgeNone ? 1 : 0;</span>
		}

		@Override
		public void clear() {
<span class="nc bnc" id="L1385" title="All 2 branches missed.">			if (edge != EdgeNone) {</span>
<span class="nc" id="L1386">				g.removeEdge(edge);</span>
<span class="nc" id="L1387">				edge = EdgeNone;</span>
			}
<span class="nc" id="L1389">		}</span>

		@Override
		public EdgeIter iterator() {
<span class="pc bpc" id="L1393" title="1 of 2 branches missed.">			if (edge == EdgeNone)</span>
<span class="nc" id="L1394">				return EdgeIter.emptyIterator();</span>
<span class="fc" id="L1395">			return new EdgeIter() {</span>

<span class="fc" id="L1397">				boolean beforeNext = true;</span>

				@Override
				public boolean hasNext() {
<span class="fc" id="L1401">					return beforeNext;</span>
				}

				@Override
				public int nextInt() {
<span class="fc" id="L1406">					Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L1407">					beforeNext = false;</span>
<span class="fc" id="L1408">					return edge;</span>
				}

				@Override
				public int peekNext() {
<span class="fc" id="L1413">					Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L1414">					return edge;</span>
				}

				@Override
				public int source() {
<span class="fc" id="L1419">					return source;</span>
				}

				@Override
				public int target() {
<span class="fc" id="L1424">					return target;</span>
				}

				@Override
				public void remove() {
<span class="nc bnc" id="L1429" title="All 2 branches missed.">					if (beforeNext)</span>
<span class="nc" id="L1430">						throw new IllegalStateException();</span>
<span class="nc" id="L1431">					g.removeEdge(edge);</span>
<span class="nc" id="L1432">					edge = EdgeNone;</span>
<span class="nc" id="L1433">				}</span>
			};
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>