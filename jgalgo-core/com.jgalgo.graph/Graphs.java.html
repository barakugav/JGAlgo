<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Graphs.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.graph</a> &gt; <span class="el_source">Graphs.java</span></div><h1>Graphs.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.graph;

import java.util.AbstractSet;
import java.util.Collection;
import java.util.Objects;
import java.util.Random;
import java.util.Set;
import com.jgalgo.internal.util.Assertions;
import com.jgalgo.internal.util.IntAdapters;
import it.unimi.dsi.fastutil.ints.AbstractIntSet;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
import it.unimi.dsi.fastutil.ints.IntSet;
import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;

/**
 * Static methods class for graphs.
 *
 * @author Barak Ugav
 */
public class Graphs {
	private Graphs() {}

	/**
	 * Tag interface for graphs that can not be muted/changed/altered.
	 *
	 * @author Barak Ugav
	 */
	static interface ImmutableGraph {
	}

	private static class ImmutableGraphView&lt;V, E&gt; extends GraphBase&lt;V, E&gt; implements ImmutableGraph {

		private final Graph&lt;V, E&gt; graph;

<span class="fc" id="L51">		ImmutableGraphView(Graph&lt;V, E&gt; g) {</span>
<span class="fc" id="L52">			this.graph = Objects.requireNonNull(g);</span>
<span class="fc" id="L53">		}</span>

		@Override
		public Set&lt;V&gt; vertices() {
<span class="fc" id="L57">			return graph.vertices();</span>
		}

		@Override
		public Set&lt;E&gt; edges() {
<span class="fc" id="L62">			return graph.edges();</span>
		}

		@Override
		public void addVertex(V vertex) {
<span class="fc" id="L67">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add vertices&quot;);</span>
		}

		@Override
		public void removeVertex(V vertex) {
<span class="fc" id="L72">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove vertices&quot;);</span>
		}

		@Override
		public EdgeSet&lt;V, E&gt; outEdges(V source) {
<span class="fc" id="L77">			return new ImmutableEdgeSet&lt;&gt;(graph.outEdges(source));</span>
		}

		@Override
		public EdgeSet&lt;V, E&gt; inEdges(V target) {
<span class="fc" id="L82">			return new ImmutableEdgeSet&lt;&gt;(graph.inEdges(target));</span>
		}

		@Override
		public EdgeSet&lt;V, E&gt; getEdges(V source, V target) {
<span class="fc" id="L87">			return new ImmutableEdgeSet&lt;&gt;(graph.getEdges(source, target));</span>
		}

		@Override
		public void addEdge(V source, V target, E edge) {
<span class="fc" id="L92">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add edges&quot;);</span>
		}

		@Override
		public void removeEdge(E edge) {
<span class="fc" id="L97">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove edges&quot;);</span>
		}

		@Override
		public void reverseEdge(E edge) {
<span class="fc" id="L102">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot reverse edges&quot;);</span>
		}

		@Override
		public V edgeSource(E edge) {
<span class="fc" id="L107">			return graph.edgeSource(edge);</span>
		}

		@Override
		public V edgeTarget(E edge) {
<span class="fc" id="L112">			return graph.edgeTarget(edge);</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L117">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove vertices and edges&quot;);</span>
		}

		@Override
		public void clearEdges() {
<span class="fc" id="L122">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove edges&quot;);</span>
		}

		@SuppressWarnings(&quot;unchecked&quot;)
		@Override
		public &lt;T, WeightsT extends Weights&lt;V, T&gt;&gt; WeightsT getVerticesWeights(String key) {
<span class="fc" id="L128">			return (WeightsT) WeightsImpl.ObjImmutableView.newInstance(graph.getVerticesWeights(key));</span>
		}

		@Override
		public &lt;T, WeightsT extends Weights&lt;V, T&gt;&gt; WeightsT addVerticesWeights(String key, Class&lt;? super T&gt; type,
				T defVal) {
<span class="fc" id="L134">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add vertices weights&quot;);</span>
		}

		@Override
		public void removeVerticesWeights(String key) {
<span class="fc" id="L139">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove vertices weights&quot;);</span>
		}

		@Override
		public Set&lt;String&gt; getVerticesWeightsKeys() {
<span class="fc" id="L144">			return graph.getVerticesWeightsKeys();</span>
		}

		@SuppressWarnings(&quot;unchecked&quot;)
		@Override
		public &lt;T, WeightsT extends Weights&lt;E, T&gt;&gt; WeightsT getEdgesWeights(String key) {
<span class="fc" id="L150">			return (WeightsT) WeightsImpl.ObjImmutableView.newInstance(graph.getEdgesWeights(key));</span>
		}

		@Override
		public &lt;T, WeightsT extends Weights&lt;E, T&gt;&gt; WeightsT addEdgesWeights(String key, Class&lt;? super T&gt; type,
				T defVal) {
<span class="fc" id="L156">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add edges weights&quot;);</span>
		}

		@Override
		public void removeEdgesWeights(String key) {
<span class="fc" id="L161">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove edges weights&quot;);</span>
		}

		@Override
		public Set&lt;String&gt; getEdgesWeightsKeys() {
<span class="fc" id="L166">			return graph.getEdgesWeightsKeys();</span>
		}

		@Override
		public boolean isDirected() {
<span class="fc" id="L171">			return graph.isDirected();</span>
		}

		@Override
		public boolean isAllowSelfEdges() {
<span class="fc" id="L176">			return graph.isAllowSelfEdges();</span>
		}

		@Override
		public boolean isAllowParallelEdges() {
<span class="fc" id="L181">			return graph.isAllowParallelEdges();</span>
		}

		@Override
		public IndexGraph indexGraph() {
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">			return this instanceof IndexGraph ? (IndexGraph) this : Graphs.immutableView(graph.indexGraph());</span>
		}

		@Override
		public IndexIdMap&lt;V&gt; indexGraphVerticesMap() {
<span class="nc" id="L191">			return graph.indexGraphVerticesMap();</span>
		}

		@Override
		public IndexIdMap&lt;E&gt; indexGraphEdgesMap() {
<span class="nc" id="L196">			return graph.indexGraphEdgesMap();</span>
		}

	}

	private abstract static class ImmutableIntGraphViewBase extends IntGraphBase implements ImmutableGraph {

		private final IntGraph graph;

<span class="fc" id="L205">		ImmutableIntGraphViewBase(IntGraph g) {</span>
<span class="fc" id="L206">			this.graph = Objects.requireNonNull(g);</span>
<span class="fc" id="L207">		}</span>

		@Override
		public IntSet vertices() {
<span class="fc" id="L211">			return graph.vertices();</span>
		}

		@Override
		public IntSet edges() {
<span class="fc" id="L216">			return graph.edges();</span>
		}

		@Override
		public int addVertex() {
<span class="fc" id="L221">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add vertices&quot;);</span>
		}

		@Override
		public void addVertex(int vertex) {
<span class="fc" id="L226">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add vertices&quot;);</span>
		}

		@Override
		public void removeVertex(int vertex) {
<span class="fc" id="L231">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove vertices&quot;);</span>
		}

		@Override
		public IEdgeSet outEdges(int source) {
<span class="fc" id="L236">			return new ImmutableIEdgeSet(graph.outEdges(source));</span>
		}

		@Override
		public IEdgeSet inEdges(int target) {
<span class="fc" id="L241">			return new ImmutableIEdgeSet(graph.inEdges(target));</span>
		}

		@Override
		public IEdgeSet getEdges(int source, int target) {
<span class="fc" id="L246">			return new ImmutableIEdgeSet(graph.getEdges(source, target));</span>
		}

		@Override
		public int addEdge(int source, int target) {
<span class="fc" id="L251">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add edges&quot;);</span>
		}

		@Override
		public void addEdge(int source, int target, int edge) {
<span class="fc" id="L256">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add edges&quot;);</span>
		}

		@Override
		public void removeEdge(int edge) {
<span class="fc" id="L261">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove edges&quot;);</span>
		}

		@Override
		public void reverseEdge(int edge) {
<span class="fc" id="L266">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot reverse edges&quot;);</span>
		}

		@Override
		public int edgeSource(int edge) {
<span class="fc" id="L271">			return graph.edgeSource(edge);</span>
		}

		@Override
		public int edgeTarget(int edge) {
<span class="fc" id="L276">			return graph.edgeTarget(edge);</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L281">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove vertices and edges&quot;);</span>
		}

		@Override
		public void clearEdges() {
<span class="fc" id="L286">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove edges&quot;);</span>
		}

		@SuppressWarnings(&quot;unchecked&quot;)
		@Override
		public &lt;T, WeightsT extends IWeights&lt;T&gt;&gt; WeightsT getVerticesIWeights(String key) {
<span class="fc" id="L292">			return (WeightsT) WeightsImpl.IntImmutableView.newInstance(graph.getVerticesIWeights(key));</span>
		}

		@Override
		public &lt;T, WeightsT extends Weights&lt;Integer, T&gt;&gt; WeightsT addVerticesWeights(String key, Class&lt;? super T&gt; type,
				T defVal) {
<span class="fc" id="L298">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add vertices weights&quot;);</span>
		}

		@Override
		public void removeVerticesWeights(String key) {
<span class="fc" id="L303">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove vertices weights&quot;);</span>
		}

		@Override
		public Set&lt;String&gt; getVerticesWeightsKeys() {
<span class="fc" id="L308">			return graph.getVerticesWeightsKeys();</span>
		}

		@SuppressWarnings(&quot;unchecked&quot;)
		@Override
		public &lt;T, WeightsT extends IWeights&lt;T&gt;&gt; WeightsT getEdgesIWeights(String key) {
<span class="fc" id="L314">			return (WeightsT) WeightsImpl.IntImmutableView.newInstance(graph.getEdgesIWeights(key));</span>
		}

		@Override
		public &lt;T, WeightsT extends Weights&lt;Integer, T&gt;&gt; WeightsT addEdgesWeights(String key, Class&lt;? super T&gt; type,
				T defVal) {
<span class="fc" id="L320">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add edges weights&quot;);</span>
		}

		@Override
		public void removeEdgesWeights(String key) {
<span class="fc" id="L325">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove edges weights&quot;);</span>
		}

		@Override
		public Set&lt;String&gt; getEdgesWeightsKeys() {
<span class="fc" id="L330">			return graph.getEdgesWeightsKeys();</span>
		}

		@Override
		public boolean isDirected() {
<span class="fc" id="L335">			return graph.isDirected();</span>
		}

		@Override
		public boolean isAllowSelfEdges() {
<span class="fc" id="L340">			return graph.isAllowSelfEdges();</span>
		}

		@Override
		public boolean isAllowParallelEdges() {
<span class="fc" id="L345">			return graph.isAllowParallelEdges();</span>
		}

		@Override
		public IntGraph copy() {
<span class="nc" id="L350">			return graph.copy();</span>
		}

		IntGraph graph() {
<span class="fc" id="L354">			return graph;</span>
		}
	}

	private static class ImmutableIntGraphView extends ImmutableIntGraphViewBase {

		ImmutableIntGraphView(IntGraph g) {
<span class="fc" id="L361">			super(g);</span>
<span class="fc" id="L362">		}</span>

		@Override
		public IndexGraph indexGraph() {
<span class="fc" id="L366">			return Graphs.immutableView(graph().indexGraph());</span>
		}

		@Override
		public IndexIntIdMap indexGraphVerticesMap() {
<span class="nc" id="L371">			return graph().indexGraphVerticesMap();</span>
		}

		@Override
		public IndexIntIdMap indexGraphEdgesMap() {
<span class="nc" id="L376">			return graph().indexGraphEdgesMap();</span>
		}
	}

	private static class ImmutableIndexGraphView extends ImmutableIntGraphViewBase implements IndexGraph {

		ImmutableIndexGraphView(IndexGraph g) {
<span class="fc" id="L383">			super(g);</span>
<span class="fc" id="L384">		}</span>

		@Override
		IndexGraph graph() {
<span class="nc" id="L388">			return (IndexGraph) super.graph();</span>
		}

		@Override
		public IndexGraph copy() {
<span class="nc" id="L393">			return graph().copy();</span>
		}

		@Override
		@Deprecated
		public void addVertex(int vertex) {
<span class="nc" id="L399">			IndexGraph.super.addVertex(vertex);</span>
<span class="nc" id="L400">		}</span>

		@Override
		@Deprecated
		public void addEdge(int source, int target, int edge) {
<span class="nc" id="L405">			IndexGraph.super.addEdge(source, target, edge);</span>
<span class="nc" id="L406">		}</span>

		@Override
		public void addVertexRemoveListener(IndexRemoveListener listener) {
<span class="nc" id="L410">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add a listener&quot;);</span>
		}

		@Override
		public void removeVertexSwapRemoveListener(IndexRemoveListener listener) {
<span class="nc" id="L415">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove a listener&quot;);</span>
		}

		@Override
		public void addEdgeRemoveListener(IndexRemoveListener listener) {
<span class="nc" id="L420">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add a listener&quot;);</span>
		}

		@Override
		public void removeEdgeSwapRemoveListener(IndexRemoveListener listener) {
<span class="nc" id="L425">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove a listener&quot;);</span>
		}
	}

	private static class ImmutableEdgeSet&lt;V, E&gt; extends AbstractSet&lt;E&gt; implements EdgeSet&lt;V, E&gt; {

		private final EdgeSet&lt;V, E&gt; set;

<span class="fc" id="L433">		ImmutableEdgeSet(EdgeSet&lt;V, E&gt; set) {</span>
<span class="fc" id="L434">			this.set = Objects.requireNonNull(set);</span>
<span class="fc" id="L435">		}</span>

		@Override
		public boolean contains(Object edge) {
<span class="fc" id="L439">			return set.contains(edge);</span>
		}

		@Override
		public int size() {
<span class="fc" id="L444">			return set.size();</span>
		}

		@Override
		public EdgeIter&lt;V, E&gt; iterator() {
<span class="fc" id="L449">			return new ImmutableEdgeIter&lt;&gt;(set.iterator());</span>
		}
	}

	private static class ImmutableIEdgeSet extends AbstractIntSet implements IEdgeSet {

		private final IEdgeSet set;

<span class="fc" id="L457">		ImmutableIEdgeSet(IEdgeSet set) {</span>
<span class="fc" id="L458">			this.set = Objects.requireNonNull(set);</span>
<span class="fc" id="L459">		}</span>

		@Override
		public boolean contains(int edge) {
<span class="fc" id="L463">			return set.contains(edge);</span>
		}

		@Override
		public int size() {
<span class="fc" id="L468">			return set.size();</span>
		}

		@Override
		public IEdgeIter iterator() {
<span class="fc" id="L473">			return new ImmutableIEdgeIter(set.iterator());</span>
		}
	}

	private static class ImmutableEdgeIter&lt;V, E&gt; implements EdgeIter&lt;V, E&gt; {
		private final EdgeIter&lt;V, E&gt; it;

<span class="fc" id="L480">		ImmutableEdgeIter(EdgeIter&lt;V, E&gt; it) {</span>
<span class="fc" id="L481">			this.it = Objects.requireNonNull(it);</span>
<span class="fc" id="L482">		}</span>

		@Override
		public V source() {
<span class="fc" id="L486">			return it.source();</span>
		}

		@Override
		public V target() {
<span class="fc" id="L491">			return it.target();</span>
		}

		@Override
		public E next() {
<span class="fc" id="L496">			return it.next();</span>
		}

		@Override
		public boolean hasNext() {
<span class="fc" id="L501">			return it.hasNext();</span>
		}

		@Override
		public E peekNext() {
<span class="fc" id="L506">			return it.peekNext();</span>
		}
	}

	private static class ImmutableIEdgeIter implements IEdgeIter {
		private final IEdgeIter it;

<span class="fc" id="L513">		ImmutableIEdgeIter(IEdgeIter it) {</span>
<span class="fc" id="L514">			this.it = Objects.requireNonNull(it);</span>
<span class="fc" id="L515">		}</span>

		@Override
		public int sourceInt() {
<span class="fc" id="L519">			return it.sourceInt();</span>
		}

		@Override
		public int targetInt() {
<span class="fc" id="L524">			return it.targetInt();</span>
		}

		@Override
		public int nextInt() {
<span class="fc" id="L529">			return it.nextInt();</span>
		}

		@Override
		public boolean hasNext() {
<span class="fc" id="L534">			return it.hasNext();</span>
		}

		@Override
		public int peekNextInt() {
<span class="fc" id="L539">			return it.peekNextInt();</span>
		}
	}

	static IndexGraph immutableView(IndexGraph g) {
<span class="fc bfc" id="L544" title="All 2 branches covered.">		return g instanceof ImmutableGraph ? g : new ImmutableIndexGraphView(g);</span>
	}

	static IntGraph immutableView(IntGraph g) {
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">		if (g instanceof IndexGraph)</span>
<span class="nc" id="L549">			return immutableView((IndexGraph) g);</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">		return g instanceof ImmutableGraph ? g : new ImmutableIntGraphView(g);</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	static &lt;V, E&gt; Graph&lt;V, E&gt; immutableView(Graph&lt;V, E&gt; g) {
<span class="pc bpc" id="L555" title="1 of 2 branches missed.">		if (g instanceof IndexGraph)</span>
<span class="nc" id="L556">			return (Graph&lt;V, E&gt;) immutableView((IndexGraph) g);</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">		if (g instanceof IntGraph)</span>
<span class="fc" id="L558">			return (Graph&lt;V, E&gt;) immutableView((IntGraph) g);</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">		return g instanceof ImmutableGraph ? g : new ImmutableGraphView&lt;&gt;(g);</span>
	}

	private static class ReverseGraph&lt;V, E&gt; extends GraphBase&lt;V, E&gt; {

		private final Graph&lt;V, E&gt; graph;

<span class="fc" id="L566">		ReverseGraph(Graph&lt;V, E&gt; g) {</span>
<span class="fc" id="L567">			this.graph = Objects.requireNonNull(g);</span>
<span class="fc" id="L568">		}</span>

		@Override
		public Set&lt;V&gt; vertices() {
<span class="fc" id="L572">			return graph.vertices();</span>
		}

		@Override
		public Set&lt;E&gt; edges() {
<span class="fc" id="L577">			return graph.edges();</span>
		}

		@Override
		public void addVertex(V vertex) {
<span class="fc" id="L582">			graph.addVertex(vertex);</span>
<span class="fc" id="L583">		}</span>

		@Override
		public void removeVertex(V vertex) {
<span class="fc" id="L587">			graph.removeVertex(vertex);</span>
<span class="fc" id="L588">		}</span>

		@Override
		public EdgeSet&lt;V, E&gt; outEdges(V source) {
<span class="fc" id="L592">			return new ReversedEdgeSet&lt;&gt;(graph.inEdges(source));</span>
		}

		@Override
		public EdgeSet&lt;V, E&gt; inEdges(V target) {
<span class="fc" id="L597">			return new ReversedEdgeSet&lt;&gt;(graph.outEdges(target));</span>
		}

		@Override
		public EdgeSet&lt;V, E&gt; getEdges(V source, V target) {
<span class="fc" id="L602">			return new ReversedEdgeSet&lt;&gt;(graph.getEdges(target, source));</span>
		}

		@Override
		public void addEdge(V source, V target, E edge) {
<span class="fc" id="L607">			graph.addEdge(target, source, edge);</span>
<span class="fc" id="L608">		}</span>

		@Override
		public void removeEdge(E edge) {
<span class="fc" id="L612">			graph.removeEdge(edge);</span>
<span class="fc" id="L613">		}</span>

		@Override
		public void reverseEdge(E edge) {
<span class="fc" id="L617">			graph.reverseEdge(edge);</span>
<span class="fc" id="L618">		}</span>

		@Override
		public V edgeSource(E edge) {
<span class="fc" id="L622">			return graph.edgeTarget(edge);</span>
		}

		@Override
		public V edgeTarget(E edge) {
<span class="fc" id="L627">			return graph.edgeSource(edge);</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L632">			graph.clear();</span>
<span class="fc" id="L633">		}</span>

		@Override
		public void clearEdges() {
<span class="fc" id="L637">			graph.clearEdges();</span>
<span class="fc" id="L638">		}</span>

		@Override
		public &lt;T, WeightsT extends Weights&lt;V, T&gt;&gt; WeightsT getVerticesWeights(String key) {
<span class="fc" id="L642">			return graph.getVerticesWeights(key);</span>
		}

		@Override
		public &lt;T, WeightsT extends Weights&lt;V, T&gt;&gt; WeightsT addVerticesWeights(String key, Class&lt;? super T&gt; type,
				T defVal) {
<span class="fc" id="L648">			return graph.addVerticesWeights(key, type, defVal);</span>
		}

		@Override
		public void removeVerticesWeights(String key) {
<span class="fc" id="L653">			graph.removeVerticesWeights(key);</span>
<span class="fc" id="L654">		}</span>

		@Override
		public Set&lt;String&gt; getVerticesWeightsKeys() {
<span class="fc" id="L658">			return graph.getVerticesWeightsKeys();</span>
		}

		@Override
		public &lt;T, WeightsT extends Weights&lt;E, T&gt;&gt; WeightsT getEdgesWeights(String key) {
<span class="fc" id="L663">			return graph.getEdgesWeights(key);</span>
		}

		@Override
		public &lt;T, WeightsT extends Weights&lt;E, T&gt;&gt; WeightsT addEdgesWeights(String key, Class&lt;? super T&gt; type,
				T defVal) {
<span class="fc" id="L669">			return graph.addEdgesWeights(key, type, defVal);</span>
		}

		@Override
		public void removeEdgesWeights(String key) {
<span class="fc" id="L674">			graph.removeEdgesWeights(key);</span>
<span class="fc" id="L675">		}</span>

		@Override
		public Set&lt;String&gt; getEdgesWeightsKeys() {
<span class="fc" id="L679">			return graph.getEdgesWeightsKeys();</span>
		}

		@Override
		public boolean isDirected() {
<span class="fc" id="L684">			return graph.isDirected();</span>
		}

		@Override
		public boolean isAllowSelfEdges() {
<span class="fc" id="L689">			return graph.isAllowSelfEdges();</span>
		}

		@Override
		public boolean isAllowParallelEdges() {
<span class="fc" id="L694">			return graph.isAllowParallelEdges();</span>
		}

		@Override
		public IndexGraph indexGraph() {
<span class="pc bpc" id="L699" title="1 of 2 branches missed.">			return this instanceof IndexGraph ? (IndexGraph) this : Graphs.reverseView(graph.indexGraph());</span>
		}

		@Override
		public IndexIdMap&lt;V&gt; indexGraphVerticesMap() {
<span class="fc" id="L704">			return graph.indexGraphVerticesMap();</span>
		}

		@Override
		public IndexIdMap&lt;E&gt; indexGraphEdgesMap() {
<span class="fc" id="L709">			return graph.indexGraphEdgesMap();</span>
		}

	}

	private abstract static class ReverseIntGraphBase extends IntGraphBase {

		private final IntGraph graph;

<span class="fc" id="L718">		ReverseIntGraphBase(IntGraph g) {</span>
<span class="fc" id="L719">			this.graph = Objects.requireNonNull(g);</span>
<span class="fc" id="L720">		}</span>

		IntGraph graph() {
<span class="fc" id="L723">			return graph;</span>
		}

		@Override
		public IntSet vertices() {
<span class="fc" id="L728">			return graph.vertices();</span>
		}

		@Override
		public IntSet edges() {
<span class="fc" id="L733">			return graph.edges();</span>
		}

		@Override
		public int addVertex() {
<span class="fc" id="L738">			return graph.addVertex();</span>
		}

		@Override
		public void addVertex(int vertex) {
<span class="fc" id="L743">			graph.addVertex(vertex);</span>
<span class="fc" id="L744">		}</span>

		@Override
		public void removeVertex(int vertex) {
<span class="fc" id="L748">			graph.removeVertex(vertex);</span>
<span class="fc" id="L749">		}</span>

		@Override
		public IEdgeSet outEdges(int source) {
<span class="fc" id="L753">			return new ReversedIEdgeSet(graph.inEdges(source));</span>
		}

		@Override
		public IEdgeSet inEdges(int target) {
<span class="fc" id="L758">			return new ReversedIEdgeSet(graph.outEdges(target));</span>
		}

		@Override
		public IEdgeSet getEdges(int source, int target) {
<span class="fc" id="L763">			return new ReversedIEdgeSet(graph.getEdges(target, source));</span>
		}

		@Override
		public int addEdge(int source, int target) {
<span class="fc" id="L768">			return graph.addEdge(target, source);</span>
		}

		@Override
		public void addEdge(int source, int target, int edge) {
<span class="fc" id="L773">			graph.addEdge(target, source, edge);</span>
<span class="fc" id="L774">		}</span>

		@Override
		public void removeEdge(int edge) {
<span class="fc" id="L778">			graph.removeEdge(edge);</span>
<span class="fc" id="L779">		}</span>

		@Override
		public int edgeSource(int edge) {
<span class="fc" id="L783">			return graph.edgeTarget(edge);</span>
		}

		@Override
		public int edgeTarget(int edge) {
<span class="fc" id="L788">			return graph.edgeSource(edge);</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L793">			graph.clear();</span>
<span class="fc" id="L794">		}</span>

		@Override
		public void clearEdges() {
<span class="fc" id="L798">			graph.clearEdges();</span>
<span class="fc" id="L799">		}</span>

		@Override
		public &lt;T, WeightsT extends IWeights&lt;T&gt;&gt; WeightsT getVerticesIWeights(String key) {
<span class="fc" id="L803">			return graph.getVerticesWeights(key);</span>
		}

		@Override
		public Set&lt;String&gt; getVerticesWeightsKeys() {
<span class="fc" id="L808">			return graph.getVerticesWeightsKeys();</span>
		}

		@Override
		public void removeVerticesWeights(String key) {
<span class="fc" id="L813">			graph.removeVerticesWeights(key);</span>
<span class="fc" id="L814">		}</span>

		@Override
		public &lt;T, WeightsT extends IWeights&lt;T&gt;&gt; WeightsT getEdgesIWeights(String key) {
<span class="fc" id="L818">			return graph.getEdgesWeights(key);</span>
		}

		@Override
		public Set&lt;String&gt; getEdgesWeightsKeys() {
<span class="fc" id="L823">			return graph.getEdgesWeightsKeys();</span>
		}

		@Override
		public void removeEdgesWeights(String key) {
<span class="fc" id="L828">			graph.removeEdgesWeights(key);</span>
<span class="fc" id="L829">		}</span>

		@Override
		public boolean isDirected() {
<span class="fc" id="L833">			return graph.isDirected();</span>
		}

		@Override
		public boolean isAllowSelfEdges() {
<span class="fc" id="L838">			return graph.isAllowSelfEdges();</span>
		}

		@Override
		public boolean isAllowParallelEdges() {
<span class="fc" id="L843">			return graph.isAllowParallelEdges();</span>
		}

		@Override
		public void reverseEdge(int edge) {
<span class="fc" id="L848">			graph.reverseEdge(edge);</span>
<span class="fc" id="L849">		}</span>

		@Override
		public &lt;T, WeightsT extends Weights&lt;Integer, T&gt;&gt; WeightsT addVerticesWeights(String key, Class&lt;? super T&gt; type,
				T defVal) {
<span class="fc" id="L854">			return graph.addVerticesWeights(key, type, defVal);</span>
		}

		@Override
		public &lt;T, WeightsT extends Weights&lt;Integer, T&gt;&gt; WeightsT addEdgesWeights(String key, Class&lt;? super T&gt; type,
				T defVal) {
<span class="fc" id="L860">			return graph.addEdgesWeights(key, type, defVal);</span>
		}
	}

	private static class ReverseIntGraph extends ReverseIntGraphBase {

		ReverseIntGraph(IntGraph g) {
<span class="fc" id="L867">			super(g);</span>
<span class="fc" id="L868">		}</span>

		@Override
		public IndexGraph indexGraph() {
<span class="fc" id="L872">			return Graphs.reverseView(graph().indexGraph());</span>
		}

		@Override
		public IndexIntIdMap indexGraphVerticesMap() {
<span class="fc" id="L877">			return graph().indexGraphVerticesMap();</span>
		}

		@Override
		public IndexIntIdMap indexGraphEdgesMap() {
<span class="fc" id="L882">			return graph().indexGraphEdgesMap();</span>
		}
	}

	private static class ReverseIndexGraph extends ReverseIntGraphBase implements IndexGraph {

		ReverseIndexGraph(IndexGraph g) {
<span class="fc" id="L889">			super(g);</span>
<span class="fc" id="L890">		}</span>

		@Override
		IndexGraph graph() {
<span class="nc" id="L894">			return (IndexGraph) super.graph();</span>
		}

		@Override
		@Deprecated
		public void addVertex(int vertex) {
<span class="nc" id="L900">			IndexGraph.super.addVertex(vertex);</span>
<span class="nc" id="L901">		}</span>

		@Override
		@Deprecated
		public void addEdge(int source, int target, int edge) {
<span class="nc" id="L906">			IndexGraph.super.addEdge(source, target, edge);</span>
<span class="nc" id="L907">		}</span>

		@Override
		public void addVertexRemoveListener(IndexRemoveListener listener) {
<span class="nc" id="L911">			graph().addVertexRemoveListener(listener);</span>
<span class="nc" id="L912">		}</span>

		@Override
		public void removeVertexSwapRemoveListener(IndexRemoveListener listener) {
<span class="nc" id="L916">			graph().removeVertexSwapRemoveListener(listener);</span>
<span class="nc" id="L917">		}</span>

		@Override
		public void addEdgeRemoveListener(IndexRemoveListener listener) {
<span class="nc" id="L921">			graph().addEdgeRemoveListener(listener);</span>
<span class="nc" id="L922">		}</span>

		@Override
		public void removeEdgeSwapRemoveListener(IndexRemoveListener listener) {
<span class="nc" id="L926">			graph().removeEdgeSwapRemoveListener(listener);</span>
<span class="nc" id="L927">		}</span>
	}

	private static class ReversedEdgeSet&lt;V, E&gt; extends AbstractSet&lt;E&gt; implements EdgeSet&lt;V, E&gt; {

		private final EdgeSet&lt;V, E&gt; set;

<span class="fc" id="L934">		ReversedEdgeSet(EdgeSet&lt;V, E&gt; set) {</span>
<span class="fc" id="L935">			this.set = Objects.requireNonNull(set);</span>
<span class="fc" id="L936">		}</span>

		@Override
		public boolean contains(Object edge) {
<span class="fc" id="L940">			return set.contains(edge);</span>
		}

		@Override
		public int size() {
<span class="fc" id="L945">			return set.size();</span>
		}

		@Override
		public boolean remove(Object edge) {
<span class="nc" id="L950">			return set.remove(edge);</span>
		}

		@Override
		public void clear() {
<span class="nc" id="L955">			set.clear();</span>
<span class="nc" id="L956">		}</span>

		@Override
		public EdgeIter&lt;V, E&gt; iterator() {
<span class="fc" id="L960">			return new ReversedEdgeIter&lt;&gt;(set.iterator());</span>
		}
	}

	private static class ReversedIEdgeSet extends AbstractIntSet implements IEdgeSet {

		private final IEdgeSet set;

<span class="fc" id="L968">		ReversedIEdgeSet(IEdgeSet set) {</span>
<span class="fc" id="L969">			this.set = Objects.requireNonNull(set);</span>
<span class="fc" id="L970">		}</span>

		@Override
		public boolean contains(int edge) {
<span class="fc" id="L974">			return set.contains(edge);</span>
		}

		@Override
		public int size() {
<span class="fc" id="L979">			return set.size();</span>
		}

		@Override
		public boolean remove(int edge) {
<span class="nc" id="L984">			return set.remove(edge);</span>
		}

		@Override
		public void clear() {
<span class="nc" id="L989">			set.clear();</span>
<span class="nc" id="L990">		}</span>

		@Override
		public IEdgeIter iterator() {
<span class="fc" id="L994">			return new ReversedIEdgeIter(set.iterator());</span>
		}
	}

	private static class ReversedEdgeIter&lt;V, E&gt; implements EdgeIter&lt;V, E&gt; {
		final EdgeIter&lt;V, E&gt; it;

<span class="fc" id="L1001">		ReversedEdgeIter(EdgeIter&lt;V, E&gt; it) {</span>
<span class="fc" id="L1002">			this.it = it;</span>
<span class="fc" id="L1003">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc" id="L1007">			return it.hasNext();</span>
		}

		@Override
		public E next() {
<span class="fc" id="L1012">			return it.next();</span>
		}

		@Override
		public E peekNext() {
<span class="fc" id="L1017">			return it.peekNext();</span>
		}

		@Override
		public V source() {
<span class="fc" id="L1022">			return it.target();</span>
		}

		@Override
		public V target() {
<span class="fc" id="L1027">			return it.source();</span>
		}

		@Override
		public void remove() {
<span class="fc" id="L1032">			it.remove();</span>
<span class="fc" id="L1033">		}</span>
	}

	private static class ReversedIEdgeIter implements IEdgeIter {
		final IEdgeIter it;

<span class="fc" id="L1039">		ReversedIEdgeIter(IEdgeIter it) {</span>
<span class="fc" id="L1040">			this.it = it;</span>
<span class="fc" id="L1041">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc" id="L1045">			return it.hasNext();</span>
		}

		@Override
		public int nextInt() {
<span class="fc" id="L1050">			return it.nextInt();</span>
		}

		@Override
		public int peekNextInt() {
<span class="fc" id="L1055">			return it.peekNextInt();</span>
		}

		@Override
		public int sourceInt() {
<span class="fc" id="L1060">			return it.targetInt();</span>
		}

		@Override
		public int targetInt() {
<span class="fc" id="L1065">			return it.sourceInt();</span>
		}

		@Override
		public void remove() {
<span class="fc" id="L1070">			it.remove();</span>
<span class="fc" id="L1071">		}</span>
	}

	static IndexGraph reverseView(IndexGraph g) {
<span class="pc bpc" id="L1075" title="1 of 2 branches missed.">		return g instanceof ReverseIntGraphBase ? ((ReverseIntGraphBase) g).graph.indexGraph()</span>
<span class="fc" id="L1076">				: new ReverseIndexGraph(g);</span>
	}

	static IntGraph reverseView(IntGraph g) {
<span class="pc bpc" id="L1080" title="1 of 2 branches missed.">		if (g instanceof IndexGraph)</span>
<span class="nc" id="L1081">			return reverseView((IndexGraph) g);</span>
<span class="pc bpc" id="L1082" title="1 of 2 branches missed.">		return g instanceof ReverseIntGraphBase ? ((ReverseIntGraphBase) g).graph : new ReverseIntGraph(g);</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	static &lt;V, E&gt; Graph&lt;V, E&gt; reverseView(Graph&lt;V, E&gt; g) {
<span class="pc bpc" id="L1087" title="1 of 2 branches missed.">		if (g instanceof IndexGraph)</span>
<span class="nc" id="L1088">			return (Graph&lt;V, E&gt;) reverseView((IndexGraph) g);</span>
<span class="fc bfc" id="L1089" title="All 2 branches covered.">		if (g instanceof IntGraph)</span>
<span class="fc" id="L1090">			return (Graph&lt;V, E&gt;) reverseView((IntGraph) g);</span>
<span class="pc bpc" id="L1091" title="1 of 2 branches missed.">		return g instanceof ReverseGraph ? ((ReverseGraph&lt;V, E&gt;) g).graph : new ReverseGraph&lt;&gt;(g);</span>
	}

	static String getIndexGraphImpl(IndexGraph g) {
		for (;;) {
<span class="fc" id="L1096">			IndexGraph g0 = g;</span>
<span class="pc bpc" id="L1097" title="1 of 2 branches missed.">			if (g instanceof ReverseIndexGraph)</span>
<span class="nc" id="L1098">				g = ((ReverseIndexGraph) g).graph();</span>
<span class="pc bpc" id="L1099" title="1 of 2 branches missed.">			if (g instanceof ImmutableIndexGraphView)</span>
<span class="nc" id="L1100">				g = ((ImmutableIndexGraphView) g).graph();</span>
<span class="fc bfc" id="L1101" title="All 2 branches covered.">			if (g instanceof GraphArrayAbstract)</span>
<span class="fc" id="L1102">				return &quot;array&quot;;</span>
<span class="fc bfc" id="L1103" title="All 2 branches covered.">			if (g instanceof GraphLinkedAbstract)</span>
<span class="fc" id="L1104">				return &quot;linked-list&quot;;</span>
<span class="fc bfc" id="L1105" title="All 2 branches covered.">			if (g instanceof GraphHashmapAbstract)</span>
<span class="fc" id="L1106">				return &quot;hashtable&quot;;</span>
<span class="pc bpc" id="L1107" title="1 of 2 branches missed.">			if (g instanceof GraphMatrixAbstract)</span>
<span class="fc" id="L1108">				return &quot;matrix&quot;;</span>
<span class="nc bnc" id="L1109" title="All 2 branches missed.">			if (g == g0)</span>
<span class="nc" id="L1110">				return null;</span>
<span class="nc" id="L1111">		}</span>
	}

<span class="fc" id="L1114">	static final IndexIntIdMap IndexIdMapIdentify = new IndexGraphMapIdentify();</span>

	private static class IndexGraphMapIdentify implements IndexIntIdMap {
		@Override
		public int indexToIdInt(int index) {
<span class="fc" id="L1119">			return index;</span>
		}

		@Override
		public int idToIndex(int id) {
<span class="fc" id="L1124">			return id;</span>
		}

		@Override
		public int idToIndexIfExist(int id) {
<span class="nc" id="L1129">			return id;</span>
		}
	}

	static class EdgeSetSourceTargetSingleton extends AbstractIntSet implements IEdgeSet {

		private final IntGraph g;
		private final int source, target;
		private int edge;
		private static final int EdgeNone = -1;

<span class="fc" id="L1140">		EdgeSetSourceTargetSingleton(IntGraph g, int source, int target, int edge) {</span>
<span class="fc" id="L1141">			this.g = g;</span>
<span class="fc" id="L1142">			this.source = source;</span>
<span class="fc" id="L1143">			this.target = target;</span>
<span class="fc" id="L1144">			this.edge = edge;</span>
<span class="fc" id="L1145">		}</span>

		@Override
		public boolean remove(int edge) {
<span class="pc bpc" id="L1149" title="1 of 2 branches missed.">			if (this.edge != edge)</span>
<span class="nc" id="L1150">				return false;</span>
<span class="fc" id="L1151">			g.removeEdge(edge);</span>
<span class="fc" id="L1152">			this.edge = EdgeNone;</span>
<span class="fc" id="L1153">			return true;</span>
		}

		@Override
		public boolean contains(int edge) {
<span class="pc bpc" id="L1158" title="2 of 4 branches missed.">			return this.edge != EdgeNone &amp;&amp; this.edge == edge;</span>
		}

		@Override
		public int size() {
<span class="pc bpc" id="L1163" title="1 of 2 branches missed.">			return edge != EdgeNone ? 1 : 0;</span>
		}

		@Override
		public void clear() {
<span class="nc bnc" id="L1168" title="All 2 branches missed.">			if (edge != EdgeNone) {</span>
<span class="nc" id="L1169">				g.removeEdge(edge);</span>
<span class="nc" id="L1170">				edge = EdgeNone;</span>
			}
<span class="nc" id="L1172">		}</span>

		@Override
		public IEdgeIter iterator() {
<span class="fc" id="L1176">			return new IEdgeIter() {</span>

<span class="pc bpc" id="L1178" title="1 of 2 branches missed.">				boolean beforeNext = edge != EdgeNone;</span>

				@Override
				public boolean hasNext() {
<span class="fc" id="L1182">					return beforeNext;</span>
				}

				@Override
				public int nextInt() {
<span class="fc" id="L1187">					Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L1188">					beforeNext = false;</span>
<span class="fc" id="L1189">					return edge;</span>
				}

				@Override
				public int peekNextInt() {
<span class="fc" id="L1194">					Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L1195">					return edge;</span>
				}

				@Override
				public int sourceInt() {
<span class="fc" id="L1200">					return source;</span>
				}

				@Override
				public int targetInt() {
<span class="fc" id="L1205">					return target;</span>
				}

				@Override
				public void remove() {
<span class="nc bnc" id="L1210" title="All 2 branches missed.">					if (beforeNext)</span>
<span class="nc" id="L1211">						throw new IllegalStateException();</span>
<span class="nc" id="L1212">					g.removeEdge(edge);</span>
<span class="nc" id="L1213">					edge = EdgeNone;</span>
<span class="nc" id="L1214">				}</span>
			};
		}
	}

	/**
	 * Create a new graph that is an induced subgraph of the given graph.
	 *
	 * &lt;p&gt;
	 * An induced subgraph of a graph \(G=(V,E)\) is a graph \(G'=(V',E')\) where \(V' \subseteq V\) and \(E' =
	 * \{\{u,v\} \mid u,v \in V', \{u,v\} \in E\}\). The created graph will have the same type (directed/undirected) as
	 * the given graph. The vertices and edges of the created graph will be a subset of the vertices and edges of the
	 * given graph.
	 *
	 * &lt;p&gt;
	 * The weights of both vertices and edges will not be copied to the new sub graph. For more flexible sub graph
	 * creation, see {@link #subGraph(Graph, Collection, Collection, boolean, boolean)}.
	 *
	 * &lt;p&gt;
	 * If {@code g} is {@link IntGraph}, the returned sub graph is also an {@link IntGraph}.
	 *
	 * @param  &lt;V&gt;      the vertices type
	 * @param  &lt;E&gt;      the edges type
	 * @param  g        the graph to create a sub graph from
	 * @param  vertices the vertices of the sub graph
	 * @return          a new graph that is an induced subgraph of the given graph
	 */
	public static &lt;V, E&gt; Graph&lt;V, E&gt; subGraph(Graph&lt;V, E&gt; g, Collection&lt;V&gt; vertices) {
<span class="fc" id="L1242">		return subGraph(g, Objects.requireNonNull(vertices), null);</span>
	}

	/**
	 * Create a new graph that is a subgraph of the given graph.
	 *
	 * &lt;p&gt;
	 * If {@code edges} is {@code null}, then the created graph will be an induced subgraph of the given graph, namely
	 * an induced subgraph of a graph \(G=(V,E)\) is a graph \(G'=(V',E')\) where \(V' \subseteq V\) and \(E' =
	 * \{\{u,v\} \mid u,v \in V', \{u,v\} \in E\}\). The behavior is similar to {@link #subGraph(Graph, Collection)}.
	 * {@code vertices} must not be {@code null} in this case.
	 *
	 * &lt;p&gt;
	 * If {@code vertices} is {@code null}, then {@code edges} must not be {@code null}, and the sub graph will contain
	 * all the vertices which are either a source or a target of an edge in {@code edges}.
	 *
	 * &lt;p&gt;
	 * The created graph will have the same type (directed/undirected) as the given graph. The vertices and edges of the
	 * created graph will be a subset of the vertices and edges of the given graph.
	 *
	 * &lt;p&gt;
	 * The weights of both vertices and edges will not be copied to the new sub graph. For more flexible sub graph
	 * creation, see {@link #subGraph(Graph, Collection, Collection, boolean, boolean)}.
	 *
	 * &lt;p&gt;
	 * If {@code g} is {@link IntGraph}, the returned sub graph is also an {@link IntGraph}.
	 *
	 * @param  &lt;V&gt;                  the vertices type
	 * @param  &lt;E&gt;                  the edges type
	 * @param  g                    the graph to create a sub graph from
	 * @param  vertices             the vertices of the sub graph, if {@code null} then {@code edges} must not be
	 *                                  {@code null} and the vertices of the sub graph will be all the vertices which
	 *                                  are either a source or a target of an edge in {@code edges}
	 * @param  edges                the edges of the sub graph, if {@code null} then {@code vertices} must not be
	 *                                  {@code null} and the sub graph will be an induced subgraph of the given graph
	 * @return                      a new graph that is a subgraph of the given graph
	 * @throws NullPointerException if both {@code vertices} and {@code edges} are {@code null}
	 */
	public static &lt;V, E&gt; Graph&lt;V, E&gt; subGraph(Graph&lt;V, E&gt; g, Collection&lt;V&gt; vertices, Collection&lt;E&gt; edges) {
<span class="fc" id="L1281">		return subGraph(g, vertices, edges, false, false);</span>
	}

	/**
	 * Create a new graph that is a subgraph of the given graph, with option to copy weights.
	 *
	 * &lt;p&gt;
	 * If {@code edges} is {@code null}, then the created graph will be an induced subgraph of the given graph, namely
	 * an induced subgraph of a graph \(G=(V,E)\) is a graph \(G'=(V',E')\) where \(V' \subseteq V\) and \(E' =
	 * \{\{u,v\} \mid u,v \in V', \{u,v\} \in E\}\). The behavior is similar to {@link #subGraph(Graph, Collection)}.
	 * {@code vertices} must not be {@code null} in this case.
	 *
	 * &lt;p&gt;
	 * If {@code vertices} is {@code null}, then {@code edges} must not be {@code null}, and the sub graph will contain
	 * all the vertices which are either a source or a target of an edge in {@code edges}.
	 *
	 * &lt;p&gt;
	 * The created graph will have the same type (directed/undirected) as the given graph. The vertices and edges of the
	 * created graph will be a subset of the vertices and edges of the given graph.
	 *
	 * &lt;p&gt;
	 * An additional parameter options for copying the weights of the vertices and edges of the given graph to the new
	 * sub graph are provided. If {@code copyVerticesWeights} is {@code true}, then all the vertices weights of the
	 * given graph will be copied to the new sub graph. If {@code copyEdgesWeights} is {@code true}, then all the edges
	 * weights of the given graph will be copied to the new sub graph.
	 *
	 * &lt;p&gt;
	 * If {@code g} is {@link IntGraph}, the returned sub graph is also an {@link IntGraph}.
	 *
	 * @param  &lt;V&gt;                  the vertices type
	 * @param  &lt;E&gt;                  the edges type
	 * @param  g                    the graph to create a sub graph from
	 * @param  vertices             the vertices of the sub graph, if {@code null} then {@code edges} must not be
	 *                                  {@code null} and the vertices of the sub graph will be all the vertices which
	 *                                  are either a source or a target of an edge in {@code edges}
	 * @param  edges                the edges of the sub graph, if {@code null} then {@code vertices} must not be
	 *                                  {@code null} and the sub graph will be an induced subgraph of the given graph
	 * @param  copyVerticesWeights  if {@code true} then all the vertices weights of the given graph will be copied to
	 *                                  the new sub graph
	 * @param  copyEdgesWeights     if {@code true} then all the edges weights of the given graph will be copied to the
	 *                                  new sub graph
	 * @return                      a new graph that is a subgraph of the given graph
	 * @throws NullPointerException if both {@code vertices} and {@code edges} are {@code null}
	 */
	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot;, &quot;cast&quot; })
	public static &lt;V, E&gt; Graph&lt;V, E&gt; subGraph(Graph&lt;V, E&gt; g, Collection&lt;V&gt; vertices, Collection&lt;E&gt; edges,
			boolean copyVerticesWeights, boolean copyEdgesWeights) {
<span class="fc bfc" id="L1328" title="All 2 branches covered.">		if (g instanceof IntGraph) {</span>
<span class="fc bfc" id="L1329" title="All 2 branches covered.">			IntCollection vs = vertices == null ? null : IntAdapters.asIntCollection((Collection&lt;Integer&gt;) vertices);</span>
<span class="fc bfc" id="L1330" title="All 2 branches covered.">			IntCollection es = edges == null ? null : IntAdapters.asIntCollection((Collection&lt;Integer&gt;) edges);</span>
<span class="fc" id="L1331">			return (Graph&lt;V, E&gt;) subGraph((IntGraph) g, vs, es, copyVerticesWeights, copyEdgesWeights);</span>
		}

<span class="pc bpc" id="L1334" title="1 of 4 branches missed.">		if (vertices == null &amp;&amp; edges == null)</span>
<span class="nc" id="L1335">			throw new NullPointerException();</span>
<span class="fc bfc" id="L1336" title="All 2 branches covered.">		GraphBuilder&lt;V, E&gt; gb = g.isDirected() ? GraphBuilder.newDirected() : GraphBuilder.newUndirected();</span>

<span class="fc bfc" id="L1338" title="All 2 branches covered.">		if (vertices == null) {</span>
<span class="fc" id="L1339">			vertices = new ObjectOpenHashSet();</span>
<span class="fc bfc" id="L1340" title="All 2 branches covered.">			for (E e : edges) {</span>
<span class="fc" id="L1341">				vertices.add(g.edgeSource(e));</span>
<span class="fc" id="L1342">				vertices.add(g.edgeTarget(e));</span>
<span class="fc" id="L1343">			}</span>
		}
<span class="fc" id="L1345">		gb.expectedVerticesNum(vertices.size());</span>
<span class="fc bfc" id="L1346" title="All 2 branches covered.">		for (V v : vertices)</span>
<span class="fc" id="L1347">			gb.addVertex(v);</span>

<span class="fc bfc" id="L1349" title="All 2 branches covered.">		if (edges == null) {</span>
<span class="fc bfc" id="L1350" title="All 2 branches covered.">			for (E e : g.edges()) {</span>
<span class="fc" id="L1351">				V u = g.edgeSource(e), v = g.edgeTarget(e);</span>
<span class="fc bfc" id="L1352" title="All 4 branches covered.">				if (gb.vertices().contains(u) &amp;&amp; gb.vertices().contains(v))</span>
<span class="fc" id="L1353">					gb.addEdge(u, v, e);</span>
<span class="fc" id="L1354">			}</span>
		} else {
<span class="fc bfc" id="L1356" title="All 2 branches covered.">			for (E e : edges)</span>
<span class="fc" id="L1357">				gb.addEdge(g.edgeSource(e), g.edgeTarget(e), e);</span>
		}

<span class="fc bfc" id="L1360" title="All 2 branches covered.">		if (copyVerticesWeights) {</span>
<span class="fc bfc" id="L1361" title="All 2 branches covered.">			for (String key : g.getVerticesWeightsKeys()) {</span>
<span class="fc" id="L1362">				Weights wSrc = g.getVerticesWeights(key);</span>
<span class="fc" id="L1363">				Class&lt;?&gt; type = (Class) getWeightsType(wSrc);</span>
<span class="fc" id="L1364">				Weights wDst = gb.addVerticesWeights(key, (Class) type, wSrc.defaultWeightAsObj());</span>
<span class="fc" id="L1365">				copyWeights(wSrc, wDst, type, gb.vertices());</span>
<span class="fc" id="L1366">			}</span>
		}
<span class="fc bfc" id="L1368" title="All 2 branches covered.">		if (copyEdgesWeights) {</span>
<span class="fc bfc" id="L1369" title="All 2 branches covered.">			for (String key : g.getEdgesWeightsKeys()) {</span>
<span class="fc" id="L1370">				Weights wSrc = g.getEdgesWeights(key);</span>
<span class="fc" id="L1371">				Class&lt;?&gt; type = (Class) getWeightsType(wSrc);</span>
<span class="fc" id="L1372">				Weights wDst = gb.addEdgesWeights(key, (Class) type, wSrc.defaultWeightAsObj());</span>
<span class="fc" id="L1373">				copyWeights(wSrc, wDst, type, gb.edges());</span>
<span class="fc" id="L1374">			}</span>
		}

<span class="fc" id="L1377">		return gb.build();</span>
	}

	/**
	 * Create a new graph that is a subgraph of the given int graph, with option to copy weights.
	 *
	 * &lt;p&gt;
	 * If {@code edges} is {@code null}, then the created graph will be an induced subgraph of the given graph, namely
	 * an induced subgraph of a graph \(G=(V,E)\) is a graph \(G'=(V',E')\) where \(V' \subseteq V\) and \(E' =
	 * \{\{u,v\} \mid u,v \in V', \{u,v\} \in E\}\).
	 *
	 * &lt;p&gt;
	 * If {@code vertices} is {@code null}, then {@code edges} must not be {@code null}, and the sub graph will contain
	 * all the vertices which are either a source or a target of an edge in {@code edges}.
	 *
	 * &lt;p&gt;
	 * The created graph will have the same type (directed/undirected) as the given graph. The vertices and edges of the
	 * created graph will be a subset of the vertices and edges of the given graph.
	 *
	 * &lt;p&gt;
	 * An additional parameter options for copying the weights of the vertices and edges of the given graph to the new
	 * sub graph are provided. If {@code copyVerticesWeights} is {@code true}, then all the vertices weights of the
	 * given graph will be copied to the new sub graph. If {@code copyEdgesWeights} is {@code true}, then all the edges
	 * weights of the given graph will be copied to the new sub graph.
	 *
	 * @param  g                    the graph to create a sub graph from
	 * @param  vertices             the vertices of the sub graph, if {@code null} then {@code edges} must not be
	 *                                  {@code null} and the vertices of the sub graph will be all the vertices which
	 *                                  are either a source or a target of an edge in {@code edges}
	 * @param  edges                the edges of the sub graph, if {@code null} then {@code vertices} must not be
	 *                                  {@code null} and the sub graph will be an induced subgraph of the given graph
	 * @param  copyVerticesWeights  if {@code true} then all the vertices weights of the given graph will be copied to
	 *                                  the new sub graph
	 * @param  copyEdgesWeights     if {@code true} then all the edges weights of the given graph will be copied to the
	 *                                  new sub graph
	 * @return                      a new graph that is a subgraph of the given graph
	 * @throws NullPointerException if both {@code vertices} and {@code edges} are {@code null}
	 */
	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot;, &quot;cast&quot; })
	public static IntGraph subGraph(IntGraph g, IntCollection vertices, IntCollection edges,
			boolean copyVerticesWeights, boolean copyEdgesWeights) {
<span class="pc bpc" id="L1418" title="1 of 4 branches missed.">		if (vertices == null &amp;&amp; edges == null)</span>
<span class="nc" id="L1419">			throw new NullPointerException(&quot;Either vertices or edges can be null, not both.&quot;);</span>
<span class="fc bfc" id="L1420" title="All 2 branches covered.">		IntGraphBuilder gb = g.isDirected() ? IntGraphBuilder.newDirected() : IntGraphBuilder.newUndirected();</span>

<span class="fc bfc" id="L1422" title="All 2 branches covered.">		if (vertices == null) {</span>
<span class="fc" id="L1423">			vertices = new IntOpenHashSet();</span>
<span class="fc bfc" id="L1424" title="All 2 branches covered.">			for (int e : edges) {</span>
<span class="fc" id="L1425">				vertices.add(g.edgeSource(e));</span>
<span class="fc" id="L1426">				vertices.add(g.edgeTarget(e));</span>
<span class="fc" id="L1427">			}</span>
		}
<span class="fc" id="L1429">		gb.expectedVerticesNum(vertices.size());</span>
<span class="fc bfc" id="L1430" title="All 2 branches covered.">		for (int v : vertices)</span>
<span class="fc" id="L1431">			gb.addVertex(v);</span>

<span class="fc bfc" id="L1433" title="All 2 branches covered.">		if (edges == null) {</span>
<span class="fc bfc" id="L1434" title="All 2 branches covered.">			for (int e : g.edges()) {</span>
<span class="fc" id="L1435">				int u = g.edgeSource(e), v = g.edgeTarget(e);</span>
<span class="fc bfc" id="L1436" title="All 4 branches covered.">				if (gb.vertices().contains(u) &amp;&amp; gb.vertices().contains(v))</span>
<span class="fc" id="L1437">					gb.addEdge(u, v, e);</span>
<span class="fc" id="L1438">			}</span>
		} else {
<span class="fc bfc" id="L1440" title="All 2 branches covered.">			for (int e : edges)</span>
<span class="fc" id="L1441">				gb.addEdge(g.edgeSource(e), g.edgeTarget(e), e);</span>
		}

<span class="fc bfc" id="L1444" title="All 2 branches covered.">		if (copyVerticesWeights) {</span>
<span class="fc bfc" id="L1445" title="All 2 branches covered.">			for (String key : g.getVerticesWeightsKeys()) {</span>
<span class="fc" id="L1446">				IWeights wSrc = g.getVerticesWeights(key);</span>
<span class="fc" id="L1447">				Class&lt;?&gt; type = (Class) getWeightsType(wSrc);</span>
<span class="fc" id="L1448">				IWeights wDst = (IWeights) gb.addVerticesWeights(key, (Class) type, wSrc.defaultWeightAsObj());</span>
<span class="fc" id="L1449">				copyWeights(wSrc, wDst, type, gb.vertices());</span>
<span class="fc" id="L1450">			}</span>
		}
<span class="fc bfc" id="L1452" title="All 2 branches covered.">		if (copyEdgesWeights) {</span>
<span class="fc bfc" id="L1453" title="All 2 branches covered.">			for (String key : g.getEdgesWeightsKeys()) {</span>
<span class="fc" id="L1454">				IWeights wSrc = g.getEdgesWeights(key);</span>
<span class="fc" id="L1455">				Class&lt;?&gt; type = (Class) getWeightsType(wSrc);</span>
<span class="fc" id="L1456">				IWeights wDst = (IWeights) gb.addEdgesWeights(key, (Class) type, wSrc.defaultWeightAsObj());</span>
<span class="fc" id="L1457">				copyWeights(wSrc, wDst, type, gb.edges());</span>
<span class="fc" id="L1458">			}</span>
		}

<span class="fc" id="L1461">		return gb.build();</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	private static &lt;K&gt; void copyWeights(Weights&lt;K, ?&gt; src, Weights&lt;K, ?&gt; dst, Class&lt;?&gt; type, Collection&lt;K&gt; elements) {
<span class="fc bfc" id="L1466" title="All 2 branches covered.">		if (type == byte.class) {</span>
<span class="fc" id="L1467">			WeightsByte&lt;K&gt; src0 = (WeightsByte&lt;K&gt;) src;</span>
<span class="fc" id="L1468">			WeightsByte&lt;K&gt; dst0 = (WeightsByte&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L1469" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L1470">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L1471" title="All 2 branches covered.">		} else if (type == short.class) {</span>
<span class="fc" id="L1472">			WeightsShort&lt;K&gt; src0 = (WeightsShort&lt;K&gt;) src;</span>
<span class="fc" id="L1473">			WeightsShort&lt;K&gt; dst0 = (WeightsShort&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L1474" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L1475">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L1476" title="All 2 branches covered.">		} else if (type == int.class) {</span>
<span class="fc" id="L1477">			WeightsInt&lt;K&gt; src0 = (WeightsInt&lt;K&gt;) src;</span>
<span class="fc" id="L1478">			WeightsInt&lt;K&gt; dst0 = (WeightsInt&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L1479" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L1480">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L1481" title="All 2 branches covered.">		} else if (type == long.class) {</span>
<span class="fc" id="L1482">			WeightsLong&lt;K&gt; src0 = (WeightsLong&lt;K&gt;) src;</span>
<span class="fc" id="L1483">			WeightsLong&lt;K&gt; dst0 = (WeightsLong&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L1484" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L1485">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L1486" title="All 2 branches covered.">		} else if (type == float.class) {</span>
<span class="fc" id="L1487">			WeightsFloat&lt;K&gt; src0 = (WeightsFloat&lt;K&gt;) src;</span>
<span class="fc" id="L1488">			WeightsFloat&lt;K&gt; dst0 = (WeightsFloat&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L1489" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L1490">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L1491" title="All 2 branches covered.">		} else if (type == double.class) {</span>
<span class="fc" id="L1492">			WeightsDouble&lt;K&gt; src0 = (WeightsDouble&lt;K&gt;) src;</span>
<span class="fc" id="L1493">			WeightsDouble&lt;K&gt; dst0 = (WeightsDouble&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L1494" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L1495">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L1496" title="All 2 branches covered.">		} else if (type == boolean.class) {</span>
<span class="fc" id="L1497">			WeightsBool&lt;K&gt; src0 = (WeightsBool&lt;K&gt;) src;</span>
<span class="fc" id="L1498">			WeightsBool&lt;K&gt; dst0 = (WeightsBool&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L1499" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L1500">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L1501" title="All 2 branches covered.">		} else if (type == char.class) {</span>
<span class="fc" id="L1502">			WeightsChar&lt;K&gt; src0 = (WeightsChar&lt;K&gt;) src;</span>
<span class="fc" id="L1503">			WeightsChar&lt;K&gt; dst0 = (WeightsChar&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L1504" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L1505">				dst0.set(elm, src0.get(elm));</span>
<span class="pc bpc" id="L1506" title="1 of 2 branches missed.">		} else if (type == Object.class) {</span>
<span class="fc" id="L1507">			WeightsObj&lt;K, Object&gt; src0 = (WeightsObj&lt;K, Object&gt;) src;</span>
<span class="fc" id="L1508">			WeightsObj&lt;K, Object&gt; dst0 = (WeightsObj&lt;K, Object&gt;) dst;</span>
<span class="fc bfc" id="L1509" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L1510">				dst0.set(elm, src0.get(elm));</span>
<span class="fc" id="L1511">		} else {</span>
<span class="nc" id="L1512">			throw new AssertionError();</span>
		}
<span class="fc" id="L1514">	}</span>

	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
	private static void copyWeights(IWeights&lt;?&gt; src, IWeights&lt;?&gt; dst, Class&lt;?&gt; type, IntCollection elements) {
<span class="fc bfc" id="L1518" title="All 2 branches covered.">		if (type == byte.class) {</span>
<span class="fc" id="L1519">			IWeightsByte src0 = (IWeightsByte) src;</span>
<span class="fc" id="L1520">			IWeightsByte dst0 = (IWeightsByte) dst;</span>
<span class="fc bfc" id="L1521" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L1522">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L1523" title="All 2 branches covered.">		} else if (type == short.class) {</span>
<span class="fc" id="L1524">			IWeightsShort src0 = (IWeightsShort) src;</span>
<span class="fc" id="L1525">			IWeightsShort dst0 = (IWeightsShort) dst;</span>
<span class="fc bfc" id="L1526" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L1527">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L1528" title="All 2 branches covered.">		} else if (type == int.class) {</span>
<span class="fc" id="L1529">			IWeightsInt src0 = (IWeightsInt) src;</span>
<span class="fc" id="L1530">			IWeightsInt dst0 = (IWeightsInt) dst;</span>
<span class="fc bfc" id="L1531" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L1532">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L1533" title="All 2 branches covered.">		} else if (type == long.class) {</span>
<span class="fc" id="L1534">			IWeightsLong src0 = (IWeightsLong) src;</span>
<span class="fc" id="L1535">			IWeightsLong dst0 = (IWeightsLong) dst;</span>
<span class="fc bfc" id="L1536" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L1537">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L1538" title="All 2 branches covered.">		} else if (type == float.class) {</span>
<span class="fc" id="L1539">			IWeightsFloat src0 = (IWeightsFloat) src;</span>
<span class="fc" id="L1540">			IWeightsFloat dst0 = (IWeightsFloat) dst;</span>
<span class="fc bfc" id="L1541" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L1542">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L1543" title="All 2 branches covered.">		} else if (type == double.class) {</span>
<span class="fc" id="L1544">			IWeightsDouble src0 = (IWeightsDouble) src;</span>
<span class="fc" id="L1545">			IWeightsDouble dst0 = (IWeightsDouble) dst;</span>
<span class="fc bfc" id="L1546" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L1547">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L1548" title="All 2 branches covered.">		} else if (type == boolean.class) {</span>
<span class="fc" id="L1549">			IWeightsBool src0 = (IWeightsBool) src;</span>
<span class="fc" id="L1550">			IWeightsBool dst0 = (IWeightsBool) dst;</span>
<span class="fc bfc" id="L1551" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L1552">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L1553" title="All 2 branches covered.">		} else if (type == char.class) {</span>
<span class="fc" id="L1554">			IWeightsChar src0 = (IWeightsChar) src;</span>
<span class="fc" id="L1555">			IWeightsChar dst0 = (IWeightsChar) dst;</span>
<span class="fc bfc" id="L1556" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L1557">				dst0.set(elm, src0.get(elm));</span>
<span class="pc bpc" id="L1558" title="1 of 2 branches missed.">		} else if (type == Object.class) {</span>
<span class="fc" id="L1559">			IWeightsObj src0 = (IWeightsObj) src;</span>
<span class="fc" id="L1560">			IWeightsObj dst0 = (IWeightsObj) dst;</span>
<span class="fc bfc" id="L1561" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L1562">				dst0.set(elm, src0.get(elm));</span>
<span class="fc" id="L1563">		} else {</span>
<span class="nc" id="L1564">			throw new AssertionError();</span>
		}
<span class="fc" id="L1566">	}</span>

	private static Class&lt;?&gt; getWeightsType(Weights&lt;?, ?&gt; w) {
<span class="fc bfc" id="L1569" title="All 2 branches covered.">		if (w instanceof WeightsByte)</span>
<span class="fc" id="L1570">			return byte.class;</span>
<span class="fc bfc" id="L1571" title="All 2 branches covered.">		if (w instanceof WeightsShort)</span>
<span class="fc" id="L1572">			return short.class;</span>
<span class="fc bfc" id="L1573" title="All 2 branches covered.">		if (w instanceof WeightsInt)</span>
<span class="fc" id="L1574">			return int.class;</span>
<span class="fc bfc" id="L1575" title="All 2 branches covered.">		if (w instanceof WeightsLong)</span>
<span class="fc" id="L1576">			return long.class;</span>
<span class="fc bfc" id="L1577" title="All 2 branches covered.">		if (w instanceof WeightsFloat)</span>
<span class="fc" id="L1578">			return float.class;</span>
<span class="fc bfc" id="L1579" title="All 2 branches covered.">		if (w instanceof WeightsDouble)</span>
<span class="fc" id="L1580">			return double.class;</span>
<span class="fc bfc" id="L1581" title="All 2 branches covered.">		if (w instanceof WeightsBool)</span>
<span class="fc" id="L1582">			return boolean.class;</span>
<span class="fc bfc" id="L1583" title="All 2 branches covered.">		if (w instanceof WeightsChar)</span>
<span class="fc" id="L1584">			return char.class;</span>
<span class="pc bpc" id="L1585" title="1 of 2 branches missed.">		if (w instanceof WeightsObj)</span>
<span class="fc" id="L1586">			return Object.class;</span>
<span class="nc" id="L1587">		throw new AssertionError();</span>
	}

	/**
	 * Get a random vertex from the given graph.
	 *
	 * @param  &lt;V&gt;  the vertices type
	 * @param  g    the graph
	 * @param  rand the random number generator
	 * @return      a random vertex from the given graph
	 */
	public static &lt;V&gt; V randVertex(Graph&lt;V, ?&gt; g, Random rand) {
<span class="fc" id="L1599">		return g.indexGraphVerticesMap().indexToId(rand.nextInt(g.vertices().size()));</span>
	}

	/**
	 * Get a random vertex from the given int graph.
	 *
	 * @param  g    the graph
	 * @param  rand the random number generator
	 * @return      a random vertex from the given graph
	 */
	public static int randVertex(IntGraph g, Random rand) {
<span class="fc" id="L1610">		return g.indexGraphVerticesMap().indexToIdInt(rand.nextInt(g.vertices().size()));</span>
	}

	/**
	 * Get a random edge from the given graph.
	 *
	 * @param  &lt;E&gt;  the edges type
	 * @param  g    the graph
	 * @param  rand the random number generator
	 * @return      a random edge from the given graph
	 */
	public static &lt;E&gt; E randEdge(Graph&lt;?, E&gt; g, Random rand) {
<span class="fc" id="L1622">		return g.indexGraphEdgesMap().indexToId(rand.nextInt(g.edges().size()));</span>
	}

	/**
	 * Get a random edge from the given int graph.
	 *
	 * @param  g    the graph
	 * @param  rand the random number generator
	 * @return      a random edge from the given graph
	 */
	public static int randEdge(IntGraph g, Random rand) {
<span class="fc" id="L1633">		return g.indexGraphEdgesMap().indexToIdInt(rand.nextInt(g.edges().size()));</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>