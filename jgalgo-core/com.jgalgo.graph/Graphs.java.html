<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Graphs.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.graph</a> &gt; <span class="el_source">Graphs.java</span></div><h1>Graphs.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.graph;

import static com.jgalgo.internal.util.Range.range;
import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.Random;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.IntConsumer;
import java.util.function.ObjIntConsumer;
import com.jgalgo.internal.util.Assertions;
import com.jgalgo.internal.util.IntAdapters;
import it.unimi.dsi.fastutil.ints.AbstractIntSet;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntIterables;
import it.unimi.dsi.fastutil.ints.IntIterator;
import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
import it.unimi.dsi.fastutil.ints.IntSet;
import it.unimi.dsi.fastutil.ints.IntSets;
import it.unimi.dsi.fastutil.objects.ObjectArrayList;
import it.unimi.dsi.fastutil.objects.ObjectSets;

/**
 * Static methods class for graphs.
 *
 * @author Barak Ugav
 */
public class Graphs {
	private Graphs() {}

	static &lt;V, E&gt; Graph&lt;V, E&gt; copy(Graph&lt;V, E&gt; g, boolean copyVerticesWeights, boolean copyEdgesWeights) {
<span class="fc" id="L49">		return factoryForCopy(g).newCopyOf(g, copyVerticesWeights, copyEdgesWeights);</span>
	}

	static &lt;V, E&gt; Graph&lt;V, E&gt; immutableCopy(Graph&lt;V, E&gt; g, boolean copyVerticesWeights, boolean copyEdgesWeights) {
<span class="fc" id="L53">		return factoryForCopy(g).newImmutableCopyOf(g, copyVerticesWeights, copyEdgesWeights);</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	private static &lt;V, E&gt; GraphFactory&lt;V, E&gt; factoryForCopy(Graph&lt;V, E&gt; g) {
		GraphFactory&lt;V, E&gt; factory;
<span class="fc bfc" id="L59" title="All 2 branches covered.">		if (g instanceof IndexGraph) {</span>
<span class="fc" id="L60">			factory = (GraphFactory&lt;V, E&gt;) IndexGraphFactory.newInstance(g.isDirected());</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">		} else if (g instanceof IntGraph) {</span>
<span class="fc" id="L62">			factory = (GraphFactory&lt;V, E&gt;) IntGraphFactory.newInstance(g.isDirected());</span>
		} else {
<span class="fc" id="L64">			factory = GraphFactory.newInstance(g.isDirected());</span>
		}
<span class="fc bfc" id="L66" title="All 2 branches covered.">		if (g.isAllowSelfEdges())</span>
<span class="fc" id="L67">			factory.allowSelfEdges();</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">		if (g.isAllowParallelEdges())</span>
<span class="fc" id="L69">			factory.allowParallelEdges();</span>
<span class="fc" id="L70">		return factory;</span>
	}

	/**
	 * Tag interface for graphs that can not be muted/changed/altered.
	 *
	 * @author Barak Ugav
	 */
	static interface ImmutableGraph {
	}

	static class EdgeSetSourceTargetSingleEdge extends AbstractIntSet implements IEdgeSet {

		private final IndexGraph g;
		private final int source, target;
		private int edge;
		private static final int EdgeNone = -1;

<span class="fc" id="L88">		EdgeSetSourceTargetSingleEdge(IndexGraph g, int source, int target, int edge) {</span>
<span class="fc" id="L89">			this.g = g;</span>
<span class="fc" id="L90">			this.source = source;</span>
<span class="fc" id="L91">			this.target = target;</span>
<span class="fc" id="L92">			this.edge = edge;</span>
<span class="fc" id="L93">		}</span>

		@Override
		public boolean remove(int edge) {
<span class="fc bfc" id="L97" title="All 2 branches covered.">			if (!contains(edge))</span>
<span class="fc" id="L98">				return false;</span>
<span class="fc" id="L99">			g.removeEdge(edge);</span>
<span class="fc" id="L100">			this.edge = EdgeNone;</span>
<span class="fc" id="L101">			return true;</span>
		}

		@Override
		public boolean contains(int edge) {
<span class="fc bfc" id="L106" title="All 4 branches covered.">			return this.edge != EdgeNone &amp;&amp; this.edge == edge;</span>
		}

		@Override
		public int size() {
<span class="fc bfc" id="L111" title="All 2 branches covered.">			return edge != EdgeNone ? 1 : 0;</span>
		}

		@Override
		public void clear() {
<span class="fc bfc" id="L116" title="All 2 branches covered.">			if (edge != EdgeNone) {</span>
<span class="fc" id="L117">				g.removeEdge(edge);</span>
<span class="fc" id="L118">				edge = EdgeNone;</span>
			}
<span class="fc" id="L120">		}</span>

		@Override
		public IEdgeIter iterator() {
<span class="fc" id="L124">			return new IEdgeIter() {</span>

<span class="fc bfc" id="L126" title="All 2 branches covered.">				boolean beforeNext = edge != EdgeNone;</span>

				@Override
				public boolean hasNext() {
<span class="fc" id="L130">					return beforeNext;</span>
				}

				@Override
				public int nextInt() {
<span class="fc" id="L135">					Assertions.hasNext(this);</span>
<span class="fc" id="L136">					beforeNext = false;</span>
<span class="fc" id="L137">					return edge;</span>
				}

				@Override
				public int peekNextInt() {
<span class="fc" id="L142">					Assertions.hasNext(this);</span>
<span class="fc" id="L143">					return edge;</span>
				}

				@Override
				public int sourceInt() {
<span class="fc" id="L148">					return source;</span>
				}

				@Override
				public int targetInt() {
<span class="fc" id="L153">					return target;</span>
				}

				@Override
				public void remove() {
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">					if (beforeNext)</span>
<span class="nc" id="L159">						throw new IllegalStateException();</span>
<span class="fc" id="L160">					g.removeEdge(edge);</span>
<span class="fc" id="L161">					edge = EdgeNone;</span>
<span class="fc" id="L162">				}</span>
			};
		}
	}

	/**
	 * Create a new graph that is an induced subgraph of the given graph.
	 *
	 * &lt;p&gt;
	 * An induced subgraph of a graph \(G=(V,E)\) is a graph \(G'=(V',E')\) where \(V' \subseteq V\) and \(E' =
	 * \{\{u,v\} \mid u,v \in V', \{u,v\} \in E\}\). The created graph will have the same type (directed/undirected) as
	 * the given graph. The vertices and edges of the created graph will be a subset of the vertices and edges of the
	 * given graph.
	 *
	 * &lt;p&gt;
	 * The weights of both vertices and edges will not be copied to the new sub graph. For more flexible sub graph
	 * creation, see {@link #subGraph(Graph, Collection, Collection, boolean, boolean)}.
	 *
	 * &lt;p&gt;
	 * If {@code g} is {@link IntGraph}, the returned sub graph is also an {@link IntGraph}.
	 *
	 * @param  &lt;V&gt;      the vertices type
	 * @param  &lt;E&gt;      the edges type
	 * @param  g        the graph to create a sub graph from
	 * @param  vertices the vertices of the sub graph
	 * @return          a new graph that is an induced subgraph of the given graph
	 */
	public static &lt;V, E&gt; Graph&lt;V, E&gt; subGraph(Graph&lt;V, E&gt; g, Collection&lt;V&gt; vertices) {
<span class="fc" id="L190">		return subGraph(g, Objects.requireNonNull(vertices), null);</span>
	}

	/**
	 * Create a new graph that is a subgraph of the given graph.
	 *
	 * &lt;p&gt;
	 * If {@code edges} is {@code null}, then the created graph will be an induced subgraph of the given graph, namely
	 * an induced subgraph of a graph \(G=(V,E)\) is a graph \(G'=(V',E')\) where \(V' \subseteq V\) and \(E' =
	 * \{\{u,v\} \mid u,v \in V', \{u,v\} \in E\}\). The behavior is similar to {@link #subGraph(Graph, Collection)}.
	 * {@code vertices} must not be {@code null} in this case.
	 *
	 * &lt;p&gt;
	 * If {@code vertices} is {@code null}, then {@code edges} must not be {@code null}, and the sub graph will contain
	 * all the vertices which are either a source or a target of an edge in {@code edges}.
	 *
	 * &lt;p&gt;
	 * The created graph will have the same type (directed/undirected) as the given graph. The vertices and edges of the
	 * created graph will be a subset of the vertices and edges of the given graph.
	 *
	 * &lt;p&gt;
	 * The weights of both vertices and edges will not be copied to the new sub graph. For more flexible sub graph
	 * creation, see {@link #subGraph(Graph, Collection, Collection, boolean, boolean)}.
	 *
	 * &lt;p&gt;
	 * If {@code g} is {@link IntGraph}, the returned sub graph is also an {@link IntGraph}.
	 *
	 * @param  &lt;V&gt;                  the vertices type
	 * @param  &lt;E&gt;                  the edges type
	 * @param  g                    the graph to create a sub graph from
	 * @param  vertices             the vertices of the sub graph, if {@code null} then {@code edges} must not be
	 *                                  {@code null} and the vertices of the sub graph will be all the vertices which
	 *                                  are either a source or a target of an edge in {@code edges}
	 * @param  edges                the edges of the sub graph, if {@code null} then {@code vertices} must not be
	 *                                  {@code null} and the sub graph will be an induced subgraph of the given graph
	 * @return                      a new graph that is a subgraph of the given graph
	 * @throws NullPointerException if both {@code vertices} and {@code edges} are {@code null}
	 */
	public static &lt;V, E&gt; Graph&lt;V, E&gt; subGraph(Graph&lt;V, E&gt; g, Collection&lt;V&gt; vertices, Collection&lt;E&gt; edges) {
<span class="fc" id="L229">		return subGraph(g, vertices, edges, false, false);</span>
	}

	/**
	 * Create a new graph that is a subgraph of the given graph, with option to copy weights.
	 *
	 * &lt;p&gt;
	 * If {@code edges} is {@code null}, then the created graph will be an induced subgraph of the given graph, namely
	 * an induced subgraph of a graph \(G=(V,E)\) is a graph \(G'=(V',E')\) where \(V' \subseteq V\) and \(E' =
	 * \{\{u,v\} \mid u,v \in V', \{u,v\} \in E\}\). The behavior is similar to {@link #subGraph(Graph, Collection)}.
	 * {@code vertices} must not be {@code null} in this case.
	 *
	 * &lt;p&gt;
	 * If {@code vertices} is {@code null}, then {@code edges} must not be {@code null}, and the sub graph will contain
	 * all the vertices which are either a source or a target of an edge in {@code edges}.
	 *
	 * &lt;p&gt;
	 * The created graph will have the same type (directed/undirected) as the given graph. The vertices and edges of the
	 * created graph will be a subset of the vertices and edges of the given graph.
	 *
	 * &lt;p&gt;
	 * An additional parameter options for copying the weights of the vertices and edges of the given graph to the new
	 * sub graph are provided. If {@code copyVerticesWeights} is {@code true}, then all the vertices weights of the
	 * given graph will be copied to the new sub graph. If {@code copyEdgesWeights} is {@code true}, then all the edges
	 * weights of the given graph will be copied to the new sub graph.
	 *
	 * &lt;p&gt;
	 * If {@code g} is {@link IntGraph}, the returned sub graph is also an {@link IntGraph}.
	 *
	 * @param  &lt;V&gt;                  the vertices type
	 * @param  &lt;E&gt;                  the edges type
	 * @param  g                    the graph to create a sub graph from
	 * @param  vertices             the vertices of the sub graph, if {@code null} then {@code edges} must not be
	 *                                  {@code null} and the vertices of the sub graph will be all the vertices which
	 *                                  are either a source or a target of an edge in {@code edges}
	 * @param  edges                the edges of the sub graph, if {@code null} then {@code vertices} must not be
	 *                                  {@code null} and the sub graph will be an induced subgraph of the given graph
	 * @param  copyVerticesWeights  if {@code true} then all the vertices weights of the given graph will be copied to
	 *                                  the new sub graph
	 * @param  copyEdgesWeights     if {@code true} then all the edges weights of the given graph will be copied to the
	 *                                  new sub graph
	 * @return                      a new graph that is a subgraph of the given graph
	 * @throws NullPointerException if both {@code vertices} and {@code edges} are {@code null}
	 */
	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot;, &quot;cast&quot; })
	public static &lt;V, E&gt; Graph&lt;V, E&gt; subGraph(Graph&lt;V, E&gt; g, Collection&lt;V&gt; vertices, Collection&lt;E&gt; edges,
			boolean copyVerticesWeights, boolean copyEdgesWeights) {
<span class="fc bfc" id="L276" title="All 2 branches covered.">		if (g instanceof IntGraph) {</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">			IntCollection vs = vertices == null ? null : IntAdapters.asIntCollection((Collection&lt;Integer&gt;) vertices);</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">			IntCollection es = edges == null ? null : IntAdapters.asIntCollection((Collection&lt;Integer&gt;) edges);</span>
<span class="fc" id="L279">			return (Graph&lt;V, E&gt;) subGraph((IntGraph) g, vs, es, copyVerticesWeights, copyEdgesWeights);</span>
		}
<span class="fc bfc" id="L281" title="All 4 branches covered.">		if (vertices == null &amp;&amp; edges == null)</span>
<span class="fc" id="L282">			throw new NullPointerException(&quot;Either vertices or edges can be null, not both.&quot;);</span>

<span class="fc" id="L284">		GraphBuilder&lt;V, E&gt; gb = GraphBuilder.newInstance(g.isDirected());</span>
<span class="fc" id="L285">		IndexGraph ig = g.indexGraph();</span>
<span class="fc" id="L286">		IndexIdMap&lt;V&gt; viMap = g.indexGraphVerticesMap();</span>
<span class="fc" id="L287">		IndexIdMap&lt;E&gt; eiMap = g.indexGraphEdgesMap();</span>

		IntCollection verticesIndices;
<span class="fc bfc" id="L290" title="All 2 branches covered.">		if (vertices == null) {</span>
<span class="fc" id="L291">			verticesIndices = new IntOpenHashSet();</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">			for (E e : edges) {</span>
<span class="fc" id="L293">				int eIdx = eiMap.idToIndex(e);</span>
<span class="fc" id="L294">				verticesIndices.add(ig.edgeSource(eIdx));</span>
<span class="fc" id="L295">				verticesIndices.add(ig.edgeTarget(eIdx));</span>
<span class="fc" id="L296">			}</span>
<span class="fc" id="L297">			vertices = IndexIdMaps.indexToIdCollection(verticesIndices, viMap);</span>
		} else {
<span class="fc" id="L299">			verticesIndices = IndexIdMaps.idToIndexCollection(vertices, viMap);</span>
		}
<span class="fc" id="L301">		gb.addVertices(vertices);</span>

<span class="fc bfc" id="L303" title="All 2 branches covered.">		if (edges != null) {</span>
<span class="fc" id="L304">			gb.ensureEdgeCapacity(edges.size());</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">			for (E e : edges) {</span>
<span class="fc" id="L306">				int eIdx = eiMap.idToIndex(e);</span>
<span class="fc" id="L307">				int uIdx = ig.edgeSource(eIdx), vIdx = ig.edgeTarget(eIdx);</span>
<span class="fc" id="L308">				V u = viMap.indexToId(uIdx), v = viMap.indexToId(vIdx);</span>
<span class="fc" id="L309">				gb.addEdge(u, v, e);</span>
<span class="fc" id="L310">			}</span>
		} else {
<span class="fc bfc" id="L312" title="All 2 branches covered.">			if (g.isDirected()) {</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">				for (int uIdx : verticesIndices) {</span>
<span class="fc" id="L314">					V u = viMap.indexToId(uIdx);</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">					for (IEdgeIter eit = ig.outEdges(uIdx).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L316">						int eIdx = eit.nextInt();</span>
<span class="fc" id="L317">						int vIdx = eit.targetInt();</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">						if (verticesIndices.contains(vIdx)) {</span>
<span class="fc" id="L319">							E e = eiMap.indexToId(eIdx);</span>
<span class="fc" id="L320">							V v = viMap.indexToId(vIdx);</span>
<span class="fc" id="L321">							gb.addEdge(u, v, e);</span>
						}
<span class="fc" id="L323">					}</span>
<span class="fc" id="L324">				}</span>
			} else {
<span class="fc bfc" id="L326" title="All 2 branches covered.">				for (int uIdx : verticesIndices) {</span>
<span class="fc" id="L327">					V u = viMap.indexToId(uIdx);</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">					for (IEdgeIter eit = ig.outEdges(uIdx).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L329">						int eIdx = eit.nextInt();</span>
<span class="fc" id="L330">						int vIdx = eit.targetInt();</span>
<span class="fc bfc" id="L331" title="All 4 branches covered.">						if (uIdx &lt;= vIdx &amp;&amp; verticesIndices.contains(vIdx)) {</span>
<span class="fc" id="L332">							E e = eiMap.indexToId(eIdx);</span>
<span class="fc" id="L333">							V v = viMap.indexToId(vIdx);</span>
<span class="fc" id="L334">							gb.addEdge(u, v, e);</span>
						}
<span class="fc" id="L336">					}</span>
<span class="fc" id="L337">				}</span>
			}
		}

<span class="fc bfc" id="L341" title="All 2 branches covered.">		if (copyVerticesWeights) {</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">			for (String key : g.verticesWeightsKeys()) {</span>
<span class="fc" id="L343">				Weights wSrc = g.verticesWeights(key);</span>
<span class="fc" id="L344">				Class&lt;?&gt; type = (Class) getWeightsType(wSrc);</span>
<span class="fc" id="L345">				Weights wDst = gb.addVerticesWeights(key, (Class) type, wSrc.defaultWeightAsObj());</span>
<span class="fc" id="L346">				copyWeights(wSrc, wDst, type, gb.vertices());</span>
<span class="fc" id="L347">			}</span>
		}
<span class="fc bfc" id="L349" title="All 2 branches covered.">		if (copyEdgesWeights) {</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">			for (String key : g.edgesWeightsKeys()) {</span>
<span class="fc" id="L351">				Weights wSrc = g.edgesWeights(key);</span>
<span class="fc" id="L352">				Class&lt;?&gt; type = (Class) getWeightsType(wSrc);</span>
<span class="fc" id="L353">				Weights wDst = gb.addEdgesWeights(key, (Class) type, wSrc.defaultWeightAsObj());</span>
<span class="fc" id="L354">				copyWeights(wSrc, wDst, type, gb.edges());</span>
<span class="fc" id="L355">			}</span>
		}

<span class="fc" id="L358">		return gb.build();</span>
	}

	/**
	 * Create a new graph that is a subgraph of the given int graph, with option to copy weights.
	 *
	 * &lt;p&gt;
	 * If {@code edges} is {@code null}, then the created graph will be an induced subgraph of the given graph, namely
	 * an induced subgraph of a graph \(G=(V,E)\) is a graph \(G'=(V',E')\) where \(V' \subseteq V\) and \(E' =
	 * \{\{u,v\} \mid u,v \in V', \{u,v\} \in E\}\).
	 *
	 * &lt;p&gt;
	 * If {@code vertices} is {@code null}, then {@code edges} must not be {@code null}, and the sub graph will contain
	 * all the vertices which are either a source or a target of an edge in {@code edges}.
	 *
	 * &lt;p&gt;
	 * The created graph will have the same type (directed/undirected) as the given graph. The vertices and edges of the
	 * created graph will be a subset of the vertices and edges of the given graph.
	 *
	 * &lt;p&gt;
	 * An additional parameter options for copying the weights of the vertices and edges of the given graph to the new
	 * sub graph are provided. If {@code copyVerticesWeights} is {@code true}, then all the vertices weights of the
	 * given graph will be copied to the new sub graph. If {@code copyEdgesWeights} is {@code true}, then all the edges
	 * weights of the given graph will be copied to the new sub graph.
	 *
	 * @param  g                    the graph to create a sub graph from
	 * @param  vertices             the vertices of the sub graph, if {@code null} then {@code edges} must not be
	 *                                  {@code null} and the vertices of the sub graph will be all the vertices which
	 *                                  are either a source or a target of an edge in {@code edges}
	 * @param  edges                the edges of the sub graph, if {@code null} then {@code vertices} must not be
	 *                                  {@code null} and the sub graph will be an induced subgraph of the given graph
	 * @param  copyVerticesWeights  if {@code true} then all the vertices weights of the given graph will be copied to
	 *                                  the new sub graph
	 * @param  copyEdgesWeights     if {@code true} then all the edges weights of the given graph will be copied to the
	 *                                  new sub graph
	 * @return                      a new graph that is a subgraph of the given graph
	 * @throws NullPointerException if both {@code vertices} and {@code edges} are {@code null}
	 */
	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot;, &quot;cast&quot; })
	public static IntGraph subGraph(IntGraph g, IntCollection vertices, IntCollection edges,
			boolean copyVerticesWeights, boolean copyEdgesWeights) {
<span class="fc bfc" id="L399" title="All 4 branches covered.">		if (vertices == null &amp;&amp; edges == null)</span>
<span class="fc" id="L400">			throw new NullPointerException(&quot;Either vertices or edges can be null, not both.&quot;);</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">		if (g instanceof IndexGraph)</span>
<span class="fc" id="L402">			return subGraph((IndexGraph) g, vertices, edges, copyVerticesWeights, copyEdgesWeights);</span>

<span class="fc" id="L404">		IntGraphBuilder gb = IntGraphBuilder.newInstance(g.isDirected());</span>
<span class="fc" id="L405">		IndexGraph ig = g.indexGraph();</span>
<span class="fc" id="L406">		IndexIntIdMap viMap = g.indexGraphVerticesMap();</span>
<span class="fc" id="L407">		IndexIntIdMap eiMap = g.indexGraphEdgesMap();</span>

		IntCollection verticesIndices;
<span class="fc bfc" id="L410" title="All 2 branches covered.">		if (vertices == null) {</span>
<span class="fc" id="L411">			verticesIndices = new IntOpenHashSet();</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">			for (int e : edges) {</span>
<span class="fc" id="L413">				int eIdx = eiMap.idToIndex(e);</span>
<span class="fc" id="L414">				verticesIndices.add(ig.edgeSource(eIdx));</span>
<span class="fc" id="L415">				verticesIndices.add(ig.edgeTarget(eIdx));</span>
<span class="fc" id="L416">			}</span>
<span class="fc" id="L417">			vertices = IndexIdMaps.indexToIdCollection(verticesIndices, viMap);</span>
		} else {
<span class="fc" id="L419">			verticesIndices = IndexIdMaps.idToIndexCollection(vertices, viMap);</span>
		}
<span class="fc" id="L421">		gb.addVertices(vertices);</span>

<span class="fc bfc" id="L423" title="All 2 branches covered.">		if (edges != null) {</span>
<span class="fc" id="L424">			gb.ensureEdgeCapacity(edges.size());</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">			for (int e : edges) {</span>
<span class="fc" id="L426">				int eIdx = eiMap.idToIndex(e);</span>
<span class="fc" id="L427">				int uIdx = ig.edgeSource(eIdx), vIdx = ig.edgeTarget(eIdx);</span>
<span class="fc" id="L428">				int u = viMap.indexToIdInt(uIdx), v = viMap.indexToIdInt(vIdx);</span>
<span class="fc" id="L429">				gb.addEdge(u, v, e);</span>
<span class="fc" id="L430">			}</span>
		} else {
<span class="fc bfc" id="L432" title="All 2 branches covered.">			if (g.isDirected()) {</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">				for (int uIdx : verticesIndices) {</span>
<span class="fc" id="L434">					int u = viMap.indexToIdInt(uIdx);</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">					for (IEdgeIter eit = ig.outEdges(uIdx).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L436">						int eIdx = eit.nextInt();</span>
<span class="fc" id="L437">						int vIdx = eit.targetInt();</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">						if (verticesIndices.contains(vIdx)) {</span>
<span class="fc" id="L439">							int e = eiMap.indexToIdInt(eIdx);</span>
<span class="fc" id="L440">							int v = viMap.indexToIdInt(vIdx);</span>
<span class="fc" id="L441">							gb.addEdge(u, v, e);</span>
						}
<span class="fc" id="L443">					}</span>
<span class="fc" id="L444">				}</span>
			} else {
<span class="fc bfc" id="L446" title="All 2 branches covered.">				for (int uIdx : verticesIndices) {</span>
<span class="fc" id="L447">					int u = viMap.indexToIdInt(uIdx);</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">					for (IEdgeIter eit = ig.outEdges(uIdx).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L449">						int eIdx = eit.nextInt();</span>
<span class="fc" id="L450">						int vIdx = eit.targetInt();</span>
<span class="fc bfc" id="L451" title="All 4 branches covered.">						if (uIdx &lt;= vIdx &amp;&amp; verticesIndices.contains(vIdx)) {</span>
<span class="fc" id="L452">							int e = eiMap.indexToIdInt(eIdx);</span>
<span class="fc" id="L453">							int v = viMap.indexToIdInt(vIdx);</span>
<span class="fc" id="L454">							gb.addEdge(u, v, e);</span>
						}
<span class="fc" id="L456">					}</span>
<span class="fc" id="L457">				}</span>
			}
		}

<span class="fc bfc" id="L461" title="All 2 branches covered.">		if (copyVerticesWeights) {</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">			for (String key : g.verticesWeightsKeys()) {</span>
<span class="fc" id="L463">				IWeights wSrc = g.verticesWeights(key);</span>
<span class="fc" id="L464">				Class&lt;?&gt; type = (Class) getWeightsType(wSrc);</span>
<span class="fc" id="L465">				IWeights wDst = (IWeights) gb.addVerticesWeights(key, (Class) type, wSrc.defaultWeightAsObj());</span>
<span class="fc" id="L466">				copyWeights(wSrc, wDst, type, gb.vertices());</span>
<span class="fc" id="L467">			}</span>
		}
<span class="fc bfc" id="L469" title="All 2 branches covered.">		if (copyEdgesWeights) {</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">			for (String key : g.edgesWeightsKeys()) {</span>
<span class="fc" id="L471">				IWeights wSrc = g.edgesWeights(key);</span>
<span class="fc" id="L472">				Class&lt;?&gt; type = (Class) getWeightsType(wSrc);</span>
<span class="fc" id="L473">				IWeights wDst = (IWeights) gb.addEdgesWeights(key, (Class) type, wSrc.defaultWeightAsObj());</span>
<span class="fc" id="L474">				copyWeights(wSrc, wDst, type, gb.edges());</span>
<span class="fc" id="L475">			}</span>
		}

<span class="fc" id="L478">		return gb.build();</span>
	}

	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot;, &quot;cast&quot; })
	private static IntGraph subGraph(IndexGraph g, IntCollection vertices, IntCollection edges,
			boolean copyVerticesWeights, boolean copyEdgesWeights) {
<span class="fc" id="L484">		IntGraphBuilder gb = IntGraphBuilder.newInstance(g.isDirected());</span>

<span class="fc bfc" id="L486" title="All 2 branches covered.">		if (vertices == null) {</span>
<span class="fc" id="L487">			vertices = new IntOpenHashSet();</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">			for (int e : edges) {</span>
<span class="fc" id="L489">				vertices.add(g.edgeSource(e));</span>
<span class="fc" id="L490">				vertices.add(g.edgeTarget(e));</span>
<span class="fc" id="L491">			}</span>
		}
<span class="fc" id="L493">		gb.addVertices(vertices);</span>

<span class="fc bfc" id="L495" title="All 2 branches covered.">		if (edges != null) {</span>
<span class="fc" id="L496">			gb.ensureEdgeCapacity(edges.size());</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">			for (int e : edges)</span>
<span class="fc" id="L498">				gb.addEdge(g.edgeSource(e), g.edgeTarget(e), e);</span>
		} else {
<span class="fc bfc" id="L500" title="All 2 branches covered.">			if (g.isDirected()) {</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">				for (int u : vertices) {</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">					for (IEdgeIter eit = g.outEdges(u).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L503">						int e = eit.nextInt();</span>
<span class="fc" id="L504">						int v = eit.targetInt();</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">						if (vertices.contains(v))</span>
<span class="fc" id="L506">							gb.addEdge(u, v, e);</span>
<span class="fc" id="L507">					}</span>
<span class="fc" id="L508">				}</span>
			} else {
<span class="fc bfc" id="L510" title="All 2 branches covered.">				for (int u : vertices) {</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">					for (IEdgeIter eit = g.outEdges(u).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L512">						int e = eit.nextInt();</span>
<span class="fc" id="L513">						int v = eit.targetInt();</span>
<span class="fc bfc" id="L514" title="All 4 branches covered.">						if (u &lt;= v &amp;&amp; vertices.contains(v))</span>
<span class="fc" id="L515">							gb.addEdge(u, v, e);</span>
<span class="fc" id="L516">					}</span>
<span class="fc" id="L517">				}</span>
			}
		}

<span class="fc bfc" id="L521" title="All 2 branches covered.">		if (copyVerticesWeights) {</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">			for (String key : g.verticesWeightsKeys()) {</span>
<span class="fc" id="L523">				IWeights wSrc = g.verticesWeights(key);</span>
<span class="fc" id="L524">				Class&lt;?&gt; type = (Class) getWeightsType(wSrc);</span>
<span class="fc" id="L525">				IWeights wDst = (IWeights) gb.addVerticesWeights(key, (Class) type, wSrc.defaultWeightAsObj());</span>
<span class="fc" id="L526">				copyWeights(wSrc, wDst, type, gb.vertices());</span>
<span class="fc" id="L527">			}</span>
		}
<span class="fc bfc" id="L529" title="All 2 branches covered.">		if (copyEdgesWeights) {</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">			for (String key : g.edgesWeightsKeys()) {</span>
<span class="fc" id="L531">				IWeights wSrc = g.edgesWeights(key);</span>
<span class="fc" id="L532">				Class&lt;?&gt; type = (Class) getWeightsType(wSrc);</span>
<span class="fc" id="L533">				IWeights wDst = (IWeights) gb.addEdgesWeights(key, (Class) type, wSrc.defaultWeightAsObj());</span>
<span class="fc" id="L534">				copyWeights(wSrc, wDst, type, gb.edges());</span>
<span class="fc" id="L535">			}</span>
		}

<span class="fc" id="L538">		return gb.build();</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	private static &lt;K&gt; void copyWeights(Weights&lt;K, ?&gt; src, Weights&lt;K, ?&gt; dst, Class&lt;?&gt; type, Collection&lt;K&gt; elements) {
<span class="fc bfc" id="L543" title="All 2 branches covered.">		if (type == byte.class) {</span>
<span class="fc" id="L544">			WeightsByte&lt;K&gt; src0 = (WeightsByte&lt;K&gt;) src;</span>
<span class="fc" id="L545">			WeightsByte&lt;K&gt; dst0 = (WeightsByte&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L547">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">		} else if (type == short.class) {</span>
<span class="fc" id="L549">			WeightsShort&lt;K&gt; src0 = (WeightsShort&lt;K&gt;) src;</span>
<span class="fc" id="L550">			WeightsShort&lt;K&gt; dst0 = (WeightsShort&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L552">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">		} else if (type == int.class) {</span>
<span class="fc" id="L554">			WeightsInt&lt;K&gt; src0 = (WeightsInt&lt;K&gt;) src;</span>
<span class="fc" id="L555">			WeightsInt&lt;K&gt; dst0 = (WeightsInt&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L557">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">		} else if (type == long.class) {</span>
<span class="fc" id="L559">			WeightsLong&lt;K&gt; src0 = (WeightsLong&lt;K&gt;) src;</span>
<span class="fc" id="L560">			WeightsLong&lt;K&gt; dst0 = (WeightsLong&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L562">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">		} else if (type == float.class) {</span>
<span class="fc" id="L564">			WeightsFloat&lt;K&gt; src0 = (WeightsFloat&lt;K&gt;) src;</span>
<span class="fc" id="L565">			WeightsFloat&lt;K&gt; dst0 = (WeightsFloat&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L567">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">		} else if (type == double.class) {</span>
<span class="fc" id="L569">			WeightsDouble&lt;K&gt; src0 = (WeightsDouble&lt;K&gt;) src;</span>
<span class="fc" id="L570">			WeightsDouble&lt;K&gt; dst0 = (WeightsDouble&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L572">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">		} else if (type == boolean.class) {</span>
<span class="fc" id="L574">			WeightsBool&lt;K&gt; src0 = (WeightsBool&lt;K&gt;) src;</span>
<span class="fc" id="L575">			WeightsBool&lt;K&gt; dst0 = (WeightsBool&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L577">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">		} else if (type == char.class) {</span>
<span class="fc" id="L579">			WeightsChar&lt;K&gt; src0 = (WeightsChar&lt;K&gt;) src;</span>
<span class="fc" id="L580">			WeightsChar&lt;K&gt; dst0 = (WeightsChar&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L581" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L582">				dst0.set(elm, src0.get(elm));</span>
<span class="fc" id="L583">		} else {</span>
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">			assert type == Object.class;</span>
<span class="fc" id="L585">			WeightsObj&lt;K, Object&gt; src0 = (WeightsObj&lt;K, Object&gt;) src;</span>
<span class="fc" id="L586">			WeightsObj&lt;K, Object&gt; dst0 = (WeightsObj&lt;K, Object&gt;) dst;</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L588">				dst0.set(elm, src0.get(elm));</span>
		}
<span class="fc" id="L590">	}</span>

	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
	private static void copyWeights(IWeights&lt;?&gt; src, IWeights&lt;?&gt; dst, Class&lt;?&gt; type, IntCollection elements) {
<span class="fc bfc" id="L594" title="All 2 branches covered.">		if (type == byte.class) {</span>
<span class="fc" id="L595">			IWeightsByte src0 = (IWeightsByte) src;</span>
<span class="fc" id="L596">			IWeightsByte dst0 = (IWeightsByte) dst;</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L598">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">		} else if (type == short.class) {</span>
<span class="fc" id="L600">			IWeightsShort src0 = (IWeightsShort) src;</span>
<span class="fc" id="L601">			IWeightsShort dst0 = (IWeightsShort) dst;</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L603">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">		} else if (type == int.class) {</span>
<span class="fc" id="L605">			IWeightsInt src0 = (IWeightsInt) src;</span>
<span class="fc" id="L606">			IWeightsInt dst0 = (IWeightsInt) dst;</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L608">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">		} else if (type == long.class) {</span>
<span class="fc" id="L610">			IWeightsLong src0 = (IWeightsLong) src;</span>
<span class="fc" id="L611">			IWeightsLong dst0 = (IWeightsLong) dst;</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L613">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">		} else if (type == float.class) {</span>
<span class="fc" id="L615">			IWeightsFloat src0 = (IWeightsFloat) src;</span>
<span class="fc" id="L616">			IWeightsFloat dst0 = (IWeightsFloat) dst;</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L618">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L619" title="All 2 branches covered.">		} else if (type == double.class) {</span>
<span class="fc" id="L620">			IWeightsDouble src0 = (IWeightsDouble) src;</span>
<span class="fc" id="L621">			IWeightsDouble dst0 = (IWeightsDouble) dst;</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L623">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">		} else if (type == boolean.class) {</span>
<span class="fc" id="L625">			IWeightsBool src0 = (IWeightsBool) src;</span>
<span class="fc" id="L626">			IWeightsBool dst0 = (IWeightsBool) dst;</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L628">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">		} else if (type == char.class) {</span>
<span class="fc" id="L630">			IWeightsChar src0 = (IWeightsChar) src;</span>
<span class="fc" id="L631">			IWeightsChar dst0 = (IWeightsChar) dst;</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L633">				dst0.set(elm, src0.get(elm));</span>
<span class="fc" id="L634">		} else {</span>
<span class="pc bpc" id="L635" title="1 of 2 branches missed.">			assert type == Object.class;</span>
<span class="fc" id="L636">			IWeightsObj src0 = (IWeightsObj) src;</span>
<span class="fc" id="L637">			IWeightsObj dst0 = (IWeightsObj) dst;</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L639">				dst0.set(elm, src0.get(elm));</span>
		}
<span class="fc" id="L641">	}</span>

	private static Class&lt;?&gt; getWeightsType(Weights&lt;?, ?&gt; w) {
<span class="fc bfc" id="L644" title="All 2 branches covered.">		if (w instanceof WeightsByte)</span>
<span class="fc" id="L645">			return byte.class;</span>
<span class="fc bfc" id="L646" title="All 2 branches covered.">		if (w instanceof WeightsShort)</span>
<span class="fc" id="L647">			return short.class;</span>
<span class="fc bfc" id="L648" title="All 2 branches covered.">		if (w instanceof WeightsInt)</span>
<span class="fc" id="L649">			return int.class;</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">		if (w instanceof WeightsLong)</span>
<span class="fc" id="L651">			return long.class;</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">		if (w instanceof WeightsFloat)</span>
<span class="fc" id="L653">			return float.class;</span>
<span class="fc bfc" id="L654" title="All 2 branches covered.">		if (w instanceof WeightsDouble)</span>
<span class="fc" id="L655">			return double.class;</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">		if (w instanceof WeightsBool)</span>
<span class="fc" id="L657">			return boolean.class;</span>
<span class="fc bfc" id="L658" title="All 2 branches covered.">		if (w instanceof WeightsChar)</span>
<span class="fc" id="L659">			return char.class;</span>
<span class="pc bpc" id="L660" title="1 of 2 branches missed.">		assert w instanceof WeightsObj;</span>
<span class="fc" id="L661">		return Object.class;</span>
	}

	/**
	 * Get a random vertex from the given graph.
	 *
	 * @param  &lt;V&gt;                      the vertices type
	 * @param  g                        the graph
	 * @param  rand                     the random number generator
	 * @return                          a random vertex from the given graph
	 * @throws IllegalArgumentException if the graph is contains no vertices
	 */
	public static &lt;V&gt; V randVertex(Graph&lt;V, ?&gt; g, Random rand) {
<span class="fc" id="L674">		int n = g.vertices().size();</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">		if (n == 0)</span>
<span class="fc" id="L676">			throw new IllegalArgumentException(&quot;Can't choose a random graph from a graph without vertices&quot;);</span>
<span class="fc" id="L677">		return g.indexGraphVerticesMap().indexToId(rand.nextInt(n));</span>
	}

	/**
	 * Get a random vertex from the given int graph.
	 *
	 * @param  g                        the graph
	 * @param  rand                     the random number generator
	 * @return                          a random vertex from the given graph
	 * @throws IllegalArgumentException if the graph is contains no vertices
	 */
	public static int randVertex(IntGraph g, Random rand) {
<span class="fc" id="L689">		int n = g.vertices().size();</span>
<span class="fc bfc" id="L690" title="All 2 branches covered.">		if (n == 0)</span>
<span class="fc" id="L691">			throw new IllegalArgumentException(&quot;Can't choose a random graph from a graph without vertices&quot;);</span>
<span class="fc" id="L692">		return g.indexGraphVerticesMap().indexToIdInt(rand.nextInt(n));</span>
	}

	/**
	 * Get a random edge from the given graph.
	 *
	 * @param  &lt;E&gt;                      the edges type
	 * @param  g                        the graph
	 * @param  rand                     the random number generator
	 * @return                          a random edge from the given graph
	 * @throws IllegalArgumentException if the graph is contains no edges
	 */
	public static &lt;E&gt; E randEdge(Graph&lt;?, E&gt; g, Random rand) {
<span class="fc" id="L705">		int m = g.edges().size();</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">		if (m == 0)</span>
<span class="fc" id="L707">			throw new IllegalArgumentException(&quot;Can't choose a random graph from a graph without edges&quot;);</span>
<span class="fc" id="L708">		return g.indexGraphEdgesMap().indexToId(rand.nextInt(m));</span>
	}

	/**
	 * Get a random edge from the given int graph.
	 *
	 * @param  g                        the graph
	 * @param  rand                     the random number generator
	 * @return                          a random edge from the given graph
	 * @throws IllegalArgumentException if the graph is contains no edges
	 */
	public static int randEdge(IntGraph g, Random rand) {
<span class="fc" id="L720">		int m = g.edges().size();</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">		if (m == 0)</span>
<span class="fc" id="L722">			throw new IllegalArgumentException(&quot;Can't choose a random graph from a graph without edges&quot;);</span>
<span class="fc" id="L723">		return g.indexGraphEdgesMap().indexToIdInt(rand.nextInt(m));</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	static boolean isEquals(Graph&lt;?, ?&gt; g1, Graph&lt;?, ?&gt; g2) {
<span class="fc bfc" id="L728" title="All 2 branches covered.">		if (g1 == g2)</span>
<span class="fc" id="L729">			return true;</span>
<span class="fc bfc" id="L730" title="All 4 branches covered.">		if (g1 instanceof IntGraph &amp;&amp; g2 instanceof IntGraph)</span>
<span class="fc" id="L731">			return isEquals((IntGraph) g1, (IntGraph) g2);</span>

<span class="fc bfc" id="L733" title="All 2 branches covered.">		if (g1.isDirected() != g2.isDirected())</span>
<span class="fc" id="L734">			return false;</span>
<span class="fc bfc" id="L735" title="All 2 branches covered.">		if (!g1.vertices().equals(g2.vertices()))</span>
<span class="fc" id="L736">			return false;</span>
<span class="fc bfc" id="L737" title="All 2 branches covered.">		if (!g1.edges().equals(g2.edges()))</span>
<span class="fc" id="L738">			return false;</span>
<span class="fc" id="L739">		Graph&lt;Object, Object&gt; g10 = (Graph&lt;Object, Object&gt;) g1, g20 = (Graph&lt;Object, Object&gt;) g2;</span>
<span class="fc" id="L740">		return isEquals0(g10, g20);</span>
	}

	private static &lt;V, E&gt; boolean isEquals0(Graph&lt;V, E&gt; g1, Graph&lt;V, E&gt; g2) {
<span class="fc bfc" id="L744" title="All 2 branches covered.">		if (g1.isDirected()) {</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">			for (E e : g1.edges())</span>
<span class="pc bpc" id="L746" title="1 of 4 branches missed.">				if (!g1.edgeSource(e).equals(g2.edgeSource(e)) || !g1.edgeTarget(e).equals(g2.edgeTarget(e)))</span>
<span class="fc" id="L747">					return false;</span>
		} else {
<span class="fc bfc" id="L749" title="All 2 branches covered.">			for (E e : g1.edges()) {</span>
<span class="fc" id="L750">				V s1 = g1.edgeSource(e), t1 = g1.edgeTarget(e);</span>
<span class="fc" id="L751">				V s2 = g2.edgeSource(e), t2 = g2.edgeTarget(e);</span>
<span class="pc bpc" id="L752" title="4 of 8 branches missed.">				if (!(s1.equals(s2) &amp;&amp; t1.equals(t2)) &amp;&amp; !(s1.equals(t2) &amp;&amp; t1.equals(s2)))</span>
<span class="fc" id="L753">					return false;</span>
<span class="fc" id="L754">			}</span>
		}

<span class="fc bfc" id="L757" title="All 2 branches covered.">		if (!g1.verticesWeightsKeys().equals(g2.verticesWeightsKeys()))</span>
<span class="fc" id="L758">			return false;</span>
<span class="fc bfc" id="L759" title="All 2 branches covered.">		for (String key : g1.verticesWeightsKeys()) {</span>
<span class="fc" id="L760">			Weights&lt;V, ?&gt; w1 = g1.verticesWeights(key), w2 = g2.verticesWeights(key);</span>
<span class="fc bfc" id="L761" title="All 2 branches covered.">			if (!WeightsImpl.isEqual(g1.vertices(), w1, w2))</span>
<span class="fc" id="L762">				return false;</span>
<span class="fc" id="L763">		}</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">		if (!g1.edgesWeightsKeys().equals(g2.edgesWeightsKeys()))</span>
<span class="fc" id="L765">			return false;</span>
<span class="fc bfc" id="L766" title="All 2 branches covered.">		for (String key : g1.edgesWeightsKeys()) {</span>
<span class="fc" id="L767">			Weights&lt;E, ?&gt; w1 = g1.edgesWeights(key), w2 = g2.edgesWeights(key);</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">			if (!WeightsImpl.isEqual(g1.edges(), w1, w2))</span>
<span class="fc" id="L769">				return false;</span>
<span class="fc" id="L770">		}</span>

<span class="fc" id="L772">		return true;</span>
	}

	private static boolean isEquals(IntGraph g1, IntGraph g2) {
<span class="fc bfc" id="L776" title="All 2 branches covered.">		if (g1.isDirected() != g2.isDirected())</span>
<span class="fc" id="L777">			return false;</span>
<span class="fc bfc" id="L778" title="All 2 branches covered.">		if (!g1.vertices().equals(g2.vertices()))</span>
<span class="fc" id="L779">			return false;</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">		if (!g1.edges().equals(g2.edges()))</span>
<span class="fc" id="L781">			return false;</span>
<span class="fc bfc" id="L782" title="All 2 branches covered.">		if (g1.isDirected()) {</span>
<span class="fc bfc" id="L783" title="All 2 branches covered.">			for (int e : g1.edges())</span>
<span class="pc bpc" id="L784" title="1 of 4 branches missed.">				if (g1.edgeSource(e) != g2.edgeSource(e) || g1.edgeTarget(e) != g2.edgeTarget(e))</span>
<span class="fc" id="L785">					return false;</span>
		} else {
<span class="fc bfc" id="L787" title="All 2 branches covered.">			for (int e : g1.edges()) {</span>
<span class="fc" id="L788">				int s1 = g1.edgeSource(e), t1 = g1.edgeTarget(e);</span>
<span class="fc" id="L789">				int s2 = g2.edgeSource(e), t2 = g2.edgeTarget(e);</span>
<span class="pc bpc" id="L790" title="1 of 8 branches missed.">				if (!(s1 == s2 &amp;&amp; t1 == t2) &amp;&amp; !(s1 == t2 &amp;&amp; t1 == s2))</span>
<span class="fc" id="L791">					return false;</span>
<span class="fc" id="L792">			}</span>
		}

<span class="fc bfc" id="L795" title="All 2 branches covered.">		if (!g1.verticesWeightsKeys().equals(g2.verticesWeightsKeys()))</span>
<span class="fc" id="L796">			return false;</span>
<span class="fc bfc" id="L797" title="All 2 branches covered.">		for (String key : g1.verticesWeightsKeys()) {</span>
<span class="fc" id="L798">			IWeights&lt;?&gt; w1 = (IWeights&lt;?&gt;) g1.verticesWeights(key), w2 = (IWeights&lt;?&gt;) g2.verticesWeights(key);</span>
<span class="fc bfc" id="L799" title="All 2 branches covered.">			if (!WeightsImpl.isEqual(g1.vertices(), w1, w2))</span>
<span class="fc" id="L800">				return false;</span>
<span class="fc" id="L801">		}</span>
<span class="fc bfc" id="L802" title="All 2 branches covered.">		if (!g1.edgesWeightsKeys().equals(g2.edgesWeightsKeys()))</span>
<span class="fc" id="L803">			return false;</span>
<span class="fc bfc" id="L804" title="All 2 branches covered.">		for (String key : g1.edgesWeightsKeys()) {</span>
<span class="fc" id="L805">			IWeights&lt;?&gt; w1 = (IWeights&lt;?&gt;) g1.edgesWeights(key), w2 = (IWeights&lt;?&gt;) g2.edgesWeights(key);</span>
<span class="fc bfc" id="L806" title="All 2 branches covered.">			if (!WeightsImpl.isEqual(g1.edges(), w1, w2))</span>
<span class="fc" id="L807">				return false;</span>
<span class="fc" id="L808">		}</span>

<span class="fc" id="L810">		return true;</span>
	}

	static &lt;V, E&gt; int hashCode(Graph&lt;V, E&gt; g) {
<span class="fc bfc" id="L814" title="All 2 branches covered.">		if (g instanceof IntGraph)</span>
<span class="fc" id="L815">			return hashCode((IntGraph) g);</span>

<span class="fc" id="L817">		int h = Boolean.hashCode(g.isDirected());</span>
<span class="fc" id="L818">		h += g.vertices().hashCode();</span>
<span class="fc" id="L819">		h += g.edges().hashCode();</span>
<span class="fc bfc" id="L820" title="All 2 branches covered.">		if (g.isDirected()) {</span>
<span class="fc bfc" id="L821" title="All 2 branches covered.">			for (E e : g.edges())</span>
<span class="fc" id="L822">				h += g.edgeSource(e).hashCode() + 31 * g.edgeTarget(e).hashCode();</span>
		} else {
<span class="fc bfc" id="L824" title="All 2 branches covered.">			for (E e : g.edges())</span>
<span class="fc" id="L825">				h += g.edgeSource(e).hashCode() + g.edgeTarget(e).hashCode();</span>
		}
<span class="fc bfc" id="L827" title="All 2 branches covered.">		for (String key : g.verticesWeightsKeys())</span>
<span class="fc" id="L828">			h += WeightsImpl.hashCode(g.vertices(), g.verticesWeights(key));</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">		for (String key : g.edgesWeightsKeys())</span>
<span class="fc" id="L830">			h += WeightsImpl.hashCode(g.edges(), g.edgesWeights(key));</span>
<span class="fc" id="L831">		return h;</span>
	}

	private static int hashCode(IntGraph g) {
<span class="fc" id="L835">		int h = Boolean.hashCode(g.isDirected());</span>
<span class="fc" id="L836">		h += g.vertices().hashCode();</span>
<span class="fc" id="L837">		h += g.edges().hashCode();</span>
<span class="fc bfc" id="L838" title="All 2 branches covered.">		if (g.isDirected()) {</span>
<span class="fc bfc" id="L839" title="All 2 branches covered.">			for (int e : g.edges())</span>
<span class="fc" id="L840">				h += g.edgeSource(e) + 31 * g.edgeTarget(e);</span>
		} else {
<span class="fc bfc" id="L842" title="All 2 branches covered.">			for (int e : g.edges())</span>
<span class="fc" id="L843">				h += g.edgeSource(e) + g.edgeTarget(e);</span>
		}
<span class="fc bfc" id="L845" title="All 2 branches covered.">		for (String key : g.verticesWeightsKeys())</span>
<span class="fc" id="L846">			h += WeightsImpl.hashCode(g.vertices(), g.verticesWeights(key));</span>
<span class="fc bfc" id="L847" title="All 2 branches covered.">		for (String key : g.edgesWeightsKeys())</span>
<span class="fc" id="L848">			h += WeightsImpl.hashCode(g.edges(), g.edgesWeights(key));</span>
<span class="fc" id="L849">		return h;</span>
	}

	static &lt;V, E&gt; String toString(Graph&lt;V, E&gt; g) {
<span class="fc bfc" id="L853" title="All 2 branches covered.">		if (g instanceof IntGraph)</span>
<span class="fc" id="L854">			return toString((IntGraph) g);</span>

<span class="fc" id="L856">		StringBuilder s = new StringBuilder();</span>

<span class="fc" id="L858">		Set&lt;String&gt; verticesWeightsKeys = g.verticesWeightsKeys();</span>
<span class="fc" id="L859">		List&lt;Weights&lt;V, ?&gt;&gt; verticesWeights = new ObjectArrayList&lt;&gt;(verticesWeightsKeys.size());</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">		for (String key : verticesWeightsKeys)</span>
<span class="fc" id="L861">			verticesWeights.add(g.verticesWeights(key));</span>

<span class="fc" id="L863">		Set&lt;String&gt; edgesWeightsKeys = g.edgesWeightsKeys();</span>
<span class="fc" id="L864">		List&lt;Weights&lt;E, ?&gt;&gt; edgesWeights = new ObjectArrayList&lt;&gt;(edgesWeightsKeys.size());</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">		for (String key : edgesWeightsKeys)</span>
<span class="fc" id="L866">			edgesWeights.add(g.edgesWeights(key));</span>

<span class="fc" id="L868">		BiConsumer&lt;Collection&lt;Weights&lt;Object, ?&gt;&gt;, Object&gt; appendWeights = (weights, id) -&gt; {</span>
<span class="fc" id="L869">			s.append('{');</span>
<span class="fc" id="L870">			boolean firstData = true;</span>
<span class="fc bfc" id="L871" title="All 2 branches covered.">			for (Weights&lt;Object, ?&gt; weight : weights) {</span>
<span class="fc bfc" id="L872" title="All 2 branches covered.">				if (firstData) {</span>
<span class="fc" id="L873">					firstData = false;</span>
				} else {
<span class="fc" id="L875">					s.append(&quot;, &quot;);</span>
				}
<span class="fc" id="L877">				s.append(weight.getAsObj(id));</span>
<span class="fc" id="L878">			}</span>
<span class="fc" id="L879">			s.append('}');</span>
<span class="fc" id="L880">		};</span>
<span class="fc" id="L881">		Consumer&lt;V&gt; appendVertexWeights = vertex -&gt; {</span>
			@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L883">			Collection&lt;Weights&lt;Object, ?&gt;&gt; weights0 = (Collection) verticesWeights;</span>
<span class="fc" id="L884">			appendWeights.accept(weights0, vertex);</span>
<span class="fc" id="L885">		};</span>
<span class="fc" id="L886">		Consumer&lt;E&gt; appendEdgeWeights = edge -&gt; {</span>
			@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L888">			Collection&lt;Weights&lt;Object, ?&gt;&gt; weights0 = (Collection) edgesWeights;</span>
<span class="fc" id="L889">			appendWeights.accept(weights0, edge);</span>
<span class="fc" id="L890">		};</span>

<span class="fc" id="L892">		s.append('{');</span>
<span class="fc" id="L893">		boolean firstVertex = true;</span>
<span class="fc bfc" id="L894" title="All 2 branches covered.">		for (V u : g.vertices()) {</span>
<span class="fc bfc" id="L895" title="All 2 branches covered.">			if (firstVertex) {</span>
<span class="fc" id="L896">				firstVertex = false;</span>
			} else {
<span class="fc" id="L898">				s.append(&quot;, &quot;);</span>
			}
<span class="fc" id="L900">			s.append(u);</span>
<span class="fc bfc" id="L901" title="All 2 branches covered.">			if (!verticesWeights.isEmpty())</span>
<span class="fc" id="L902">				appendVertexWeights.accept(u);</span>

<span class="fc" id="L904">			s.append(&quot;: [&quot;);</span>
<span class="fc" id="L905">			boolean firstEdge = true;</span>
<span class="fc bfc" id="L906" title="All 2 branches covered.">			for (EdgeIter&lt;V, E&gt; eit = g.outEdges(u).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L907">				E e = eit.next();</span>
<span class="fc" id="L908">				V v = eit.target();</span>
<span class="fc bfc" id="L909" title="All 2 branches covered.">				if (firstEdge)</span>
<span class="fc" id="L910">					firstEdge = false;</span>
				else
<span class="fc" id="L912">					s.append(&quot;, &quot;);</span>
<span class="fc" id="L913">				s.append(e).append('(').append(u).append(&quot;, &quot;).append(v);</span>
<span class="fc bfc" id="L914" title="All 2 branches covered.">				if (!edgesWeights.isEmpty()) {</span>
<span class="fc" id="L915">					s.append(&quot;, &quot;);</span>
<span class="fc" id="L916">					appendEdgeWeights.accept(e);</span>
				}
<span class="fc" id="L918">				s.append(')');</span>
<span class="fc" id="L919">			}</span>
<span class="fc" id="L920">			s.append(']');</span>
<span class="fc" id="L921">		}</span>
<span class="fc" id="L922">		s.append('}');</span>
<span class="fc" id="L923">		return s.toString();</span>
	}

	private static String toString(IntGraph g) {
<span class="fc" id="L927">		StringBuilder s = new StringBuilder();</span>

<span class="fc" id="L929">		Set&lt;String&gt; verticesWeightsKeys = g.verticesWeightsKeys();</span>
<span class="fc" id="L930">		Collection&lt;IWeights&lt;?&gt;&gt; verticesWeights = new ObjectArrayList&lt;&gt;(verticesWeightsKeys.size());</span>
<span class="fc bfc" id="L931" title="All 2 branches covered.">		for (String key : verticesWeightsKeys)</span>
<span class="fc" id="L932">			verticesWeights.add((IWeights&lt;?&gt;) g.verticesWeights(key));</span>

<span class="fc" id="L934">		Set&lt;String&gt; edgesWeightsKeys = g.edgesWeightsKeys();</span>
<span class="fc" id="L935">		Collection&lt;IWeights&lt;?&gt;&gt; edgesWeights = new ObjectArrayList&lt;&gt;(edgesWeightsKeys.size());</span>
<span class="fc bfc" id="L936" title="All 2 branches covered.">		for (String key : edgesWeightsKeys)</span>
<span class="fc" id="L937">			edgesWeights.add((IWeights&lt;?&gt;) g.edgesWeights(key));</span>

<span class="fc" id="L939">		ObjIntConsumer&lt;Collection&lt;IWeights&lt;?&gt;&gt;&gt; appendWeights = (weights, id) -&gt; {</span>
<span class="fc" id="L940">			s.append('{');</span>
<span class="fc" id="L941">			boolean firstData = true;</span>
<span class="fc bfc" id="L942" title="All 2 branches covered.">			for (IWeights&lt;?&gt; weight : weights) {</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">				if (firstData) {</span>
<span class="fc" id="L944">					firstData = false;</span>
				} else {
<span class="fc" id="L946">					s.append(&quot;, &quot;);</span>
				}
<span class="fc" id="L948">				s.append(weight.getAsObj(id));</span>
<span class="fc" id="L949">			}</span>
<span class="fc" id="L950">			s.append('}');</span>
<span class="fc" id="L951">		};</span>
<span class="fc" id="L952">		IntConsumer appendVertexWeights = vertex -&gt; appendWeights.accept(verticesWeights, vertex);</span>
<span class="fc" id="L953">		IntConsumer appendEdgeWeights = edge -&gt; appendWeights.accept(edgesWeights, edge);</span>

<span class="fc" id="L955">		s.append('{');</span>
<span class="fc" id="L956">		boolean firstVertex = true;</span>
<span class="fc bfc" id="L957" title="All 2 branches covered.">		for (int u : g.vertices()) {</span>
<span class="fc bfc" id="L958" title="All 2 branches covered.">			if (firstVertex) {</span>
<span class="fc" id="L959">				firstVertex = false;</span>
			} else {
<span class="fc" id="L961">				s.append(&quot;, &quot;);</span>
			}
<span class="fc" id="L963">			s.append(u);</span>
<span class="fc bfc" id="L964" title="All 2 branches covered.">			if (!verticesWeights.isEmpty())</span>
<span class="fc" id="L965">				appendVertexWeights.accept(u);</span>

<span class="fc" id="L967">			s.append(&quot;: [&quot;);</span>
<span class="fc" id="L968">			boolean firstEdge = true;</span>
<span class="fc bfc" id="L969" title="All 2 branches covered.">			for (IEdgeIter eit = g.outEdges(u).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L970">				int e = eit.nextInt();</span>
<span class="fc" id="L971">				int v = eit.targetInt();</span>
<span class="fc bfc" id="L972" title="All 2 branches covered.">				if (firstEdge)</span>
<span class="fc" id="L973">					firstEdge = false;</span>
				else
<span class="fc" id="L975">					s.append(&quot;, &quot;);</span>
<span class="fc" id="L976">				s.append(e).append('(').append(u).append(&quot;, &quot;).append(v);</span>
<span class="fc bfc" id="L977" title="All 2 branches covered.">				if (!edgesWeights.isEmpty()) {</span>
<span class="fc" id="L978">					s.append(&quot;, &quot;);</span>
<span class="fc" id="L979">					appendEdgeWeights.accept(e);</span>
				}
<span class="fc" id="L981">				s.append(')');</span>
<span class="fc" id="L982">			}</span>
<span class="fc" id="L983">			s.append(']');</span>
<span class="fc" id="L984">		}</span>
<span class="fc" id="L985">		s.append('}');</span>
<span class="fc" id="L986">		return s.toString();</span>
	}

	/**
	 * Get a view of all the self edges in a graph.
	 *
	 * &lt;p&gt;
	 * The returned set is a view, namely it will be updated when the graph is updated.
	 *
	 * @param  &lt;V&gt; the vertices type
	 * @param  &lt;E&gt; the edges type
	 * @param  g   a graph
	 * @return     a view of all the self edges in the graph
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public static &lt;V, E&gt; Set&lt;E&gt; selfEdges(Graph&lt;V, E&gt; g) {
<span class="fc bfc" id="L1002" title="All 2 branches covered.">		if (g instanceof IntGraph)</span>
<span class="fc" id="L1003">			return (Set&lt;E&gt;) selfEdges((IntGraph) g);</span>
<span class="fc bfc" id="L1004" title="All 2 branches covered.">		if (!g.isAllowSelfEdges())</span>
<span class="fc" id="L1005">			return ObjectSets.emptySet();</span>
<span class="fc" id="L1006">		IntSet indexSelfEdges = selfEdges(g.indexGraph());</span>
<span class="fc" id="L1007">		return IndexIdMaps.indexToIdSet(indexSelfEdges, g.indexGraphEdgesMap());</span>
	}

	/**
	 * Get a view of all the self edges in an int graph.
	 *
	 * &lt;p&gt;
	 * The returned set is a view, namely it will be updated when the graph is updated.
	 *
	 * @param  g an int graph
	 * @return   a view of all the self edges in the graph
	 */
	public static IntSet selfEdges(IntGraph g) {
<span class="fc bfc" id="L1020" title="All 2 branches covered.">		if (!g.isAllowSelfEdges())</span>
<span class="fc" id="L1021">			return IntSets.EMPTY_SET;</span>
<span class="fc bfc" id="L1022" title="All 2 branches covered.">		if (g instanceof IndexGraph)</span>
<span class="fc" id="L1023">			return selfEdges((IndexGraph) g);</span>
<span class="fc" id="L1024">		IntSet indexSelfEdges = selfEdges(g.indexGraph());</span>
<span class="fc" id="L1025">		return IndexIdMaps.indexToIdSet(indexSelfEdges, g.indexGraphEdgesMap());</span>
	}

	private static IntSet selfEdges(IndexGraph g) {
<span class="fc" id="L1029">		return new AbstractIntSet() {</span>

			@Override
			public boolean contains(int edge) {
<span class="fc bfc" id="L1033" title="All 6 branches covered.">				return 0 &lt;= edge &amp;&amp; edge &lt; g.edges().size() &amp;&amp; g.edgeSource(edge) == g.edgeTarget(edge);</span>
			}

			@Override
			public int size() {
<span class="fc" id="L1038">				return (int) IntIterables.size(this);</span>
			}

			@Override
			public boolean isEmpty() {
<span class="pc bpc" id="L1043" title="1 of 2 branches missed.">				return !iterator().hasNext();</span>
			}

			@Override
			public IntIterator iterator() {
<span class="fc" id="L1048">				return new IntIterator() {</span>
<span class="fc" id="L1049">					final int m = g.edges().size();</span>
<span class="fc" id="L1050">					int nextEdge = 0;</span>
					{
<span class="fc" id="L1052">						advance();</span>
<span class="fc" id="L1053">					}</span>

					private void advance() {
<span class="fc bfc" id="L1056" title="All 2 branches covered.">						for (; nextEdge &lt; m; nextEdge++)</span>
<span class="fc bfc" id="L1057" title="All 2 branches covered.">							if (g.edgeSource(nextEdge) == g.edgeTarget(nextEdge))</span>
<span class="fc" id="L1058">								break;</span>
<span class="fc" id="L1059">					}</span>

					@Override
					public boolean hasNext() {
<span class="fc bfc" id="L1063" title="All 2 branches covered.">						return nextEdge &lt; m;</span>
					}

					@Override
					public int nextInt() {
<span class="fc" id="L1068">						Assertions.hasNext(this);</span>
<span class="fc" id="L1069">						int edge = nextEdge++;</span>
<span class="fc" id="L1070">						advance();</span>
<span class="fc" id="L1071">						return edge;</span>
					}
				};
			}
		};
	}

	/**
	 * Check whether a graph contain parallel edges.
	 *
	 * &lt;p&gt;
	 * Two parallel edges are edges that have the same source and target vertices.
	 *
	 * @param  &lt;V&gt; the vertices type
	 * @param  &lt;E&gt; the edges type
	 * @param  g   a graph
	 * @return     {@code true} if the graph contain at least one pair of parallel edges, else {@code false}
	 */
	public static &lt;V, E&gt; boolean containsParallelEdges(Graph&lt;V, E&gt; g) {
<span class="fc bfc" id="L1090" title="All 2 branches covered.">		if (!g.isAllowParallelEdges())</span>
<span class="fc" id="L1091">			return false;</span>
<span class="fc" id="L1092">		IndexGraph ig = g.indexGraph();</span>
<span class="fc" id="L1093">		final int n = ig.vertices().size();</span>
<span class="fc" id="L1094">		int[] lastVisit = new int[n];</span>
<span class="fc bfc" id="L1095" title="All 2 branches covered.">		for (int u : range(n)) {</span>
<span class="fc" id="L1096">			final int visitIdx = u + 1;</span>
<span class="fc bfc" id="L1097" title="All 2 branches covered.">			for (IEdgeIter eit = ig.outEdges(u).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L1098">				eit.nextInt();</span>
<span class="fc" id="L1099">				int v = eit.targetInt();</span>
<span class="fc bfc" id="L1100" title="All 2 branches covered.">				if (lastVisit[v] == visitIdx)</span>
<span class="fc" id="L1101">					return true;</span>
<span class="fc" id="L1102">				lastVisit[v] = visitIdx;</span>
<span class="fc" id="L1103">			}</span>
<span class="fc" id="L1104">		}</span>
<span class="fc" id="L1105">		return false;</span>
	}

<span class="fc" id="L1108">	static IdBuilderInt IndexGraphIdBuilder = existingIds -&gt; existingIds.size();</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>