<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Graphs.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.graph</a> &gt; <span class="el_source">Graphs.java</span></div><h1>Graphs.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.graph;

import java.util.AbstractSet;
import java.util.Collection;
import java.util.Objects;
import java.util.Random;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.ObjIntConsumer;
import com.jgalgo.internal.util.Assertions;
import com.jgalgo.internal.util.IntAdapters;
import it.unimi.dsi.fastutil.ints.AbstractIntSet;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
import it.unimi.dsi.fastutil.ints.IntSet;
import it.unimi.dsi.fastutil.objects.ObjectArrayList;
import it.unimi.dsi.fastutil.objects.ObjectIterables;
import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;

/**
 * Static methods class for graphs.
 *
 * @author Barak Ugav
 */
public class Graphs {
	private Graphs() {}

	/**
	 * Tag interface for graphs that can not be muted/changed/altered.
	 *
	 * @author Barak Ugav
	 */
	static interface ImmutableGraph {
	}

	private static class ImmutableGraphView&lt;V, E&gt; extends GraphBase&lt;V, E&gt; implements ImmutableGraph {

		private final Graph&lt;V, E&gt; graph;

<span class="fc" id="L55">		ImmutableGraphView(Graph&lt;V, E&gt; g) {</span>
<span class="fc" id="L56">			this.graph = Objects.requireNonNull(g);</span>
<span class="fc" id="L57">		}</span>

		@Override
		public Set&lt;V&gt; vertices() {
<span class="fc" id="L61">			return graph.vertices();</span>
		}

		@Override
		public Set&lt;E&gt; edges() {
<span class="fc" id="L66">			return graph.edges();</span>
		}

		@Override
		public void addVertex(V vertex) {
<span class="fc" id="L71">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add vertices&quot;);</span>
		}

		@Override
		public void removeVertex(V vertex) {
<span class="fc" id="L76">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove vertices&quot;);</span>
		}

		@Override
		public EdgeSet&lt;V, E&gt; outEdges(V source) {
<span class="fc" id="L81">			return new ImmutableEdgeSet&lt;&gt;(graph.outEdges(source));</span>
		}

		@Override
		public EdgeSet&lt;V, E&gt; inEdges(V target) {
<span class="fc" id="L86">			return new ImmutableEdgeSet&lt;&gt;(graph.inEdges(target));</span>
		}

		@Override
		public EdgeSet&lt;V, E&gt; getEdges(V source, V target) {
<span class="fc" id="L91">			return new ImmutableEdgeSet&lt;&gt;(graph.getEdges(source, target));</span>
		}

		@Override
		public void addEdge(V source, V target, E edge) {
<span class="fc" id="L96">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add edges&quot;);</span>
		}

		@Override
		public void removeEdge(E edge) {
<span class="fc" id="L101">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove edges&quot;);</span>
		}

		@Override
		public void reverseEdge(E edge) {
<span class="fc" id="L106">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot reverse edges&quot;);</span>
		}

		@Override
		public V edgeSource(E edge) {
<span class="fc" id="L111">			return graph.edgeSource(edge);</span>
		}

		@Override
		public V edgeTarget(E edge) {
<span class="fc" id="L116">			return graph.edgeTarget(edge);</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L121">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove vertices and edges&quot;);</span>
		}

		@Override
		public void clearEdges() {
<span class="fc" id="L126">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove edges&quot;);</span>
		}

		@SuppressWarnings(&quot;unchecked&quot;)
		@Override
		public &lt;T, WeightsT extends Weights&lt;V, T&gt;&gt; WeightsT getVerticesWeights(String key) {
<span class="fc" id="L132">			return (WeightsT) WeightsImpl.ObjImmutableView.newInstance(graph.getVerticesWeights(key));</span>
		}

		@Override
		public &lt;T, WeightsT extends Weights&lt;V, T&gt;&gt; WeightsT addVerticesWeights(String key, Class&lt;? super T&gt; type,
				T defVal) {
<span class="fc" id="L138">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add vertices weights&quot;);</span>
		}

		@Override
		public void removeVerticesWeights(String key) {
<span class="fc" id="L143">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove vertices weights&quot;);</span>
		}

		@Override
		public Set&lt;String&gt; getVerticesWeightsKeys() {
<span class="fc" id="L148">			return graph.getVerticesWeightsKeys();</span>
		}

		@SuppressWarnings(&quot;unchecked&quot;)
		@Override
		public &lt;T, WeightsT extends Weights&lt;E, T&gt;&gt; WeightsT getEdgesWeights(String key) {
<span class="fc" id="L154">			return (WeightsT) WeightsImpl.ObjImmutableView.newInstance(graph.getEdgesWeights(key));</span>
		}

		@Override
		public &lt;T, WeightsT extends Weights&lt;E, T&gt;&gt; WeightsT addEdgesWeights(String key, Class&lt;? super T&gt; type,
				T defVal) {
<span class="fc" id="L160">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add edges weights&quot;);</span>
		}

		@Override
		public void removeEdgesWeights(String key) {
<span class="fc" id="L165">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove edges weights&quot;);</span>
		}

		@Override
		public Set&lt;String&gt; getEdgesWeightsKeys() {
<span class="fc" id="L170">			return graph.getEdgesWeightsKeys();</span>
		}

		@Override
		public boolean isDirected() {
<span class="fc" id="L175">			return graph.isDirected();</span>
		}

		@Override
		public boolean isAllowSelfEdges() {
<span class="fc" id="L180">			return graph.isAllowSelfEdges();</span>
		}

		@Override
		public boolean isAllowParallelEdges() {
<span class="fc" id="L185">			return graph.isAllowParallelEdges();</span>
		}

		@Override
		public IndexGraph indexGraph() {
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">			return this instanceof IndexGraph ? (IndexGraph) this : Graphs.immutableView(graph.indexGraph());</span>
		}

		@Override
		public IndexIdMap&lt;V&gt; indexGraphVerticesMap() {
<span class="nc" id="L195">			return graph.indexGraphVerticesMap();</span>
		}

		@Override
		public IndexIdMap&lt;E&gt; indexGraphEdgesMap() {
<span class="nc" id="L200">			return graph.indexGraphEdgesMap();</span>
		}

	}

	private abstract static class ImmutableIntGraphViewBase extends GraphBase&lt;Integer, Integer&gt;
			implements IntGraph, ImmutableGraph {

		private final IntGraph graph;

<span class="fc" id="L210">		ImmutableIntGraphViewBase(IntGraph g) {</span>
<span class="fc" id="L211">			this.graph = Objects.requireNonNull(g);</span>
<span class="fc" id="L212">		}</span>

		@Override
		public IntSet vertices() {
<span class="fc" id="L216">			return graph.vertices();</span>
		}

		@Override
		public IntSet edges() {
<span class="fc" id="L221">			return graph.edges();</span>
		}

		@Override
		public int addVertex() {
<span class="fc" id="L226">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add vertices&quot;);</span>
		}

		@Override
		public void addVertex(int vertex) {
<span class="fc" id="L231">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add vertices&quot;);</span>
		}

		@Override
		public void removeVertex(int vertex) {
<span class="fc" id="L236">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove vertices&quot;);</span>
		}

		@Override
		public IEdgeSet outEdges(int source) {
<span class="fc" id="L241">			return new ImmutableIEdgeSet(graph.outEdges(source));</span>
		}

		@Override
		public IEdgeSet inEdges(int target) {
<span class="fc" id="L246">			return new ImmutableIEdgeSet(graph.inEdges(target));</span>
		}

		@Override
		public IEdgeSet getEdges(int source, int target) {
<span class="fc" id="L251">			return new ImmutableIEdgeSet(graph.getEdges(source, target));</span>
		}

		@Override
		public int addEdge(int source, int target) {
<span class="fc" id="L256">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add edges&quot;);</span>
		}

		@Override
		public void addEdge(int source, int target, int edge) {
<span class="fc" id="L261">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add edges&quot;);</span>
		}

		@Override
		public void removeEdge(int edge) {
<span class="fc" id="L266">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove edges&quot;);</span>
		}

		@Override
		public void reverseEdge(int edge) {
<span class="fc" id="L271">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot reverse edges&quot;);</span>
		}

		@Override
		public int edgeSource(int edge) {
<span class="fc" id="L276">			return graph.edgeSource(edge);</span>
		}

		@Override
		public int edgeTarget(int edge) {
<span class="fc" id="L281">			return graph.edgeTarget(edge);</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L286">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove vertices and edges&quot;);</span>
		}

		@Override
		public void clearEdges() {
<span class="fc" id="L291">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove edges&quot;);</span>
		}

		@SuppressWarnings(&quot;unchecked&quot;)
		@Override
		public &lt;T, WeightsT extends IWeights&lt;T&gt;&gt; WeightsT getVerticesIWeights(String key) {
<span class="fc" id="L297">			return (WeightsT) WeightsImpl.IntImmutableView.newInstance(graph.getVerticesIWeights(key));</span>
		}

		@Override
		public &lt;T, WeightsT extends Weights&lt;Integer, T&gt;&gt; WeightsT addVerticesWeights(String key, Class&lt;? super T&gt; type,
				T defVal) {
<span class="fc" id="L303">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add vertices weights&quot;);</span>
		}

		@Override
		public void removeVerticesWeights(String key) {
<span class="fc" id="L308">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove vertices weights&quot;);</span>
		}

		@Override
		public Set&lt;String&gt; getVerticesWeightsKeys() {
<span class="fc" id="L313">			return graph.getVerticesWeightsKeys();</span>
		}

		@SuppressWarnings(&quot;unchecked&quot;)
		@Override
		public &lt;T, WeightsT extends IWeights&lt;T&gt;&gt; WeightsT getEdgesIWeights(String key) {
<span class="fc" id="L319">			return (WeightsT) WeightsImpl.IntImmutableView.newInstance(graph.getEdgesIWeights(key));</span>
		}

		@Override
		public &lt;T, WeightsT extends Weights&lt;Integer, T&gt;&gt; WeightsT addEdgesWeights(String key, Class&lt;? super T&gt; type,
				T defVal) {
<span class="fc" id="L325">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add edges weights&quot;);</span>
		}

		@Override
		public void removeEdgesWeights(String key) {
<span class="fc" id="L330">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove edges weights&quot;);</span>
		}

		@Override
		public Set&lt;String&gt; getEdgesWeightsKeys() {
<span class="fc" id="L335">			return graph.getEdgesWeightsKeys();</span>
		}

		@Override
		public boolean isDirected() {
<span class="fc" id="L340">			return graph.isDirected();</span>
		}

		@Override
		public boolean isAllowSelfEdges() {
<span class="fc" id="L345">			return graph.isAllowSelfEdges();</span>
		}

		@Override
		public boolean isAllowParallelEdges() {
<span class="fc" id="L350">			return graph.isAllowParallelEdges();</span>
		}

		@Override
		public IntGraph copy() {
<span class="nc" id="L355">			return graph.copy();</span>
		}

		IntGraph graph() {
<span class="fc" id="L359">			return graph;</span>
		}
	}

	private static class ImmutableIntGraphView extends ImmutableIntGraphViewBase {

		ImmutableIntGraphView(IntGraph g) {
<span class="fc" id="L366">			super(g);</span>
<span class="fc" id="L367">		}</span>

		@Override
		public IndexGraph indexGraph() {
<span class="fc" id="L371">			return Graphs.immutableView(graph().indexGraph());</span>
		}

		@Override
		public IndexIntIdMap indexGraphVerticesMap() {
<span class="nc" id="L376">			return graph().indexGraphVerticesMap();</span>
		}

		@Override
		public IndexIntIdMap indexGraphEdgesMap() {
<span class="nc" id="L381">			return graph().indexGraphEdgesMap();</span>
		}
	}

	private static class ImmutableIndexGraphView extends ImmutableIntGraphViewBase implements IndexGraph {

		ImmutableIndexGraphView(IndexGraph g) {
<span class="fc" id="L388">			super(g);</span>
<span class="fc" id="L389">		}</span>

		@Override
		IndexGraph graph() {
<span class="nc" id="L393">			return (IndexGraph) super.graph();</span>
		}

		@Override
		public IndexGraph copy() {
<span class="nc" id="L398">			return graph().copy();</span>
		}

		@Override
		@Deprecated
		public void addVertex(int vertex) {
<span class="nc" id="L404">			IndexGraph.super.addVertex(vertex);</span>
<span class="nc" id="L405">		}</span>

		@Override
		@Deprecated
		public void addEdge(int source, int target, int edge) {
<span class="nc" id="L410">			IndexGraph.super.addEdge(source, target, edge);</span>
<span class="nc" id="L411">		}</span>

		@Override
		public void addVertexRemoveListener(IndexRemoveListener listener) {
<span class="nc" id="L415">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add a listener&quot;);</span>
		}

		@Override
		public void removeVertexRemoveListener(IndexRemoveListener listener) {
<span class="nc" id="L420">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove a listener&quot;);</span>
		}

		@Override
		public void addEdgeRemoveListener(IndexRemoveListener listener) {
<span class="nc" id="L425">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot add a listener&quot;);</span>
		}

		@Override
		public void removeEdgeRemoveListener(IndexRemoveListener listener) {
<span class="nc" id="L430">			throw new UnsupportedOperationException(&quot;graph is immutable, cannot remove a listener&quot;);</span>
		}
	}

	private static class ImmutableEdgeSet&lt;V, E&gt; extends AbstractSet&lt;E&gt; implements EdgeSet&lt;V, E&gt; {

		private final EdgeSet&lt;V, E&gt; set;

<span class="fc" id="L438">		ImmutableEdgeSet(EdgeSet&lt;V, E&gt; set) {</span>
<span class="fc" id="L439">			this.set = Objects.requireNonNull(set);</span>
<span class="fc" id="L440">		}</span>

		@Override
		public boolean contains(Object edge) {
<span class="fc" id="L444">			return set.contains(edge);</span>
		}

		@Override
		public int size() {
<span class="fc" id="L449">			return set.size();</span>
		}

		@Override
		public EdgeIter&lt;V, E&gt; iterator() {
<span class="fc" id="L454">			return new ImmutableEdgeIter&lt;&gt;(set.iterator());</span>
		}
	}

	private static class ImmutableIEdgeSet extends AbstractIntSet implements IEdgeSet {

		private final IEdgeSet set;

<span class="fc" id="L462">		ImmutableIEdgeSet(IEdgeSet set) {</span>
<span class="fc" id="L463">			this.set = Objects.requireNonNull(set);</span>
<span class="fc" id="L464">		}</span>

		@Override
		public boolean contains(int edge) {
<span class="fc" id="L468">			return set.contains(edge);</span>
		}

		@Override
		public int size() {
<span class="fc" id="L473">			return set.size();</span>
		}

		@Override
		public IEdgeIter iterator() {
<span class="fc" id="L478">			return new ImmutableIEdgeIter(set.iterator());</span>
		}
	}

	private static class ImmutableEdgeIter&lt;V, E&gt; implements EdgeIter&lt;V, E&gt; {
		private final EdgeIter&lt;V, E&gt; it;

<span class="fc" id="L485">		ImmutableEdgeIter(EdgeIter&lt;V, E&gt; it) {</span>
<span class="fc" id="L486">			this.it = Objects.requireNonNull(it);</span>
<span class="fc" id="L487">		}</span>

		@Override
		public V source() {
<span class="fc" id="L491">			return it.source();</span>
		}

		@Override
		public V target() {
<span class="fc" id="L496">			return it.target();</span>
		}

		@Override
		public E next() {
<span class="fc" id="L501">			return it.next();</span>
		}

		@Override
		public boolean hasNext() {
<span class="fc" id="L506">			return it.hasNext();</span>
		}

		@Override
		public E peekNext() {
<span class="fc" id="L511">			return it.peekNext();</span>
		}
	}

	private static class ImmutableIEdgeIter implements IEdgeIter {
		private final IEdgeIter it;

<span class="fc" id="L518">		ImmutableIEdgeIter(IEdgeIter it) {</span>
<span class="fc" id="L519">			this.it = Objects.requireNonNull(it);</span>
<span class="fc" id="L520">		}</span>

		@Override
		public int sourceInt() {
<span class="fc" id="L524">			return it.sourceInt();</span>
		}

		@Override
		public int targetInt() {
<span class="fc" id="L529">			return it.targetInt();</span>
		}

		@Override
		public int nextInt() {
<span class="fc" id="L534">			return it.nextInt();</span>
		}

		@Override
		public boolean hasNext() {
<span class="fc" id="L539">			return it.hasNext();</span>
		}

		@Override
		public int peekNextInt() {
<span class="fc" id="L544">			return it.peekNextInt();</span>
		}
	}

	static IndexGraph immutableView(IndexGraph g) {
<span class="fc bfc" id="L549" title="All 2 branches covered.">		return g instanceof ImmutableGraph ? g : new ImmutableIndexGraphView(g);</span>
	}

	static IntGraph immutableView(IntGraph g) {
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">		if (g instanceof IndexGraph)</span>
<span class="nc" id="L554">			return immutableView((IndexGraph) g);</span>
<span class="fc bfc" id="L555" title="All 2 branches covered.">		return g instanceof ImmutableGraph ? g : new ImmutableIntGraphView(g);</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	static &lt;V, E&gt; Graph&lt;V, E&gt; immutableView(Graph&lt;V, E&gt; g) {
<span class="fc bfc" id="L560" title="All 2 branches covered.">		if (g instanceof IndexGraph)</span>
<span class="fc" id="L561">			return (Graph&lt;V, E&gt;) immutableView((IndexGraph) g);</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">		if (g instanceof IntGraph)</span>
<span class="fc" id="L563">			return (Graph&lt;V, E&gt;) immutableView((IntGraph) g);</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">		return g instanceof ImmutableGraph ? g : new ImmutableGraphView&lt;&gt;(g);</span>
	}

	private abstract static class GraphViewBase&lt;V, E&gt; extends GraphBase&lt;V, E&gt; {

		private final Graph&lt;V, E&gt; graph;

<span class="fc" id="L571">		GraphViewBase(Graph&lt;V, E&gt; g) {</span>
<span class="fc" id="L572">			this.graph = Objects.requireNonNull(g);</span>
<span class="fc" id="L573">		}</span>

		Graph&lt;V, E&gt; graph() {
<span class="fc" id="L576">			return graph;</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L581">			graph().clear();</span>
<span class="fc" id="L582">		}</span>

		@Override
		public void clearEdges() {
<span class="fc" id="L586">			graph().clearEdges();</span>
<span class="fc" id="L587">		}</span>

		@Override
		public &lt;T, WeightsT extends Weights&lt;V, T&gt;&gt; WeightsT addVerticesWeights(String key, Class&lt;? super T&gt; type,
				T defVal) {
<span class="fc" id="L592">			return graph().addVerticesWeights(key, type, defVal);</span>
		}

		@Override
		public void removeVerticesWeights(String key) {
<span class="fc" id="L597">			graph().removeVerticesWeights(key);</span>
<span class="fc" id="L598">		}</span>

		@Override
		public Set&lt;String&gt; getVerticesWeightsKeys() {
<span class="fc" id="L602">			return graph().getVerticesWeightsKeys();</span>
		}

		@Override
		public &lt;T, WeightsT extends Weights&lt;E, T&gt;&gt; WeightsT addEdgesWeights(String key, Class&lt;? super T&gt; type,
				T defVal) {
<span class="fc" id="L608">			return graph().addEdgesWeights(key, type, defVal);</span>
		}

		@Override
		public void removeEdgesWeights(String key) {
<span class="fc" id="L613">			graph().removeEdgesWeights(key);</span>
<span class="fc" id="L614">		}</span>

		@Override
		public Set&lt;String&gt; getEdgesWeightsKeys() {
<span class="fc" id="L618">			return graph().getEdgesWeightsKeys();</span>
		}

		@Override
		public boolean isDirected() {
<span class="fc" id="L623">			return graph().isDirected();</span>
		}

		@Override
		public boolean isAllowSelfEdges() {
<span class="fc" id="L628">			return graph().isAllowSelfEdges();</span>
		}

		@Override
		public boolean isAllowParallelEdges() {
<span class="fc" id="L633">			return graph().isAllowParallelEdges();</span>
		}

	}

	private abstract static class GraphView&lt;V, E&gt; extends GraphViewBase&lt;V, E&gt; {

		GraphView(Graph&lt;V, E&gt; g) {
<span class="fc" id="L641">			super(g);</span>
<span class="fc" id="L642">		}</span>

		@Override
		public Set&lt;V&gt; vertices() {
<span class="fc" id="L646">			return graph().vertices();</span>
		}

		@Override
		public Set&lt;E&gt; edges() {
<span class="fc" id="L651">			return graph().edges();</span>
		}

		@Override
		public void addVertex(V vertex) {
<span class="fc" id="L656">			graph().addVertex(vertex);</span>
<span class="fc" id="L657">		}</span>

		@Override
		public void removeVertex(V vertex) {
<span class="fc" id="L661">			graph().removeVertex(vertex);</span>
<span class="fc" id="L662">		}</span>

		@Override
		public EdgeSet&lt;V, E&gt; outEdges(V source) {
<span class="nc" id="L666">			return graph().outEdges(source);</span>
		}

		@Override
		public EdgeSet&lt;V, E&gt; inEdges(V target) {
<span class="nc" id="L671">			return graph().inEdges(target);</span>
		}

		@Override
		public E getEdge(V source, V target) {
<span class="nc" id="L676">			return graph().getEdge(source, target);</span>
		}

		@Override
		public EdgeSet&lt;V, E&gt; getEdges(V source, V target) {
<span class="nc" id="L681">			return graph().getEdges(source, target);</span>
		}

		@Override
		public void addEdge(V source, V target, E edge) {
<span class="fc" id="L686">			graph().addEdge(source, target, edge);</span>
<span class="fc" id="L687">		}</span>

		@Override
		public void removeEdge(E edge) {
<span class="fc" id="L691">			graph().removeEdge(edge);</span>
<span class="fc" id="L692">		}</span>

		@Override
		public void removeEdgesOf(V vertex) {
<span class="nc" id="L696">			graph().removeEdgesOf(vertex);</span>
<span class="nc" id="L697">		}</span>

		@Override
		public void removeInEdgesOf(V vertex) {
<span class="nc" id="L701">			graph().removeInEdgesOf(vertex);</span>
<span class="nc" id="L702">		}</span>

		@Override
		public void removeOutEdgesOf(V vertex) {
<span class="nc" id="L706">			graph().removeOutEdgesOf(vertex);</span>
<span class="nc" id="L707">		}</span>

		@Override
		public void reverseEdge(E edge) {
<span class="fc" id="L711">			graph().reverseEdge(edge);</span>
<span class="fc" id="L712">		}</span>

		@Override
		public V edgeSource(E edge) {
<span class="fc" id="L716">			return graph().edgeSource(edge);</span>
		}

		@Override
		public V edgeTarget(E edge) {
<span class="fc" id="L721">			return graph().edgeTarget(edge);</span>
		}

		@Override
		public &lt;T, WeightsT extends Weights&lt;V, T&gt;&gt; WeightsT getVerticesWeights(String key) {
<span class="fc" id="L726">			return graph().getVerticesWeights(key);</span>
		}

		@Override
		public &lt;T, WeightsT extends Weights&lt;E, T&gt;&gt; WeightsT getEdgesWeights(String key) {
<span class="fc" id="L731">			return graph().getEdgesWeights(key);</span>
		}

		@Override
		public IndexIdMap&lt;V&gt; indexGraphVerticesMap() {
<span class="fc" id="L736">			return graph().indexGraphVerticesMap();</span>
		}

		@Override
		public IndexIdMap&lt;E&gt; indexGraphEdgesMap() {
<span class="fc" id="L741">			return graph().indexGraphEdgesMap();</span>
		}
	}

	private abstract static class IntGraphViewBase extends GraphViewBase&lt;Integer, Integer&gt; implements IntGraph {

		IntGraphViewBase(IntGraph g) {
<span class="fc" id="L748">			super(g);</span>
<span class="fc" id="L749">		}</span>

		@Override
		IntGraph graph() {
<span class="fc" id="L753">			return (IntGraph) super.graph();</span>
		}

		@Override
		public IntSet vertices() {
<span class="fc" id="L758">			return graph().vertices();</span>
		}

		@Override
		public IntSet edges() {
<span class="fc" id="L763">			return graph().edges();</span>
		}

		@Override
		public int addVertex() {
<span class="fc" id="L768">			return graph().addVertex();</span>
		}

		@Override
		public void addVertex(int vertex) {
<span class="fc" id="L773">			graph().addVertex(vertex);</span>
<span class="fc" id="L774">		}</span>

		@Override
		public void removeVertex(int vertex) {
<span class="fc" id="L778">			graph().removeVertex(vertex);</span>
<span class="fc" id="L779">		}</span>

		@Override
		public IEdgeSet outEdges(int source) {
<span class="nc" id="L783">			return graph().outEdges(source);</span>
		}

		@Override
		public IEdgeSet inEdges(int target) {
<span class="nc" id="L788">			return graph().inEdges(target);</span>
		}

		@Override
		public int getEdge(int source, int target) {
<span class="nc" id="L793">			return graph().getEdge(source, target);</span>
		}

		@Override
		public IEdgeSet getEdges(int source, int target) {
<span class="nc" id="L798">			return graph().getEdges(source, target);</span>
		}

		@Override
		public int addEdge(int source, int target) {
<span class="fc" id="L803">			return graph().addEdge(source, target);</span>
		}

		@Override
		public void addEdge(int source, int target, int edge) {
<span class="fc" id="L808">			graph().addEdge(source, target, edge);</span>
<span class="fc" id="L809">		}</span>

		@Override
		public void removeEdge(int edge) {
<span class="fc" id="L813">			graph().removeEdge(edge);</span>
<span class="fc" id="L814">		}</span>

		@Override
		public void removeEdgesOf(int vertex) {
<span class="nc" id="L818">			graph().removeEdgesOf(vertex);</span>
<span class="nc" id="L819">		}</span>

		@Override
		public void removeInEdgesOf(int vertex) {
<span class="nc" id="L823">			graph().removeInEdgesOf(vertex);</span>
<span class="nc" id="L824">		}</span>

		@Override
		public void removeOutEdgesOf(int vertex) {
<span class="nc" id="L828">			graph().removeOutEdgesOf(vertex);</span>
<span class="nc" id="L829">		}</span>

		@Override
		public void reverseEdge(int edge) {
<span class="fc" id="L833">			graph().reverseEdge(edge);</span>
<span class="fc" id="L834">		}</span>

		@Override
		public int edgeSource(int edge) {
<span class="fc" id="L838">			return graph().edgeSource(edge);</span>
		}

		@Override
		public int edgeTarget(int edge) {
<span class="fc" id="L843">			return graph().edgeTarget(edge);</span>
		}

		@Override
		public &lt;T, WeightsT extends IWeights&lt;T&gt;&gt; WeightsT getVerticesIWeights(String key) {
<span class="fc" id="L848">			return graph().getVerticesIWeights(key);</span>
		}

		@Override
		public &lt;T, WeightsT extends IWeights&lt;T&gt;&gt; WeightsT getEdgesIWeights(String key) {
<span class="fc" id="L853">			return graph().getEdgesIWeights(key);</span>
		}
	}

	private static class EdgeIterView&lt;V, E&gt; implements EdgeIter&lt;V, E&gt; {
		final EdgeIter&lt;V, E&gt; it;

<span class="fc" id="L860">		EdgeIterView(EdgeIter&lt;V, E&gt; it) {</span>
<span class="fc" id="L861">			this.it = it;</span>
<span class="fc" id="L862">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc" id="L866">			return it.hasNext();</span>
		}

		@Override
		public E next() {
<span class="fc" id="L871">			return it.next();</span>
		}

		@Override
		public E peekNext() {
<span class="fc" id="L876">			return it.peekNext();</span>
		}

		@Override
		public V source() {
<span class="nc" id="L881">			return it.source();</span>
		}

		@Override
		public V target() {
<span class="nc" id="L886">			return it.target();</span>
		}

		@Override
		public void remove() {
<span class="nc" id="L891">			it.remove();</span>
<span class="nc" id="L892">		}</span>
	}

	private static class IEdgeIterView implements IEdgeIter {
		final IEdgeIter it;

<span class="fc" id="L898">		IEdgeIterView(IEdgeIter it) {</span>
<span class="fc" id="L899">			this.it = it;</span>
<span class="fc" id="L900">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc" id="L904">			return it.hasNext();</span>
		}

		@Override
		public int nextInt() {
<span class="fc" id="L909">			return it.nextInt();</span>
		}

		@Override
		public int peekNextInt() {
<span class="fc" id="L914">			return it.peekNextInt();</span>
		}

		@Override
		public int sourceInt() {
<span class="nc" id="L919">			return it.sourceInt();</span>
		}

		@Override
		public int targetInt() {
<span class="nc" id="L924">			return it.targetInt();</span>
		}

		@Override
		public void remove() {
<span class="nc" id="L929">			it.remove();</span>
<span class="nc" id="L930">		}</span>
	}

	private static class ReverseGraph&lt;V, E&gt; extends GraphView&lt;V, E&gt; {

		ReverseGraph(Graph&lt;V, E&gt; g) {
<span class="fc" id="L936">			super(g);</span>
<span class="fc" id="L937">		}</span>

		@Override
		public EdgeSet&lt;V, E&gt; outEdges(V source) {
<span class="fc" id="L941">			return new ReversedEdgeSet&lt;&gt;(graph().inEdges(source));</span>
		}

		@Override
		public EdgeSet&lt;V, E&gt; inEdges(V target) {
<span class="fc" id="L946">			return new ReversedEdgeSet&lt;&gt;(graph().outEdges(target));</span>
		}

		@Override
		public E getEdge(V source, V target) {
<span class="fc" id="L951">			return graph().getEdge(target, source);</span>
		}

		@Override
		public EdgeSet&lt;V, E&gt; getEdges(V source, V target) {
<span class="fc" id="L956">			return new ReversedEdgeSet&lt;&gt;(graph().getEdges(target, source));</span>
		}

		@Override
		public void addEdge(V source, V target, E edge) {
<span class="fc" id="L961">			graph().addEdge(target, source, edge);</span>
<span class="fc" id="L962">		}</span>

		@Override
		public void removeEdgesOf(V vertex) {
<span class="fc" id="L966">			graph().removeEdgesOf(vertex);</span>
<span class="fc" id="L967">		}</span>

		@Override
		public void removeInEdgesOf(V vertex) {
<span class="fc" id="L971">			graph().removeOutEdgesOf(vertex);</span>
<span class="fc" id="L972">		}</span>

		@Override
		public void removeOutEdgesOf(V vertex) {
<span class="fc" id="L976">			graph().removeInEdgesOf(vertex);</span>
<span class="fc" id="L977">		}</span>

		@Override
		public V edgeSource(E edge) {
<span class="fc" id="L981">			return graph().edgeTarget(edge);</span>
		}

		@Override
		public V edgeTarget(E edge) {
<span class="fc" id="L986">			return graph().edgeSource(edge);</span>
		}

		@Override
		public IndexGraph indexGraph() {
<span class="fc" id="L991">			return (IndexGraph) Graphs.reverseView(graph().indexGraph());</span>
		}
	}

	private abstract static class ReverseIntGraphBase extends IntGraphViewBase {

		ReverseIntGraphBase(IntGraph g) {
<span class="fc" id="L998">			super(g);</span>
<span class="fc" id="L999">		}</span>

		@Override
		public IEdgeSet outEdges(int source) {
<span class="fc" id="L1003">			return new ReversedIEdgeSet(graph().inEdges(source));</span>
		}

		@Override
		public IEdgeSet inEdges(int target) {
<span class="fc" id="L1008">			return new ReversedIEdgeSet(graph().outEdges(target));</span>
		}

		@Override
		public int getEdge(int source, int target) {
<span class="fc" id="L1013">			return graph().getEdge(target, source);</span>
		}

		@Override
		public IEdgeSet getEdges(int source, int target) {
<span class="fc" id="L1018">			return new ReversedIEdgeSet(graph().getEdges(target, source));</span>
		}

		@Override
		public int addEdge(int source, int target) {
<span class="fc" id="L1023">			return graph().addEdge(target, source);</span>
		}

		@Override
		public void addEdge(int source, int target, int edge) {
<span class="fc" id="L1028">			graph().addEdge(target, source, edge);</span>
<span class="fc" id="L1029">		}</span>

		@Override
		public void removeEdgesOf(int vertex) {
<span class="fc" id="L1033">			graph().removeEdgesOf(vertex);</span>
<span class="fc" id="L1034">		}</span>

		@Override
		public void removeInEdgesOf(int vertex) {
<span class="fc" id="L1038">			graph().removeOutEdgesOf(vertex);</span>
<span class="fc" id="L1039">		}</span>

		@Override
		public void removeOutEdgesOf(int vertex) {
<span class="fc" id="L1043">			graph().removeInEdgesOf(vertex);</span>
<span class="fc" id="L1044">		}</span>

		@Override
		public int edgeSource(int edge) {
<span class="fc" id="L1048">			return graph().edgeTarget(edge);</span>
		}

		@Override
		public int edgeTarget(int edge) {
<span class="fc" id="L1053">			return graph().edgeSource(edge);</span>
		}
	}

	private static class ReverseIntGraph extends ReverseIntGraphBase {

		ReverseIntGraph(IntGraph g) {
<span class="fc" id="L1060">			super(g);</span>
<span class="fc" id="L1061">		}</span>

		@Override
		public IndexGraph indexGraph() {
<span class="fc" id="L1065">			return (IndexGraph) Graphs.reverseView(graph().indexGraph());</span>
		}

		@Override
		public IndexIntIdMap indexGraphVerticesMap() {
<span class="fc" id="L1070">			return graph().indexGraphVerticesMap();</span>
		}

		@Override
		public IndexIntIdMap indexGraphEdgesMap() {
<span class="fc" id="L1075">			return graph().indexGraphEdgesMap();</span>
		}
	}

	private static class ReverseIndexGraph extends ReverseIntGraphBase implements IndexGraph {

		ReverseIndexGraph(IndexGraph g) {
<span class="fc" id="L1082">			super(g);</span>
<span class="fc" id="L1083">		}</span>

		@Override
		IndexGraph graph() {
<span class="fc" id="L1087">			return (IndexGraph) super.graph();</span>
		}

		@Override
		@Deprecated
		public void addVertex(int vertex) {
<span class="nc" id="L1093">			IndexGraph.super.addVertex(vertex);</span>
<span class="nc" id="L1094">		}</span>

		@Override
		@Deprecated
		public void addEdge(int source, int target, int edge) {
<span class="nc" id="L1099">			IndexGraph.super.addEdge(source, target, edge);</span>
<span class="nc" id="L1100">		}</span>

		@Override
		public void addVertexRemoveListener(IndexRemoveListener listener) {
<span class="fc" id="L1104">			graph().addVertexRemoveListener(listener);</span>
<span class="fc" id="L1105">		}</span>

		@Override
		public void removeVertexRemoveListener(IndexRemoveListener listener) {
<span class="fc" id="L1109">			graph().removeVertexRemoveListener(listener);</span>
<span class="fc" id="L1110">		}</span>

		@Override
		public void addEdgeRemoveListener(IndexRemoveListener listener) {
<span class="fc" id="L1114">			graph().addEdgeRemoveListener(listener);</span>
<span class="fc" id="L1115">		}</span>

		@Override
		public void removeEdgeRemoveListener(IndexRemoveListener listener) {
<span class="fc" id="L1119">			graph().removeEdgeRemoveListener(listener);</span>
<span class="fc" id="L1120">		}</span>
	}

	private static class ReversedEdgeSet&lt;V, E&gt; extends AbstractSet&lt;E&gt; implements EdgeSet&lt;V, E&gt; {

		private final EdgeSet&lt;V, E&gt; set;

<span class="fc" id="L1127">		ReversedEdgeSet(EdgeSet&lt;V, E&gt; set) {</span>
<span class="fc" id="L1128">			this.set = Objects.requireNonNull(set);</span>
<span class="fc" id="L1129">		}</span>

		@Override
		public boolean contains(Object edge) {
<span class="fc" id="L1133">			return set.contains(edge);</span>
		}

		@Override
		public int size() {
<span class="fc" id="L1138">			return set.size();</span>
		}

		@Override
		public boolean remove(Object edge) {
<span class="fc" id="L1143">			return set.remove(edge);</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L1148">			set.clear();</span>
<span class="fc" id="L1149">		}</span>

		@Override
		public EdgeIter&lt;V, E&gt; iterator() {
<span class="fc" id="L1153">			return new ReversedEdgeIter&lt;&gt;(set.iterator());</span>
		}
	}

	private static class ReversedIEdgeSet extends AbstractIntSet implements IEdgeSet {

		private final IEdgeSet set;

<span class="fc" id="L1161">		ReversedIEdgeSet(IEdgeSet set) {</span>
<span class="fc" id="L1162">			this.set = Objects.requireNonNull(set);</span>
<span class="fc" id="L1163">		}</span>

		@Override
		public boolean contains(int edge) {
<span class="fc" id="L1167">			return set.contains(edge);</span>
		}

		@Override
		public int size() {
<span class="fc" id="L1172">			return set.size();</span>
		}

		@Override
		public boolean remove(int edge) {
<span class="fc" id="L1177">			return set.remove(edge);</span>
		}

		@Override
		public void clear() {
<span class="fc" id="L1182">			set.clear();</span>
<span class="fc" id="L1183">		}</span>

		@Override
		public IEdgeIter iterator() {
<span class="fc" id="L1187">			return new ReversedIEdgeIter(set.iterator());</span>
		}
	}

	private static class ReversedEdgeIter&lt;V, E&gt; extends EdgeIterView&lt;V, E&gt; {
		ReversedEdgeIter(EdgeIter&lt;V, E&gt; it) {
<span class="fc" id="L1193">			super(it);</span>
<span class="fc" id="L1194">		}</span>

		@Override
		public V source() {
<span class="fc" id="L1198">			return it.target();</span>
		}

		@Override
		public V target() {
<span class="fc" id="L1203">			return it.source();</span>
		}
	}

	private static class ReversedIEdgeIter extends IEdgeIterView {
		ReversedIEdgeIter(IEdgeIter it) {
<span class="fc" id="L1209">			super(it);</span>
<span class="fc" id="L1210">		}</span>

		@Override
		public int sourceInt() {
<span class="fc" id="L1214">			return it.targetInt();</span>
		}

		@Override
		public int targetInt() {
<span class="fc" id="L1219">			return it.sourceInt();</span>
		}
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	static &lt;V, E&gt; Graph&lt;V, E&gt; reverseView(Graph&lt;V, E&gt; g) {
<span class="fc bfc" id="L1225" title="All 2 branches covered.">		if (g instanceof IndexGraph) {</span>
<span class="pc bpc" id="L1226" title="1 of 2 branches missed.">			return (Graph&lt;V, E&gt;) (g instanceof ReverseIndexGraph ? ((ReverseIndexGraph) g).graph()</span>
<span class="fc" id="L1227">					: new ReverseIndexGraph((IndexGraph) g));</span>
<span class="fc bfc" id="L1228" title="All 2 branches covered.">		} else if (g instanceof IntGraph) {</span>
<span class="pc bpc" id="L1229" title="1 of 2 branches missed.">			return (Graph&lt;V, E&gt;) (g instanceof ReverseIntGraphBase ? ((ReverseIntGraphBase) g).graph()</span>
<span class="fc" id="L1230">					: new ReverseIntGraph((IntGraph) g));</span>
		} else {
<span class="pc bpc" id="L1232" title="1 of 2 branches missed.">			return g instanceof ReverseGraph ? ((ReverseGraph&lt;V, E&gt;) g).graph() : new ReverseGraph&lt;&gt;(g);</span>
		}
	}

<span class="fc" id="L1236">	private static class UndirectedView&lt;V, E&gt; extends GraphView&lt;V, E&gt; {</span>

		UndirectedView(Graph&lt;V, E&gt; g) {
<span class="fc" id="L1239">			super(g);</span>
<span class="pc bnc" id="L1240" title="All 2 branches missed.">			assert g.isDirected();</span>
<span class="fc" id="L1241">		}</span>

		@Override
		public EdgeSet&lt;V, E&gt; outEdges(V source) {
<span class="fc" id="L1245">			return new EdgeSetOut(source);</span>
		}

		@Override
		public EdgeSet&lt;V, E&gt; inEdges(V target) {
<span class="fc" id="L1250">			return new EdgeSetIn(target);</span>
		}

		@Override
		public E getEdge(V source, V target) {
<span class="fc" id="L1255">			E e = graph().getEdge(source, target);</span>
<span class="fc bfc" id="L1256" title="All 2 branches covered.">			return e != null ? e : graph().getEdge(target, source);</span>
		}

		@Override
		public EdgeSet&lt;V, E&gt; getEdges(V source, V target) {
<span class="fc bfc" id="L1261" title="All 2 branches covered.">			if (source.equals(target))</span>
<span class="fc" id="L1262">				return graph().getEdges(source, target);</span>
<span class="fc" id="L1263">			return new EdgeSetSourceTarget(source, target);</span>
		}

		@Override
		public void removeEdgesOf(V vertex) {
<span class="fc" id="L1268">			graph().removeEdgesOf(vertex);</span>
<span class="fc" id="L1269">		}</span>

		@Override
		public void removeInEdgesOf(V vertex) {
<span class="fc" id="L1273">			graph().removeEdgesOf(vertex);</span>
<span class="fc" id="L1274">		}</span>

		@Override
		public void removeOutEdgesOf(V vertex) {
<span class="fc" id="L1278">			graph().removeEdgesOf(vertex);</span>
<span class="fc" id="L1279">		}</span>

		@Override
		public IndexGraph indexGraph() {
<span class="fc" id="L1283">			return graph().indexGraph().undirectedView();</span>
		}

		@Override
		public boolean isDirected() {
<span class="fc" id="L1288">			return false;</span>
		}

		@Override
		public boolean isAllowParallelEdges() {
			/*
			 * We do not enforce that (u,v) and (v,u) both exists in the original graph. Although this function return
			 * true, the original graph may no support parallel edges. See {@link Graph#undirectedView()}.
			 */
<span class="fc" id="L1297">			return true;</span>
		}

		private abstract class EdgeSetBase extends AbstractSet&lt;E&gt; implements EdgeSet&lt;V, E&gt; {

			final EdgeSet&lt;V, E&gt; out;
			final EdgeSet&lt;V, E&gt; in;

<span class="fc" id="L1305">			EdgeSetBase(EdgeSet&lt;V, E&gt; out, EdgeSet&lt;V, E&gt; in) {</span>
<span class="fc" id="L1306">				this.out = out;</span>
<span class="fc" id="L1307">				this.in = in;</span>
<span class="fc" id="L1308">			}</span>

			@Override
			public boolean contains(Object o) {
<span class="fc bfc" id="L1312" title="All 4 branches covered.">				return out.contains(o) || in.contains(o);</span>
			}

			@Override
			public boolean remove(Object o) {
<span class="pc bpc" id="L1317" title="1 of 4 branches missed.">				return out.remove(o) || in.remove(o);</span>
			}

			@Override
			public boolean removeAll(Collection&lt;?&gt; c) {
<span class="fc" id="L1322">				boolean changed = false;</span>
<span class="fc" id="L1323">				changed |= out.removeAll(c);</span>
<span class="fc" id="L1324">				changed |= in.removeAll(c);</span>
<span class="fc" id="L1325">				return changed;</span>
			}

			@Override
			public void clear() {
<span class="fc" id="L1330">				out.clear();</span>
<span class="fc" id="L1331">				in.clear();</span>
<span class="fc" id="L1332">			}</span>
		}

		private abstract class EdgeSetOutOrInBase extends EdgeSetBase {

			final V vertex;

<span class="fc" id="L1339">			EdgeSetOutOrInBase(V vertex) {</span>
<span class="fc" id="L1340">				super(graph().outEdges(vertex), graph().inEdges(vertex));</span>
<span class="fc" id="L1341">				this.vertex = vertex;</span>
<span class="fc" id="L1342">			}</span>

			@Override
			public int size() {
<span class="fc" id="L1346">				return (int) ObjectIterables.size(this);</span>
			}

			@Override
			public boolean isEmpty() {
<span class="fc bfc" id="L1351" title="All 2 branches covered.">				return !iterator().hasNext();</span>
			}
		}

		private abstract class EdgeIterOutOrInBase implements EdgeIter&lt;V, E&gt; {

			private EdgeIter&lt;V, E&gt; outIt, inIt;
			final V vertex;
			V endpoint;

<span class="fc" id="L1361">			EdgeIterOutOrInBase(V vertex) {</span>
<span class="fc" id="L1362">				outIt = graph().outEdges(vertex).iterator();</span>
<span class="fc" id="L1363">				inIt = graph().inEdges(vertex).iterator();</span>
<span class="fc" id="L1364">				this.vertex = vertex;</span>
<span class="fc" id="L1365">				advance();</span>
<span class="fc" id="L1366">			}</span>

			private void advance() {
<span class="fc bfc" id="L1369" title="All 2 branches covered.">				if (outIt != null) {</span>
<span class="fc bfc" id="L1370" title="All 2 branches covered.">					if (outIt.hasNext())</span>
<span class="fc" id="L1371">						return;</span>
<span class="fc" id="L1372">					outIt = null;</span>
				}
<span class="pc bpc" id="L1374" title="1 of 2 branches missed.">				if (inIt != null) {</span>
<span class="fc bfc" id="L1375" title="All 2 branches covered.">					for (; inIt.hasNext(); inIt.next()) {</span>
<span class="fc" id="L1376">						E e = inIt.peekNext();</span>
						/* we skip self edges in the in-edges iterator */
<span class="fc bfc" id="L1378" title="All 2 branches covered.">						if (!vertex.equals(graph().edgeSource(e)))</span>
<span class="fc" id="L1379">							return;</span>
					}
<span class="fc" id="L1381">					inIt = null;</span>
				}
<span class="fc" id="L1383">			}</span>

			@Override
			public boolean hasNext() {
<span class="fc bfc" id="L1387" title="All 2 branches covered.">				return inIt != null;</span>
			}

			@Override
			public E next() {
<span class="fc" id="L1392">				Assertions.Iters.hasNext(this);</span>
				E e;
<span class="fc bfc" id="L1394" title="All 2 branches covered.">				if (outIt != null) {</span>
<span class="fc" id="L1395">					e = outIt.next();</span>
<span class="fc" id="L1396">					endpoint = outIt.target();</span>
				} else {
<span class="fc" id="L1398">					e = inIt.next();</span>
<span class="fc" id="L1399">					endpoint = inIt.source();</span>
				}
<span class="fc" id="L1401">				advance();</span>
<span class="fc" id="L1402">				return e;</span>
			}

			@Override
			public E peekNext() {
<span class="fc" id="L1407">				Assertions.Iters.hasNext(this);</span>
<span class="fc bfc" id="L1408" title="All 2 branches covered.">				return outIt != null ? outIt.peekNext() : inIt.peekNext();</span>
			}
		}

		private class EdgeSetOut extends EdgeSetOutOrInBase {
<span class="fc" id="L1413">			EdgeSetOut(V source) {</span>
<span class="fc" id="L1414">				super(source);</span>
<span class="fc" id="L1415">			}</span>

			@Override
			public EdgeIter&lt;V, E&gt; iterator() {
<span class="fc" id="L1419">				return new EdgeIterOut(vertex);</span>
			}
		}

		private class EdgeIterOut extends EdgeIterOutOrInBase {
<span class="fc" id="L1424">			EdgeIterOut(V source) {</span>
<span class="fc" id="L1425">				super(source);</span>
<span class="fc" id="L1426">			}</span>

			@Override
			public V source() {
<span class="fc" id="L1430">				return vertex;</span>
			}

			@Override
			public V target() {
<span class="fc" id="L1435">				return endpoint;</span>
			}
		}

		private class EdgeSetIn extends EdgeSetOutOrInBase {
<span class="fc" id="L1440">			EdgeSetIn(V target) {</span>
<span class="fc" id="L1441">				super(target);</span>
<span class="fc" id="L1442">			}</span>

			@Override
			public EdgeIter&lt;V, E&gt; iterator() {
<span class="fc" id="L1446">				return new EdgeIterIn(vertex);</span>
			}
		}

		private class EdgeIterIn extends EdgeIterOutOrInBase {
<span class="fc" id="L1451">			EdgeIterIn(V target) {</span>
<span class="fc" id="L1452">				super(target);</span>
<span class="fc" id="L1453">			}</span>

			@Override
			public V source() {
<span class="fc" id="L1457">				return endpoint;</span>
			}

			@Override
			public V target() {
<span class="fc" id="L1462">				return vertex;</span>
			}
		}

		private class EdgeSetSourceTarget extends EdgeSetBase {

			private final V source, target;

<span class="fc" id="L1470">			EdgeSetSourceTarget(V source, V target) {</span>
<span class="fc" id="L1471">				super(graph().getEdges(source, target), graph().getEdges(target, source));</span>
<span class="fc" id="L1472">				this.source = source;</span>
<span class="fc" id="L1473">				this.target = target;</span>
<span class="fc" id="L1474">			}</span>

			@Override
			public int size() {
<span class="fc" id="L1478">				return out.size() + in.size();</span>
			}

			@Override
			public EdgeIter&lt;V, E&gt; iterator() {
<span class="fc" id="L1483">				return new EdgeIter&lt;&gt;() {</span>

<span class="fc" id="L1485">					private final EdgeIter&lt;V, E&gt; stIt = out.iterator();</span>
<span class="fc" id="L1486">					private final EdgeIter&lt;V, E&gt; tsIt = in.iterator();</span>
<span class="fc" id="L1487">					private EdgeIter&lt;V, E&gt; it = stIt;</span>
					{
<span class="fc" id="L1489">						advance();</span>
<span class="fc" id="L1490">					}</span>

					private void advance() {
<span class="fc bfc" id="L1493" title="All 2 branches covered.">						if (it.hasNext())</span>
<span class="fc" id="L1494">							return;</span>
<span class="fc bfc" id="L1495" title="All 4 branches covered.">						if (it == stIt &amp;&amp; tsIt.hasNext()) {</span>
<span class="fc" id="L1496">							it = tsIt;</span>
						} else {
<span class="fc" id="L1498">							it = null;</span>
						}
<span class="fc" id="L1500">					}</span>

					@Override
					public boolean hasNext() {
<span class="fc bfc" id="L1504" title="All 2 branches covered.">						return it != null;</span>
					}

					@Override
					public E next() {
<span class="fc" id="L1509">						Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L1510">						E e = it.next();</span>
<span class="fc" id="L1511">						advance();</span>
<span class="fc" id="L1512">						return e;</span>
					}

					@Override
					public E peekNext() {
<span class="fc" id="L1517">						Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L1518">						return it.peekNext();</span>
					}

					@Override
					public V source() {
<span class="fc" id="L1523">						return source;</span>
					}

					@Override
					public V target() {
<span class="fc" id="L1528">						return target;</span>
					}
				};
			}
		}
	}

<span class="fc" id="L1535">	private abstract static class UndirectedViewIntBase extends IntGraphViewBase {</span>

		UndirectedViewIntBase(IntGraph g) {
<span class="fc" id="L1538">			super(g);</span>
<span class="pc bnc" id="L1539" title="All 2 branches missed.">			assert g.isDirected();</span>
<span class="fc" id="L1540">		}</span>

		@Override
		public IEdgeSet outEdges(int source) {
<span class="fc" id="L1544">			return new EdgeSetOut(source);</span>
		}

		@Override
		public IEdgeSet inEdges(int target) {
<span class="fc" id="L1549">			return new EdgeSetIn(target);</span>
		}

		@Override
		public int getEdge(int source, int target) {
<span class="fc" id="L1554">			int e = graph().getEdge(source, target);</span>
<span class="fc bfc" id="L1555" title="All 2 branches covered.">			return e != -1 ? e : graph().getEdge(target, source);</span>
		}

		@Override
		public IEdgeSet getEdges(int source, int target) {
<span class="fc bfc" id="L1560" title="All 2 branches covered.">			if (source == target)</span>
<span class="fc" id="L1561">				return graph().getEdges(source, target);</span>
<span class="fc" id="L1562">			return new EdgeSetSourceTarget(source, target);</span>
		}

		@Override
		public void removeEdgesOf(int vertex) {
<span class="fc" id="L1567">			graph().removeEdgesOf(vertex);</span>
<span class="fc" id="L1568">		}</span>

		@Override
		public void removeInEdgesOf(int vertex) {
<span class="fc" id="L1572">			graph().removeEdgesOf(vertex);</span>
<span class="fc" id="L1573">		}</span>

		@Override
		public void removeOutEdgesOf(int vertex) {
<span class="fc" id="L1577">			graph().removeEdgesOf(vertex);</span>
<span class="fc" id="L1578">		}</span>

		@Override
		public boolean isDirected() {
<span class="fc" id="L1582">			return false;</span>
		}

		@Override
		public boolean isAllowParallelEdges() {
			/*
			 * We do not enforce that (u,v) and (v,u) both exists in the original graph. Although this function return
			 * true, the original graph may no support parallel edges. See {@link Graph#undirectedView()}.
			 */
<span class="fc" id="L1591">			return true;</span>
		}

		private abstract class EdgeSetBase extends AbstractIntSet implements IEdgeSet {

			final IEdgeSet out;
			final IEdgeSet in;

<span class="fc" id="L1599">			EdgeSetBase(IEdgeSet out, IEdgeSet in) {</span>
<span class="fc" id="L1600">				this.out = out;</span>
<span class="fc" id="L1601">				this.in = in;</span>
<span class="fc" id="L1602">			}</span>

			@Override
			public boolean contains(int o) {
<span class="fc bfc" id="L1606" title="All 4 branches covered.">				return out.contains(o) || in.contains(o);</span>
			}

			@Override
			public boolean remove(int o) {
<span class="pc bpc" id="L1611" title="1 of 4 branches missed.">				return out.remove(o) || in.remove(o);</span>
			}

			@Override
			public boolean removeAll(IntCollection c) {
<span class="fc" id="L1616">				boolean changed = false;</span>
<span class="fc" id="L1617">				changed |= out.removeAll(c);</span>
<span class="fc" id="L1618">				changed |= in.removeAll(c);</span>
<span class="fc" id="L1619">				return changed;</span>
			}

			@Override
			public void clear() {
<span class="fc" id="L1624">				out.clear();</span>
<span class="fc" id="L1625">				in.clear();</span>
<span class="fc" id="L1626">			}</span>
		}

		private abstract class EdgeSetOutOrInBase extends EdgeSetBase {

			final int vertex;

<span class="fc" id="L1633">			EdgeSetOutOrInBase(int vertex) {</span>
<span class="fc" id="L1634">				super(graph().outEdges(vertex), graph().inEdges(vertex));</span>
<span class="fc" id="L1635">				this.vertex = vertex;</span>
<span class="fc" id="L1636">			}</span>

			@Override
			public int size() {
<span class="fc" id="L1640">				return (int) ObjectIterables.size(this);</span>
			}

			@Override
			public boolean isEmpty() {
<span class="fc bfc" id="L1645" title="All 2 branches covered.">				return !iterator().hasNext();</span>
			}
		}

		private abstract class EdgeIterOutOrInBase implements IEdgeIter {

			private IEdgeIter outIt, inIt;
			final int vertex;
			int endpoint;

<span class="fc" id="L1655">			EdgeIterOutOrInBase(int vertex) {</span>
<span class="fc" id="L1656">				outIt = graph().outEdges(vertex).iterator();</span>
<span class="fc" id="L1657">				inIt = graph().inEdges(vertex).iterator();</span>
<span class="fc" id="L1658">				this.vertex = vertex;</span>
<span class="fc" id="L1659">				advance();</span>
<span class="fc" id="L1660">			}</span>

			private void advance() {
<span class="fc bfc" id="L1663" title="All 2 branches covered.">				if (outIt != null) {</span>
<span class="fc bfc" id="L1664" title="All 2 branches covered.">					if (outIt.hasNext())</span>
<span class="fc" id="L1665">						return;</span>
<span class="fc" id="L1666">					outIt = null;</span>
				}
<span class="pc bpc" id="L1668" title="1 of 2 branches missed.">				if (inIt != null) {</span>
<span class="fc bfc" id="L1669" title="All 2 branches covered.">					for (; inIt.hasNext(); inIt.nextInt()) {</span>
<span class="fc" id="L1670">						int e = inIt.peekNextInt();</span>
						/* we skip self edges in the in-edges iterator */
<span class="fc bfc" id="L1672" title="All 2 branches covered.">						if (vertex != graph().edgeSource(e))</span>
<span class="fc" id="L1673">							return;</span>
					}
<span class="fc" id="L1675">					inIt = null;</span>
				}
<span class="fc" id="L1677">			}</span>

			@Override
			public boolean hasNext() {
<span class="fc bfc" id="L1681" title="All 2 branches covered.">				return inIt != null;</span>
			}

			@Override
			public int nextInt() {
<span class="fc" id="L1686">				Assertions.Iters.hasNext(this);</span>
				int e;
<span class="fc bfc" id="L1688" title="All 2 branches covered.">				if (outIt != null) {</span>
<span class="fc" id="L1689">					e = outIt.nextInt();</span>
<span class="fc" id="L1690">					endpoint = outIt.targetInt();</span>
				} else {
<span class="fc" id="L1692">					e = inIt.nextInt();</span>
<span class="fc" id="L1693">					endpoint = inIt.sourceInt();</span>
				}
<span class="fc" id="L1695">				advance();</span>
<span class="fc" id="L1696">				return e;</span>
			}

			@Override
			public int peekNextInt() {
<span class="fc" id="L1701">				Assertions.Iters.hasNext(this);</span>
<span class="fc bfc" id="L1702" title="All 2 branches covered.">				return outIt != null ? outIt.peekNextInt() : inIt.peekNextInt();</span>
			}
		}

		private class EdgeSetOut extends EdgeSetOutOrInBase {
<span class="fc" id="L1707">			EdgeSetOut(int source) {</span>
<span class="fc" id="L1708">				super(source);</span>
<span class="fc" id="L1709">			}</span>

			@Override
			public IEdgeIter iterator() {
<span class="fc" id="L1713">				return new EdgeIterOut(vertex);</span>
			}
		}

		private class EdgeIterOut extends EdgeIterOutOrInBase {
<span class="fc" id="L1718">			EdgeIterOut(int source) {</span>
<span class="fc" id="L1719">				super(source);</span>
<span class="fc" id="L1720">			}</span>

			@Override
			public int sourceInt() {
<span class="fc" id="L1724">				return vertex;</span>
			}

			@Override
			public int targetInt() {
<span class="fc" id="L1729">				return endpoint;</span>
			}
		}

		private class EdgeSetIn extends EdgeSetOutOrInBase {
<span class="fc" id="L1734">			EdgeSetIn(int target) {</span>
<span class="fc" id="L1735">				super(target);</span>
<span class="fc" id="L1736">			}</span>

			@Override
			public IEdgeIter iterator() {
<span class="fc" id="L1740">				return new EdgeIterIn(vertex);</span>
			}
		}

		private class EdgeIterIn extends EdgeIterOutOrInBase {
<span class="fc" id="L1745">			EdgeIterIn(int target) {</span>
<span class="fc" id="L1746">				super(target);</span>
<span class="fc" id="L1747">			}</span>

			@Override
			public int sourceInt() {
<span class="fc" id="L1751">				return endpoint;</span>
			}

			@Override
			public int targetInt() {
<span class="fc" id="L1756">				return vertex;</span>
			}
		}

		private class EdgeSetSourceTarget extends EdgeSetBase {

			private final int source, target;

<span class="fc" id="L1764">			EdgeSetSourceTarget(int source, int target) {</span>
<span class="fc" id="L1765">				super(graph().getEdges(source, target), graph().getEdges(target, source));</span>
<span class="fc" id="L1766">				this.source = source;</span>
<span class="fc" id="L1767">				this.target = target;</span>
<span class="fc" id="L1768">			}</span>

			@Override
			public int size() {
<span class="fc" id="L1772">				return out.size() + in.size();</span>
			}

			@Override
			public IEdgeIter iterator() {
<span class="fc" id="L1777">				return new IEdgeIter() {</span>

<span class="fc" id="L1779">					private final IEdgeIter stIt = out.iterator();</span>
<span class="fc" id="L1780">					private final IEdgeIter tsIt = in.iterator();</span>
<span class="fc" id="L1781">					private IEdgeIter it = stIt;</span>
					{
<span class="fc" id="L1783">						advance();</span>
<span class="fc" id="L1784">					}</span>

					private void advance() {
<span class="fc bfc" id="L1787" title="All 2 branches covered.">						if (it.hasNext())</span>
<span class="fc" id="L1788">							return;</span>
<span class="fc bfc" id="L1789" title="All 4 branches covered.">						if (it == stIt &amp;&amp; tsIt.hasNext()) {</span>
<span class="fc" id="L1790">							it = tsIt;</span>
						} else {
<span class="fc" id="L1792">							it = null;</span>
						}
<span class="fc" id="L1794">					}</span>

					@Override
					public boolean hasNext() {
<span class="fc bfc" id="L1798" title="All 2 branches covered.">						return it != null;</span>
					}

					@Override
					public int nextInt() {
<span class="fc" id="L1803">						Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L1804">						int e = it.nextInt();</span>
<span class="fc" id="L1805">						advance();</span>
<span class="fc" id="L1806">						return e;</span>
					}

					@Override
					public int peekNextInt() {
<span class="fc" id="L1811">						Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L1812">						return it.peekNextInt();</span>
					}

					@Override
					public int sourceInt() {
<span class="fc" id="L1817">						return source;</span>
					}

					@Override
					public int targetInt() {
<span class="fc" id="L1822">						return target;</span>
					}
				};
			}
		}

	}

	private static class UndirectedViewInt extends UndirectedViewIntBase {

		UndirectedViewInt(IntGraph g) {
<span class="fc" id="L1833">			super(g);</span>
<span class="fc" id="L1834">		}</span>

		@Override
		public IndexGraph indexGraph() {
<span class="fc" id="L1838">			return graph().indexGraph().undirectedView();</span>
		}

		@Override
		public IndexIntIdMap indexGraphVerticesMap() {
<span class="fc" id="L1843">			return graph().indexGraphVerticesMap();</span>
		}

		@Override
		public IndexIntIdMap indexGraphEdgesMap() {
<span class="fc" id="L1848">			return graph().indexGraphEdgesMap();</span>
		}
	}

	private static class UndirectedViewIndex extends UndirectedViewIntBase implements IndexGraph {

		UndirectedViewIndex(IndexGraph g) {
<span class="fc" id="L1855">			super(g);</span>
<span class="fc" id="L1856">		}</span>

		@Override
		IndexGraph graph() {
<span class="fc" id="L1860">			return (IndexGraph) super.graph();</span>
		}

		@Override
		@Deprecated
		public void addVertex(int vertex) {
<span class="nc" id="L1866">			IndexGraph.super.addVertex(vertex);</span>
<span class="nc" id="L1867">		}</span>

		@Override
		@Deprecated
		public void addEdge(int source, int target, int edge) {
<span class="nc" id="L1872">			IndexGraph.super.addEdge(source, target, edge);</span>
<span class="nc" id="L1873">		}</span>

		@Override
		public void addVertexRemoveListener(IndexRemoveListener listener) {
<span class="fc" id="L1877">			graph().addVertexRemoveListener(listener);</span>
<span class="fc" id="L1878">		}</span>

		@Override
		public void removeVertexRemoveListener(IndexRemoveListener listener) {
<span class="fc" id="L1882">			graph().removeVertexRemoveListener(listener);</span>
<span class="fc" id="L1883">		}</span>

		@Override
		public void addEdgeRemoveListener(IndexRemoveListener listener) {
<span class="fc" id="L1887">			graph().addEdgeRemoveListener(listener);</span>
<span class="fc" id="L1888">		}</span>

		@Override
		public void removeEdgeRemoveListener(IndexRemoveListener listener) {
<span class="fc" id="L1892">			graph().removeEdgeRemoveListener(listener);</span>
<span class="fc" id="L1893">		}</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	static &lt;V, E&gt; Graph&lt;V, E&gt; undirectedView(Graph&lt;V, E&gt; g) {
<span class="fc bfc" id="L1898" title="All 2 branches covered.">		if (!g.isDirected()) {</span>
<span class="fc" id="L1899">			return g;</span>
<span class="fc bfc" id="L1900" title="All 2 branches covered.">		} else if (g instanceof IndexGraph) {</span>
<span class="fc" id="L1901">			return (Graph&lt;V, E&gt;) new UndirectedViewIndex((IndexGraph) g);</span>
<span class="fc bfc" id="L1902" title="All 2 branches covered.">		} else if (g instanceof IntGraph) {</span>
<span class="fc" id="L1903">			return (Graph&lt;V, E&gt;) new UndirectedViewInt((IntGraph) g);</span>
		} else {
<span class="fc" id="L1905">			return new UndirectedView&lt;&gt;(g);</span>
		}
	}

	static String getIndexGraphImpl(IndexGraph g) {
		for (;;) {
<span class="fc" id="L1911">			IndexGraph g0 = g;</span>
<span class="pc bpc" id="L1912" title="1 of 2 branches missed.">			if (g instanceof ReverseIndexGraph)</span>
<span class="nc" id="L1913">				g = ((ReverseIndexGraph) g).graph();</span>
<span class="pc bpc" id="L1914" title="1 of 2 branches missed.">			if (g instanceof ImmutableIndexGraphView)</span>
<span class="nc" id="L1915">				g = ((ImmutableIndexGraphView) g).graph();</span>
<span class="fc bfc" id="L1916" title="All 2 branches covered.">			if (g instanceof GraphArrayAbstract)</span>
<span class="fc" id="L1917">				return &quot;array&quot;;</span>
<span class="fc bfc" id="L1918" title="All 2 branches covered.">			if (g instanceof GraphLinkedAbstract)</span>
<span class="fc" id="L1919">				return &quot;linked-list&quot;;</span>
<span class="fc bfc" id="L1920" title="All 2 branches covered.">			if (g instanceof GraphHashmapAbstract)</span>
<span class="fc" id="L1921">				return &quot;hashtable&quot;;</span>
<span class="fc bfc" id="L1922" title="All 2 branches covered.">			if (g instanceof GraphMatrixAbstract)</span>
<span class="fc" id="L1923">				return &quot;matrix&quot;;</span>
<span class="pc bpc" id="L1924" title="1 of 2 branches missed.">			if (g == g0)</span>
<span class="fc" id="L1925">				return null;</span>
<span class="nc" id="L1926">		}</span>
	}

<span class="fc" id="L1929">	static final IndexIntIdMap IndexIdMapIdentify = new IndexGraphMapIdentify();</span>

	private static class IndexGraphMapIdentify implements IndexIntIdMap {
		@Override
		public int indexToIdInt(int index) {
<span class="fc" id="L1934">			return index;</span>
		}

		@Override
		public int indexToIdIfExistInt(int index) {
<span class="nc" id="L1939">			return index;</span>
		}

		@Override
		public int idToIndex(int id) {
<span class="fc" id="L1944">			return id;</span>
		}

		@Override
		public int idToIndexIfExist(int id) {
<span class="nc" id="L1949">			return id;</span>
		}
	}

	static class EdgeSetSourceTargetSingleton extends AbstractIntSet implements IEdgeSet {

		private final IntGraph g;
		private final int source, target;
		private int edge;
		private static final int EdgeNone = -1;

<span class="fc" id="L1960">		EdgeSetSourceTargetSingleton(IntGraph g, int source, int target, int edge) {</span>
<span class="fc" id="L1961">			this.g = g;</span>
<span class="fc" id="L1962">			this.source = source;</span>
<span class="fc" id="L1963">			this.target = target;</span>
<span class="fc" id="L1964">			this.edge = edge;</span>
<span class="fc" id="L1965">		}</span>

		@Override
		public boolean remove(int edge) {
<span class="pc bpc" id="L1969" title="1 of 2 branches missed.">			if (this.edge != edge)</span>
<span class="nc" id="L1970">				return false;</span>
<span class="fc" id="L1971">			g.removeEdge(edge);</span>
<span class="fc" id="L1972">			this.edge = EdgeNone;</span>
<span class="fc" id="L1973">			return true;</span>
		}

		@Override
		public boolean contains(int edge) {
<span class="pc bpc" id="L1978" title="2 of 4 branches missed.">			return this.edge != EdgeNone &amp;&amp; this.edge == edge;</span>
		}

		@Override
		public int size() {
<span class="pc bpc" id="L1983" title="1 of 2 branches missed.">			return edge != EdgeNone ? 1 : 0;</span>
		}

		@Override
		public void clear() {
<span class="nc bnc" id="L1988" title="All 2 branches missed.">			if (edge != EdgeNone) {</span>
<span class="nc" id="L1989">				g.removeEdge(edge);</span>
<span class="nc" id="L1990">				edge = EdgeNone;</span>
			}
<span class="nc" id="L1992">		}</span>

		@Override
		public IEdgeIter iterator() {
<span class="fc" id="L1996">			return new IEdgeIter() {</span>

<span class="pc bpc" id="L1998" title="1 of 2 branches missed.">				boolean beforeNext = edge != EdgeNone;</span>

				@Override
				public boolean hasNext() {
<span class="fc" id="L2002">					return beforeNext;</span>
				}

				@Override
				public int nextInt() {
<span class="fc" id="L2007">					Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L2008">					beforeNext = false;</span>
<span class="fc" id="L2009">					return edge;</span>
				}

				@Override
				public int peekNextInt() {
<span class="fc" id="L2014">					Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L2015">					return edge;</span>
				}

				@Override
				public int sourceInt() {
<span class="fc" id="L2020">					return source;</span>
				}

				@Override
				public int targetInt() {
<span class="fc" id="L2025">					return target;</span>
				}

				@Override
				public void remove() {
<span class="nc bnc" id="L2030" title="All 2 branches missed.">					if (beforeNext)</span>
<span class="nc" id="L2031">						throw new IllegalStateException();</span>
<span class="nc" id="L2032">					g.removeEdge(edge);</span>
<span class="nc" id="L2033">					edge = EdgeNone;</span>
<span class="nc" id="L2034">				}</span>
			};
		}
	}

	/**
	 * Create a new graph that is an induced subgraph of the given graph.
	 *
	 * &lt;p&gt;
	 * An induced subgraph of a graph \(G=(V,E)\) is a graph \(G'=(V',E')\) where \(V' \subseteq V\) and \(E' =
	 * \{\{u,v\} \mid u,v \in V', \{u,v\} \in E\}\). The created graph will have the same type (directed/undirected) as
	 * the given graph. The vertices and edges of the created graph will be a subset of the vertices and edges of the
	 * given graph.
	 *
	 * &lt;p&gt;
	 * The weights of both vertices and edges will not be copied to the new sub graph. For more flexible sub graph
	 * creation, see {@link #subGraph(Graph, Collection, Collection, boolean, boolean)}.
	 *
	 * &lt;p&gt;
	 * If {@code g} is {@link IntGraph}, the returned sub graph is also an {@link IntGraph}.
	 *
	 * @param  &lt;V&gt;      the vertices type
	 * @param  &lt;E&gt;      the edges type
	 * @param  g        the graph to create a sub graph from
	 * @param  vertices the vertices of the sub graph
	 * @return          a new graph that is an induced subgraph of the given graph
	 */
	public static &lt;V, E&gt; Graph&lt;V, E&gt; subGraph(Graph&lt;V, E&gt; g, Collection&lt;V&gt; vertices) {
<span class="fc" id="L2062">		return subGraph(g, Objects.requireNonNull(vertices), null);</span>
	}

	/**
	 * Create a new graph that is a subgraph of the given graph.
	 *
	 * &lt;p&gt;
	 * If {@code edges} is {@code null}, then the created graph will be an induced subgraph of the given graph, namely
	 * an induced subgraph of a graph \(G=(V,E)\) is a graph \(G'=(V',E')\) where \(V' \subseteq V\) and \(E' =
	 * \{\{u,v\} \mid u,v \in V', \{u,v\} \in E\}\). The behavior is similar to {@link #subGraph(Graph, Collection)}.
	 * {@code vertices} must not be {@code null} in this case.
	 *
	 * &lt;p&gt;
	 * If {@code vertices} is {@code null}, then {@code edges} must not be {@code null}, and the sub graph will contain
	 * all the vertices which are either a source or a target of an edge in {@code edges}.
	 *
	 * &lt;p&gt;
	 * The created graph will have the same type (directed/undirected) as the given graph. The vertices and edges of the
	 * created graph will be a subset of the vertices and edges of the given graph.
	 *
	 * &lt;p&gt;
	 * The weights of both vertices and edges will not be copied to the new sub graph. For more flexible sub graph
	 * creation, see {@link #subGraph(Graph, Collection, Collection, boolean, boolean)}.
	 *
	 * &lt;p&gt;
	 * If {@code g} is {@link IntGraph}, the returned sub graph is also an {@link IntGraph}.
	 *
	 * @param  &lt;V&gt;                  the vertices type
	 * @param  &lt;E&gt;                  the edges type
	 * @param  g                    the graph to create a sub graph from
	 * @param  vertices             the vertices of the sub graph, if {@code null} then {@code edges} must not be
	 *                                  {@code null} and the vertices of the sub graph will be all the vertices which
	 *                                  are either a source or a target of an edge in {@code edges}
	 * @param  edges                the edges of the sub graph, if {@code null} then {@code vertices} must not be
	 *                                  {@code null} and the sub graph will be an induced subgraph of the given graph
	 * @return                      a new graph that is a subgraph of the given graph
	 * @throws NullPointerException if both {@code vertices} and {@code edges} are {@code null}
	 */
	public static &lt;V, E&gt; Graph&lt;V, E&gt; subGraph(Graph&lt;V, E&gt; g, Collection&lt;V&gt; vertices, Collection&lt;E&gt; edges) {
<span class="fc" id="L2101">		return subGraph(g, vertices, edges, false, false);</span>
	}

	/**
	 * Create a new graph that is a subgraph of the given graph, with option to copy weights.
	 *
	 * &lt;p&gt;
	 * If {@code edges} is {@code null}, then the created graph will be an induced subgraph of the given graph, namely
	 * an induced subgraph of a graph \(G=(V,E)\) is a graph \(G'=(V',E')\) where \(V' \subseteq V\) and \(E' =
	 * \{\{u,v\} \mid u,v \in V', \{u,v\} \in E\}\). The behavior is similar to {@link #subGraph(Graph, Collection)}.
	 * {@code vertices} must not be {@code null} in this case.
	 *
	 * &lt;p&gt;
	 * If {@code vertices} is {@code null}, then {@code edges} must not be {@code null}, and the sub graph will contain
	 * all the vertices which are either a source or a target of an edge in {@code edges}.
	 *
	 * &lt;p&gt;
	 * The created graph will have the same type (directed/undirected) as the given graph. The vertices and edges of the
	 * created graph will be a subset of the vertices and edges of the given graph.
	 *
	 * &lt;p&gt;
	 * An additional parameter options for copying the weights of the vertices and edges of the given graph to the new
	 * sub graph are provided. If {@code copyVerticesWeights} is {@code true}, then all the vertices weights of the
	 * given graph will be copied to the new sub graph. If {@code copyEdgesWeights} is {@code true}, then all the edges
	 * weights of the given graph will be copied to the new sub graph.
	 *
	 * &lt;p&gt;
	 * If {@code g} is {@link IntGraph}, the returned sub graph is also an {@link IntGraph}.
	 *
	 * @param  &lt;V&gt;                  the vertices type
	 * @param  &lt;E&gt;                  the edges type
	 * @param  g                    the graph to create a sub graph from
	 * @param  vertices             the vertices of the sub graph, if {@code null} then {@code edges} must not be
	 *                                  {@code null} and the vertices of the sub graph will be all the vertices which
	 *                                  are either a source or a target of an edge in {@code edges}
	 * @param  edges                the edges of the sub graph, if {@code null} then {@code vertices} must not be
	 *                                  {@code null} and the sub graph will be an induced subgraph of the given graph
	 * @param  copyVerticesWeights  if {@code true} then all the vertices weights of the given graph will be copied to
	 *                                  the new sub graph
	 * @param  copyEdgesWeights     if {@code true} then all the edges weights of the given graph will be copied to the
	 *                                  new sub graph
	 * @return                      a new graph that is a subgraph of the given graph
	 * @throws NullPointerException if both {@code vertices} and {@code edges} are {@code null}
	 */
	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot;, &quot;cast&quot; })
	public static &lt;V, E&gt; Graph&lt;V, E&gt; subGraph(Graph&lt;V, E&gt; g, Collection&lt;V&gt; vertices, Collection&lt;E&gt; edges,
			boolean copyVerticesWeights, boolean copyEdgesWeights) {
<span class="fc bfc" id="L2148" title="All 2 branches covered.">		if (g instanceof IntGraph) {</span>
<span class="fc bfc" id="L2149" title="All 2 branches covered.">			IntCollection vs = vertices == null ? null : IntAdapters.asIntCollection((Collection&lt;Integer&gt;) vertices);</span>
<span class="fc bfc" id="L2150" title="All 2 branches covered.">			IntCollection es = edges == null ? null : IntAdapters.asIntCollection((Collection&lt;Integer&gt;) edges);</span>
<span class="fc" id="L2151">			return (Graph&lt;V, E&gt;) subGraph((IntGraph) g, vs, es, copyVerticesWeights, copyEdgesWeights);</span>
		}

<span class="pc bpc" id="L2154" title="1 of 4 branches missed.">		if (vertices == null &amp;&amp; edges == null)</span>
<span class="nc" id="L2155">			throw new NullPointerException();</span>
<span class="fc bfc" id="L2156" title="All 2 branches covered.">		GraphBuilder&lt;V, E&gt; gb = g.isDirected() ? GraphBuilder.newDirected() : GraphBuilder.newUndirected();</span>

<span class="fc bfc" id="L2158" title="All 2 branches covered.">		if (vertices == null) {</span>
<span class="fc" id="L2159">			vertices = new ObjectOpenHashSet();</span>
<span class="fc bfc" id="L2160" title="All 2 branches covered.">			for (E e : edges) {</span>
<span class="fc" id="L2161">				vertices.add(g.edgeSource(e));</span>
<span class="fc" id="L2162">				vertices.add(g.edgeTarget(e));</span>
<span class="fc" id="L2163">			}</span>
		}
<span class="fc" id="L2165">		gb.expectedVerticesNum(vertices.size());</span>
<span class="fc bfc" id="L2166" title="All 2 branches covered.">		for (V v : vertices)</span>
<span class="fc" id="L2167">			gb.addVertex(v);</span>

<span class="fc bfc" id="L2169" title="All 2 branches covered.">		if (edges == null) {</span>
<span class="fc bfc" id="L2170" title="All 2 branches covered.">			if (g.isDirected()) {</span>
<span class="fc bfc" id="L2171" title="All 2 branches covered.">				for (V u : gb.vertices()) {</span>
<span class="fc bfc" id="L2172" title="All 2 branches covered.">					for (EdgeIter&lt;V, E&gt; eit = g.outEdges(u).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L2173">						E e = eit.next();</span>
<span class="fc" id="L2174">						V v = eit.target();</span>
<span class="fc bfc" id="L2175" title="All 2 branches covered.">						if (gb.vertices().contains(v))</span>
<span class="fc" id="L2176">							gb.addEdge(u, v, e);</span>
<span class="fc" id="L2177">					}</span>
<span class="fc" id="L2178">				}</span>
			} else {
<span class="fc" id="L2180">				IndexIdMap&lt;V&gt; viMap = g.indexGraphVerticesMap();</span>
<span class="fc bfc" id="L2181" title="All 2 branches covered.">				for (V u : gb.vertices()) {</span>
<span class="fc bfc" id="L2182" title="All 2 branches covered.">					for (EdgeIter&lt;V, E&gt; eit = g.outEdges(u).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L2183">						E e = eit.next();</span>
<span class="fc" id="L2184">						V v = eit.target();</span>
<span class="fc bfc" id="L2185" title="All 4 branches covered.">						if (viMap.idToIndex(u) &lt;= viMap.idToIndex(v) &amp;&amp; gb.vertices().contains(v))</span>
<span class="fc" id="L2186">							gb.addEdge(u, v, e);</span>
<span class="fc" id="L2187">					}</span>
<span class="fc" id="L2188">				}</span>
<span class="fc" id="L2189">			}</span>
		} else {
<span class="fc bfc" id="L2191" title="All 2 branches covered.">			for (E e : edges)</span>
<span class="fc" id="L2192">				gb.addEdge(g.edgeSource(e), g.edgeTarget(e), e);</span>
		}

<span class="fc bfc" id="L2195" title="All 2 branches covered.">		if (copyVerticesWeights) {</span>
<span class="fc bfc" id="L2196" title="All 2 branches covered.">			for (String key : g.getVerticesWeightsKeys()) {</span>
<span class="fc" id="L2197">				Weights wSrc = g.getVerticesWeights(key);</span>
<span class="fc" id="L2198">				Class&lt;?&gt; type = (Class) getWeightsType(wSrc);</span>
<span class="fc" id="L2199">				Weights wDst = gb.addVerticesWeights(key, (Class) type, wSrc.defaultWeightAsObj());</span>
<span class="fc" id="L2200">				copyWeights(wSrc, wDst, type, gb.vertices());</span>
<span class="fc" id="L2201">			}</span>
		}
<span class="fc bfc" id="L2203" title="All 2 branches covered.">		if (copyEdgesWeights) {</span>
<span class="fc bfc" id="L2204" title="All 2 branches covered.">			for (String key : g.getEdgesWeightsKeys()) {</span>
<span class="fc" id="L2205">				Weights wSrc = g.getEdgesWeights(key);</span>
<span class="fc" id="L2206">				Class&lt;?&gt; type = (Class) getWeightsType(wSrc);</span>
<span class="fc" id="L2207">				Weights wDst = gb.addEdgesWeights(key, (Class) type, wSrc.defaultWeightAsObj());</span>
<span class="fc" id="L2208">				copyWeights(wSrc, wDst, type, gb.edges());</span>
<span class="fc" id="L2209">			}</span>
		}

<span class="fc" id="L2212">		return gb.build();</span>
	}

	/**
	 * Create a new graph that is a subgraph of the given int graph, with option to copy weights.
	 *
	 * &lt;p&gt;
	 * If {@code edges} is {@code null}, then the created graph will be an induced subgraph of the given graph, namely
	 * an induced subgraph of a graph \(G=(V,E)\) is a graph \(G'=(V',E')\) where \(V' \subseteq V\) and \(E' =
	 * \{\{u,v\} \mid u,v \in V', \{u,v\} \in E\}\).
	 *
	 * &lt;p&gt;
	 * If {@code vertices} is {@code null}, then {@code edges} must not be {@code null}, and the sub graph will contain
	 * all the vertices which are either a source or a target of an edge in {@code edges}.
	 *
	 * &lt;p&gt;
	 * The created graph will have the same type (directed/undirected) as the given graph. The vertices and edges of the
	 * created graph will be a subset of the vertices and edges of the given graph.
	 *
	 * &lt;p&gt;
	 * An additional parameter options for copying the weights of the vertices and edges of the given graph to the new
	 * sub graph are provided. If {@code copyVerticesWeights} is {@code true}, then all the vertices weights of the
	 * given graph will be copied to the new sub graph. If {@code copyEdgesWeights} is {@code true}, then all the edges
	 * weights of the given graph will be copied to the new sub graph.
	 *
	 * @param  g                    the graph to create a sub graph from
	 * @param  vertices             the vertices of the sub graph, if {@code null} then {@code edges} must not be
	 *                                  {@code null} and the vertices of the sub graph will be all the vertices which
	 *                                  are either a source or a target of an edge in {@code edges}
	 * @param  edges                the edges of the sub graph, if {@code null} then {@code vertices} must not be
	 *                                  {@code null} and the sub graph will be an induced subgraph of the given graph
	 * @param  copyVerticesWeights  if {@code true} then all the vertices weights of the given graph will be copied to
	 *                                  the new sub graph
	 * @param  copyEdgesWeights     if {@code true} then all the edges weights of the given graph will be copied to the
	 *                                  new sub graph
	 * @return                      a new graph that is a subgraph of the given graph
	 * @throws NullPointerException if both {@code vertices} and {@code edges} are {@code null}
	 */
	@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot;, &quot;cast&quot; })
	public static IntGraph subGraph(IntGraph g, IntCollection vertices, IntCollection edges,
			boolean copyVerticesWeights, boolean copyEdgesWeights) {
<span class="pc bpc" id="L2253" title="1 of 4 branches missed.">		if (vertices == null &amp;&amp; edges == null)</span>
<span class="nc" id="L2254">			throw new NullPointerException(&quot;Either vertices or edges can be null, not both.&quot;);</span>
<span class="fc bfc" id="L2255" title="All 2 branches covered.">		IntGraphBuilder gb = g.isDirected() ? IntGraphBuilder.newDirected() : IntGraphBuilder.newUndirected();</span>

<span class="fc bfc" id="L2257" title="All 2 branches covered.">		if (vertices == null) {</span>
<span class="fc" id="L2258">			vertices = new IntOpenHashSet();</span>
<span class="fc bfc" id="L2259" title="All 2 branches covered.">			for (int e : edges) {</span>
<span class="fc" id="L2260">				vertices.add(g.edgeSource(e));</span>
<span class="fc" id="L2261">				vertices.add(g.edgeTarget(e));</span>
<span class="fc" id="L2262">			}</span>
		}
<span class="fc" id="L2264">		gb.expectedVerticesNum(vertices.size());</span>
<span class="fc bfc" id="L2265" title="All 2 branches covered.">		for (int v : vertices)</span>
<span class="fc" id="L2266">			gb.addVertex(v);</span>

<span class="fc bfc" id="L2268" title="All 2 branches covered.">		if (edges == null) {</span>
<span class="fc bfc" id="L2269" title="All 2 branches covered.">			if (g.isDirected()) {</span>
<span class="fc bfc" id="L2270" title="All 2 branches covered.">				for (int u : gb.vertices()) {</span>
<span class="fc bfc" id="L2271" title="All 2 branches covered.">					for (IEdgeIter eit = g.outEdges(u).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L2272">						int e = eit.nextInt();</span>
<span class="fc" id="L2273">						int v = eit.targetInt();</span>
<span class="fc bfc" id="L2274" title="All 2 branches covered.">						if (gb.vertices().contains(v))</span>
<span class="fc" id="L2275">							gb.addEdge(u, v, e);</span>
<span class="fc" id="L2276">					}</span>
<span class="fc" id="L2277">				}</span>
			} else {
<span class="fc bfc" id="L2279" title="All 2 branches covered.">				for (int u : gb.vertices()) {</span>
<span class="fc bfc" id="L2280" title="All 2 branches covered.">					for (IEdgeIter eit = g.outEdges(u).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L2281">						int e = eit.nextInt();</span>
<span class="fc" id="L2282">						int v = eit.targetInt();</span>
<span class="fc bfc" id="L2283" title="All 4 branches covered.">						if (u &lt;= v &amp;&amp; gb.vertices().contains(v))</span>
<span class="fc" id="L2284">							gb.addEdge(u, v, e);</span>
<span class="fc" id="L2285">					}</span>
<span class="fc" id="L2286">				}</span>
			}
		} else {
<span class="fc bfc" id="L2289" title="All 2 branches covered.">			for (int e : edges)</span>
<span class="fc" id="L2290">				gb.addEdge(g.edgeSource(e), g.edgeTarget(e), e);</span>
		}

<span class="fc bfc" id="L2293" title="All 2 branches covered.">		if (copyVerticesWeights) {</span>
<span class="fc bfc" id="L2294" title="All 2 branches covered.">			for (String key : g.getVerticesWeightsKeys()) {</span>
<span class="fc" id="L2295">				IWeights wSrc = g.getVerticesWeights(key);</span>
<span class="fc" id="L2296">				Class&lt;?&gt; type = (Class) getWeightsType(wSrc);</span>
<span class="fc" id="L2297">				IWeights wDst = (IWeights) gb.addVerticesWeights(key, (Class) type, wSrc.defaultWeightAsObj());</span>
<span class="fc" id="L2298">				copyWeights(wSrc, wDst, type, gb.vertices());</span>
<span class="fc" id="L2299">			}</span>
		}
<span class="fc bfc" id="L2301" title="All 2 branches covered.">		if (copyEdgesWeights) {</span>
<span class="fc bfc" id="L2302" title="All 2 branches covered.">			for (String key : g.getEdgesWeightsKeys()) {</span>
<span class="fc" id="L2303">				IWeights wSrc = g.getEdgesWeights(key);</span>
<span class="fc" id="L2304">				Class&lt;?&gt; type = (Class) getWeightsType(wSrc);</span>
<span class="fc" id="L2305">				IWeights wDst = (IWeights) gb.addEdgesWeights(key, (Class) type, wSrc.defaultWeightAsObj());</span>
<span class="fc" id="L2306">				copyWeights(wSrc, wDst, type, gb.edges());</span>
<span class="fc" id="L2307">			}</span>
		}

<span class="fc" id="L2310">		return gb.build();</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	private static &lt;K&gt; void copyWeights(Weights&lt;K, ?&gt; src, Weights&lt;K, ?&gt; dst, Class&lt;?&gt; type, Collection&lt;K&gt; elements) {
<span class="fc bfc" id="L2315" title="All 2 branches covered.">		if (type == byte.class) {</span>
<span class="fc" id="L2316">			WeightsByte&lt;K&gt; src0 = (WeightsByte&lt;K&gt;) src;</span>
<span class="fc" id="L2317">			WeightsByte&lt;K&gt; dst0 = (WeightsByte&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L2318" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L2319">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L2320" title="All 2 branches covered.">		} else if (type == short.class) {</span>
<span class="fc" id="L2321">			WeightsShort&lt;K&gt; src0 = (WeightsShort&lt;K&gt;) src;</span>
<span class="fc" id="L2322">			WeightsShort&lt;K&gt; dst0 = (WeightsShort&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L2323" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L2324">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L2325" title="All 2 branches covered.">		} else if (type == int.class) {</span>
<span class="fc" id="L2326">			WeightsInt&lt;K&gt; src0 = (WeightsInt&lt;K&gt;) src;</span>
<span class="fc" id="L2327">			WeightsInt&lt;K&gt; dst0 = (WeightsInt&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L2328" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L2329">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L2330" title="All 2 branches covered.">		} else if (type == long.class) {</span>
<span class="fc" id="L2331">			WeightsLong&lt;K&gt; src0 = (WeightsLong&lt;K&gt;) src;</span>
<span class="fc" id="L2332">			WeightsLong&lt;K&gt; dst0 = (WeightsLong&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L2333" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L2334">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L2335" title="All 2 branches covered.">		} else if (type == float.class) {</span>
<span class="fc" id="L2336">			WeightsFloat&lt;K&gt; src0 = (WeightsFloat&lt;K&gt;) src;</span>
<span class="fc" id="L2337">			WeightsFloat&lt;K&gt; dst0 = (WeightsFloat&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L2338" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L2339">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L2340" title="All 2 branches covered.">		} else if (type == double.class) {</span>
<span class="fc" id="L2341">			WeightsDouble&lt;K&gt; src0 = (WeightsDouble&lt;K&gt;) src;</span>
<span class="fc" id="L2342">			WeightsDouble&lt;K&gt; dst0 = (WeightsDouble&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L2343" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L2344">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L2345" title="All 2 branches covered.">		} else if (type == boolean.class) {</span>
<span class="fc" id="L2346">			WeightsBool&lt;K&gt; src0 = (WeightsBool&lt;K&gt;) src;</span>
<span class="fc" id="L2347">			WeightsBool&lt;K&gt; dst0 = (WeightsBool&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L2348" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L2349">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L2350" title="All 2 branches covered.">		} else if (type == char.class) {</span>
<span class="fc" id="L2351">			WeightsChar&lt;K&gt; src0 = (WeightsChar&lt;K&gt;) src;</span>
<span class="fc" id="L2352">			WeightsChar&lt;K&gt; dst0 = (WeightsChar&lt;K&gt;) dst;</span>
<span class="fc bfc" id="L2353" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L2354">				dst0.set(elm, src0.get(elm));</span>
<span class="pc bpc" id="L2355" title="1 of 2 branches missed.">		} else if (type == Object.class) {</span>
<span class="fc" id="L2356">			WeightsObj&lt;K, Object&gt; src0 = (WeightsObj&lt;K, Object&gt;) src;</span>
<span class="fc" id="L2357">			WeightsObj&lt;K, Object&gt; dst0 = (WeightsObj&lt;K, Object&gt;) dst;</span>
<span class="fc bfc" id="L2358" title="All 2 branches covered.">			for (K elm : elements)</span>
<span class="fc" id="L2359">				dst0.set(elm, src0.get(elm));</span>
<span class="fc" id="L2360">		} else {</span>
<span class="nc" id="L2361">			throw new AssertionError();</span>
		}
<span class="fc" id="L2363">	}</span>

	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
	private static void copyWeights(IWeights&lt;?&gt; src, IWeights&lt;?&gt; dst, Class&lt;?&gt; type, IntCollection elements) {
<span class="fc bfc" id="L2367" title="All 2 branches covered.">		if (type == byte.class) {</span>
<span class="fc" id="L2368">			IWeightsByte src0 = (IWeightsByte) src;</span>
<span class="fc" id="L2369">			IWeightsByte dst0 = (IWeightsByte) dst;</span>
<span class="fc bfc" id="L2370" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L2371">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L2372" title="All 2 branches covered.">		} else if (type == short.class) {</span>
<span class="fc" id="L2373">			IWeightsShort src0 = (IWeightsShort) src;</span>
<span class="fc" id="L2374">			IWeightsShort dst0 = (IWeightsShort) dst;</span>
<span class="fc bfc" id="L2375" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L2376">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L2377" title="All 2 branches covered.">		} else if (type == int.class) {</span>
<span class="fc" id="L2378">			IWeightsInt src0 = (IWeightsInt) src;</span>
<span class="fc" id="L2379">			IWeightsInt dst0 = (IWeightsInt) dst;</span>
<span class="fc bfc" id="L2380" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L2381">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L2382" title="All 2 branches covered.">		} else if (type == long.class) {</span>
<span class="fc" id="L2383">			IWeightsLong src0 = (IWeightsLong) src;</span>
<span class="fc" id="L2384">			IWeightsLong dst0 = (IWeightsLong) dst;</span>
<span class="fc bfc" id="L2385" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L2386">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L2387" title="All 2 branches covered.">		} else if (type == float.class) {</span>
<span class="fc" id="L2388">			IWeightsFloat src0 = (IWeightsFloat) src;</span>
<span class="fc" id="L2389">			IWeightsFloat dst0 = (IWeightsFloat) dst;</span>
<span class="fc bfc" id="L2390" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L2391">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L2392" title="All 2 branches covered.">		} else if (type == double.class) {</span>
<span class="fc" id="L2393">			IWeightsDouble src0 = (IWeightsDouble) src;</span>
<span class="fc" id="L2394">			IWeightsDouble dst0 = (IWeightsDouble) dst;</span>
<span class="fc bfc" id="L2395" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L2396">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L2397" title="All 2 branches covered.">		} else if (type == boolean.class) {</span>
<span class="fc" id="L2398">			IWeightsBool src0 = (IWeightsBool) src;</span>
<span class="fc" id="L2399">			IWeightsBool dst0 = (IWeightsBool) dst;</span>
<span class="fc bfc" id="L2400" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L2401">				dst0.set(elm, src0.get(elm));</span>
<span class="fc bfc" id="L2402" title="All 2 branches covered.">		} else if (type == char.class) {</span>
<span class="fc" id="L2403">			IWeightsChar src0 = (IWeightsChar) src;</span>
<span class="fc" id="L2404">			IWeightsChar dst0 = (IWeightsChar) dst;</span>
<span class="fc bfc" id="L2405" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L2406">				dst0.set(elm, src0.get(elm));</span>
<span class="pc bpc" id="L2407" title="1 of 2 branches missed.">		} else if (type == Object.class) {</span>
<span class="fc" id="L2408">			IWeightsObj src0 = (IWeightsObj) src;</span>
<span class="fc" id="L2409">			IWeightsObj dst0 = (IWeightsObj) dst;</span>
<span class="fc bfc" id="L2410" title="All 2 branches covered.">			for (int elm : elements)</span>
<span class="fc" id="L2411">				dst0.set(elm, src0.get(elm));</span>
<span class="fc" id="L2412">		} else {</span>
<span class="nc" id="L2413">			throw new AssertionError();</span>
		}
<span class="fc" id="L2415">	}</span>

	private static Class&lt;?&gt; getWeightsType(Weights&lt;?, ?&gt; w) {
<span class="fc bfc" id="L2418" title="All 2 branches covered.">		if (w instanceof WeightsByte)</span>
<span class="fc" id="L2419">			return byte.class;</span>
<span class="fc bfc" id="L2420" title="All 2 branches covered.">		if (w instanceof WeightsShort)</span>
<span class="fc" id="L2421">			return short.class;</span>
<span class="fc bfc" id="L2422" title="All 2 branches covered.">		if (w instanceof WeightsInt)</span>
<span class="fc" id="L2423">			return int.class;</span>
<span class="fc bfc" id="L2424" title="All 2 branches covered.">		if (w instanceof WeightsLong)</span>
<span class="fc" id="L2425">			return long.class;</span>
<span class="fc bfc" id="L2426" title="All 2 branches covered.">		if (w instanceof WeightsFloat)</span>
<span class="fc" id="L2427">			return float.class;</span>
<span class="fc bfc" id="L2428" title="All 2 branches covered.">		if (w instanceof WeightsDouble)</span>
<span class="fc" id="L2429">			return double.class;</span>
<span class="fc bfc" id="L2430" title="All 2 branches covered.">		if (w instanceof WeightsBool)</span>
<span class="fc" id="L2431">			return boolean.class;</span>
<span class="fc bfc" id="L2432" title="All 2 branches covered.">		if (w instanceof WeightsChar)</span>
<span class="fc" id="L2433">			return char.class;</span>
<span class="pc bpc" id="L2434" title="1 of 2 branches missed.">		if (w instanceof WeightsObj)</span>
<span class="fc" id="L2435">			return Object.class;</span>
<span class="nc" id="L2436">		throw new AssertionError();</span>
	}

	/**
	 * Get a random vertex from the given graph.
	 *
	 * @param  &lt;V&gt;  the vertices type
	 * @param  g    the graph
	 * @param  rand the random number generator
	 * @return      a random vertex from the given graph
	 */
	public static &lt;V&gt; V randVertex(Graph&lt;V, ?&gt; g, Random rand) {
<span class="fc" id="L2448">		return g.indexGraphVerticesMap().indexToId(rand.nextInt(g.vertices().size()));</span>
	}

	/**
	 * Get a random vertex from the given int graph.
	 *
	 * @param  g    the graph
	 * @param  rand the random number generator
	 * @return      a random vertex from the given graph
	 */
	public static int randVertex(IntGraph g, Random rand) {
<span class="fc" id="L2459">		return g.indexGraphVerticesMap().indexToIdInt(rand.nextInt(g.vertices().size()));</span>
	}

	/**
	 * Get a random edge from the given graph.
	 *
	 * @param  &lt;E&gt;  the edges type
	 * @param  g    the graph
	 * @param  rand the random number generator
	 * @return      a random edge from the given graph
	 */
	public static &lt;E&gt; E randEdge(Graph&lt;?, E&gt; g, Random rand) {
<span class="fc" id="L2471">		return g.indexGraphEdgesMap().indexToId(rand.nextInt(g.edges().size()));</span>
	}

	/**
	 * Get a random edge from the given int graph.
	 *
	 * @param  g    the graph
	 * @param  rand the random number generator
	 * @return      a random edge from the given graph
	 */
	public static int randEdge(IntGraph g, Random rand) {
<span class="fc" id="L2482">		return g.indexGraphEdgesMap().indexToIdInt(rand.nextInt(g.edges().size()));</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	static boolean isEquals(Graph&lt;?, ?&gt; g1, Graph&lt;?, ?&gt; g2) {
<span class="pc bpc" id="L2487" title="1 of 2 branches missed.">		if (g1 == g2)</span>
<span class="nc" id="L2488">			return true;</span>
<span class="pc bpc" id="L2489" title="1 of 4 branches missed.">		if (g1 instanceof IntGraph &amp;&amp; g2 instanceof IntGraph)</span>
<span class="fc" id="L2490">			return isEquals((IntGraph) g1, (IntGraph) g2);</span>

<span class="fc bfc" id="L2492" title="All 2 branches covered.">		if (g1.isDirected() != g2.isDirected())</span>
<span class="fc" id="L2493">			return false;</span>
<span class="fc bfc" id="L2494" title="All 2 branches covered.">		if (!g1.vertices().equals(g2.vertices()))</span>
<span class="fc" id="L2495">			return false;</span>
<span class="fc bfc" id="L2496" title="All 2 branches covered.">		if (!g1.edges().equals(g2.edges()))</span>
<span class="fc" id="L2497">			return false;</span>
<span class="fc" id="L2498">		Graph&lt;Object, Object&gt; g10 = (Graph&lt;Object, Object&gt;) g1, g20 = (Graph&lt;Object, Object&gt;) g2;</span>
<span class="fc" id="L2499">		return isEquals0(g10, g20);</span>
	}

	private static &lt;V, E&gt; boolean isEquals0(Graph&lt;V, E&gt; g1, Graph&lt;V, E&gt; g2) {
<span class="fc bfc" id="L2503" title="All 2 branches covered.">		if (g1.isDirected()) {</span>
<span class="fc bfc" id="L2504" title="All 2 branches covered.">			for (E e : g1.edges())</span>
<span class="pc bpc" id="L2505" title="1 of 4 branches missed.">				if (!g1.edgeSource(e).equals(g2.edgeSource(e)) || !g1.edgeTarget(e).equals(g2.edgeTarget(e)))</span>
<span class="fc" id="L2506">					return false;</span>
		} else {
<span class="fc bfc" id="L2508" title="All 2 branches covered.">			for (E e : g1.edges()) {</span>
<span class="fc" id="L2509">				V s1 = g1.edgeSource(e), t1 = g1.edgeTarget(e);</span>
<span class="fc" id="L2510">				V s2 = g2.edgeSource(e), t2 = g2.edgeTarget(e);</span>
<span class="pc bpc" id="L2511" title="4 of 8 branches missed.">				if (!(s1.equals(s2) &amp;&amp; t1.equals(t2)) &amp;&amp; !(s1.equals(t2) &amp;&amp; t1.equals(s2)))</span>
<span class="fc" id="L2512">					return false;</span>
<span class="fc" id="L2513">			}</span>
		}

<span class="fc bfc" id="L2516" title="All 2 branches covered.">		if (!g1.getVerticesWeightsKeys().equals(g2.getVerticesWeightsKeys()))</span>
<span class="fc" id="L2517">			return false;</span>
<span class="fc bfc" id="L2518" title="All 2 branches covered.">		for (String key : g1.getVerticesWeightsKeys()) {</span>
<span class="fc" id="L2519">			Weights&lt;V, ?&gt; w1 = g1.getVerticesWeights(key), w2 = g2.getVerticesWeights(key);</span>
<span class="fc bfc" id="L2520" title="All 2 branches covered.">			if (!WeightsImpl.isEqual(g1.vertices(), w1, w2))</span>
<span class="fc" id="L2521">				return false;</span>
<span class="fc" id="L2522">		}</span>
<span class="fc bfc" id="L2523" title="All 2 branches covered.">		if (!g1.getEdgesWeightsKeys().equals(g2.getEdgesWeightsKeys()))</span>
<span class="fc" id="L2524">			return false;</span>
<span class="fc bfc" id="L2525" title="All 2 branches covered.">		for (String key : g1.getEdgesWeightsKeys()) {</span>
<span class="fc" id="L2526">			Weights&lt;E, ?&gt; w1 = g1.getEdgesWeights(key), w2 = g2.getEdgesWeights(key);</span>
<span class="fc bfc" id="L2527" title="All 2 branches covered.">			if (!WeightsImpl.isEqual(g1.edges(), w1, w2))</span>
<span class="fc" id="L2528">				return false;</span>
<span class="fc" id="L2529">		}</span>

<span class="fc" id="L2531">		return true;</span>
	}

	private static boolean isEquals(IntGraph g1, IntGraph g2) {
<span class="fc bfc" id="L2535" title="All 2 branches covered.">		if (g1.isDirected() != g2.isDirected())</span>
<span class="fc" id="L2536">			return false;</span>
<span class="fc bfc" id="L2537" title="All 2 branches covered.">		if (!g1.vertices().equals(g2.vertices()))</span>
<span class="fc" id="L2538">			return false;</span>
<span class="fc bfc" id="L2539" title="All 2 branches covered.">		if (!g1.edges().equals(g2.edges()))</span>
<span class="fc" id="L2540">			return false;</span>
<span class="fc bfc" id="L2541" title="All 2 branches covered.">		if (g1.isDirected()) {</span>
<span class="fc bfc" id="L2542" title="All 2 branches covered.">			for (int e : g1.edges())</span>
<span class="pc bpc" id="L2543" title="1 of 4 branches missed.">				if (g1.edgeSource(e) != g2.edgeSource(e) || g1.edgeTarget(e) != g2.edgeTarget(e))</span>
<span class="fc" id="L2544">					return false;</span>
		} else {
<span class="fc bfc" id="L2546" title="All 2 branches covered.">			for (int e : g1.edges()) {</span>
<span class="fc" id="L2547">				int s1 = g1.edgeSource(e), t1 = g1.edgeTarget(e);</span>
<span class="fc" id="L2548">				int s2 = g2.edgeSource(e), t2 = g2.edgeTarget(e);</span>
<span class="pc bpc" id="L2549" title="4 of 8 branches missed.">				if (!(s1 == s2 &amp;&amp; t1 == t2) &amp;&amp; !(s1 == t2 &amp;&amp; t1 == s2))</span>
<span class="fc" id="L2550">					return false;</span>
<span class="fc" id="L2551">			}</span>
		}

<span class="fc bfc" id="L2554" title="All 2 branches covered.">		if (!g1.getVerticesWeightsKeys().equals(g2.getVerticesWeightsKeys()))</span>
<span class="fc" id="L2555">			return false;</span>
<span class="fc bfc" id="L2556" title="All 2 branches covered.">		for (String key : g1.getVerticesWeightsKeys()) {</span>
<span class="fc" id="L2557">			IWeights&lt;?&gt; w1 = g1.getVerticesIWeights(key), w2 = g2.getVerticesIWeights(key);</span>
<span class="fc bfc" id="L2558" title="All 2 branches covered.">			if (!WeightsImpl.isEqual(g1.vertices(), w1, w2))</span>
<span class="fc" id="L2559">				return false;</span>
<span class="fc" id="L2560">		}</span>
<span class="fc bfc" id="L2561" title="All 2 branches covered.">		if (!g1.getEdgesWeightsKeys().equals(g2.getEdgesWeightsKeys()))</span>
<span class="fc" id="L2562">			return false;</span>
<span class="fc bfc" id="L2563" title="All 2 branches covered.">		for (String key : g1.getEdgesWeightsKeys()) {</span>
<span class="fc" id="L2564">			IWeights&lt;?&gt; w1 = g1.getEdgesIWeights(key), w2 = g2.getEdgesIWeights(key);</span>
<span class="fc bfc" id="L2565" title="All 2 branches covered.">			if (!WeightsImpl.isEqual(g1.edges(), w1, w2))</span>
<span class="fc" id="L2566">				return false;</span>
<span class="fc" id="L2567">		}</span>

<span class="fc" id="L2569">		return true;</span>
	}

	static &lt;V, E&gt; int hashCode(Graph&lt;V, E&gt; g) {
<span class="fc bfc" id="L2573" title="All 2 branches covered.">		if (g instanceof IntGraph)</span>
<span class="fc" id="L2574">			return hashCode((IntGraph) g);</span>

<span class="fc" id="L2576">		int h = Boolean.hashCode(g.isDirected());</span>
<span class="fc" id="L2577">		h += g.vertices().hashCode();</span>
<span class="fc" id="L2578">		h += g.edges().hashCode();</span>
<span class="fc bfc" id="L2579" title="All 2 branches covered.">		if (g.isDirected()) {</span>
<span class="fc bfc" id="L2580" title="All 2 branches covered.">			for (E e : g.edges())</span>
<span class="fc" id="L2581">				h += g.edgeSource(e).hashCode() + 31 * g.edgeTarget(e).hashCode();</span>
		} else {
<span class="fc bfc" id="L2583" title="All 2 branches covered.">			for (E e : g.edges())</span>
<span class="fc" id="L2584">				h += g.edgeSource(e).hashCode() + g.edgeTarget(e).hashCode();</span>
		}
<span class="fc bfc" id="L2586" title="All 2 branches covered.">		for (String key : g.getVerticesWeightsKeys())</span>
<span class="fc" id="L2587">			h += WeightsImpl.hashCode(g.vertices(), g.getVerticesWeights(key));</span>
<span class="fc bfc" id="L2588" title="All 2 branches covered.">		for (String key : g.getEdgesWeightsKeys())</span>
<span class="fc" id="L2589">			h += WeightsImpl.hashCode(g.edges(), g.getEdgesWeights(key));</span>
<span class="fc" id="L2590">		return h;</span>
	}

	private static int hashCode(IntGraph g) {
<span class="fc" id="L2594">		int h = Boolean.hashCode(g.isDirected());</span>
<span class="fc" id="L2595">		h += g.vertices().hashCode();</span>
<span class="fc" id="L2596">		h += g.edges().hashCode();</span>
<span class="fc bfc" id="L2597" title="All 2 branches covered.">		if (g.isDirected()) {</span>
<span class="fc bfc" id="L2598" title="All 2 branches covered.">			for (int e : g.edges())</span>
<span class="fc" id="L2599">				h += g.edgeSource(e) + 31 * g.edgeTarget(e);</span>
		} else {
<span class="fc bfc" id="L2601" title="All 2 branches covered.">			for (int e : g.edges())</span>
<span class="fc" id="L2602">				h += g.edgeSource(e) + g.edgeTarget(e);</span>
		}
<span class="fc bfc" id="L2604" title="All 2 branches covered.">		for (String key : g.getVerticesWeightsKeys())</span>
<span class="fc" id="L2605">			h += WeightsImpl.hashCode(g.vertices(), g.getVerticesIWeights(key));</span>
<span class="fc bfc" id="L2606" title="All 2 branches covered.">		for (String key : g.getEdgesWeightsKeys())</span>
<span class="fc" id="L2607">			h += WeightsImpl.hashCode(g.edges(), g.getEdgesIWeights(key));</span>
<span class="fc" id="L2608">		return h;</span>
	}

	static &lt;V, E&gt; String toString(Graph&lt;V, E&gt; g) {
<span class="nc bnc" id="L2612" title="All 2 branches missed.">		if (g instanceof IntGraph)</span>
<span class="nc" id="L2613">			return toString((IntGraph) g);</span>

<span class="nc" id="L2615">		StringBuilder s = new StringBuilder();</span>
<span class="nc" id="L2616">		s.append('{');</span>

<span class="nc" id="L2618">		Set&lt;String&gt; verticesWeightsKeys = g.getVerticesWeightsKeys();</span>
<span class="nc" id="L2619">		Collection&lt;Weights&lt;V, ?&gt;&gt; verticesWeights = new ObjectArrayList&lt;&gt;(verticesWeightsKeys.size());</span>
<span class="nc bnc" id="L2620" title="All 2 branches missed.">		for (String key : verticesWeightsKeys)</span>
<span class="nc" id="L2621">			verticesWeights.add(g.getVerticesWeights(key));</span>

<span class="nc" id="L2623">		Set&lt;String&gt; edgesWeightsKeys = g.getEdgesWeightsKeys();</span>
<span class="nc" id="L2624">		Collection&lt;Weights&lt;E, ?&gt;&gt; edgesWeights = new ObjectArrayList&lt;&gt;(edgesWeightsKeys.size());</span>
<span class="nc bnc" id="L2625" title="All 2 branches missed.">		for (String key : edgesWeightsKeys)</span>
<span class="nc" id="L2626">			edgesWeights.add(g.getEdgesWeights(key));</span>

<span class="nc" id="L2628">		BiConsumer&lt;Collection&lt;Weights&lt;V, ?&gt;&gt;, V&gt; appendVertexWeights = (weights, vertex) -&gt; {</span>
<span class="nc" id="L2629">			s.append('[');</span>
<span class="nc" id="L2630">			boolean firstData = true;</span>
<span class="nc bnc" id="L2631" title="All 2 branches missed.">			for (Weights&lt;V, ?&gt; weight : weights) {</span>
<span class="nc bnc" id="L2632" title="All 2 branches missed.">				if (firstData) {</span>
<span class="nc" id="L2633">					firstData = false;</span>
				} else {
<span class="nc" id="L2635">					s.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L2637">				s.append(weight.getAsObj(vertex));</span>
<span class="nc" id="L2638">			}</span>
<span class="nc" id="L2639">			s.append(']');</span>
<span class="nc" id="L2640">		};</span>
<span class="nc" id="L2641">		BiConsumer&lt;Collection&lt;Weights&lt;E, ?&gt;&gt;, E&gt; appendEdgeWeights = (weights, edge) -&gt; {</span>
<span class="nc" id="L2642">			s.append('[');</span>
<span class="nc" id="L2643">			boolean firstData = true;</span>
<span class="nc bnc" id="L2644" title="All 2 branches missed.">			for (Weights&lt;E, ?&gt; weight : weights) {</span>
<span class="nc bnc" id="L2645" title="All 2 branches missed.">				if (firstData) {</span>
<span class="nc" id="L2646">					firstData = false;</span>
				} else {
<span class="nc" id="L2648">					s.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L2650">				s.append(weight.getAsObj(edge));</span>
<span class="nc" id="L2651">			}</span>
<span class="nc" id="L2652">			s.append(']');</span>
<span class="nc" id="L2653">		};</span>

<span class="nc" id="L2655">		boolean firstVertex = true;</span>
<span class="nc bnc" id="L2656" title="All 2 branches missed.">		for (V u : g.vertices()) {</span>
<span class="nc bnc" id="L2657" title="All 2 branches missed.">			if (firstVertex) {</span>
<span class="nc" id="L2658">				firstVertex = false;</span>
			} else {
<span class="nc" id="L2660">				s.append(&quot;, &quot;);</span>
			}
<span class="nc" id="L2662">			s.append('v').append(u);</span>
<span class="nc bnc" id="L2663" title="All 2 branches missed.">			if (!verticesWeights.isEmpty())</span>
<span class="nc" id="L2664">				appendVertexWeights.accept(verticesWeights, u);</span>

<span class="nc" id="L2666">			s.append(&quot;: [&quot;);</span>
<span class="nc" id="L2667">			boolean firstEdge = true;</span>
<span class="nc bnc" id="L2668" title="All 2 branches missed.">			for (EdgeIter&lt;V, E&gt; eit = g.outEdges(u).iterator(); eit.hasNext();) {</span>
<span class="nc" id="L2669">				E e = eit.next();</span>
<span class="nc" id="L2670">				V v = eit.target();</span>
<span class="nc bnc" id="L2671" title="All 2 branches missed.">				if (firstEdge)</span>
<span class="nc" id="L2672">					firstEdge = false;</span>
				else
<span class="nc" id="L2674">					s.append(&quot;, &quot;);</span>
<span class="nc" id="L2675">				s.append(e).append('(').append(u).append(&quot;, &quot;).append(v);</span>
<span class="nc bnc" id="L2676" title="All 2 branches missed.">				if (!edgesWeights.isEmpty()) {</span>
<span class="nc" id="L2677">					s.append(&quot;, &quot;);</span>
<span class="nc" id="L2678">					appendEdgeWeights.accept(edgesWeights, e);</span>
				}
<span class="nc" id="L2680">				s.append(')');</span>
<span class="nc" id="L2681">			}</span>
<span class="nc" id="L2682">			s.append(']');</span>
<span class="nc" id="L2683">		}</span>
<span class="nc" id="L2684">		s.append('}');</span>
<span class="nc" id="L2685">		return s.toString();</span>
	}

	private static String toString(IntGraph g) {
<span class="nc" id="L2689">		StringBuilder s = new StringBuilder();</span>
<span class="nc" id="L2690">		s.append('{');</span>

<span class="nc" id="L2692">		Set&lt;String&gt; verticesWeightsKeys = g.getVerticesWeightsKeys();</span>
<span class="nc" id="L2693">		Collection&lt;IWeights&lt;?&gt;&gt; verticesWeights = new ObjectArrayList&lt;&gt;(verticesWeightsKeys.size());</span>
<span class="nc bnc" id="L2694" title="All 2 branches missed.">		for (String key : verticesWeightsKeys)</span>
<span class="nc" id="L2695">			verticesWeights.add(g.getVerticesIWeights(key));</span>

<span class="nc" id="L2697">		Set&lt;String&gt; edgesWeightsKeys = g.getEdgesWeightsKeys();</span>
<span class="nc" id="L2698">		Collection&lt;IWeights&lt;?&gt;&gt; edgesWeights = new ObjectArrayList&lt;&gt;(edgesWeightsKeys.size());</span>
<span class="nc bnc" id="L2699" title="All 2 branches missed.">		for (String key : edgesWeightsKeys)</span>
<span class="nc" id="L2700">			edgesWeights.add(g.getEdgesIWeights(key));</span>

<span class="nc" id="L2702">		ObjIntConsumer&lt;Collection&lt;IWeights&lt;?&gt;&gt;&gt; appendWeights = (weights, elm) -&gt; {</span>
<span class="nc" id="L2703">			s.append('[');</span>
<span class="nc" id="L2704">			boolean firstData = true;</span>
<span class="nc bnc" id="L2705" title="All 2 branches missed.">			for (IWeights&lt;?&gt; weight : weights) {</span>
<span class="nc bnc" id="L2706" title="All 2 branches missed.">				if (firstData) {</span>
<span class="nc" id="L2707">					firstData = false;</span>
				} else {
<span class="nc" id="L2709">					s.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L2711">				s.append(weight.getAsObj(elm));</span>
<span class="nc" id="L2712">			}</span>
<span class="nc" id="L2713">			s.append(']');</span>
<span class="nc" id="L2714">		};</span>

<span class="nc" id="L2716">		boolean firstVertex = true;</span>
<span class="nc bnc" id="L2717" title="All 2 branches missed.">		for (int u : g.vertices()) {</span>
<span class="nc bnc" id="L2718" title="All 2 branches missed.">			if (firstVertex) {</span>
<span class="nc" id="L2719">				firstVertex = false;</span>
			} else {
<span class="nc" id="L2721">				s.append(&quot;, &quot;);</span>
			}
<span class="nc" id="L2723">			s.append('v').append(u);</span>
<span class="nc bnc" id="L2724" title="All 2 branches missed.">			if (!verticesWeights.isEmpty())</span>
<span class="nc" id="L2725">				appendWeights.accept(verticesWeights, u);</span>

<span class="nc" id="L2727">			s.append(&quot;: [&quot;);</span>
<span class="nc" id="L2728">			boolean firstEdge = true;</span>
<span class="nc bnc" id="L2729" title="All 2 branches missed.">			for (IEdgeIter eit = g.outEdges(u).iterator(); eit.hasNext();) {</span>
<span class="nc" id="L2730">				int e = eit.nextInt();</span>
<span class="nc" id="L2731">				int v = eit.targetInt();</span>
<span class="nc bnc" id="L2732" title="All 2 branches missed.">				if (firstEdge)</span>
<span class="nc" id="L2733">					firstEdge = false;</span>
				else
<span class="nc" id="L2735">					s.append(&quot;, &quot;);</span>
<span class="nc" id="L2736">				s.append(e).append('(').append(u).append(&quot;, &quot;).append(v);</span>
<span class="nc bnc" id="L2737" title="All 2 branches missed.">				if (!edgesWeights.isEmpty()) {</span>
<span class="nc" id="L2738">					s.append(&quot;, &quot;);</span>
<span class="nc" id="L2739">					appendWeights.accept(edgesWeights, e);</span>
				}
<span class="nc" id="L2741">				s.append(')');</span>
<span class="nc" id="L2742">			}</span>
<span class="nc" id="L2743">			s.append(']');</span>
<span class="nc" id="L2744">		}</span>
<span class="nc" id="L2745">		s.append('}');</span>
<span class="nc" id="L2746">		return s.toString();</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>