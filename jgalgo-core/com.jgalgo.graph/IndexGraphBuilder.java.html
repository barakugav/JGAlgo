<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IndexGraphBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.graph</a> &gt; <span class="el_source">IndexGraphBuilder.java</span></div><h1>IndexGraphBuilder.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.graph;

import static com.jgalgo.internal.util.Range.range;
import java.util.Collection;
import java.util.Objects;
import java.util.Optional;
import it.unimi.dsi.fastutil.ints.IntSet;

/**
 * A builder for {@linkplain IndexGraph Index graphs}.
 *
 * &lt;p&gt;
 * The builder is used to construct &lt;b&gt;non-empty&lt;/b&gt; index graphs. Differing from {@link IndexGraphFactory} which create
 * new empty graphs, the builder is used to add vertices and edges before actually creating the graph. This capability
 * is required to create immutable graphs, but can also be used to build mutable graph and may give a performance boost
 * compared to creating an empty graph and adding the same vertices and edges.
 *
 * &lt;p&gt;
 * To create a new builder, use one of the static methods {@link #undirected()}, {@link #directed()} or
 * {@link #newInstance(boolean)}. For more options, create a new {@link IndexGraphFactory} and use
 * {@link IndexGraphFactory#newBuilder()}, or use {@link IndexGraphFactory#newBuilderCopyOf(Graph)} to create a builder
 * initialized with an existing graph vertices and edges.
 *
 * &lt;p&gt;
 * This interface is a specification of {@link IntGraphBuilder} for {@link IndexGraph}.
 *
 * @see    IndexGraphBuilder#undirected()
 * @see    IndexGraphBuilder#directed()
 * @see    IntGraphBuilder
 * @see    IndexGraphFactory
 * @author Barak Ugav
 */
public interface IndexGraphBuilder extends IntGraphBuilder {

	/**
	 * {@inheritDoc}
	 *
	 * &lt;p&gt;
	 * The vertex created by this method will be assigned the next available index, {@code verticesNum}. For example, if
	 * the graph currently contains the vertices {@code 0,1,2}, the next vertex added will be {@code 3}.
	 */
	@Override
	int addVertexInt();

	/**
	 * {@inheritDoc}
	 *
	 * &lt;p&gt;
	 * Index graphs vertices IDs are always {@code (0,1,2, ...,verticesNum-1)} therefore the only vertex ID that can be
	 * added is {@code verticesNum}. For any other vertex passed to this method, an exception will be thrown. If
	 * {@code verticesNum} is passed, this method is equivalent to {@link #addVertexInt()}.
	 *
	 * @throws     IllegalArgumentException if {@code vertex} is not {@code verticesNum}
	 * @deprecated                          use {@link #addVertexInt()} instead
	 */
	@Deprecated
	@Override
	default void addVertex(int vertex) {
<span class="fc bfc" id="L74" title="All 2 branches covered.">		if (vertex != vertices().size())</span>
<span class="fc" id="L75">			throw new IllegalArgumentException(&quot;Only vertex ID &quot; + vertices().size() + &quot; can be added&quot;);</span>
<span class="fc" id="L76">		addVertexInt();</span>
<span class="fc" id="L77">	}</span>

	/**
	 * {@inheritDoc}
	 *
	 * &lt;p&gt;
	 * Index graphs vertices IDs are always {@code (0,1,2, ...,verticesNum-1)} therefore the only vertices that can be
	 * added are {@code (verticesNum,verticesNum+1,verticesNum+2, ...)}. For any other vertices passed to this method,
	 * an exception will be thrown.
	 */
	@Override
	void addVertices(Collection&lt;? extends Integer&gt; vertices);

	/**
	 * {@inheritDoc}
	 *
	 * &lt;p&gt;
	 * The edge created by this method will be assigned the next available index, {@code edgesNum}. For example, if the
	 * graph currently contains the edges {@code 0,1,2}, the next edge added will be {@code 3}.
	 */
	@Override
	int addEdge(int source, int target);

	/**
	 * {@inheritDoc}
	 *
	 * &lt;p&gt;
	 * Index graphs edges IDs are always {@code (0,1,2, ...,edgesNum-1)} therefore the only edge ID that can be added is
	 * {@code edgesNum}. For any other edge passed to this method, an exception will be thrown. If {@code edgesNum} is
	 * passed, this method is equivalent to {@link #addEdge(int, int)}.
	 *
	 * @throws     IllegalArgumentException if {@code edge} is not {@code edgesNum}
	 * @deprecated                          use {@link #addEdge(int, int)} instead
	 */
	@Deprecated
	@Override
	default void addEdge(int source, int target, int edge) {
<span class="fc bfc" id="L114" title="All 2 branches covered.">		if (edge != edges().size())</span>
<span class="fc" id="L115">			throw new IllegalArgumentException(&quot;Only edge ID &quot; + edges().size() + &quot; can be added&quot;);</span>
<span class="fc" id="L116">		addEdge(source, target);</span>
<span class="fc" id="L117">	}</span>

	/**
	 * {@inheritDoc}
	 *
	 *
	 * &lt;p&gt;
	 * Index graphs edges IDs are always {@code (0,1,2, ...,edgesNum-1)} therefore the only edges that can be added are
	 * {@code (edgesNum,edgesNum+1,edgesNum+2, ...)}. For any other edges passed to this method, an exception will be
	 * thrown. If there is no need to keep the identifiers of the edges, consider using
	 * {@link #addEdgesReassignIds(IEdgeSet)}.
	 */
	@Override
	void addEdges(EdgeSet&lt;? extends Integer, ? extends Integer&gt; edges);

	/**
	 * Add multiple edges to the built graph and re-assign ids for them.
	 *
	 * &lt;p&gt;
	 * The {@link IEdgeSet} passed to this method contains the endpoints (sources and targets) of the edges, see
	 * {@link EdgeSet#iterator()}, {@link EdgeIter#source()}, {@link EdgeIter#target()}. The identifiers of the edges,
	 * which are also accessible via {@link IEdgeSet} are ignored, and new identifiers (indices) are assigned to the
	 * added edges. An {@link IEdgeSet} can be obtained from one of the methods of an {@link IntGraph}, or using
	 * {@link IEdgeSet#of(IntSet, IntGraph)}.
	 *
	 * &lt;p&gt;
	 * The identifiers assigned to the newly added edges are {@code (edgesNum,edgesNum+1,edgesNum+2, ...)} matching the
	 * iteration order of the provided set. This method different than {@link #addEdges(EdgeSet)} in a similar way that
	 * {@link #addEdge(int, int)} is different than {@link #addEdge(int, int, int)}.
	 *
	 * &lt;p&gt;
	 * In the following snippet, a maximum cardinality matching is computed on a graph, and a new graph containing only
	 * the matching edges is created. It would be wrong to use {@link #addEdges(EdgeSet)} in this example, as there is
	 * no guarantee that the added edges ids are {@code (0, 1, 2, ...)}, which is a requirement to build an
	 * {@link IndexGraph}.
	 *
	 * &lt;pre&gt; {@code
	 * IndexGraph g = ...;
	 * IntSet matching = (IntSet) MatchingAlgo.newInstance().computeMaximumMatching(g, null).edges();
	 *
	 * IndexGraphBuilder matchingGraphBuilder = IndexGraphBuilder.undirected();
	 * matchingGraphBuilder.addVertices(g.vertices());
	 * matchingGraphBuilder.addEdgesReassignIds(IEdgeSet.of(matching, g));
	 * IndexGraph matchingGraph = matchingGraphBuilder.build();
	 * }&lt;/pre&gt;
	 *
	 * @param  edges the set of edges to add. Only the endpoints of the edges is considered, while the edges identifiers
	 *                   are ignored.
	 * @return       the set of newly edge identifiers added to the graph,
	 *               {@code (edgesNum,edgesNum+1,edgesNum+2, ...)}. The edges are assigned the indices in the order they
	 *               are iterated in the given set
	 */
	IntSet addEdgesReassignIds(IEdgeSet edges);

	/**
	 * {@inheritDoc}
	 *
	 * &lt;p&gt;
	 * The vertex builder returned by this method always assign the next available index, {@code verticesNum}, given the
	 * current set of vertices {@code (0,1,2, ...,verticesNum-1)}. For example, if the graph currently contains the
	 * vertices {@code 0,1,2}, the next vertex added will be {@code 3}. The builder simply returns the current vertices
	 * set size, without validating that the set is actually {@code (0,1,2, ...,verticesNum-1)}.
	 */
	@Override
	default IdBuilderInt vertexBuilder() {
<span class="fc" id="L182">		return Graphs.IndexGraphIdBuilder;</span>
	}

	/**
	 * {@inheritDoc}
	 *
	 * &lt;p&gt;
	 * The edge builder returned by this method always assign the next available index, {@code edgesNum}, given the
	 * current set of edges {@code (0,1,2, ...,edgesNum-1)}. For example, if the graph currently contains the edges
	 * {@code 0,1,2}, the next edge added will be {@code 3}. The builder simply returns the current edges set size,
	 * without validating that the set is actually {@code (0,1,2, ...,edgesNum-1)}.
	 */
	@Override
	default IdBuilderInt edgeBuilder() {
<span class="fc" id="L196">		return Graphs.IndexGraphIdBuilder;</span>
	}

	@Override
	IndexGraph build();

	@Override
	IndexGraph buildMutable();

	/**
	 * Re-Index the vertices/edges and build a new immutable graph with the new indexing.
	 *
	 * &lt;p&gt;
	 * &lt;i&gt;Re-indexing&lt;/i&gt; is the operation of assigning new indices to the vertices/edges. By re-indexing the
	 * vertices/edges, the performance of accessing/iterating over the graph vertices/edges may increase, for example if
	 * a more cache friendly indexing exists.
	 *
	 * &lt;p&gt;
	 * Note that this method is not &lt;i&gt;required&lt;/i&gt; to re-index the vertices (edges) if {@code reIndexVertices}
	 * ({@code reIndexEdges}) is {@code true}, it is simply allowed to. Whether or not a re-indexing was performed can
	 * be checked via the {@link ReIndexedGraph} return value.
	 *
	 * &lt;p&gt;
	 * Before the graph is built, the edges are validated. If the graph does not support self or parallel edges and such
	 * edges were added to the builder, an exception will be thrown.
	 *
	 * @param  reIndexVertices if {@code true}, the implementation is allowed (but not required) to re-index the
	 *                             vertices of the graph. If {@code false}, the original vertices identifiers are used.
	 *                             Whether or not re-indexing was performed can be checked via
	 *                             {@link ReIndexedGraph#verticesReIndexing}.
	 * @param  reIndexEdges    if {@code true}, the implementation is allowed (but not required) to re-index the edges
	 *                             of the graph. If {@code false}, the original edges identifiers are used. Whether or
	 *                             not re-indexing was performed can be checked via
	 *                             {@link ReIndexedGraph#edgesReIndexing}.
	 * @return                 the re-indexed immutable graph, along with the re-indexing mapping to the original
	 *                         indices
	 */
	IndexGraphBuilder.ReIndexedGraph reIndexAndBuild(boolean reIndexVertices, boolean reIndexEdges);

	/**
	 * Re-Index the vertices/edges and build a new mutable graph with the new indexing.
	 *
	 * &lt;p&gt;
	 * &lt;i&gt;Re-indexing&lt;/i&gt; is the operation of assigning new indices to the vertices/edges. By re-indexing the
	 * vertices/edges, the performance of accessing/iterating over the graph vertices/edges may increase, for example if
	 * a more cache friendly indexing exists.
	 *
	 * &lt;p&gt;
	 * Note that this method is not &lt;i&gt;required&lt;/i&gt; to re-index the vertices (edges) if {@code reIndexVertices}
	 * ({@code reIndexEdges}) is {@code true}, it is simply allowed to. Whether or not a re-indexing was performed can
	 * be checked via the {@link ReIndexedGraph} return value.
	 *
	 * &lt;p&gt;
	 * Before the graph is built, the edges are validated. If the graph does not support self or parallel edges and such
	 * edges were added to the builder, an exception will be thrown.
	 *
	 * @param  reIndexVertices if {@code true}, the implementation is allowed (but not required) to re-index the
	 *                             vertices of the graph. If {@code false}, the original vertices identifiers are used.
	 *                             Whether or not re-indexing was performed can be checked via
	 *                             {@link ReIndexedGraph#verticesReIndexing}.
	 * @param  reIndexEdges    if {@code true}, the implementation is allowed (but not required) to re-index the edges
	 *                             of the graph. If {@code false}, the original edges identifiers are used. Whether or
	 *                             not re-indexing was performed can be checked via
	 *                             {@link ReIndexedGraph#edgesReIndexing}.
	 * @return                 the re-indexed mutable graph, along with the re-indexing mapping to the original indices
	 */
	IndexGraphBuilder.ReIndexedGraph reIndexAndBuildMutable(boolean reIndexVertices, boolean reIndexEdges);

	/**
	 * A result object of re-indexing and building a graph operation.
	 *
	 * &lt;p&gt;
	 * &lt;i&gt;Re-indexing&lt;/i&gt; is the operation of assigning new indices to the vertices/edges. By re-indexing the
	 * vertices/edges, the performance of accessing/iterating over the graph vertices/edges may increase, for example if
	 * a more cache friendly indexing exists.
	 *
	 * &lt;p&gt;
	 * During the lifetime of a {@link IndexGraphBuilder}, vertices and edges are added to it, each one of them has a
	 * unique {@code int} identifier which is also its index (see {@link IndexGraph}). The builder can re-index the
	 * vertices/edges and build a new graph, resulting in a re-indexed graph {@link #graph}, the vertices re-indexing
	 * {@link #verticesReIndexing} and the edges re-indexing {@link #edgesReIndexing}.
	 *
	 * @see    IndexGraphBuilder#reIndexAndBuild(boolean, boolean)
	 * @see    ReIndexingMap
	 * @author Barak Ugav
	 */
	static final class ReIndexedGraph {

		/**
		 * The newly created re-indexed graph.
		 */
		public final IndexGraph graph;

		/**
		 * The re-indexing map of the vertices.
		 *
		 * &lt;p&gt;
		 * The map (if present) can map each original vertex index to its new index after re-indexing. If the map is not
		 * present, the vertices were not re-indexed.
		 */
		public final Optional&lt;IndexGraphBuilder.ReIndexingMap&gt; verticesReIndexing;

		/**
		 * The re-indexing map of the edges.
		 *
		 * &lt;p&gt;
		 * The map (if present) can map each original edge index to its new index after re-indexing. If the map is not
		 * present, the edges were not re-indexed.
		 */
		public final Optional&lt;IndexGraphBuilder.ReIndexingMap&gt; edgesReIndexing;

		ReIndexedGraph(IndexGraph graph, Optional&lt;IndexGraphBuilder.ReIndexingMap&gt; verticesReIndexing,
<span class="fc" id="L308">				Optional&lt;IndexGraphBuilder.ReIndexingMap&gt; edgesReIndexing) {</span>
<span class="fc" id="L309">			this.graph = Objects.requireNonNull(graph);</span>
<span class="fc" id="L310">			this.verticesReIndexing = Objects.requireNonNull(verticesReIndexing);</span>
<span class="fc" id="L311">			this.edgesReIndexing = Objects.requireNonNull(edgesReIndexing);</span>
<span class="fc" id="L312">		}</span>
	}

	/**
	 * A map of indices in range \([0, n)\) to indices in range \([0, n)\).
	 *
	 * &lt;p&gt;
	 * &lt;i&gt;Re-indexing&lt;/i&gt; is the operation of assigning new indices to the vertices/edges. By re-indexing the
	 * vertices/edges, the performance of accessing/iterating over the graph vertices/edges may increase, for example if
	 * a more cache friendly indexing exists.
	 *
	 * &lt;p&gt;
	 * A 're-indexed' index is the index assigned to vertex/edge after a re-indexing operation on a graph. This
	 * interface is used to represent the mapping of both vertices and edges (a single instance map either vertices or
	 * edges), and it should be understood from the context which one is it. In the documentation we use the term
	 * &lt;i&gt;element&lt;/i&gt; to refer to either vertex or edge.
	 *
	 * &lt;p&gt;
	 * An map (this object) is usually obtained when an {@link IndexGraphBuilder} builds a graph a re-index the indices
	 * of the vertices/edges, and the returned map maps from original indices to the new indices. The inverse map, from
	 * the new indices to the original indices may be obtained by {@link ReIndexingMap#inverse()}. Note that the
	 * direction of mapping, namely whether the map is from original to new indices or the other way around, can not be
	 * determine from the re-indexing along, and should be concluded from the context of which the map was obtained.
	 *
	 * &lt;p&gt;
	 * Re-indexing of the vertices (or edges) is a mapping from {@code [0,1,2,...,verticesNum-1]} to
	 * {@code [0,1,2,...,verticesNum-1]}, namely its bijection function.
	 *
	 * @see    IndexGraphBuilder#reIndexAndBuild(boolean, boolean)
	 * @see    ReIndexedGraph
	 * @author Barak Ugav
	 */
	static final class ReIndexingMap {

		private final int[] map;
		private ReIndexingMap inverse;

<span class="fc" id="L349">		ReIndexingMap(int[] map) {</span>
<span class="fc" id="L350">			this.map = Objects.requireNonNull(map);</span>
<span class="fc" id="L351">		}</span>

		/**
		 * Map an element's index to its re-indexed index.
		 *
		 * &lt;p&gt;
		 * Whether this methods maps original to new indices or the other way around should be determine by the context.
		 * The re-indexing maps returned by {@link IndexGraphBuilder#reIndexAndBuild(boolean, boolean)} are from
		 * original to new indices. Maps returned by {@link ReIndexingMap#inverse()} of such maps are the other way
		 * around.
		 *
		 * @param  element an element's index
		 * @return         the element's re-index index
		 */
		public int map(int element) {
<span class="fc" id="L366">			return map[element];</span>
		}

		/**
		 * Get the inverse map of this map.
		 *
		 * &lt;p&gt;
		 * If this map maps original to new indices, the inverse map maps new to original indices, and visa verse.
		 *
		 * @return the inverse map of this map
		 */
		public ReIndexingMap inverse() {
<span class="fc bfc" id="L378" title="All 2 branches covered.">			if (inverse == null) {</span>
<span class="fc" id="L379">				final int n = map.length;</span>
<span class="fc" id="L380">				int[] invMap = new int[n];</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">				for (int i : range(n))</span>
<span class="fc" id="L382">					invMap[map[i]] = i;</span>
<span class="fc" id="L383">				inverse = new ReIndexingMap(invMap);</span>
<span class="fc" id="L384">				inverse.inverse = this;</span>
			}
<span class="fc" id="L386">			return inverse;</span>
		}
	}

	/**
	 * Create a new builder that builds undirected graphs.
	 *
	 * &lt;p&gt;
	 * The graphs built by this builder will have the same default capabilities as {@link IndexGraphFactory}, namely
	 * they will not support self edges and will support parallel edges. See the factory documentation for more
	 * information.
	 *
	 * &lt;p&gt;
	 * For more options to instantiate a builder, create a new {@link IndexGraphFactory} and use one of its
	 * {@code newBuilder} methods.
	 *
	 * @return a new empty builder for undirected graphs
	 */
	static IndexGraphBuilder undirected() {
<span class="fc" id="L405">		return IndexGraphFactory.undirected().newBuilder();</span>
	}

	/**
	 * Create a new builder that builds directed graphs.
	 *
	 * &lt;p&gt;
	 * The graphs built by this builder will have the same default capabilities as {@link IndexGraphFactory}, namely
	 * they will not support self edges and will support parallel edges. See the factory documentation for more
	 * information.
	 *
	 * &lt;p&gt;
	 * For more options to instantiate a builder, create a new {@link IndexGraphFactory} and use one of its
	 * {@code newBuilder} methods.
	 *
	 * @return a new empty builder for directed graphs
	 */
	static IndexGraphBuilder directed() {
<span class="fc" id="L423">		return IndexGraphFactory.directed().newBuilder();</span>
	}

	/**
	 * Create a new builder that builds un/directed graphs.
	 *
	 * &lt;p&gt;
	 * The graphs built by this builder will have the same default capabilities as {@link IndexGraphFactory}, namely
	 * they will not support self edges and will support parallel edges. See the factory documentation for more
	 * information.
	 *
	 * &lt;p&gt;
	 * For more options to instantiate a builder, create a new {@link IndexGraphFactory} and use one of its
	 * {@code newBuilder} methods.
	 *
	 * @param  directed if {@code true}, the new builder will build directed graphs, otherwise it will build undirected
	 *                      graphs
	 * @return          a new empty builder for un/directed graphs
	 */
	static IndexGraphBuilder newInstance(boolean directed) {
<span class="fc" id="L443">		return IndexGraphFactory.newInstance(directed).newBuilder();</span>
	}

	/**
	 * Create a new builder initialized with an existing graph vertices and edges, without copying the weights.
	 *
	 * &lt;p&gt;
	 * If the given graph is directed, the new builder will build directed graphs, and similarly for undirected graphs.
	 *
	 * &lt;p&gt;
	 * For more options to instantiate a builder, create a new {@link IndexGraphFactory} and use one of its
	 * {@code newBuilder} methods.
	 *
	 * @param  g a graph
	 * @return   a builder initialized with the given graph vertices and edges, without the original graph
	 *           vertices/edges weights.
	 */
	static IndexGraphBuilder newCopyOf(IndexGraph g) {
<span class="fc" id="L461">		return newCopyOf(g, false, false);</span>
	}

	/**
	 * Create a new builder initialized with an existing graph vertices and edges, with/without copying the weights.
	 *
	 * &lt;p&gt;
	 * If the given graph is directed, the new builder will build directed graphs, and similarly for undirected graphs.
	 *
	 * &lt;p&gt;
	 * For more options to instantiate a builder, create a new {@link IndexGraphFactory} and use one of its
	 * {@code newBuilder} methods.
	 *
	 * @param  g                   a graph
	 * @param  copyVerticesWeights if {@code true}, the weights of the vertices will be copied from the graph to the
	 *                                 builder
	 * @param  copyEdgesWeights    if {@code true}, the weights of the edges will be copied from the graph to the
	 *                                 builder
	 * @return                     a builder initialized with the given graph vertices and edges, with/without the
	 *                             original graph vertices/edges weights.
	 */
	static IndexGraphBuilder newCopyOf(IndexGraph g, boolean copyVerticesWeights, boolean copyEdgesWeights) {
<span class="fc" id="L483">		return IndexGraphFactory.newInstance(g.isDirected()).newBuilderCopyOf(g, copyVerticesWeights, copyEdgesWeights);</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>