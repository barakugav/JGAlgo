<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GraphHashmapMultiAbstract.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.graph</a> &gt; <span class="el_source">GraphHashmapMultiAbstract.java</span></div><h1>GraphHashmapMultiAbstract.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jgalgo.graph;

import java.util.Iterator;
import com.jgalgo.internal.util.Assertions;
import it.unimi.dsi.fastutil.ints.AbstractIntSet;
import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;

abstract class GraphHashmapMultiAbstract extends GraphBaseMutable {

	@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L29">	static final Int2ObjectMap&lt;int[]&gt;[] EMPTY_MAP_ARRAY = new Int2ObjectMap[0];</span>
<span class="fc" id="L30">	static final int[] EmptyEdgeArr = new int[] { 0 };</span>
	static final Int2ObjectMap&lt;int[]&gt; EmptyEdgeMap;
	static {
<span class="fc" id="L33">		Int2ObjectMap&lt;int[]&gt; emptyEdgeMap = new Int2ObjectOpenHashMap&lt;&gt;(0);</span>
<span class="fc" id="L34">		emptyEdgeMap.defaultReturnValue(EmptyEdgeArr);</span>
		// emptyEdgeMap = Int2ObjectMaps.unmodifiable(emptyEdgeMap);
<span class="fc" id="L36">		EmptyEdgeMap = emptyEdgeMap;</span>
<span class="fc" id="L37">	}</span>

	GraphHashmapMultiAbstract(GraphBaseMutable.Capabilities capabilities, int expectedVerticesNum,
			int expectedEdgesNum) {
<span class="fc" id="L41">		super(capabilities, expectedVerticesNum, expectedEdgesNum);</span>
<span class="fc" id="L42">	}</span>

	GraphHashmapMultiAbstract(GraphBaseMutable.Capabilities capabilities, IndexGraph g, boolean copyVerticesWeights,
			boolean copyEdgesWeights) {
<span class="fc" id="L46">		super(capabilities, g, copyVerticesWeights, copyEdgesWeights);</span>
<span class="fc" id="L47">	}</span>

	GraphHashmapMultiAbstract(GraphBaseMutable.Capabilities capabilities, IndexGraphBuilderImpl builder) {
<span class="nc" id="L50">		super(capabilities, builder);</span>
<span class="nc" id="L51">	}</span>

	static int edgeIndexInArr(int[] edgesArr, int edge) {
<span class="fc" id="L54">		for (int edgesNum = edgesArr[0], i = 1;; i++) {</span>
<span class="pc bnc" id="L55" title="All 2 branches missed.">			assert i &lt;= edgesNum;</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">			if (edgesArr[i] == edge)</span>
<span class="fc" id="L57">				return i;</span>
		}
	}

<span class="fc" id="L61">	private abstract class EdgeIterBase implements IEdgeIter {</span>

		// either the source or target of the iterator
		final int vertex;

		private Iterator&lt;Int2ObjectMap.Entry&lt;int[]&gt;&gt; endpointIter;

		private int endpoint;
		private int[] endpointEdges;
		private int endpointEdgesNum;
		/* index in range [1, endpointEdgesNum], rather than the usual [0, endpointEdgesNum) */
<span class="fc" id="L72">		private int endpointEdgeIdx = 1;</span>

<span class="fc" id="L74">		private int prevEdge = -1;</span>
<span class="fc" id="L75">		int prevEndpoint = -1;</span>
		private Int2ObjectMap&lt;int[]&gt; clonedMap;
		private final Int2ObjectMap&lt;int[]&gt; originalMap;

<span class="fc" id="L79">		EdgeIterBase(int vertex, Int2ObjectMap&lt;int[]&gt; edges) {</span>
<span class="fc" id="L80">			this.vertex = vertex;</span>
<span class="fc" id="L81">			originalMap = edges;</span>
<span class="fc" id="L82">			endpointIter = Int2ObjectMaps.fastIterator(edges);</span>
<span class="fc" id="L83">			advance();</span>
<span class="fc" id="L84">		}</span>

		private void advance() {
<span class="fc bfc" id="L87" title="All 2 branches covered.">			if (endpointEdgeIdx &lt;= endpointEdgesNum)</span>
<span class="fc" id="L88">				return;</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">			if (endpointIter.hasNext()) {</span>
<span class="fc" id="L90">				Int2ObjectMap.Entry&lt;int[]&gt; entry = endpointIter.next();</span>
<span class="fc" id="L91">				endpoint = entry.getIntKey();</span>
<span class="fc" id="L92">				endpointEdges = entry.getValue();</span>
<span class="fc" id="L93">				endpointEdgesNum = endpointEdges[0];</span>
<span class="fc" id="L94">				endpointEdgeIdx = 1;</span>
<span class="pc bnc" id="L95" title="All 2 branches missed.">				assert endpointEdgesNum &gt; 0;</span>
<span class="fc" id="L96">			} else {</span>
<span class="fc" id="L97">				endpointEdgesNum = 0;</span>
<span class="fc" id="L98">				endpointEdgeIdx = 1;</span>
			}
<span class="fc" id="L100">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc bfc" id="L104" title="All 2 branches covered.">			return endpointEdgeIdx &lt;= endpointEdgesNum;</span>
		}

		@Override
		public int nextInt() {
<span class="fc" id="L109">			Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L110">			prevEdge = endpointEdges[endpointEdgeIdx++];</span>
<span class="fc" id="L111">			prevEndpoint = endpoint;</span>
<span class="fc" id="L112">			advance();</span>
<span class="fc" id="L113">			return prevEdge;</span>
		}

		@Override
		public int peekNextInt() {
<span class="fc" id="L118">			Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L119">			return endpointEdges[endpointEdgeIdx];</span>
		}

		@Override
		public void remove() {
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">			if (prevEdge == -1)</span>
<span class="nc" id="L125">				throw new IllegalStateException();</span>

			/*
			 * remove() is hard to implement due to two reasons: (1) if we want to provide peekNext(), we can not use
			 * HashMap.Iterator.remove(), as the map iterator already iterated over the next (peek) element, so we are
			 * forced to use HashMap.remove() which can not be used during iteration, so we clone the map. (2) If we
			 * choose to clone the map, it will not be updated when edges are swapped, so we have to update it manually.
			 */
<span class="fc bfc" id="L133" title="All 2 branches covered.">			if (clonedMap == null) {</span>
<span class="fc" id="L134">				clonedMap = new Int2ObjectOpenHashMap&lt;&gt;(1);</span>
<span class="fc" id="L135">				clonedMap.defaultReturnValue(EmptyEdgeArr);</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">				while (endpointIter.hasNext()) {</span>
<span class="fc" id="L137">					Int2ObjectMap.Entry&lt;int[]&gt; entry = endpointIter.next();</span>
<span class="fc" id="L138">					clonedMap.put(entry.getIntKey(), entry.getValue());</span>
<span class="fc" id="L139">				}</span>
<span class="fc" id="L140">				endpointIter = Int2ObjectMaps.fastIterator(clonedMap);</span>
			}

<span class="fc" id="L143">			removeEdge(prevEdge);</span>
<span class="fc" id="L144">			prevEdge = -1;</span>

<span class="fc bfc" id="L146" title="All 2 branches covered.">			if (endpointEdgeIdx &gt; 1) {</span>
<span class="fc" id="L147">				endpointEdgeIdx--;</span>
<span class="fc" id="L148">				endpointEdges = originalMap.get(endpoint);</span>
<span class="fc" id="L149">				endpointEdgesNum--;</span>
<span class="pc bnc" id="L150" title="All 2 branches missed.">				assert endpointEdgesNum == endpointEdges[0];</span>
			}
<span class="fc" id="L152">		}</span>
	}

	class EdgeIterOut extends EdgeIterBase {

<span class="fc" id="L157">		EdgeIterOut(int source, Int2ObjectMap&lt;int[]&gt; edges) {</span>
<span class="fc" id="L158">			super(source, edges);</span>
<span class="fc" id="L159">		}</span>

		@Override
		public int sourceInt() {
<span class="fc" id="L163">			return vertex;</span>
		}

		@Override
		public int targetInt() {
<span class="fc" id="L168">			return prevEndpoint;</span>
		}
	}

	class EdgeIterIn extends EdgeIterBase {

<span class="fc" id="L174">		EdgeIterIn(int target, Int2ObjectMap&lt;int[]&gt; edges) {</span>
<span class="fc" id="L175">			super(target, edges);</span>
<span class="fc" id="L176">		}</span>

		@Override
		public int sourceInt() {
<span class="fc" id="L180">			return prevEndpoint;</span>
		}

		@Override
		public int targetInt() {
<span class="fc" id="L185">			return vertex;</span>
		}
	}

	abstract class SourceTargetEdgeSet extends AbstractIntSet implements IEdgeSet {

		final int source;
		final int target;

<span class="fc" id="L194">		SourceTargetEdgeSet(int source, int target) {</span>
<span class="fc" id="L195">			this.source = source;</span>
<span class="fc" id="L196">			this.target = target;</span>
<span class="fc" id="L197">		}</span>

		abstract Int2ObjectMap&lt;int[]&gt; edgesOut(int source);

		@Override
		public int size() {
<span class="fc" id="L203">			return edgesOut(source).get(target)[0];</span>
		}

		@Override
		public boolean remove(int edge) {
<span class="fc bfc" id="L208" title="All 2 branches covered.">			if (!contains(edge))</span>
<span class="fc" id="L209">				return false;</span>
<span class="fc" id="L210">			removeEdge(edge);</span>
<span class="fc" id="L211">			return true;</span>
		}

		@Override
		public void clear() {
			for (;;) {
<span class="fc" id="L217">				int[] edgesArr = edgesOut(source).get(target);</span>
<span class="fc" id="L218">				int edgesNum = edgesArr[0];</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">				if (edgesNum == 0)</span>
<span class="fc" id="L220">					break;</span>
<span class="fc" id="L221">				removeEdge(edgesArr[1]);</span>
<span class="fc" id="L222">			}</span>
<span class="fc" id="L223">		}</span>

		@Override
		public IEdgeIter iterator() {
<span class="fc" id="L227">			return new IEdgeIter() {</span>

<span class="fc" id="L229">				int[] edgesArr = edgesOut(source).get(target);</span>
<span class="fc" id="L230">				int edgesNum = edgesArr[0];</span>
<span class="fc" id="L231">				int edgeIdx = 1; /* index in range [1, edgesNum], rather than the usual [0, edgesNum) */</span>
<span class="fc" id="L232">				int lastEdge = -1;</span>

				@Override
				public boolean hasNext() {
<span class="fc bfc" id="L236" title="All 2 branches covered.">					return edgeIdx &lt;= edgesNum;</span>
				}

				@Override
				public int nextInt() {
<span class="fc" id="L241">					Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L242">					return lastEdge = edgesArr[edgeIdx++];</span>
				}

				@Override
				public int peekNextInt() {
<span class="fc" id="L247">					Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L248">					return edgesArr[edgeIdx];</span>
				}

				@Override
				public int sourceInt() {
<span class="fc" id="L253">					return source;</span>
				}

				@Override
				public int targetInt() {
<span class="fc" id="L258">					return target;</span>
				}

				@Override
				public void remove() {
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">					if (lastEdge == -1)</span>
<span class="nc" id="L264">						throw new IllegalStateException();</span>
<span class="fc" id="L265">					removeEdge(lastEdge);</span>
<span class="fc" id="L266">					edgesNum--;</span>
<span class="fc" id="L267">					edgeIdx--;</span>
<span class="fc" id="L268">					edgesArr = edgesOut(source).get(target);</span>
<span class="fc" id="L269">					lastEdge = -1;</span>
<span class="fc" id="L270">				}</span>
			};
		}
	}

	static Int2ObjectMap&lt;int[]&gt; ensureEdgesMapMutable(Int2ObjectMap&lt;int[]&gt;[] edgesMaps, int idx) {
<span class="fc bfc" id="L276" title="All 2 branches covered.">		if (edgesMaps[idx] == EmptyEdgeMap) {</span>
<span class="fc" id="L277">			edgesMaps[idx] = new Int2ObjectOpenHashMap&lt;&gt;();</span>
<span class="fc" id="L278">			edgesMaps[idx].defaultReturnValue(EmptyEdgeArr);</span>
		}
<span class="fc" id="L280">		return edgesMaps[idx];</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>