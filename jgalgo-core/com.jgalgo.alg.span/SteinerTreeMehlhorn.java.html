<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SteinerTreeMehlhorn.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.alg.span</a> &gt; <span class="el_source">SteinerTreeMehlhorn.java</span></div><h1>SteinerTreeMehlhorn.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.alg.span;

import static com.jgalgo.internal.util.Range.range;
import java.util.Arrays;
import java.util.function.IntConsumer;
import com.jgalgo.alg.shortestpath.VoronoiAlgo;
import com.jgalgo.graph.IEdgeIter;
import com.jgalgo.graph.IWeightFunction;
import com.jgalgo.graph.IndexGraph;
import com.jgalgo.graph.IndexGraphBuilder;
import com.jgalgo.internal.util.Assertions;
import com.jgalgo.internal.util.Bitmap;
import com.jgalgo.internal.util.FIFOQueueIntNoReduce;
import com.jgalgo.internal.util.ImmutableIntArraySet;
import it.unimi.dsi.fastutil.doubles.DoubleArrayList;
import it.unimi.dsi.fastutil.ints.IntArrayList;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntList;
import it.unimi.dsi.fastutil.ints.IntPriorityQueue;

/**
 * Mehlhorn algorithm for Steiner tree approximation.
 *
 * &lt;p&gt;
 * The Steiner tree problem is NP-hard, and this algorithm provides a \(2(1-1/l)\)-approximation where \(l\) is the
 * minimum number of leaves in any Steiner tree for the given graph. Note that \(l\) is always smaller or equal to the
 * number of terminals vertices.
 *
 * &lt;p&gt;
 * The algorithm runs in \(O(m+n \log n)\) time and use linear space.
 *
 * &lt;p&gt;
 * Based on 'A faster approximation algorithm for the Steiner problem in graphs' by Kurt Mehlhorn.
 *
 * @author Barak Ugav
 */
<span class="fc" id="L52">public class SteinerTreeMehlhorn extends SteinerTreeAlgoAbstract {</span>

<span class="fc" id="L54">	private final VoronoiAlgo voronoiAlgo = VoronoiAlgo.newInstance();</span>
<span class="fc" id="L55">	private final MinimumSpanningTree mstAlgo = MinimumSpanningTree.newInstance();</span>

	/**
	 * Construct a new Steiner tree algorithm object.
	 *
	 * &lt;p&gt;
	 * Please prefer using {@link SteinerTreeAlgo#newInstance()} to get a default implementation for the
	 * {@link SteinerTreeAlgo} interface.
	 */
<span class="fc" id="L64">	public SteinerTreeMehlhorn() {}</span>

	@Override
	public SteinerTreeAlgo.IResult computeSteinerTree(IndexGraph g, IWeightFunction w, IntCollection terminals) {
<span class="fc" id="L68">		Assertions.onlyUndirected(g);</span>
<span class="fc" id="L69">		final int n = g.vertices().size();</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">		if (terminals.isEmpty())</span>
<span class="fc" id="L71">			throw new IllegalArgumentException(&quot;no terminals provided&quot;);</span>
<span class="fc" id="L72">		final int terminalNum = terminals.size();</span>
<span class="fc" id="L73">		Bitmap isTerminal = new Bitmap(n);</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">		for (int t : terminals) {</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">			if (isTerminal.get(t))</span>
<span class="fc" id="L76">				throw new IllegalArgumentException(&quot;Duplicate terminal: &quot; + t);</span>
<span class="fc" id="L77">			isTerminal.set(t);</span>
<span class="fc" id="L78">		}</span>

		/* 1.1. Compute the Voronoi cells of the terminals */
<span class="fc" id="L81">		VoronoiAlgo.IResult cells = (VoronoiAlgo.IResult) voronoiAlgo.computeVoronoiCells(g, terminals, w);</span>

		/*
		 * 1.2. Build the subgraph G'1 where each vertex is a terminal node and the edge connecting each pair of
		 * terminal nodes (s,t) is the minimum edge {d(s,u),(u,v),(v,t)} where u is in the cell of s and v is in the
		 * cell of t.
		 */
<span class="fc" id="L88">		IndexGraphBuilder g1Builder = IndexGraphBuilder.undirected();</span>
<span class="fc" id="L89">		g1Builder.addVertices(range(terminalNum));</span>
<span class="fc" id="L90">		IntArrayList g1EdgeRef0 = new IntArrayList();</span>
<span class="fc" id="L91">		DoubleArrayList g1EdgeWeight0 = new DoubleArrayList();</span>
<span class="fc" id="L92">		int[] neighborsBestEdge = new int[terminalNum];</span>
<span class="fc" id="L93">		double[] neighborsBestWeight = new double[terminalNum];</span>
<span class="fc" id="L94">		Arrays.fill(neighborsBestEdge, -1);</span>
<span class="fc" id="L95">		IntList neighbors = new IntArrayList(terminalNum);</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">		for (int t : range(terminalNum)) {</span>
<span class="pc bpc" id="L97" title="3 of 6 branches missed.">			assert neighbors.isEmpty() &amp;&amp; Arrays.stream(neighborsBestEdge).allMatch(e -&gt; e &lt; 0);</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">			for (int u : cells.partition().blockVertices(t)) {</span>
<span class="fc" id="L99">				double uDistance = cells.distance(u);</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">				for (IEdgeIter eit = g.outEdges(u).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L101">					int e = eit.nextInt();</span>
<span class="fc" id="L102">					int v = eit.targetInt();</span>
<span class="fc" id="L103">					int vT = cells.partition().vertexBlock(v);</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">					if (vT &lt;= t)</span>
<span class="fc" id="L105">						continue;</span>
<span class="fc" id="L106">					double ew = uDistance + w.weight(e) + cells.distance(v);</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">					if (neighborsBestEdge[vT] &lt; 0) {</span>
<span class="fc" id="L108">						neighborsBestEdge[vT] = e;</span>
<span class="fc" id="L109">						neighborsBestWeight[vT] = ew;</span>
<span class="fc" id="L110">						neighbors.add(vT);</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">					} else if (ew &lt; neighborsBestWeight[vT]) {</span>
<span class="fc" id="L112">						neighborsBestEdge[vT] = e;</span>
<span class="fc" id="L113">						neighborsBestWeight[vT] = ew;</span>
					}
<span class="fc" id="L115">				}</span>
<span class="fc" id="L116">			}</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">			for (int vT : neighbors) {</span>
<span class="fc" id="L118">				g1Builder.addEdge(t, vT);</span>
<span class="fc" id="L119">				g1EdgeRef0.add(neighborsBestEdge[vT]);</span>
<span class="fc" id="L120">				g1EdgeWeight0.add(neighborsBestWeight[vT]);</span>
<span class="fc" id="L121">				neighborsBestEdge[vT] = -1;</span>
<span class="fc" id="L122">			}</span>
<span class="fc" id="L123">			neighbors.clear();</span>
<span class="fc" id="L124">		}</span>
<span class="fc" id="L125">		IndexGraph g1 = g1Builder.build();</span>
<span class="fc" id="L126">		g1Builder.clear();</span>
<span class="fc" id="L127">		int[] g1EdgeRef = g1EdgeRef0.elements();</span>
<span class="fc" id="L128">		double[] g1EdgeWeight = g1EdgeWeight0.elements();</span>
<span class="fc" id="L129">		IWeightFunction g1WeightFunc = e -&gt; g1EdgeWeight[e];</span>

		/* 2. Find a minimum spanning tree G2 of G1 */
<span class="fc" id="L132">		IntCollection g2 = ((MinimumSpanningTree.IResult) mstAlgo.computeMinimumSpanningTree(g1, g1WeightFunc)).edges();</span>

		/* 3. Construct a subgraph G3 of G by replacing each edge in G2 by its corresponding shortest path in G */
<span class="fc" id="L135">		IndexGraphBuilder g3Builder = g1Builder;</span>
<span class="fc" id="L136">		g3Builder.addVertices(g.vertices());</span>
<span class="fc" id="L137">		Bitmap g3Edges = new Bitmap(g.edges().size());</span>
<span class="fc" id="L138">		IntArrayList g3EdgeRef0 = new IntArrayList();</span>
<span class="fc" id="L139">		DoubleArrayList g3EdgeWeight0 = g1EdgeWeight0;</span>
<span class="fc" id="L140">		g3EdgeWeight0.clear();</span>
<span class="fc" id="L141">		IntConsumer g3AddEdge = e -&gt; {</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">			if (!g3Edges.get(e)) {</span>
<span class="fc" id="L143">				g3Builder.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L144">				g3EdgeRef0.add(e);</span>
<span class="fc" id="L145">				g3EdgeWeight0.add(w.weight(e));</span>
<span class="fc" id="L146">				g3Edges.set(e);</span>
			}
<span class="fc" id="L148">		};</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">		for (int e2 : g2) {</span>
<span class="fc" id="L150">			int e = g1EdgeRef[e2];</span>
			/* add path from a terminal node to the original source of e */
<span class="fc bfc" id="L152" title="All 2 branches covered.">			for (int e0 : cells.getPath(g.edgeSource(e)).edges())</span>
<span class="fc" id="L153">				g3AddEdge.accept(e0);</span>
			/* add cross voronoi-cells edge e */
<span class="fc" id="L155">			g3AddEdge.accept(e);</span>
			/* add path from the original target of e to a terminal node */
<span class="fc bfc" id="L157" title="All 2 branches covered.">			for (int e0 : cells.getPath(g.edgeTarget(e)).edges())</span>
<span class="fc" id="L158">				g3AddEdge.accept(e0);</span>
<span class="fc" id="L159">		}</span>
<span class="fc" id="L160">		IndexGraph g3 = g3Builder.build();</span>
<span class="fc" id="L161">		g3Builder.clear();</span>
<span class="fc" id="L162">		int[] g3EdgeRef = g3EdgeRef0.elements();</span>
<span class="fc" id="L163">		double[] g3EdgeWeight = g3EdgeWeight0.elements();</span>
<span class="fc" id="L164">		IWeightFunction g3WeightFunc = e -&gt; g3EdgeWeight[e];</span>

		/* 4. Find the minimum spanning tree G4 of G3 */
<span class="fc" id="L167">		IntCollection g4 = ((MinimumSpanningTree.IResult) mstAlgo.computeMinimumSpanningTree(g3, g3WeightFunc)).edges();</span>
<span class="fc" id="L168">		int[] g4Edges = new int[g4.size() * 2];</span>
<span class="fc" id="L169">		int[] g4EdgesOffset = new int[n + 1];</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">		for (int e4 : g4) {</span>
<span class="fc" id="L171">			g4EdgesOffset[g3.edgeSource(e4)]++;</span>
<span class="fc" id="L172">			g4EdgesOffset[g3.edgeTarget(e4)]++;</span>
<span class="fc" id="L173">		}</span>
<span class="fc" id="L174">		int s = 0;</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">		for (int v : range(n)) {</span>
<span class="fc" id="L176">			int k = g4EdgesOffset[v];</span>
<span class="fc" id="L177">			g4EdgesOffset[v] = s;</span>
<span class="fc" id="L178">			s += k;</span>
<span class="fc" id="L179">		}</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">		for (int e4 : g4) {</span>
<span class="fc" id="L181">			g4Edges[g4EdgesOffset[g3.edgeSource(e4)]++] = e4;</span>
<span class="fc" id="L182">			g4Edges[g4EdgesOffset[g3.edgeTarget(e4)]++] = e4;</span>
<span class="fc" id="L183">		}</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">		for (int v = n; v &gt; 0; v--)</span>
<span class="fc" id="L185">			g4EdgesOffset[v] = g4EdgesOffset[v - 1];</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">		assert g4EdgesOffset[n] == g4Edges.length;</span>
<span class="fc" id="L187">		g4EdgesOffset[0] = 0;</span>

		/* 5. Construct a Steiner tree G5 from G4 by deleting edges so that no leaves are Steiner vertices */
<span class="fc" id="L190">		int[] g5Degree = new int[n];</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">		for (int v : range(n))</span>
<span class="fc" id="L192">			g5Degree[v] = g4EdgesOffset[v + 1] - g4EdgesOffset[v];</span>
<span class="fc" id="L193">		IntPriorityQueue queue = new FIFOQueueIntNoReduce();</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">		for (int v : range(n))</span>
<span class="pc bpc" id="L195" title="1 of 4 branches missed.">			if (g5Degree[v] == 1 &amp;&amp; !isTerminal.get(v))</span>
<span class="nc" id="L196">				queue.enqueue(v);</span>
<span class="fc" id="L197">		Bitmap g5Edges = new Bitmap(g4Edges.length);</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">		for (int e4 : g4)</span>
<span class="fc" id="L199">			g5Edges.set(e4);</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">		while (!queue.isEmpty()) {</span>
<span class="nc" id="L201">			int u = queue.dequeueInt();</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">			assert g5Degree[u] &lt;= 1;</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">			if (g5Degree[u] == 0)</span>
<span class="nc" id="L204">				continue; /* parent edge already removed */</span>
			int e4;
<span class="nc" id="L206">			for (int eIdx = g4EdgesOffset[u];; eIdx++) {</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">				assert eIdx &lt; g4EdgesOffset[u + 1];</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">				if (g5Edges.get(g4Edges[eIdx])) {</span>
<span class="nc" id="L209">					e4 = g4Edges[eIdx];</span>
<span class="nc" id="L210">					break;</span>
				}
			}
<span class="nc" id="L213">			g5Edges.clear(e4);</span>
<span class="nc" id="L214">			int v = g3.edgeEndpoint(e4, u);</span>
<span class="nc" id="L215">			g5Degree[u]--;</span>
<span class="nc" id="L216">			g5Degree[v]--;</span>
<span class="nc bnc" id="L217" title="All 4 branches missed.">			if (g5Degree[v] == 1 &amp;&amp; !isTerminal.get(v))</span>
<span class="nc" id="L218">				queue.enqueue(v);</span>
<span class="nc" id="L219">		}</span>
<span class="fc" id="L220">		int[] g5 = new int[g5Edges.cardinality()];</span>
<span class="fc" id="L221">		int g5EdgeIdx = 0;</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">		for (int e3 : g5Edges)</span>
<span class="fc" id="L223">			g5[g5EdgeIdx++] = g3EdgeRef[e3];</span>

<span class="fc" id="L225">		return new SteinerTreeAlgoAbstract.IndexResult(ImmutableIntArraySet.withNaiveContains(g5));</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>