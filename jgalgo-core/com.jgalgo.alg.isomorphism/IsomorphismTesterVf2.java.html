<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IsomorphismTesterVf2.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.alg.isomorphism</a> &gt; <span class="el_source">IsomorphismTesterVf2.java</span></div><h1>IsomorphismTesterVf2.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.alg.isomorphism;

import static com.jgalgo.internal.util.Range.range;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.NoSuchElementException;
import com.jgalgo.graph.IEdgeIter;
import com.jgalgo.graph.IndexGraph;
import com.jgalgo.internal.util.Assertions;
import com.jgalgo.internal.util.IterTools;
import it.unimi.dsi.fastutil.ints.IntArrays;
import it.unimi.dsi.fastutil.ints.IntIterator;
import it.unimi.dsi.fastutil.ints.IntIterators;
import it.unimi.dsi.fastutil.objects.ObjectIterators;

/**
 * Vf2 algorithm for testing isomorphism of two graphs.
 *
 * &lt;p&gt;
 * Based on 'An Improved Algorithm for Matching Large Graphs' by L. P. Cordella, P. Foggia, C. Sansone and M. Vento. The
 * paper denote the smaller graph as G2 and the bigger graph as G1 in (induced) sub graph isomorphism. We use the
 * opposite notation, which seems more suitable as the returned mapping is from G1 to G2.
 *
 * @author Barak Ugav
 */
<span class="fc" id="L42">public class IsomorphismTesterVf2 extends IsomorphismTesterAbstract {</span>

	/**
	 * Create a new isomorphism algorithm.
	 *
	 * &lt;p&gt;
	 * Please prefer using {@link IsomorphismTester#newInstance()} to get a default implementation for the
	 * {@link IsomorphismTester} interface.
	 */
<span class="fc" id="L51">	public IsomorphismTesterVf2() {}</span>

	@Override
	protected Iterator&lt;IsomorphismIMapping&gt; isomorphicMappingsIter(IndexGraph g1, IndexGraph g2, boolean induced,
			IntMatcher vertexMatcher, IntMatcher edgeMatcher) {
<span class="fc" id="L56">		Assertions.noParallelEdges(g1, &quot;parallel edges are not supported&quot;);</span>
<span class="fc" id="L57">		Assertions.noParallelEdges(g2, &quot;parallel edges are not supported&quot;);</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">		if (g1.isDirected() != g2.isDirected())</span>
<span class="fc" id="L59">			throw new IllegalArgumentException(&quot;directed/undirected graphs mismatch&quot;);</span>

<span class="fc" id="L61">		final int n1 = g1.vertices().size();</span>
<span class="fc" id="L62">		final int n2 = g2.vertices().size();</span>
<span class="fc" id="L63">		final int m1 = g1.edges().size();</span>
<span class="fc" id="L64">		final int m2 = g2.edges().size();</span>

<span class="fc bfc" id="L66" title="All 10 branches covered.">		if (n1 &gt; n2 || m1 &gt; m2 || (n1 == n2 &amp;&amp; m1 != m2 &amp;&amp; induced))</span>
<span class="fc" id="L67">			return Collections.emptyIterator();</span>

<span class="fc bfc" id="L69" title="All 2 branches covered.">		if (n1 == 0) {</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">			assert m1 == 0;</span>
<span class="fc" id="L71">			return ObjectIterators</span>
<span class="fc" id="L72">					.singleton(new IndexMapping(g1, g2, IntArrays.DEFAULT_EMPTY_ARRAY, IntArrays.DEFAULT_EMPTY_ARRAY));</span>
		}

<span class="fc bfc" id="L75" title="All 2 branches covered.">		if (g1.isDirected()) {</span>
<span class="fc" id="L76">			return new IsomorphismIterDirected(g1, g2, induced, vertexMatcher, edgeMatcher);</span>
		} else {
<span class="fc" id="L78">			return new IsomorphismIterUndirected(g1, g2, induced, vertexMatcher, edgeMatcher);</span>
		}
	}

<span class="fc" id="L82">	private abstract static class IsomorphismIterBase implements Iterator&lt;IsomorphismIMapping&gt; {</span>

		final IndexGraph g1;
		final IndexGraph g2;
		final int n1, n2;
		private final IntMatcher vertexMatcher;
		private final IntMatcher edgeMatcher;
		final boolean subGraph;
		final boolean inducedSubGraph;

		final int[] core1;
		final int[] core2;
		int stateDepth;
		final int[] statePrevV1;
		final int[] statePrevV2;
		final int[] stateNextV1;
		final IntIterator[] stateNextV2Iter;

<span class="fc" id="L100">		int nextVisitIdx = 1;</span>
		final int[] visit;
		final int[] visitData;

		int[] nextMapping;

		static final int None = -1;

		IsomorphismIterBase(IndexGraph g1, IndexGraph g2, boolean induced, IntMatcher vertexMatcher,
<span class="fc" id="L109">				IntMatcher edgeMatcher) {</span>
<span class="fc" id="L110">			this.g1 = g1;</span>
<span class="fc" id="L111">			this.g2 = g2;</span>
<span class="fc" id="L112">			n1 = g1.vertices().size();</span>
<span class="fc" id="L113">			n2 = g2.vertices().size();</span>
<span class="fc" id="L114">			this.vertexMatcher = vertexMatcher;</span>
<span class="fc" id="L115">			this.edgeMatcher = edgeMatcher;</span>

<span class="pc bpc" id="L117" title="1 of 2 branches missed.">			assert n1 &lt;= n2;</span>
<span class="fc bfc" id="L118" title="All 4 branches covered.">			subGraph = !induced || n1 &lt; n2;</span>
<span class="fc" id="L119">			inducedSubGraph = induced;</span>

<span class="fc" id="L121">			core1 = new int[n1];</span>
<span class="fc" id="L122">			core2 = new int[n2];</span>
<span class="fc" id="L123">			Arrays.fill(core1, None);</span>
<span class="fc" id="L124">			Arrays.fill(core2, None);</span>

<span class="fc" id="L126">			visit = new int[/* max(n1,n2) */ n2];</span>
<span class="fc" id="L127">			visitData = new int[/* max(n1,n2) */ n2];</span>

<span class="fc" id="L129">			stateDepth = 1;</span>
<span class="fc" id="L130">			final int maxStateDepth = n1 + 1;</span>
<span class="fc" id="L131">			statePrevV1 = new int[maxStateDepth];</span>
<span class="fc" id="L132">			statePrevV2 = new int[maxStateDepth];</span>
<span class="fc" id="L133">			stateNextV1 = new int[maxStateDepth];</span>
<span class="fc" id="L134">			stateNextV2Iter = new IntIterator[maxStateDepth];</span>
<span class="fc" id="L135">		}</span>

		abstract void advance();

		@Override
		public boolean hasNext() {
<span class="fc bfc" id="L141" title="All 2 branches covered.">			if (nextMapping == null)</span>
<span class="fc" id="L142">				advance();</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">			return nextMapping != null;</span>
		}

		@Override
		public IsomorphismIMapping next() {
<span class="fc bfc" id="L148" title="All 2 branches covered.">			if (!hasNext())</span>
<span class="fc" id="L149">				throw new NoSuchElementException();</span>
<span class="fc" id="L150">			IsomorphismIMapping mapping = new IndexMapping(g1, g2, nextMapping, computeEdgeMapping(nextMapping));</span>
<span class="fc" id="L151">			nextMapping = null;</span>
<span class="fc" id="L152">			return mapping;</span>
		}

		private int[] computeEdgeMapping(int[] vMapping) {
<span class="fc" id="L156">			int[] eMapping = new int[g1.edges().size()];</span>

<span class="fc" id="L158">			Arrays.fill(visit, -1);</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">			for (final int u1 : range(g1.vertices().size())) {</span>
<span class="fc" id="L160">				final int u2 = vMapping[u1];</span>
<span class="fc" id="L161">				final int visitIdx = u1;</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">				for (IEdgeIter eit = g1.outEdges(u1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L163">					int e1 = eit.nextInt();</span>
<span class="fc" id="L164">					int v1 = eit.targetInt();</span>
<span class="fc" id="L165">					int v2 = vMapping[v1];</span>
<span class="fc" id="L166">					visit[v2] = visitIdx;</span>
<span class="fc" id="L167">					visitData[v2] = e1;</span>
<span class="fc" id="L168">				}</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">				for (IEdgeIter eit = g2.outEdges(u2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L170">					int e2 = eit.nextInt();</span>
<span class="fc" id="L171">					int v2 = eit.targetInt();</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">					if (visit[v2] == visitIdx) {</span>
<span class="fc" id="L173">						int e1 = visitData[v2];</span>
<span class="fc" id="L174">						eMapping[e1] = e2;</span>
					}
<span class="fc" id="L176">				}</span>
<span class="fc" id="L177">			}</span>
<span class="fc" id="L178">			Arrays.fill(visit, 0);</span>
<span class="fc" id="L179">			nextVisitIdx = 1;</span>

<span class="fc" id="L181">			return eMapping;</span>
		}

		boolean canMatchVertices(int v1, int v2) {
<span class="fc bfc" id="L185" title="All 4 branches covered.">			return vertexMatcher == null || vertexMatcher.isMatch(v1, v2);</span>
		}

		boolean canMatchEdges(int e1, int e2) {
<span class="fc bfc" id="L189" title="All 4 branches covered.">			return edgeMatcher == null || edgeMatcher.isMatch(e1, e2);</span>
		}

	}

<span class="fc" id="L194">	private static final class IsomorphismIterDirected extends IsomorphismIterBase {</span>

		private final int[] in1;
		private final int[] in2;
		private final int[] out1;
		private final int[] out2;

		private final int[] stateT1OutSize;
		private final int[] stateT2OutSize;
		private final int[] stateT1InSize;
		private final int[] stateT2InSize;

		IsomorphismIterDirected(IndexGraph g1, IndexGraph g2, boolean induced, IntMatcher vertexMatcher,
				IntMatcher edgeMatcher) {
<span class="fc" id="L208">			super(g1, g2, induced, vertexMatcher, edgeMatcher);</span>

<span class="fc" id="L210">			in1 = new int[n1];</span>
<span class="fc" id="L211">			in2 = new int[n2];</span>
<span class="fc" id="L212">			out1 = new int[n1];</span>
<span class="fc" id="L213">			out2 = new int[n2];</span>

<span class="fc" id="L215">			final int maxStateDepth = n1 + 1;</span>
<span class="fc" id="L216">			stateT1OutSize = new int[maxStateDepth];</span>
<span class="fc" id="L217">			stateT2OutSize = new int[maxStateDepth];</span>
<span class="fc" id="L218">			stateT1InSize = new int[maxStateDepth];</span>
<span class="fc" id="L219">			stateT2InSize = new int[maxStateDepth];</span>
<span class="fc" id="L220">			newState(None, None, 0, 0, 0, 0);</span>

<span class="fc" id="L222">			advance();</span>
<span class="fc" id="L223">		}</span>

		private void newState(int v1, int v2, int t1OutSize, int t2OutSize, int t1InSize, int t2InSize) {
<span class="fc" id="L226">			statePrevV1[stateDepth] = v1;</span>
<span class="fc" id="L227">			statePrevV2[stateDepth] = v2;</span>
<span class="fc" id="L228">			stateT1OutSize[stateDepth] = t1OutSize;</span>
<span class="fc" id="L229">			stateT2OutSize[stateDepth] = t2OutSize;</span>
<span class="fc" id="L230">			stateT1InSize[stateDepth] = t1InSize;</span>
<span class="fc" id="L231">			stateT2InSize[stateDepth] = t2InSize;</span>

<span class="pc bpc" id="L233" title="1 of 2 branches missed.">			assert t1OutSize &lt; n1;</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">			assert t2OutSize &lt; n2;</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">			assert t1InSize &lt; n1;</span>
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">			assert t2InSize &lt; n2;</span>

			int nextV1;
			IntIterator nextV2Iter;
			/*
			 * &quot;In case that only one of the in-terminal sets or only one of the out-terminal sets is empty, it can be
			 * demonstrated that the state s cannot be part of a matching, and it is not further explored.&quot; Although
			 * this is stated in the paper, this does not seem to be correct for non-full isomorphism.
			 */
<span class="fc bfc" id="L245" title="All 14 branches covered.">			if (!subGraph &amp;&amp; ((t1OutSize == 0 ^ t2OutSize == 0) || (t1InSize == 0 ^ t2InSize == 0))) {</span>
<span class="fc" id="L246">				nextV1 = None;</span>
<span class="fc" id="L247">				nextV2Iter = IntIterators.EMPTY_ITERATOR;</span>

			} else {
<span class="fc bfc" id="L250" title="All 4 branches covered.">				if (t1OutSize != 0 &amp;&amp; t2OutSize != 0) {</span>
					/* P(s)=T^{out}_1 (s) \times \{\min T^{out}_2(s)\} */
					/* we use the opposite notation of G1 G2 than what used in the paper (G1 is the smaller graph) */
<span class="fc bfc" id="L253" title="All 4 branches covered.">					nextV1 = IterTools.filter(range(n1).iterator(), u1 -&gt; core1[u1] &lt; 0 &amp;&amp; out1[u1] &gt; 0).nextInt();</span>
<span class="fc bfc" id="L254" title="All 4 branches covered.">					nextV2Iter = IterTools.filter(range(n2).iterator(), u2 -&gt; core2[u2] &lt; 0 &amp;&amp; out2[u2] &gt; 0);</span>

<span class="fc bfc" id="L256" title="All 4 branches covered.">				} else if (t1InSize != 0 &amp;&amp; t2InSize != 0) {</span>
					/* P(s)=T^{in}_1 (s) \times \{\min T^{in}_2(s)\} */
					/* we use the opposite notation of G1 G2 than what used in the paper (G1 is the smaller graph) */
<span class="fc bfc" id="L259" title="All 4 branches covered.">					nextV1 = IterTools.filter(range(n1).iterator(), u1 -&gt; core1[u1] &lt; 0 &amp;&amp; in1[u1] &gt; 0).nextInt();</span>
<span class="fc bfc" id="L260" title="All 4 branches covered.">					nextV2Iter = IterTools.filter(range(n2).iterator(), u2 -&gt; core2[u2] &lt; 0 &amp;&amp; in2[u2] &gt; 0);</span>

				} else {
					/* P(s)=(N_1 - M_1(s)) \times \{\min (N_2 - M_2)\} */
<span class="fc bfc" id="L264" title="All 2 branches covered.">					nextV1 = IterTools.filter(range(n1).iterator(), u1 -&gt; core1[u1] &lt; 0).nextInt();</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">					nextV2Iter = IterTools.filter(range(n2).iterator(), u2 -&gt; core2[u2] &lt; 0);</span>
				}
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">				assert nextV2Iter.hasNext();</span>
			}
<span class="fc" id="L269">			stateNextV1[stateDepth] = nextV1;</span>
<span class="fc" id="L270">			stateNextV2Iter[stateDepth] = nextV2Iter;</span>
<span class="fc" id="L271">		}</span>

		@Override
		void advance() {
<span class="fc bfc" id="L275" title="All 2 branches covered.">			dfs: while (stateDepth &gt; 0) {</span>
<span class="fc" id="L276">				final int v1 = stateNextV1[stateDepth];</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">				for (IntIterator v2Iter = stateNextV2Iter[stateDepth]; v2Iter.hasNext();) {</span>
<span class="fc" id="L278">					final int v2 = v2Iter.nextInt();</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">					if (!isFeasibleMatchVertices(v1, v2))</span>
<span class="fc" id="L280">						continue;</span>

<span class="fc bfc" id="L282" title="All 2 branches covered.">					if (stateDepth == n1) {</span>
						/* found a valid full matching */
<span class="fc" id="L284">						nextMapping = core1.clone();</span>
<span class="fc" id="L285">						nextMapping[v1] = v2;</span>
<span class="fc" id="L286">						return;</span>
					}
					/* match v1 to v2 and update state */
<span class="fc" id="L289">					core1[v1] = v2;</span>
<span class="fc" id="L290">					core2[v2] = v1;</span>
<span class="fc" id="L291">					stateDepth++;</span>
<span class="fc" id="L292">					updateState(v1, v2);</span>

<span class="fc bfc" id="L294" title="All 2 branches covered.">					if (!isFeasibleCurrentState()) {</span>
<span class="fc" id="L295">						popLastState();</span>
<span class="fc" id="L296">						continue;</span>
					}
					continue dfs;
				}
<span class="fc" id="L300">				popLastState();</span>
<span class="fc" id="L301">			}</span>
<span class="fc" id="L302">			nextMapping = null;</span>
<span class="fc" id="L303">		}</span>

		private boolean isFeasibleMatchVertices(int v1, int v2) {
			/* check custom matcher */
<span class="fc bfc" id="L307" title="All 2 branches covered.">			if (!canMatchVertices(v1, v2))</span>
<span class="fc" id="L308">				return false;</span>

			/*
			 * check that out edges connecting v1 and other mapped vertices of g1 can be mapped to out edges connecting
			 * v2 and other mapped vertices of g2
			 */
<span class="fc" id="L314">			int visitIdx = nextVisitIdx++;</span>
<span class="fc" id="L315">			int edgeCount = 0;</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">			for (IEdgeIter eit = g1.outEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L317">				int e1 = eit.nextInt();</span>
<span class="fc" id="L318">				int w1 = eit.targetInt();</span>
<span class="fc" id="L319">				int w2 = core1[w1];</span>
<span class="fc bfc" id="L320" title="All 4 branches covered.">				if (w2 &lt; 0 &amp;&amp; v1 != w1)</span>
<span class="fc" id="L321">					continue;</span>
<span class="fc" id="L322">				visit[w1] = visitIdx;</span>
<span class="fc" id="L323">				visitData[w1] = e1;</span>
<span class="fc" id="L324">				edgeCount++;</span>

<span class="fc" id="L326">			}</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">			for (IEdgeIter eit = g2.outEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L328">				int e2 = eit.nextInt();</span>
<span class="fc" id="L329">				int w2 = eit.targetInt();</span>
<span class="fc" id="L330">				int w1 = core2[w2];</span>
<span class="fc bfc" id="L331" title="All 4 branches covered.">				if (w1 &lt; 0 &amp;&amp; v2 != w2)</span>
<span class="fc" id="L332">					continue;</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">				if (v2 == w2)</span>
<span class="fc" id="L334">					w1 = v1;</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">				if (visit[w1] == visitIdx) {</span>
<span class="fc" id="L336">					int e1 = visitData[w1];</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">					if (!canMatchEdges(e1, e2))</span>
<span class="fc" id="L338">						return false;</span>
<span class="fc" id="L339">					edgeCount--;</span>

<span class="fc bfc" id="L341" title="All 2 branches covered.">				} else if (inducedSubGraph) {</span>
					/* there is no edge (v1,w1) matching e2 */
<span class="fc" id="L343">					return false;</span>
				}
<span class="fc" id="L345">			}</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">			if (edgeCount != 0)</span>
				/* there are some edges connecting v1 in g1 without match in g2 */
<span class="fc" id="L348">				return false;</span>

			/*
			 * check that in edges connecting v1 and other mapped vertices of g1 can be mapped to in edges connecting v2
			 * and other mapped vertices of g2
			 */
<span class="fc" id="L354">			visitIdx = nextVisitIdx++;</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">			for (IEdgeIter eit = g1.inEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L356">				int e1 = eit.nextInt();</span>
<span class="fc" id="L357">				int u1 = eit.sourceInt();</span>
<span class="fc" id="L358">				int u2 = core1[u1];</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">				if (u2 &lt; 0)</span>
<span class="fc" id="L360">					continue;</span>
<span class="fc" id="L361">				visit[u1] = visitIdx;</span>
<span class="fc" id="L362">				visitData[u1] = e1;</span>
<span class="fc" id="L363">				edgeCount++;</span>
<span class="fc" id="L364">			}</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">			for (IEdgeIter eit = g2.inEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L366">				int e2 = eit.nextInt();</span>
<span class="fc" id="L367">				int u2 = eit.sourceInt();</span>
<span class="fc" id="L368">				int u1 = core2[u2];</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">				if (u1 &lt; 0)</span>
<span class="fc" id="L370">					continue;</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">				if (visit[u1] == visitIdx) {</span>
<span class="fc" id="L372">					int e1 = visitData[u1];</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">					if (!canMatchEdges(e1, e2))</span>
<span class="fc" id="L374">						return false;</span>
<span class="fc" id="L375">					edgeCount--;</span>

<span class="fc bfc" id="L377" title="All 2 branches covered.">				} else if (inducedSubGraph) {</span>
					/* there is no edge (u1,v1) matching e2 */
<span class="fc" id="L379">					return false;</span>
				}
<span class="fc" id="L381">			}</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">			if (edgeCount != 0)</span>
				/* there are some edges connecting v1 in g1 without match in g2 */
<span class="fc" id="L384">				return false;</span>

<span class="fc" id="L386">			return true;</span>
		}

		private boolean isFeasibleCurrentState() {
<span class="fc bfc" id="L390" title="All 2 branches covered.">			if (subGraph) {</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">				if (stateT1OutSize[stateDepth] &gt; stateT2OutSize[stateDepth])</span>
<span class="fc" id="L392">					return false;</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">				if (stateT1InSize[stateDepth] &gt; stateT2InSize[stateDepth])</span>
<span class="fc" id="L394">					return false;</span>
			} else {
<span class="fc bfc" id="L396" title="All 2 branches covered.">				if (stateT1OutSize[stateDepth] != stateT2OutSize[stateDepth])</span>
<span class="fc" id="L397">					return false;</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">				if (stateT1InSize[stateDepth] != stateT2InSize[stateDepth])</span>
<span class="fc" id="L399">					return false;</span>
			}
<span class="fc" id="L401">			return true;</span>
		}

		private void updateState(int v1, int v2) {
<span class="fc" id="L405">			final int depth = stateDepth - 1;</span>
<span class="fc" id="L406">			int t1OutSize = stateT1OutSize[depth];</span>
<span class="fc" id="L407">			int t2OutSize = stateT2OutSize[depth];</span>
<span class="fc" id="L408">			int t1InSize = stateT1InSize[depth];</span>
<span class="fc" id="L409">			int t2InSize = stateT2InSize[depth];</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">			if (in1[v1] == 0) {</span>
<span class="fc" id="L411">				in1[v1] = depth;</span>
			} else {
<span class="fc" id="L413">				t1InSize--;</span>
			}
<span class="fc bfc" id="L415" title="All 2 branches covered.">			if (out1[v1] == 0) {</span>
<span class="fc" id="L416">				out1[v1] = depth;</span>
			} else {
<span class="fc" id="L418">				t1OutSize--;</span>
			}
<span class="fc bfc" id="L420" title="All 2 branches covered.">			if (in2[v2] == 0) {</span>
<span class="fc" id="L421">				in2[v2] = depth;</span>
			} else {
<span class="fc" id="L423">				t2InSize--;</span>
			}
<span class="fc bfc" id="L425" title="All 2 branches covered.">			if (out2[v2] == 0) {</span>
<span class="fc" id="L426">				out2[v2] = depth;</span>
			} else {
<span class="fc" id="L428">				t2OutSize--;</span>
			}
<span class="fc bfc" id="L430" title="All 2 branches covered.">			for (IEdgeIter eit = g1.outEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L431">				eit.nextInt();</span>
<span class="fc" id="L432">				int w = eit.targetInt();</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">				if (out1[w] == 0) {</span>
<span class="fc" id="L434">					out1[w] = depth;</span>
<span class="fc" id="L435">					t1OutSize++;</span>
				}
<span class="fc" id="L437">			}</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">			for (IEdgeIter eit = g1.inEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L439">				eit.nextInt();</span>
<span class="fc" id="L440">				int u = eit.sourceInt();</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">				if (in1[u] == 0) {</span>
<span class="fc" id="L442">					in1[u] = depth;</span>
<span class="fc" id="L443">					t1InSize++;</span>
				}
<span class="fc" id="L445">			}</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">			for (IEdgeIter eit = g2.outEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L447">				eit.nextInt();</span>
<span class="fc" id="L448">				int w = eit.targetInt();</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">				if (out2[w] == 0) {</span>
<span class="fc" id="L450">					out2[w] = depth;</span>
<span class="fc" id="L451">					t2OutSize++;</span>
				}
<span class="fc" id="L453">			}</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">			for (IEdgeIter eit = g2.inEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L455">				eit.nextInt();</span>
<span class="fc" id="L456">				int u = eit.sourceInt();</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">				if (in2[u] == 0) {</span>
<span class="fc" id="L458">					in2[u] = depth;</span>
<span class="fc" id="L459">					t2InSize++;</span>
				}
<span class="fc" id="L461">			}</span>

<span class="fc" id="L463">			newState(v1, v2, t1OutSize, t2OutSize, t1InSize, t2InSize);</span>
<span class="fc" id="L464">		}</span>

		private void popLastState() {
<span class="fc" id="L467">			final int prevV1 = statePrevV1[stateDepth];</span>
<span class="fc" id="L468">			final int prevV2 = statePrevV2[stateDepth];</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">			if (prevV1 &gt;= 0) {</span>
<span class="fc" id="L470">				final int prevDepth = stateDepth - 1;</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">				for (IEdgeIter eit = g1.outEdges(prevV1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L472">					eit.nextInt();</span>
<span class="fc" id="L473">					int w = eit.targetInt();</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">					if (out1[w] == prevDepth)</span>
<span class="fc" id="L475">						out1[w] = 0;</span>
<span class="fc" id="L476">				}</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">				for (IEdgeIter eit = g1.inEdges(prevV1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L478">					eit.nextInt();</span>
<span class="fc" id="L479">					int u = eit.sourceInt();</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">					if (in1[u] == prevDepth)</span>
<span class="fc" id="L481">						in1[u] = 0;</span>
<span class="fc" id="L482">				}</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">				for (IEdgeIter eit = g2.outEdges(prevV2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L484">					eit.nextInt();</span>
<span class="fc" id="L485">					int w = eit.targetInt();</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">					if (out2[w] == prevDepth)</span>
<span class="fc" id="L487">						out2[w] = 0;</span>
<span class="fc" id="L488">				}</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">				for (IEdgeIter eit = g2.inEdges(prevV2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L490">					eit.nextInt();</span>
<span class="fc" id="L491">					int u = eit.sourceInt();</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">					if (in2[u] == prevDepth)</span>
<span class="fc" id="L493">						in2[u] = 0;</span>
<span class="fc" id="L494">				}</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">				if (in1[prevV1] == prevDepth)</span>
<span class="fc" id="L496">					in1[prevV1] = 0;</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">				if (out1[prevV1] == prevDepth)</span>
<span class="fc" id="L498">					out1[prevV1] = 0;</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">				if (in2[prevV2] == prevDepth)</span>
<span class="fc" id="L500">					in2[prevV2] = 0;</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">				if (out2[prevV2] == prevDepth)</span>
<span class="fc" id="L502">					out2[prevV2] = 0;</span>
<span class="fc" id="L503">				core1[prevV1] = None;</span>
<span class="fc" id="L504">				core2[prevV2] = None;</span>
			}
<span class="fc" id="L506">			stateDepth--;</span>
<span class="fc" id="L507">		}</span>
	}

<span class="fc" id="L510">	private static final class IsomorphismIterUndirected extends IsomorphismIterBase {</span>

		private final int[] out1;
		private final int[] out2;

		private final int[] stateT1OutSize;
		private final int[] stateT2OutSize;

		IsomorphismIterUndirected(IndexGraph g1, IndexGraph g2, boolean induced, IntMatcher vertexMatcher,
				IntMatcher edgeMatcher) {
<span class="fc" id="L520">			super(g1, g2, induced, vertexMatcher, edgeMatcher);</span>

<span class="fc" id="L522">			out1 = new int[n1];</span>
<span class="fc" id="L523">			out2 = new int[n2];</span>

<span class="fc" id="L525">			final int maxStateDepth = n1 + 1;</span>
<span class="fc" id="L526">			stateT1OutSize = new int[maxStateDepth];</span>
<span class="fc" id="L527">			stateT2OutSize = new int[maxStateDepth];</span>
<span class="fc" id="L528">			newState(None, None, 0, 0);</span>

<span class="fc" id="L530">			advance();</span>
<span class="fc" id="L531">		}</span>

		private void newState(int v1, int v2, int t1OutSize, int t2OutSize) {
<span class="fc" id="L534">			statePrevV1[stateDepth] = v1;</span>
<span class="fc" id="L535">			statePrevV2[stateDepth] = v2;</span>
<span class="fc" id="L536">			stateT1OutSize[stateDepth] = t1OutSize;</span>
<span class="fc" id="L537">			stateT2OutSize[stateDepth] = t2OutSize;</span>

<span class="pc bpc" id="L539" title="1 of 2 branches missed.">			assert t1OutSize &lt; n1;</span>
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">			assert t2OutSize &lt; n2;</span>
			int nextV1;
			IntIterator nextV2Iter;
			/*
			 * &quot;In case that only one of the in-terminal sets or only one of the out-terminal sets is empty, it can be
			 * demonstrated that the state s cannot be part of a matching, and it is not further explored.&quot; Although
			 * this is stated in the paper, this does not seem to be correct for non-full isomorphism.
			 */
<span class="fc bfc" id="L548" title="All 8 branches covered.">			if (!subGraph &amp;&amp; (t1OutSize == 0 ^ t2OutSize == 0)) {</span>
<span class="fc" id="L549">				nextV1 = None;</span>
<span class="fc" id="L550">				nextV2Iter = IntIterators.EMPTY_ITERATOR;</span>

			} else {
<span class="fc bfc" id="L553" title="All 4 branches covered.">				if (t1OutSize != 0 &amp;&amp; t2OutSize != 0) {</span>
					/* P(s)=T^{out}_1 (s) \times \{\min T^{out}_2(s)\} */
					/* we use the opposite notation of G1 G2 than what used in the paper (G1 is the smaller graph) */
<span class="fc bfc" id="L556" title="All 4 branches covered.">					nextV1 = IterTools.filter(range(n1).iterator(), u1 -&gt; core1[u1] &lt; 0 &amp;&amp; out1[u1] &gt; 0).nextInt();</span>
<span class="fc bfc" id="L557" title="All 4 branches covered.">					nextV2Iter = IterTools.filter(range(n2).iterator(), u2 -&gt; core2[u2] &lt; 0 &amp;&amp; out2[u2] &gt; 0);</span>

				} else {
					/* P(s)=(N_1 - M_1(s)) \times \{\min (N_2 - M_2)\} */
					/* we use the opposite notation of G1 G2 than what used in the paper (G1 is the smaller graph) */
<span class="fc bfc" id="L562" title="All 2 branches covered.">					nextV1 = IterTools.filter(range(n1).iterator(), u1 -&gt; core1[u1] &lt; 0).nextInt();</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">					nextV2Iter = IterTools.filter(range(n2).iterator(), u2 -&gt; core2[u2] &lt; 0);</span>
				}
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">				assert nextV2Iter.hasNext();</span>
			}
<span class="fc" id="L567">			stateNextV1[stateDepth] = nextV1;</span>
<span class="fc" id="L568">			stateNextV2Iter[stateDepth] = nextV2Iter;</span>
<span class="fc" id="L569">		}</span>

		@Override
		void advance() {
<span class="fc bfc" id="L573" title="All 2 branches covered.">			dfs: while (stateDepth &gt; 0) {</span>
<span class="fc" id="L574">				final int v1 = stateNextV1[stateDepth];</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">				for (IntIterator v2Iter = stateNextV2Iter[stateDepth]; v2Iter.hasNext();) {</span>
<span class="fc" id="L576">					final int v2 = v2Iter.nextInt();</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">					if (!isFeasibleMatchVertices(v1, v2))</span>
<span class="fc" id="L578">						continue;</span>

<span class="fc bfc" id="L580" title="All 2 branches covered.">					if (stateDepth == n1) {</span>
						/* found a valid full matching */
<span class="fc" id="L582">						nextMapping = core1.clone();</span>
<span class="fc" id="L583">						nextMapping[v1] = v2;</span>
<span class="fc" id="L584">						return;</span>
					}
					/* match v1 to v2 and update state */
<span class="fc" id="L587">					core1[v1] = v2;</span>
<span class="fc" id="L588">					core2[v2] = v1;</span>
<span class="fc" id="L589">					stateDepth++;</span>
<span class="fc" id="L590">					updateState(v1, v2);</span>

<span class="fc bfc" id="L592" title="All 2 branches covered.">					if (!isFeasibleCurrentState()) {</span>
<span class="fc" id="L593">						popLastState();</span>
<span class="fc" id="L594">						continue;</span>
					}
					continue dfs;
				}
<span class="fc" id="L598">				popLastState();</span>
<span class="fc" id="L599">			}</span>
<span class="fc" id="L600">			nextMapping = null;</span>
<span class="fc" id="L601">		}</span>

		private boolean isFeasibleMatchVertices(int v1, int v2) {
			/* check custom matcher */
<span class="fc bfc" id="L605" title="All 2 branches covered.">			if (!canMatchVertices(v1, v2))</span>
<span class="fc" id="L606">				return false;</span>

			/*
			 * check that out edges connecting v1 and other mapped vertices of g1 can be mapped to out edges connecting
			 * v2 and other mapped vertices of g2
			 */
<span class="fc" id="L612">			int visitIdx = nextVisitIdx++;</span>
<span class="fc" id="L613">			int edgeCount = 0;</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">			for (IEdgeIter eit = g1.outEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L615">				int e1 = eit.nextInt();</span>
<span class="fc" id="L616">				int w1 = eit.targetInt();</span>
<span class="fc" id="L617">				int w2 = core1[w1];</span>
<span class="fc bfc" id="L618" title="All 4 branches covered.">				if (w2 &lt; 0 &amp;&amp; v1 != w1)</span>
<span class="fc" id="L619">					continue;</span>
<span class="fc" id="L620">				visit[w1] = visitIdx;</span>
<span class="fc" id="L621">				visitData[w1] = e1;</span>
<span class="fc" id="L622">				edgeCount++;</span>
<span class="fc" id="L623">			}</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">			for (IEdgeIter eit = g2.outEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L625">				int e2 = eit.nextInt();</span>
<span class="fc" id="L626">				int w2 = eit.targetInt();</span>
<span class="fc" id="L627">				int w1 = core2[w2];</span>
<span class="fc bfc" id="L628" title="All 4 branches covered.">				if (w1 &lt; 0 &amp;&amp; v2 != w2)</span>
<span class="fc" id="L629">					continue;</span>
<span class="fc bfc" id="L630" title="All 2 branches covered.">				if (v2 == w2)</span>
<span class="fc" id="L631">					w1 = v1;</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">				if (visit[w1] == visitIdx) {</span>
<span class="fc" id="L633">					int e1 = visitData[w1];</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">					if (!canMatchEdges(e1, e2))</span>
<span class="fc" id="L635">						return false;</span>
<span class="fc" id="L636">					edgeCount--;</span>

<span class="fc bfc" id="L638" title="All 2 branches covered.">				} else if (inducedSubGraph) {</span>
					/* there is no edge (v1,w1) matching e2 */
<span class="fc" id="L640">					return false;</span>
				}
<span class="fc" id="L642">			}</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">			if (edgeCount != 0)</span>
				/* there are some edges connecting v1 in g1 without match in g2 */
<span class="fc" id="L645">				return false;</span>

<span class="fc" id="L647">			return true;</span>
		}

		private boolean isFeasibleCurrentState() {
<span class="fc bfc" id="L651" title="All 2 branches covered.">			if (subGraph) {</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">				if (stateT1OutSize[stateDepth] &gt; stateT2OutSize[stateDepth])</span>
<span class="fc" id="L653">					return false;</span>
			} else {
<span class="fc bfc" id="L655" title="All 2 branches covered.">				if (stateT1OutSize[stateDepth] != stateT2OutSize[stateDepth])</span>
<span class="fc" id="L656">					return false;</span>
			}
<span class="fc" id="L658">			return true;</span>
		}

		private void updateState(int v1, int v2) {
<span class="fc" id="L662">			final int depth = stateDepth - 1;</span>
<span class="fc" id="L663">			int t1OutSize = stateT1OutSize[depth];</span>
<span class="fc" id="L664">			int t2OutSize = stateT2OutSize[depth];</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">			if (out1[v1] == 0) {</span>
<span class="fc" id="L666">				out1[v1] = depth;</span>
			} else {
<span class="fc" id="L668">				t1OutSize--;</span>
			}
<span class="fc bfc" id="L670" title="All 2 branches covered.">			if (out2[v2] == 0) {</span>
<span class="fc" id="L671">				out2[v2] = depth;</span>
			} else {
<span class="fc" id="L673">				t2OutSize--;</span>
			}
<span class="fc bfc" id="L675" title="All 2 branches covered.">			for (IEdgeIter eit = g1.outEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L676">				eit.nextInt();</span>
<span class="fc" id="L677">				int w = eit.targetInt();</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">				if (out1[w] == 0) {</span>
<span class="fc" id="L679">					out1[w] = depth;</span>
<span class="fc" id="L680">					t1OutSize++;</span>
				}
<span class="fc" id="L682">			}</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">			for (IEdgeIter eit = g2.outEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L684">				eit.nextInt();</span>
<span class="fc" id="L685">				int w = eit.targetInt();</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">				if (out2[w] == 0) {</span>
<span class="fc" id="L687">					out2[w] = depth;</span>
<span class="fc" id="L688">					t2OutSize++;</span>
				}
<span class="fc" id="L690">			}</span>

<span class="fc" id="L692">			newState(v1, v2, t1OutSize, t2OutSize);</span>
<span class="fc" id="L693">		}</span>

		private void popLastState() {
<span class="fc" id="L696">			final int prevV1 = statePrevV1[stateDepth];</span>
<span class="fc" id="L697">			final int prevV2 = statePrevV2[stateDepth];</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">			if (prevV1 &gt;= 0) {</span>
<span class="fc" id="L699">				final int prevDepth = stateDepth - 1;</span>
<span class="fc bfc" id="L700" title="All 2 branches covered.">				for (IEdgeIter eit = g1.outEdges(prevV1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L701">					eit.nextInt();</span>
<span class="fc" id="L702">					int w = eit.targetInt();</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">					if (out1[w] == prevDepth)</span>
<span class="fc" id="L704">						out1[w] = 0;</span>
<span class="fc" id="L705">				}</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">				for (IEdgeIter eit = g2.outEdges(prevV2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L707">					eit.nextInt();</span>
<span class="fc" id="L708">					int w = eit.targetInt();</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">					if (out2[w] == prevDepth)</span>
<span class="fc" id="L710">						out2[w] = 0;</span>
<span class="fc" id="L711">				}</span>
<span class="fc bfc" id="L712" title="All 2 branches covered.">				if (out1[prevV1] == prevDepth)</span>
<span class="fc" id="L713">					out1[prevV1] = 0;</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">				if (out2[prevV2] == prevDepth)</span>
<span class="fc" id="L715">					out2[prevV2] = 0;</span>
<span class="fc" id="L716">				core1[prevV1] = None;</span>
<span class="fc" id="L717">				core2[prevV2] = None;</span>
			}

<span class="fc" id="L720">			stateDepth--;</span>
<span class="fc" id="L721">		}</span>

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>