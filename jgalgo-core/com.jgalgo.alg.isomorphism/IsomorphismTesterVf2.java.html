<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IsomorphismTesterVf2.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.alg.isomorphism</a> &gt; <span class="el_source">IsomorphismTesterVf2.java</span></div><h1>IsomorphismTesterVf2.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.alg.isomorphism;

import static com.jgalgo.internal.util.Range.range;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.NoSuchElementException;
import com.jgalgo.graph.IEdgeIter;
import com.jgalgo.graph.IndexGraph;
import com.jgalgo.internal.util.Assertions;
import com.jgalgo.internal.util.IterTools;
import it.unimi.dsi.fastutil.ints.IntArrays;
import it.unimi.dsi.fastutil.ints.IntIterator;
import it.unimi.dsi.fastutil.ints.IntIterators;
import it.unimi.dsi.fastutil.objects.ObjectIterators;

/**
 * Vf2 algorithm for testing isomorphism of two graphs.
 *
 * &lt;p&gt;
 * Based on 'An Improved Algorithm for Matching Large Graphs' by L. P. Cordella, P. Foggia, C. Sansone and M. Vento. The
 * paper denote the smaller graph as G2 and the bigger graph as G1 in (induced) sub graph isomorphism. We use the
 * opposite notation, which seems more suitable as the returned mapping is from G1 to G2.
 *
 * @author Barak Ugav
 */
<span class="fc" id="L42">public class IsomorphismTesterVf2 extends IsomorphismTesterAbstract {</span>

	/**
	 * Create a new isomorphism algorithm.
	 *
	 * &lt;p&gt;
	 * Please prefer using {@link IsomorphismTester#newInstance()} to get a default implementation for the
	 * {@link IsomorphismTester} interface.
	 */
<span class="fc" id="L51">	public IsomorphismTesterVf2() {}</span>

	@Override
	protected Iterator&lt;IsomorphismIMapping&gt; isomorphicMappingsIter(IndexGraph g1, IndexGraph g2, boolean induced,
			IntMatcher vertexMatcher, IntMatcher edgeMatcher) {
<span class="fc" id="L56">		Assertions.noParallelEdges(g1, &quot;parallel edges are not supported&quot;);</span>
<span class="fc" id="L57">		Assertions.noParallelEdges(g2, &quot;parallel edges are not supported&quot;);</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">		if (g1.isDirected() != g2.isDirected())</span>
<span class="fc" id="L59">			throw new IllegalArgumentException(&quot;directed/undirected graphs mismatch&quot;);</span>

<span class="fc" id="L61">		final int n1 = g1.vertices().size();</span>
<span class="fc" id="L62">		final int n2 = g2.vertices().size();</span>
<span class="fc" id="L63">		final int m1 = g1.edges().size();</span>
<span class="fc" id="L64">		final int m2 = g2.edges().size();</span>

<span class="fc bfc" id="L66" title="All 10 branches covered.">		if (n1 &gt; n2 || m1 &gt; m2 || (n1 == n2 &amp;&amp; m1 != m2 &amp;&amp; induced))</span>
<span class="fc" id="L67">			return Collections.emptyIterator();</span>

<span class="fc bfc" id="L69" title="All 2 branches covered.">		if (n1 == 0) {</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">			assert m1 == 0;</span>
<span class="fc" id="L71">			return ObjectIterators</span>
<span class="fc" id="L72">					.singleton(new IndexMapping(g1, g2, IntArrays.DEFAULT_EMPTY_ARRAY, IntArrays.DEFAULT_EMPTY_ARRAY));</span>
		}

<span class="fc bfc" id="L75" title="All 2 branches covered.">		if (g1.isDirected()) {</span>
<span class="fc" id="L76">			return new IsomorphismIterDirected(g1, g2, induced, vertexMatcher, edgeMatcher);</span>
		} else {
<span class="fc" id="L78">			return new IsomorphismIterUndirected(g1, g2, induced, vertexMatcher, edgeMatcher);</span>
		}
	}

<span class="fc" id="L82">	private abstract static class IsomorphismIterBase implements Iterator&lt;IsomorphismIMapping&gt; {</span>

		final IndexGraph g1;
		final IndexGraph g2;
		final int n1, n2;
		private final IntMatcher vertexMatcher;
		private final IntMatcher edgeMatcher;
		final boolean subGraph;
		final boolean inducedSubGraph;

		final int[] core1;
		final int[] core2;
		int stateDepth;
		final int[] statePrevV1;
		final int[] statePrevV2;
		final int[] stateNextV1;
		final IntIterator[] stateNextV2Iter;

<span class="fc" id="L100">		int nextVisitIdx = 1;</span>
		final int[] visit;
		final int[] visitData;

		int[] nextMapping;

		static final int None = -1;

		IsomorphismIterBase(IndexGraph g1, IndexGraph g2, boolean induced, IntMatcher vertexMatcher,
<span class="fc" id="L109">				IntMatcher edgeMatcher) {</span>
<span class="fc" id="L110">			this.g1 = g1;</span>
<span class="fc" id="L111">			this.g2 = g2;</span>
<span class="fc" id="L112">			n1 = g1.vertices().size();</span>
<span class="fc" id="L113">			n2 = g2.vertices().size();</span>
<span class="fc" id="L114">			this.vertexMatcher = vertexMatcher;</span>
<span class="fc" id="L115">			this.edgeMatcher = edgeMatcher;</span>

<span class="pc bpc" id="L117" title="1 of 2 branches missed.">			assert n1 &lt;= n2;</span>
<span class="fc bfc" id="L118" title="All 4 branches covered.">			subGraph = !induced || n1 &lt; n2;</span>
<span class="fc" id="L119">			inducedSubGraph = induced;</span>

<span class="fc" id="L121">			core1 = new int[n1];</span>
<span class="fc" id="L122">			core2 = new int[n2];</span>
<span class="fc" id="L123">			Arrays.fill(core1, None);</span>
<span class="fc" id="L124">			Arrays.fill(core2, None);</span>

<span class="fc" id="L126">			visit = new int[/* max(n1,n2) */ n2];</span>
<span class="fc" id="L127">			visitData = new int[/* max(n1,n2) */ n2];</span>

<span class="fc" id="L129">			stateDepth = 1;</span>
<span class="fc" id="L130">			final int maxStateDepth = n1 + 1;</span>
<span class="fc" id="L131">			statePrevV1 = new int[maxStateDepth];</span>
<span class="fc" id="L132">			statePrevV2 = new int[maxStateDepth];</span>
<span class="fc" id="L133">			stateNextV1 = new int[maxStateDepth];</span>
<span class="fc" id="L134">			stateNextV2Iter = new IntIterator[maxStateDepth];</span>
<span class="fc" id="L135">		}</span>

		abstract void advance();

		@Override
		public boolean hasNext() {
<span class="fc bfc" id="L141" title="All 2 branches covered.">			if (nextMapping == null)</span>
<span class="fc" id="L142">				advance();</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">			return nextMapping != null;</span>
		}

		@Override
		public IsomorphismIMapping next() {
<span class="fc bfc" id="L148" title="All 2 branches covered.">			if (!hasNext())</span>
<span class="fc" id="L149">				throw new NoSuchElementException();</span>
<span class="fc" id="L150">			IsomorphismIMapping mapping = new IndexMapping(g1, g2, nextMapping, computeEdgeMapping(nextMapping));</span>
<span class="fc" id="L151">			nextMapping = null;</span>
<span class="fc" id="L152">			return mapping;</span>
		}

		private int[] computeEdgeMapping(int[] vMapping) {
<span class="fc" id="L156">			int[] eMapping = new int[g1.edges().size()];</span>

<span class="fc" id="L158">			Arrays.fill(visit, -1);</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">			for (final int u1 : range(g1.vertices().size())) {</span>
<span class="fc" id="L160">				final int u2 = vMapping[u1];</span>
<span class="fc" id="L161">				final int visitIdx = u1;</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">				for (IEdgeIter eit = g1.outEdges(u1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L163">					int e1 = eit.nextInt();</span>
<span class="fc" id="L164">					int v1 = eit.targetInt();</span>
<span class="fc" id="L165">					int v2 = vMapping[v1];</span>
<span class="fc" id="L166">					visit[v2] = visitIdx;</span>
<span class="fc" id="L167">					visitData[v2] = e1;</span>
<span class="fc" id="L168">				}</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">				for (IEdgeIter eit = g2.outEdges(u2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L170">					int e2 = eit.nextInt();</span>
<span class="fc" id="L171">					int v2 = eit.targetInt();</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">					if (visit[v2] == visitIdx) {</span>
<span class="fc" id="L173">						int e1 = visitData[v2];</span>
<span class="fc" id="L174">						eMapping[e1] = e2;</span>
					}
<span class="fc" id="L176">				}</span>
<span class="fc" id="L177">			}</span>
<span class="fc" id="L178">			Arrays.fill(visit, 0);</span>
<span class="fc" id="L179">			nextVisitIdx = 1;</span>

<span class="fc" id="L181">			return eMapping;</span>
		}

		boolean canMatchVertices(int v1, int v2) {
<span class="fc bfc" id="L185" title="All 4 branches covered.">			return vertexMatcher == null || vertexMatcher.isMatch(v1, v2);</span>
		}

		boolean canMatchEdges(int e1, int e2) {
<span class="fc bfc" id="L189" title="All 4 branches covered.">			return edgeMatcher == null || edgeMatcher.isMatch(e1, e2);</span>
		}
	}

<span class="fc" id="L193">	private static class IsomorphismIterDirected extends IsomorphismIterBase {</span>

		private final int[] in1;
		private final int[] in2;
		private final int[] out1;
		private final int[] out2;

		private final int[] stateT1OutSize;
		private final int[] stateT2OutSize;
		private final int[] stateT1InSize;
		private final int[] stateT2InSize;

		IsomorphismIterDirected(IndexGraph g1, IndexGraph g2, boolean induced, IntMatcher vertexMatcher,
				IntMatcher edgeMatcher) {
<span class="fc" id="L207">			super(g1, g2, induced, vertexMatcher, edgeMatcher);</span>

<span class="fc" id="L209">			in1 = new int[n1];</span>
<span class="fc" id="L210">			in2 = new int[n2];</span>
<span class="fc" id="L211">			out1 = new int[n1];</span>
<span class="fc" id="L212">			out2 = new int[n2];</span>

<span class="fc" id="L214">			final int maxStateDepth = n1 + 1;</span>
<span class="fc" id="L215">			stateT1OutSize = new int[maxStateDepth];</span>
<span class="fc" id="L216">			stateT2OutSize = new int[maxStateDepth];</span>
<span class="fc" id="L217">			stateT1InSize = new int[maxStateDepth];</span>
<span class="fc" id="L218">			stateT2InSize = new int[maxStateDepth];</span>
<span class="fc" id="L219">			newState(None, None, 0, 0, 0, 0);</span>

<span class="fc" id="L221">			advance();</span>
<span class="fc" id="L222">		}</span>

		private void newState(int v1, int v2, int t1OutSize, int t2OutSize, int t1InSize, int t2InSize) {
<span class="fc" id="L225">			statePrevV1[stateDepth] = v1;</span>
<span class="fc" id="L226">			statePrevV2[stateDepth] = v2;</span>
<span class="fc" id="L227">			stateT1OutSize[stateDepth] = t1OutSize;</span>
<span class="fc" id="L228">			stateT2OutSize[stateDepth] = t2OutSize;</span>
<span class="fc" id="L229">			stateT1InSize[stateDepth] = t1InSize;</span>
<span class="fc" id="L230">			stateT2InSize[stateDepth] = t2InSize;</span>

<span class="pc bpc" id="L232" title="1 of 2 branches missed.">			assert t1OutSize &lt; n1;</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">			assert t2OutSize &lt; n2;</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">			assert t1InSize &lt; n1;</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">			assert t2InSize &lt; n2;</span>

			int nextV1;
			IntIterator nextV2Iter;
			/*
			 * &quot;In case that only one of the in-terminal sets or only one of the out-terminal sets is empty, it can be
			 * demonstrated that the state s cannot be part of a matching, and it is not further explored.&quot; Although
			 * this is stated in the paper, this does not seem to be correct for non-full isomorphism.
			 */
<span class="fc bfc" id="L244" title="All 14 branches covered.">			if (!subGraph &amp;&amp; ((t1OutSize == 0 ^ t2OutSize == 0) || (t1InSize == 0 ^ t2InSize == 0))) {</span>
<span class="fc" id="L245">				nextV1 = None;</span>
<span class="fc" id="L246">				nextV2Iter = IntIterators.EMPTY_ITERATOR;</span>

			} else {
<span class="fc bfc" id="L249" title="All 4 branches covered.">				if (t1OutSize != 0 &amp;&amp; t2OutSize != 0) {</span>
					/* P(s)=T^{out}_1 (s) \times \{\min T^{out}_2(s)\} */
					/* we use the opposite notation of G1 G2 than what used in the paper (G1 is the smaller graph) */
<span class="fc bfc" id="L252" title="All 4 branches covered.">					nextV1 = IterTools.filter(range(n1).iterator(), u1 -&gt; core1[u1] &lt; 0 &amp;&amp; out1[u1] &gt; 0).nextInt();</span>
<span class="fc bfc" id="L253" title="All 4 branches covered.">					nextV2Iter = IterTools.filter(range(n2).iterator(), u2 -&gt; core2[u2] &lt; 0 &amp;&amp; out2[u2] &gt; 0);</span>

<span class="fc bfc" id="L255" title="All 4 branches covered.">				} else if (t1InSize != 0 &amp;&amp; t2InSize != 0) {</span>
					/* P(s)=T^{in}_1 (s) \times \{\min T^{in}_2(s)\} */
					/* we use the opposite notation of G1 G2 than what used in the paper (G1 is the smaller graph) */
<span class="fc bfc" id="L258" title="All 4 branches covered.">					nextV1 = IterTools.filter(range(n1).iterator(), u1 -&gt; core1[u1] &lt; 0 &amp;&amp; in1[u1] &gt; 0).nextInt();</span>
<span class="fc bfc" id="L259" title="All 4 branches covered.">					nextV2Iter = IterTools.filter(range(n2).iterator(), u2 -&gt; core2[u2] &lt; 0 &amp;&amp; in2[u2] &gt; 0);</span>

				} else {
					/* P(s)=(N_1 - M_1(s)) \times \{\min (N_2 - M_2)\} */
<span class="fc bfc" id="L263" title="All 2 branches covered.">					nextV1 = IterTools.filter(range(n1).iterator(), u1 -&gt; core1[u1] &lt; 0).nextInt();</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">					nextV2Iter = IterTools.filter(range(n2).iterator(), u2 -&gt; core2[u2] &lt; 0);</span>
				}
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">				assert nextV2Iter.hasNext();</span>
			}
<span class="fc" id="L268">			stateNextV1[stateDepth] = nextV1;</span>
<span class="fc" id="L269">			stateNextV2Iter[stateDepth] = nextV2Iter;</span>
<span class="fc" id="L270">		}</span>

		@Override
		void advance() {
<span class="fc bfc" id="L274" title="All 2 branches covered.">			dfs: while (stateDepth &gt; 0) {</span>
<span class="fc" id="L275">				final int v1 = stateNextV1[stateDepth];</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">				for (IntIterator v2Iter = stateNextV2Iter[stateDepth]; v2Iter.hasNext();) {</span>
<span class="fc" id="L277">					final int v2 = v2Iter.nextInt();</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">					if (!isFeasibleMatchVertices(v1, v2))</span>
<span class="fc" id="L279">						continue;</span>

<span class="fc bfc" id="L281" title="All 2 branches covered.">					if (stateDepth == n1) {</span>
						/* found a valid full matching */
<span class="fc" id="L283">						nextMapping = core1.clone();</span>
<span class="fc" id="L284">						nextMapping[v1] = v2;</span>
<span class="fc" id="L285">						return;</span>
					}
					/* match v1 to v2 and update state */
<span class="fc" id="L288">					core1[v1] = v2;</span>
<span class="fc" id="L289">					core2[v2] = v1;</span>
<span class="fc" id="L290">					stateDepth++;</span>
<span class="fc" id="L291">					updateState(v1, v2);</span>

<span class="fc bfc" id="L293" title="All 2 branches covered.">					if (!isFeasibleCurrentState()) {</span>
<span class="fc" id="L294">						popLastState();</span>
<span class="fc" id="L295">						continue;</span>
					}
					continue dfs;
				}
<span class="fc" id="L299">				popLastState();</span>
<span class="fc" id="L300">			}</span>
<span class="fc" id="L301">			nextMapping = null;</span>
<span class="fc" id="L302">		}</span>

		private boolean isFeasibleMatchVertices(int v1, int v2) {
			/* check custom matcher */
<span class="fc bfc" id="L306" title="All 2 branches covered.">			if (!canMatchVertices(v1, v2))</span>
<span class="fc" id="L307">				return false;</span>

			/*
			 * check that out edges connecting v1 and other mapped vertices of g1 can be mapped to out edges connecting
			 * v2 and other mapped vertices of g2
			 */
<span class="fc" id="L313">			int visitIdx = nextVisitIdx++;</span>
<span class="fc" id="L314">			int edgeCount = 0;</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">			for (IEdgeIter eit = g1.outEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L316">				int e1 = eit.nextInt();</span>
<span class="fc" id="L317">				int w1 = eit.targetInt();</span>
<span class="fc" id="L318">				int w2 = core1[w1];</span>
<span class="fc bfc" id="L319" title="All 4 branches covered.">				if (w2 &lt; 0 &amp;&amp; v1 != w1)</span>
<span class="fc" id="L320">					continue;</span>
<span class="fc" id="L321">				visit[w1] = visitIdx;</span>
<span class="fc" id="L322">				visitData[w1] = e1;</span>
<span class="fc" id="L323">				edgeCount++;</span>

<span class="fc" id="L325">			}</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">			for (IEdgeIter eit = g2.outEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L327">				int e2 = eit.nextInt();</span>
<span class="fc" id="L328">				int w2 = eit.targetInt();</span>
<span class="fc" id="L329">				int w1 = core2[w2];</span>
<span class="fc bfc" id="L330" title="All 4 branches covered.">				if (w1 &lt; 0 &amp;&amp; v2 != w2)</span>
<span class="fc" id="L331">					continue;</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">				if (v2 == w2)</span>
<span class="fc" id="L333">					w1 = v1;</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">				if (visit[w1] == visitIdx) {</span>
<span class="fc" id="L335">					int e1 = visitData[w1];</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">					if (!canMatchEdges(e1, e2))</span>
<span class="fc" id="L337">						return false;</span>
<span class="fc" id="L338">					edgeCount--;</span>

<span class="fc bfc" id="L340" title="All 2 branches covered.">				} else if (inducedSubGraph) {</span>
					/* there is no edge (v1,w1) matching e2 */
<span class="fc" id="L342">					return false;</span>
				}
<span class="fc" id="L344">			}</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">			if (edgeCount != 0)</span>
				/* there are some edges connecting v1 in g1 without match in g2 */
<span class="fc" id="L347">				return false;</span>

			/*
			 * check that in edges connecting v1 and other mapped vertices of g1 can be mapped to in edges connecting v2
			 * and other mapped vertices of g2
			 */
<span class="fc" id="L353">			visitIdx = nextVisitIdx++;</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">			for (IEdgeIter eit = g1.inEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L355">				int e1 = eit.nextInt();</span>
<span class="fc" id="L356">				int u1 = eit.sourceInt();</span>
<span class="fc" id="L357">				int u2 = core1[u1];</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">				if (u2 &lt; 0)</span>
<span class="fc" id="L359">					continue;</span>
<span class="fc" id="L360">				visit[u1] = visitIdx;</span>
<span class="fc" id="L361">				visitData[u1] = e1;</span>
<span class="fc" id="L362">				edgeCount++;</span>
<span class="fc" id="L363">			}</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">			for (IEdgeIter eit = g2.inEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L365">				int e2 = eit.nextInt();</span>
<span class="fc" id="L366">				int u2 = eit.sourceInt();</span>
<span class="fc" id="L367">				int u1 = core2[u2];</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">				if (u1 &lt; 0)</span>
<span class="fc" id="L369">					continue;</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">				if (visit[u1] == visitIdx) {</span>
<span class="fc" id="L371">					int e1 = visitData[u1];</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">					if (!canMatchEdges(e1, e2))</span>
<span class="fc" id="L373">						return false;</span>
<span class="fc" id="L374">					edgeCount--;</span>

<span class="fc bfc" id="L376" title="All 2 branches covered.">				} else if (inducedSubGraph) {</span>
					/* there is no edge (u1,v1) matching e2 */
<span class="fc" id="L378">					return false;</span>
				}
<span class="fc" id="L380">			}</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">			if (edgeCount != 0)</span>
				/* there are some edges connecting v1 in g1 without match in g2 */
<span class="fc" id="L383">				return false;</span>

<span class="fc" id="L385">			return true;</span>
		}

		private boolean isFeasibleCurrentState() {
<span class="fc bfc" id="L389" title="All 2 branches covered.">			if (subGraph) {</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">				if (stateT1OutSize[stateDepth] &gt; stateT2OutSize[stateDepth])</span>
<span class="fc" id="L391">					return false;</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">				if (stateT1InSize[stateDepth] &gt; stateT2InSize[stateDepth])</span>
<span class="fc" id="L393">					return false;</span>
			} else {
<span class="fc bfc" id="L395" title="All 2 branches covered.">				if (stateT1OutSize[stateDepth] != stateT2OutSize[stateDepth])</span>
<span class="fc" id="L396">					return false;</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">				if (stateT1InSize[stateDepth] != stateT2InSize[stateDepth])</span>
<span class="fc" id="L398">					return false;</span>
			}
<span class="fc" id="L400">			return true;</span>
		}

		private void updateState(int v1, int v2) {
<span class="fc" id="L404">			final int depth = stateDepth - 1;</span>
<span class="fc" id="L405">			int t1OutSize = stateT1OutSize[depth];</span>
<span class="fc" id="L406">			int t2OutSize = stateT2OutSize[depth];</span>
<span class="fc" id="L407">			int t1InSize = stateT1InSize[depth];</span>
<span class="fc" id="L408">			int t2InSize = stateT2InSize[depth];</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">			if (in1[v1] == 0) {</span>
<span class="fc" id="L410">				in1[v1] = depth;</span>
			} else {
<span class="fc" id="L412">				t1InSize--;</span>
			}
<span class="fc bfc" id="L414" title="All 2 branches covered.">			if (out1[v1] == 0) {</span>
<span class="fc" id="L415">				out1[v1] = depth;</span>
			} else {
<span class="fc" id="L417">				t1OutSize--;</span>
			}
<span class="fc bfc" id="L419" title="All 2 branches covered.">			if (in2[v2] == 0) {</span>
<span class="fc" id="L420">				in2[v2] = depth;</span>
			} else {
<span class="fc" id="L422">				t2InSize--;</span>
			}
<span class="fc bfc" id="L424" title="All 2 branches covered.">			if (out2[v2] == 0) {</span>
<span class="fc" id="L425">				out2[v2] = depth;</span>
			} else {
<span class="fc" id="L427">				t2OutSize--;</span>
			}
<span class="fc bfc" id="L429" title="All 2 branches covered.">			for (IEdgeIter eit = g1.outEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L430">				eit.nextInt();</span>
<span class="fc" id="L431">				int w = eit.targetInt();</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">				if (out1[w] == 0) {</span>
<span class="fc" id="L433">					out1[w] = depth;</span>
<span class="fc" id="L434">					t1OutSize++;</span>
				}
<span class="fc" id="L436">			}</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">			for (IEdgeIter eit = g1.inEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L438">				eit.nextInt();</span>
<span class="fc" id="L439">				int u = eit.sourceInt();</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">				if (in1[u] == 0) {</span>
<span class="fc" id="L441">					in1[u] = depth;</span>
<span class="fc" id="L442">					t1InSize++;</span>
				}
<span class="fc" id="L444">			}</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">			for (IEdgeIter eit = g2.outEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L446">				eit.nextInt();</span>
<span class="fc" id="L447">				int w = eit.targetInt();</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">				if (out2[w] == 0) {</span>
<span class="fc" id="L449">					out2[w] = depth;</span>
<span class="fc" id="L450">					t2OutSize++;</span>
				}
<span class="fc" id="L452">			}</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">			for (IEdgeIter eit = g2.inEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L454">				eit.nextInt();</span>
<span class="fc" id="L455">				int u = eit.sourceInt();</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">				if (in2[u] == 0) {</span>
<span class="fc" id="L457">					in2[u] = depth;</span>
<span class="fc" id="L458">					t2InSize++;</span>
				}
<span class="fc" id="L460">			}</span>

<span class="fc" id="L462">			newState(v1, v2, t1OutSize, t2OutSize, t1InSize, t2InSize);</span>
<span class="fc" id="L463">		}</span>

		private void popLastState() {
<span class="fc" id="L466">			final int prevV1 = statePrevV1[stateDepth];</span>
<span class="fc" id="L467">			final int prevV2 = statePrevV2[stateDepth];</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">			if (prevV1 &gt;= 0) {</span>
<span class="fc" id="L469">				final int prevDepth = stateDepth - 1;</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">				for (IEdgeIter eit = g1.outEdges(prevV1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L471">					eit.nextInt();</span>
<span class="fc" id="L472">					int w = eit.targetInt();</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">					if (out1[w] == prevDepth)</span>
<span class="fc" id="L474">						out1[w] = 0;</span>
<span class="fc" id="L475">				}</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">				for (IEdgeIter eit = g1.inEdges(prevV1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L477">					eit.nextInt();</span>
<span class="fc" id="L478">					int u = eit.sourceInt();</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">					if (in1[u] == prevDepth)</span>
<span class="fc" id="L480">						in1[u] = 0;</span>
<span class="fc" id="L481">				}</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">				for (IEdgeIter eit = g2.outEdges(prevV2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L483">					eit.nextInt();</span>
<span class="fc" id="L484">					int w = eit.targetInt();</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">					if (out2[w] == prevDepth)</span>
<span class="fc" id="L486">						out2[w] = 0;</span>
<span class="fc" id="L487">				}</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">				for (IEdgeIter eit = g2.inEdges(prevV2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L489">					eit.nextInt();</span>
<span class="fc" id="L490">					int u = eit.sourceInt();</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">					if (in2[u] == prevDepth)</span>
<span class="fc" id="L492">						in2[u] = 0;</span>
<span class="fc" id="L493">				}</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">				if (in1[prevV1] == prevDepth)</span>
<span class="fc" id="L495">					in1[prevV1] = 0;</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">				if (out1[prevV1] == prevDepth)</span>
<span class="fc" id="L497">					out1[prevV1] = 0;</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">				if (in2[prevV2] == prevDepth)</span>
<span class="fc" id="L499">					in2[prevV2] = 0;</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">				if (out2[prevV2] == prevDepth)</span>
<span class="fc" id="L501">					out2[prevV2] = 0;</span>
<span class="fc" id="L502">				core1[prevV1] = None;</span>
<span class="fc" id="L503">				core2[prevV2] = None;</span>
			}
<span class="fc" id="L505">			stateDepth--;</span>
<span class="fc" id="L506">		}</span>
	}

<span class="fc" id="L509">	private static class IsomorphismIterUndirected extends IsomorphismIterBase {</span>

		private final int[] out1;
		private final int[] out2;

		private final int[] stateT1OutSize;
		private final int[] stateT2OutSize;

		IsomorphismIterUndirected(IndexGraph g1, IndexGraph g2, boolean induced, IntMatcher vertexMatcher,
				IntMatcher edgeMatcher) {
<span class="fc" id="L519">			super(g1, g2, induced, vertexMatcher, edgeMatcher);</span>

<span class="fc" id="L521">			out1 = new int[n1];</span>
<span class="fc" id="L522">			out2 = new int[n2];</span>

<span class="fc" id="L524">			final int maxStateDepth = n1 + 1;</span>
<span class="fc" id="L525">			stateT1OutSize = new int[maxStateDepth];</span>
<span class="fc" id="L526">			stateT2OutSize = new int[maxStateDepth];</span>
<span class="fc" id="L527">			newState(None, None, 0, 0);</span>

<span class="fc" id="L529">			advance();</span>
<span class="fc" id="L530">		}</span>

		private void newState(int v1, int v2, int t1OutSize, int t2OutSize) {
<span class="fc" id="L533">			statePrevV1[stateDepth] = v1;</span>
<span class="fc" id="L534">			statePrevV2[stateDepth] = v2;</span>
<span class="fc" id="L535">			stateT1OutSize[stateDepth] = t1OutSize;</span>
<span class="fc" id="L536">			stateT2OutSize[stateDepth] = t2OutSize;</span>

<span class="pc bpc" id="L538" title="1 of 2 branches missed.">			assert t1OutSize &lt; n1;</span>
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">			assert t2OutSize &lt; n2;</span>
			int nextV1;
			IntIterator nextV2Iter;
			/*
			 * &quot;In case that only one of the in-terminal sets or only one of the out-terminal sets is empty, it can be
			 * demonstrated that the state s cannot be part of a matching, and it is not further explored.&quot; Although
			 * this is stated in the paper, this does not seem to be correct for non-full isomorphism.
			 */
<span class="fc bfc" id="L547" title="All 8 branches covered.">			if (!subGraph &amp;&amp; (t1OutSize == 0 ^ t2OutSize == 0)) {</span>
<span class="fc" id="L548">				nextV1 = None;</span>
<span class="fc" id="L549">				nextV2Iter = IntIterators.EMPTY_ITERATOR;</span>

			} else {
<span class="fc bfc" id="L552" title="All 4 branches covered.">				if (t1OutSize != 0 &amp;&amp; t2OutSize != 0) {</span>
					/* P(s)=T^{out}_1 (s) \times \{\min T^{out}_2(s)\} */
					/* we use the opposite notation of G1 G2 than what used in the paper (G1 is the smaller graph) */
<span class="fc bfc" id="L555" title="All 4 branches covered.">					nextV1 = IterTools.filter(range(n1).iterator(), u1 -&gt; core1[u1] &lt; 0 &amp;&amp; out1[u1] &gt; 0).nextInt();</span>
<span class="fc bfc" id="L556" title="All 4 branches covered.">					nextV2Iter = IterTools.filter(range(n2).iterator(), u2 -&gt; core2[u2] &lt; 0 &amp;&amp; out2[u2] &gt; 0);</span>

				} else {
					/* P(s)=(N_1 - M_1(s)) \times \{\min (N_2 - M_2)\} */
					/* we use the opposite notation of G1 G2 than what used in the paper (G1 is the smaller graph) */
<span class="fc bfc" id="L561" title="All 2 branches covered.">					nextV1 = IterTools.filter(range(n1).iterator(), u1 -&gt; core1[u1] &lt; 0).nextInt();</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">					nextV2Iter = IterTools.filter(range(n2).iterator(), u2 -&gt; core2[u2] &lt; 0);</span>
				}
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">				assert nextV2Iter.hasNext();</span>
			}
<span class="fc" id="L566">			stateNextV1[stateDepth] = nextV1;</span>
<span class="fc" id="L567">			stateNextV2Iter[stateDepth] = nextV2Iter;</span>
<span class="fc" id="L568">		}</span>

		@Override
		void advance() {
<span class="fc bfc" id="L572" title="All 2 branches covered.">			dfs: while (stateDepth &gt; 0) {</span>
<span class="fc" id="L573">				final int v1 = stateNextV1[stateDepth];</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">				for (IntIterator v2Iter = stateNextV2Iter[stateDepth]; v2Iter.hasNext();) {</span>
<span class="fc" id="L575">					final int v2 = v2Iter.nextInt();</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">					if (!isFeasibleMatchVertices(v1, v2))</span>
<span class="fc" id="L577">						continue;</span>

<span class="fc bfc" id="L579" title="All 2 branches covered.">					if (stateDepth == n1) {</span>
						/* found a valid full matching */
<span class="fc" id="L581">						nextMapping = core1.clone();</span>
<span class="fc" id="L582">						nextMapping[v1] = v2;</span>
<span class="fc" id="L583">						return;</span>
					}
					/* match v1 to v2 and update state */
<span class="fc" id="L586">					core1[v1] = v2;</span>
<span class="fc" id="L587">					core2[v2] = v1;</span>
<span class="fc" id="L588">					stateDepth++;</span>
<span class="fc" id="L589">					updateState(v1, v2);</span>

<span class="fc bfc" id="L591" title="All 2 branches covered.">					if (!isFeasibleCurrentState()) {</span>
<span class="fc" id="L592">						popLastState();</span>
<span class="fc" id="L593">						continue;</span>
					}
					continue dfs;
				}
<span class="fc" id="L597">				popLastState();</span>
<span class="fc" id="L598">			}</span>
<span class="fc" id="L599">			nextMapping = null;</span>
<span class="fc" id="L600">		}</span>

		private boolean isFeasibleMatchVertices(int v1, int v2) {
			/* check custom matcher */
<span class="fc bfc" id="L604" title="All 2 branches covered.">			if (!canMatchVertices(v1, v2))</span>
<span class="fc" id="L605">				return false;</span>

			/*
			 * check that out edges connecting v1 and other mapped vertices of g1 can be mapped to out edges connecting
			 * v2 and other mapped vertices of g2
			 */
<span class="fc" id="L611">			int visitIdx = nextVisitIdx++;</span>
<span class="fc" id="L612">			int edgeCount = 0;</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">			for (IEdgeIter eit = g1.outEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L614">				int e1 = eit.nextInt();</span>
<span class="fc" id="L615">				int w1 = eit.targetInt();</span>
<span class="fc" id="L616">				int w2 = core1[w1];</span>
<span class="fc bfc" id="L617" title="All 4 branches covered.">				if (w2 &lt; 0 &amp;&amp; v1 != w1)</span>
<span class="fc" id="L618">					continue;</span>
<span class="fc" id="L619">				visit[w1] = visitIdx;</span>
<span class="fc" id="L620">				visitData[w1] = e1;</span>
<span class="fc" id="L621">				edgeCount++;</span>
<span class="fc" id="L622">			}</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">			for (IEdgeIter eit = g2.outEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L624">				int e2 = eit.nextInt();</span>
<span class="fc" id="L625">				int w2 = eit.targetInt();</span>
<span class="fc" id="L626">				int w1 = core2[w2];</span>
<span class="fc bfc" id="L627" title="All 4 branches covered.">				if (w1 &lt; 0 &amp;&amp; v2 != w2)</span>
<span class="fc" id="L628">					continue;</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">				if (v2 == w2)</span>
<span class="fc" id="L630">					w1 = v1;</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">				if (visit[w1] == visitIdx) {</span>
<span class="fc" id="L632">					int e1 = visitData[w1];</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">					if (!canMatchEdges(e1, e2))</span>
<span class="fc" id="L634">						return false;</span>
<span class="fc" id="L635">					edgeCount--;</span>

<span class="fc bfc" id="L637" title="All 2 branches covered.">				} else if (inducedSubGraph) {</span>
					/* there is no edge (v1,w1) matching e2 */
<span class="fc" id="L639">					return false;</span>
				}
<span class="fc" id="L641">			}</span>
<span class="fc bfc" id="L642" title="All 2 branches covered.">			if (edgeCount != 0)</span>
				/* there are some edges connecting v1 in g1 without match in g2 */
<span class="fc" id="L644">				return false;</span>

<span class="fc" id="L646">			return true;</span>
		}

		private boolean isFeasibleCurrentState() {
<span class="fc bfc" id="L650" title="All 2 branches covered.">			if (subGraph) {</span>
<span class="fc bfc" id="L651" title="All 2 branches covered.">				if (stateT1OutSize[stateDepth] &gt; stateT2OutSize[stateDepth])</span>
<span class="fc" id="L652">					return false;</span>
			} else {
<span class="fc bfc" id="L654" title="All 2 branches covered.">				if (stateT1OutSize[stateDepth] != stateT2OutSize[stateDepth])</span>
<span class="fc" id="L655">					return false;</span>
			}
<span class="fc" id="L657">			return true;</span>
		}

		private void updateState(int v1, int v2) {
<span class="fc" id="L661">			final int depth = stateDepth - 1;</span>
<span class="fc" id="L662">			int t1OutSize = stateT1OutSize[depth];</span>
<span class="fc" id="L663">			int t2OutSize = stateT2OutSize[depth];</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">			if (out1[v1] == 0) {</span>
<span class="fc" id="L665">				out1[v1] = depth;</span>
			} else {
<span class="fc" id="L667">				t1OutSize--;</span>
			}
<span class="fc bfc" id="L669" title="All 2 branches covered.">			if (out2[v2] == 0) {</span>
<span class="fc" id="L670">				out2[v2] = depth;</span>
			} else {
<span class="fc" id="L672">				t2OutSize--;</span>
			}
<span class="fc bfc" id="L674" title="All 2 branches covered.">			for (IEdgeIter eit = g1.outEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L675">				eit.nextInt();</span>
<span class="fc" id="L676">				int w = eit.targetInt();</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">				if (out1[w] == 0) {</span>
<span class="fc" id="L678">					out1[w] = depth;</span>
<span class="fc" id="L679">					t1OutSize++;</span>
				}
<span class="fc" id="L681">			}</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">			for (IEdgeIter eit = g2.outEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L683">				eit.nextInt();</span>
<span class="fc" id="L684">				int w = eit.targetInt();</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">				if (out2[w] == 0) {</span>
<span class="fc" id="L686">					out2[w] = depth;</span>
<span class="fc" id="L687">					t2OutSize++;</span>
				}
<span class="fc" id="L689">			}</span>

<span class="fc" id="L691">			newState(v1, v2, t1OutSize, t2OutSize);</span>
<span class="fc" id="L692">		}</span>

		private void popLastState() {
<span class="fc" id="L695">			final int prevV1 = statePrevV1[stateDepth];</span>
<span class="fc" id="L696">			final int prevV2 = statePrevV2[stateDepth];</span>
<span class="fc bfc" id="L697" title="All 2 branches covered.">			if (prevV1 &gt;= 0) {</span>
<span class="fc" id="L698">				final int prevDepth = stateDepth - 1;</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">				for (IEdgeIter eit = g1.outEdges(prevV1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L700">					eit.nextInt();</span>
<span class="fc" id="L701">					int w = eit.targetInt();</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">					if (out1[w] == prevDepth)</span>
<span class="fc" id="L703">						out1[w] = 0;</span>
<span class="fc" id="L704">				}</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">				for (IEdgeIter eit = g2.outEdges(prevV2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L706">					eit.nextInt();</span>
<span class="fc" id="L707">					int w = eit.targetInt();</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">					if (out2[w] == prevDepth)</span>
<span class="fc" id="L709">						out2[w] = 0;</span>
<span class="fc" id="L710">				}</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">				if (out1[prevV1] == prevDepth)</span>
<span class="fc" id="L712">					out1[prevV1] = 0;</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">				if (out2[prevV2] == prevDepth)</span>
<span class="fc" id="L714">					out2[prevV2] = 0;</span>
<span class="fc" id="L715">				core1[prevV1] = None;</span>
<span class="fc" id="L716">				core2[prevV2] = None;</span>
			}

<span class="fc" id="L719">			stateDepth--;</span>
<span class="fc" id="L720">		}</span>

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>