<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MinimumCostFlowAbstractBasedSourceSink.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.alg.flow</a> &gt; <span class="el_source">MinimumCostFlowAbstractBasedSourceSink.java</span></div><h1>MinimumCostFlowAbstractBasedSourceSink.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.alg.flow;

import static com.jgalgo.internal.util.Range.range;
import java.util.List;
import java.util.Objects;
import com.jgalgo.graph.EdgeSet;
import com.jgalgo.graph.IWeightFunction;
import com.jgalgo.graph.IWeightFunctionInt;
import com.jgalgo.graph.IndexGraph;
import com.jgalgo.graph.IndexGraphBuilder;
import com.jgalgo.graph.WeightFunction;
import com.jgalgo.internal.util.Assertions;
import it.unimi.dsi.fastutil.doubles.DoubleArrayList;
import it.unimi.dsi.fastutil.doubles.DoubleList;
import it.unimi.dsi.fastutil.ints.IntArrayList;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntList;

/**
 * Abstract class for computing a minimum cost flow in a graph, based on a source-sink solution.
 *
 * &lt;p&gt;
 * The {@link MinimumCostFlow} interface expose a large number of methods of different variants of the minimum cost flow
 * problem. This abstract class implements some of these methods by reducing to a single source-sink problem,
 * {@link #computeMinCostMaxFlow(IndexGraph, IWeightFunction, IWeightFunction, int, int)}, which is left to the
 * subclasses to implement.
 *
 * @author Barak Ugav
 */
<span class="fc" id="L45">public abstract class MinimumCostFlowAbstractBasedSourceSink extends MinimumCostFlows.AbstractImpl {</span>

	/**
	 * Default constructor.
	 */
<span class="fc" id="L50">	public MinimumCostFlowAbstractBasedSourceSink() {}</span>

	@Override
	protected IFlow computeMinCostMaxFlow(IndexGraph gOrig, IWeightFunction capacityOrig, IWeightFunction costOrig,
			IntCollection sources, IntCollection sinks) {
<span class="fc" id="L55">		Assertions.onlyDirected(gOrig);</span>

<span class="fc" id="L57">		final boolean integerFlow = WeightFunction.isInteger(capacityOrig);</span>
<span class="fc" id="L58">		final boolean integerCost = WeightFunction.isInteger(costOrig);</span>

<span class="fc" id="L60">		IndexGraphBuilder builder = IndexGraphBuilder.directed();</span>
<span class="fc" id="L61">		builder.ensureVertexCapacity(gOrig.vertices().size() + 2);</span>
<span class="fc" id="L62">		builder.ensureEdgeCapacity(gOrig.edges().size() + sources.size() + sinks.size());</span>

		/* Add all original vertices and edges */
<span class="fc" id="L65">		builder.addVertices(gOrig.vertices());</span>
<span class="fc" id="L66">		builder.addEdges(EdgeSet.allOf(gOrig));</span>
		/* any edge with index smaller than this threshold is an original edge of the graph */
<span class="fc" id="L68">		final int origEdgesThreshold = builder.edges().size();</span>

		/* Add two artificial terminal vertices, a source and a sink */
<span class="fc" id="L71">		final int source = builder.addVertexInt();</span>
<span class="fc" id="L72">		final int sink = builder.addVertexInt();</span>

		/* Connect the source to the sources with high capacity edges */
		/* Connect the sinks to the sink with high capacity edges */
		Object capacities;
<span class="fc bfc" id="L77" title="All 2 branches covered.">		if (integerFlow) {</span>
<span class="fc" id="L78">			IWeightFunctionInt capacityOrigInt = (IWeightFunctionInt) capacityOrig;</span>
<span class="fc" id="L79">			int[] capacities0 = new int[sources.size() + sinks.size()];</span>
<span class="fc" id="L80">			int capIdx = 0;</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">			for (int s : sources) {</span>
<span class="fc" id="L82">				builder.addEdge(source, s);</span>
<span class="fc" id="L83">				capacities0[capIdx++] = Flows.vertexMaxSupply(gOrig, capacityOrigInt, s);</span>
<span class="fc" id="L84">			}</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">			for (int t : sinks) {</span>
<span class="fc" id="L86">				builder.addEdge(t, sink);</span>
<span class="fc" id="L87">				capacities0[capIdx++] = Flows.vertexMaxDemand(gOrig, capacityOrigInt, t);</span>
<span class="fc" id="L88">			}</span>
<span class="fc" id="L89">			capacities = capacities0;</span>
<span class="fc" id="L90">		} else {</span>
<span class="fc" id="L91">			double[] capacities0 = new double[sources.size() + sinks.size()];</span>
<span class="fc" id="L92">			int capIdx = 0;</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">			for (int s : sources) {</span>
<span class="fc" id="L94">				builder.addEdge(source, s);</span>
<span class="fc" id="L95">				capacities0[capIdx++] = Flows.vertexMaxSupply(gOrig, capacityOrig, s);</span>
<span class="fc" id="L96">			}</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">			for (int t : sinks) {</span>
<span class="fc" id="L98">				builder.addEdge(t, sink);</span>
<span class="fc" id="L99">				capacities0[capIdx++] = Flows.vertexMaxDemand(gOrig, capacityOrig, t);</span>
<span class="fc" id="L100">			}</span>
<span class="fc" id="L101">			capacities = capacities0;</span>
		}

<span class="fc" id="L104">		IndexGraph g = builder.build();</span>

		/*
		 * Create a network for the new graph by storing capacities and flows of the artificial edges and by reducing
		 * the capacities of edges by their lower bound
		 */
		IWeightFunction capacity;
<span class="fc bfc" id="L111" title="All 2 branches covered.">		if (integerFlow) {</span>
<span class="fc" id="L112">			IWeightFunctionInt capacityOrigInt = (IWeightFunctionInt) capacityOrig;</span>
<span class="fc" id="L113">			int[] caps = (int[]) capacities;</span>
<span class="fc" id="L114">			IWeightFunctionInt capacityInt =</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">					e -&gt; e &lt; origEdgesThreshold ? capacityOrigInt.weightInt(e) : caps[e - origEdgesThreshold];</span>
<span class="fc" id="L116">			capacity = capacityInt;</span>
<span class="fc" id="L117">		} else {</span>
<span class="fc" id="L118">			double[] caps = (double[]) capacities;</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">			capacity = e -&gt; e &lt; origEdgesThreshold ? capacityOrig.weight(e) : caps[e - origEdgesThreshold];</span>
		}

		IWeightFunction cost;
<span class="fc bfc" id="L123" title="All 2 branches covered.">		if (integerCost) {</span>
<span class="fc" id="L124">			IWeightFunctionInt costOrigInt = (IWeightFunctionInt) costOrig;</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">			IWeightFunctionInt costInt = e -&gt; e &lt; origEdgesThreshold ? costOrigInt.weightInt(e) : 0;</span>
<span class="fc" id="L126">			cost = costInt;</span>
<span class="fc" id="L127">		} else {</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">			cost = e -&gt; e &lt; origEdgesThreshold ? costOrig.weight(e) : 0;</span>
		}

		/* Compute a min-cost max-flow in the new graph and network */
<span class="fc" id="L132">		IFlow flow0 = computeMinCostMaxFlow(g, capacity, cost, source, sink);</span>
<span class="fc" id="L133">		double[] flow = new double[gOrig.edges().size()];</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">		for (int e : range(gOrig.edges().size()))</span>
<span class="fc" id="L135">			flow[e] = flow0.getFlow(e);</span>
<span class="fc" id="L136">		return newFlow(gOrig, flow);</span>
	}

	@Override
	protected IFlow computeMinCostMaxFlow(IndexGraph gOrig, IWeightFunction capacityOrig, IWeightFunction costOrig,
			IWeightFunction lowerBound, IntCollection sources, IntCollection sinks) {
<span class="fc" id="L142">		Objects.requireNonNull(gOrig);</span>
<span class="fc" id="L143">		Objects.requireNonNull(capacityOrig);</span>
<span class="fc" id="L144">		Objects.requireNonNull(costOrig);</span>
<span class="fc" id="L145">		Objects.requireNonNull(lowerBound);</span>

<span class="fc" id="L147">		Assertions.onlyDirected(gOrig);</span>
<span class="fc" id="L148">		Assertions.flowCheckLowerBound(gOrig, capacityOrig, lowerBound);</span>

<span class="pc bpc" id="L150" title="1 of 4 branches missed.">		final boolean integerFlow = WeightFunction.isInteger(capacityOrig) &amp;&amp; WeightFunction.isInteger(lowerBound);</span>
<span class="fc" id="L151">		final boolean integerCost = WeightFunction.isInteger(costOrig);</span>

		/*
		 * To solve the problem of minimum-cost maximum-flow between a set of sources and sinks, with a flow lower bound
		 * for each edge, we perform a reduction to min-cost max-flow between a single source and a sink sink without
		 * lower bounds. To get rid of the lower bound, remove from each edge capacity its lower bound, and add/remove
		 * supply from the edge endpoints. This reduction is slightly more complicated than the others, as some vertices
		 * (the sources/sinks) require 'infinite' supply, while others (other vertices with supply) require finite
		 * supply. We create a new graph with all the vertices and edges of the original graph, with addition of a new
		 * source and sink, and connect the source to the sources with high capacity edges, the source to vertices with
		 * a positive supply with capacity equal to the supply, the sinks to the sink with high capacity edges and
		 * lastly the vertices with negative supply to the sink with capacity equal to the supply.
		 */

		/* For each edge with lower bound add/remove supply to the edge endpoints */
<span class="fc" id="L166">		IWeightFunction supply = computeSupply(gOrig, capacityOrig, lowerBound, null);</span>

<span class="fc" id="L168">		IndexGraphBuilder builder = IndexGraphBuilder.directed();</span>
<span class="fc" id="L169">		builder.ensureVertexCapacity(gOrig.vertices().size() + 2);</span>
<span class="fc" id="L170">		builder.ensureEdgeCapacity(gOrig.edges().size() + sources.size() + sinks.size() + gOrig.vertices().size());</span>

		/* Add all original vertices and edges */
<span class="fc" id="L173">		builder.addVertices(gOrig.vertices());</span>
<span class="fc" id="L174">		builder.addEdges(EdgeSet.allOf(gOrig));</span>
		/* any edge with index smaller than this threshold is an original edge of the graph */
<span class="fc" id="L176">		final int origEdgesThreshold = builder.edges().size();</span>

		/* determine a great enough capacity ('infinite') for edges to sources (from sinks) */

		/* Add two artificial terminal vertices, a source and a sink */
<span class="fc" id="L181">		final int source = builder.addVertexInt();</span>
<span class="fc" id="L182">		final int sink = builder.addVertexInt();</span>

		/* Connect the source to the sources with high capacity edges */
		/* Connect the sinks to the sink with high capacity edges */
		final List&lt;?&gt; capacities;
<span class="fc bfc" id="L187" title="All 2 branches covered.">		if (integerFlow) {</span>
<span class="fc" id="L188">			IWeightFunctionInt capacityOrigInt = (IWeightFunctionInt) capacityOrig;</span>
<span class="fc" id="L189">			IntList capacities0 = new IntArrayList(sources.size() + sinks.size());</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">			for (int s : sources) {</span>
<span class="fc" id="L191">				builder.addEdge(source, s);</span>
<span class="fc" id="L192">				capacities0.add(Flows.vertexMaxSupply(gOrig, capacityOrigInt, s));</span>
<span class="fc" id="L193">			}</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">			for (int t : sinks) {</span>
<span class="fc" id="L195">				builder.addEdge(t, sink);</span>
<span class="fc" id="L196">				capacities0.add(Flows.vertexMaxDemand(gOrig, capacityOrigInt, t));</span>
<span class="fc" id="L197">			}</span>
<span class="fc" id="L198">			capacities = capacities0;</span>
<span class="fc" id="L199">		} else {</span>
<span class="fc" id="L200">			DoubleList capacities0 = new DoubleArrayList(sources.size() + sinks.size());</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">			for (int s : sources) {</span>
<span class="fc" id="L202">				builder.addEdge(source, s);</span>
<span class="fc" id="L203">				capacities0.add(Flows.vertexMaxSupply(gOrig, capacityOrig, s));</span>
<span class="fc" id="L204">			}</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">			for (int t : sinks) {</span>
<span class="fc" id="L206">				builder.addEdge(t, sink);</span>
<span class="fc" id="L207">				capacities0.add(Flows.vertexMaxDemand(gOrig, capacityOrig, t));</span>
<span class="fc" id="L208">			}</span>
<span class="fc" id="L209">			capacities = capacities0;</span>
		}
		/*
		 * Any edge with index smaller than this threshold and equal or greater than origEdgesThreshold is an edge
		 * connect source-sources or sinks-sink. Any edge with index greater or equal to this threshold is an edge
		 * connecting a source to a vertex with positive supply or a vertex with negative supply to a sink.
		 */
<span class="fc" id="L216">		final int sourcesSinksThreshold = builder.edges().size();</span>

		/*
		 * Connect the source to all vertices with positive supply and the vertices with negative supply to the sink
		 */
<span class="fc bfc" id="L221" title="All 2 branches covered.">		if (integerFlow) {</span>
<span class="fc" id="L222">			IWeightFunctionInt supplyInt = (IWeightFunctionInt) supply;</span>
<span class="fc" id="L223">			IntList capacities0 = (IntList) capacities;</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">			for (int v : range(gOrig.vertices().size())) {</span>
<span class="fc" id="L225">				int sup = supplyInt.weightInt(v);</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">				if (sup &gt; 0) {</span>
<span class="fc" id="L227">					builder.addEdge(source, v);</span>
<span class="fc" id="L228">					capacities0.add(sup);</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">				} else if (sup &lt; 0) {</span>
<span class="fc" id="L230">					builder.addEdge(v, sink);</span>
<span class="fc" id="L231">					capacities0.add(-sup);</span>
				}
<span class="fc" id="L233">			}</span>
<span class="fc" id="L234">		} else {</span>
<span class="fc" id="L235">			DoubleList capacities0 = (DoubleList) capacities;</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">			for (int v : range(gOrig.vertices().size())) {</span>
<span class="fc" id="L237">				double sup = supply.weight(v);</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">				if (sup &gt; 0) {</span>
<span class="fc" id="L239">					builder.addEdge(source, v);</span>
<span class="fc" id="L240">					capacities0.add(sup);</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">				} else if (sup &lt; 0) {</span>
<span class="fc" id="L242">					builder.addEdge(v, sink);</span>
<span class="fc" id="L243">					capacities0.add(-sup);</span>
				}
<span class="fc" id="L245">			}</span>
		}

<span class="fc" id="L248">		IndexGraph g = builder.build();</span>

		/*
		 * Create a network for the new graph by storing capacities and flows of the artificial edges and by reducing
		 * the capacities of edges by their lower bound
		 */
		IWeightFunction capacity;
<span class="fc bfc" id="L255" title="All 2 branches covered.">		if (integerFlow) {</span>
<span class="fc" id="L256">			IWeightFunctionInt capacityOrigInt = (IWeightFunctionInt) capacityOrig;</span>
<span class="fc" id="L257">			IWeightFunctionInt lowerBoundInt = (IWeightFunctionInt) lowerBound;</span>
<span class="fc" id="L258">			int[] caps = ((IntArrayList) capacities).elements();</span>
<span class="fc" id="L259">			IWeightFunctionInt capacityInt =</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">					edge -&gt; edge &lt; origEdgesThreshold ? capacityOrigInt.weightInt(edge) - lowerBoundInt.weightInt(edge)</span>
<span class="fc" id="L261">							: caps[edge - origEdgesThreshold];</span>
<span class="fc" id="L262">			capacity = capacityInt;</span>
<span class="fc" id="L263">		} else {</span>
<span class="fc" id="L264">			double[] caps = ((DoubleArrayList) capacities).elements();</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">			capacity = edge -&gt; edge &lt; origEdgesThreshold ? capacityOrig.weight(edge) - lowerBound.weight(edge)</span>
<span class="fc" id="L266">					: caps[edge - origEdgesThreshold];</span>
		}

		IWeightFunction cost;
<span class="fc bfc" id="L270" title="All 2 branches covered.">		if (integerCost) {</span>
			/*
			 * Create a cost function for the new graph: original edges have their original costs, big negative cost for
			 * edges that connect vertices with supply as we must satisfy them, and zero cost for edges connecting
			 * source-sources or sinks-sink
			 */
<span class="fc" id="L276">			IWeightFunctionInt costOrigInt = (IWeightFunctionInt) costOrig;</span>
<span class="fc" id="L277">			final int supplyEdgeCost = -hugeCost(gOrig, costOrigInt);</span>
<span class="fc" id="L278">			IWeightFunctionInt costInt = e -&gt; {</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">				if (e &lt; origEdgesThreshold)</span>
<span class="fc" id="L280">					return costOrigInt.weightInt(e); /* original edge */</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">				if (e &lt; sourcesSinksThreshold)</span>
<span class="fc" id="L282">					return 0; /* edge to source/sink */</span>
<span class="fc" id="L283">				return supplyEdgeCost; /* edge to a non source/sink vertex with non-zero supply */</span>
			};
<span class="fc" id="L285">			cost = costInt;</span>
<span class="fc" id="L286">		} else {</span>
			/*
			 * Create a cost function for the new graph: original edges have their original costs, big negative cost for
			 * edges that connect vertices with supply as we must satisfy them, and zero cost for edges connecting
			 * source-sources or sinks-sink
			 */
<span class="fc" id="L292">			final double supplyEdgeCost = -hugeCost(gOrig, costOrig);</span>
<span class="fc" id="L293">			cost = e -&gt; {</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">				if (e &lt; origEdgesThreshold)</span>
<span class="fc" id="L295">					return costOrig.weight(e); /* original edge */</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">				if (e &lt; sourcesSinksThreshold)</span>
<span class="fc" id="L297">					return 0; /* edge to source/sink */</span>
<span class="fc" id="L298">				return supplyEdgeCost; /* edge to a non source/sink vertex with non-zero supply */</span>
			};
		}

		/* Compute a min-cost max-flow in the new graph and network */
<span class="fc" id="L303">		IFlow flow0 = computeMinCostMaxFlow(g, capacity, cost, source, sink);</span>

		/* assert all supply was provided */
<span class="fc" id="L306">		double eps = range(sourcesSinksThreshold, g.edges().size())</span>
<span class="fc" id="L307">				.mapToDouble(capacity::weight)</span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">				.filter(c -&gt; c &gt; 0)</span>
<span class="fc" id="L309">				.min()</span>
<span class="fc" id="L310">				.orElse(0);</span>
<span class="pc" id="L311">		assert range(sourcesSinksThreshold, g.edges().size())</span>
<span class="pc bpc" id="L312" title="2 of 4 branches missed.">				.allMatch(e -&gt; Math.abs(flow0.getFlow(e) - capacity.weight(e)) &lt; eps);</span>

<span class="fc" id="L314">		double[] flow = new double[gOrig.edges().size()];</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">		for (int e : range(gOrig.edges().size()))</span>
<span class="fc" id="L316">			flow[e] = flow0.getFlow(e) + lowerBound.weight(e);</span>
<span class="fc" id="L317">		return newFlow(gOrig, flow);</span>
	}

	@Override
	protected IFlow computeMinCostFlow(IndexGraph gOrig, IWeightFunction capacityOrig, IWeightFunction costOrig,
			IWeightFunction supply) {
<span class="fc" id="L323">		Assertions.onlyDirected(gOrig);</span>
<span class="fc" id="L324">		Assertions.flowCheckSupply(gOrig, supply);</span>
<span class="fc" id="L325">		capacityOrig = IWeightFunction.replaceNullWeightFunc(capacityOrig);</span>
<span class="fc" id="L326">		costOrig = IWeightFunction.replaceNullWeightFunc(costOrig);</span>
<span class="fc" id="L327">		supply = IWeightFunction.replaceNullWeightFunc(supply);</span>

<span class="pc bpc" id="L329" title="1 of 4 branches missed.">		final boolean integerFlow = WeightFunction.isInteger(capacityOrig) &amp;&amp; WeightFunction.isInteger(supply);</span>
<span class="fc" id="L330">		final boolean integerCost = WeightFunction.isInteger(costOrig);</span>

		/*
		 * To solve the minimum cost flow of given supply we use a reduction to minimum-cost maximum-flow between two
		 * terminal vertices, source and sink. We add an edge from the source to each vertex with positive supply with
		 * capacity equal to the supply, and an edge from each vertex with negative supply to the sink with capacity
		 * equal to the supply.
		 */

<span class="fc" id="L339">		IndexGraphBuilder builder = IndexGraphBuilder.directed();</span>
<span class="fc" id="L340">		builder.ensureVertexCapacity(gOrig.vertices().size() + 2);</span>
<span class="fc" id="L341">		builder.ensureEdgeCapacity(gOrig.edges().size() + gOrig.vertices().size());</span>

		/* Add all original vertices and edges */
<span class="fc" id="L344">		builder.addVertices(gOrig.vertices());</span>
<span class="fc" id="L345">		builder.addEdges(EdgeSet.allOf(gOrig));</span>
		/* any edge with index greater than this threshold is not an original edge of the graph */
<span class="fc" id="L347">		final int origEdgesThreshold = builder.edges().size();</span>

		/* Add two artificial vertices, source and sink */
<span class="fc" id="L350">		final int source = builder.addVertexInt();</span>
<span class="fc" id="L351">		final int sink = builder.addVertexInt();</span>

		/* Connect the source to vertices with positive supply and vertices with negative supply to the sink */
		List&lt;?&gt; capacities;
<span class="fc bfc" id="L355" title="All 2 branches covered.">		if (integerFlow) {</span>
<span class="fc" id="L356">			IWeightFunctionInt supplyInt = (IWeightFunctionInt) supply;</span>
<span class="fc" id="L357">			IntList capacities0 = new IntArrayList();</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">			for (int v : range(gOrig.vertices().size())) {</span>
<span class="fc" id="L359">				int sup = supplyInt.weightInt(v);</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">				if (sup &gt; 0) {</span>
<span class="fc" id="L361">					builder.addEdge(source, v);</span>
<span class="fc" id="L362">					capacities0.add(sup);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">				} else if (sup &lt; 0) {</span>
<span class="fc" id="L364">					builder.addEdge(v, sink);</span>
<span class="fc" id="L365">					capacities0.add(-sup);</span>
				}
<span class="fc" id="L367">			}</span>
<span class="fc" id="L368">			capacities = capacities0;</span>
<span class="fc" id="L369">		} else {</span>
<span class="fc" id="L370">			DoubleList capacities0 = new DoubleArrayList();</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">			for (int v : range(gOrig.vertices().size())) {</span>
<span class="fc" id="L372">				double sup = supply.weight(v);</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">				if (sup &gt; 0) {</span>
<span class="fc" id="L374">					builder.addEdge(source, v);</span>
<span class="fc" id="L375">					capacities0.add(sup);</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">				} else if (sup &lt; 0) {</span>
<span class="fc" id="L377">					builder.addEdge(v, sink);</span>
<span class="fc" id="L378">					capacities0.add(-sup);</span>
				}
<span class="fc" id="L380">			}</span>
<span class="fc" id="L381">			capacities = capacities0;</span>
		}

<span class="fc" id="L384">		IndexGraph g = builder.build();</span>

		/*
		 * Create a network for the new graph by using two new arrays for the artificial edges capacities and flows
		 */
		IWeightFunction capacity;
<span class="fc bfc" id="L390" title="All 2 branches covered.">		if (integerFlow) {</span>
<span class="fc" id="L391">			IWeightFunctionInt capacityOrigInt = (IWeightFunctionInt) capacityOrig;</span>
<span class="fc" id="L392">			int[] caps = ((IntArrayList) capacities).elements();</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">			IWeightFunctionInt capacityInt = edge -&gt; edge &lt; origEdgesThreshold ? capacityOrigInt.weightInt(edge)</span>
<span class="fc" id="L394">					: caps[edge - origEdgesThreshold];</span>
<span class="fc" id="L395">			capacity = capacityInt;</span>
<span class="fc" id="L396">		} else {</span>
<span class="fc" id="L397">			double[] caps = ((DoubleArrayList) capacities).elements();</span>
<span class="fc" id="L398">			IWeightFunction capacityOrig0 = capacityOrig;</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">			capacity = edge -&gt; edge &lt; origEdgesThreshold ? capacityOrig0.weight(edge) : caps[edge - origEdgesThreshold];</span>
		}

		/*
		 * All the artificial edges should not have a cost, if its possible to satisfy the supply they will be saturated
		 * anyway
		 */
		IWeightFunction cost;
<span class="fc bfc" id="L407" title="All 2 branches covered.">		if (integerCost) {</span>
<span class="fc" id="L408">			IWeightFunctionInt costOrigInt = (IWeightFunctionInt) costOrig;</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">			IWeightFunctionInt costInt = e -&gt; e &lt; origEdgesThreshold ? costOrigInt.weightInt(e) : 0;</span>
<span class="fc" id="L410">			cost = costInt;</span>
<span class="fc" id="L411">		} else {</span>
<span class="fc" id="L412">			IWeightFunction costOrig0 = costOrig;</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">			cost = e -&gt; e &lt; origEdgesThreshold ? costOrig0.weight(e) : 0;</span>
		}

		/* Compute a minimum-cost maximum-flow between the two artificial vertices */
<span class="fc" id="L417">		IFlow flow0 = computeMinCostMaxFlow(g, capacity, cost, source, sink);</span>
<span class="fc" id="L418">		double[] flow = new double[gOrig.edges().size()];</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">		for (int e : range(gOrig.edges().size()))</span>
<span class="fc" id="L420">			flow[e] = flow0.getFlow(e);</span>
<span class="fc" id="L421">		return newFlow(gOrig, flow);</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>