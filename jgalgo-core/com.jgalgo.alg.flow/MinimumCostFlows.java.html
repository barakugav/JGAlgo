<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MinimumCostFlows.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.alg.flow</a> &gt; <span class="el_source">MinimumCostFlows.java</span></div><h1>MinimumCostFlows.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.alg.flow;

import static com.jgalgo.internal.util.Range.range;
import java.util.Objects;
import com.jgalgo.graph.Graphs;
import com.jgalgo.graph.IWeightFunction;
import com.jgalgo.graph.IWeightFunctionInt;
import com.jgalgo.graph.IWeights;
import com.jgalgo.graph.IWeightsDouble;
import com.jgalgo.graph.IWeightsInt;
import com.jgalgo.graph.IndexGraph;
import com.jgalgo.graph.WeightFunction;
import com.jgalgo.internal.util.Assertions;
import com.jgalgo.internal.util.Fastutil;

class MinimumCostFlows {

	private MinimumCostFlows() {}

	abstract static class AbstractImpl extends MinimumCostFlowAbstract {

		/**
		 * Default constructor.
		 */
<span class="fc" id="L40">		public AbstractImpl() {}</span>

		@Override
		protected IFlow computeMinCostMaxFlow(IndexGraph g, IWeightFunction capacity, IWeightFunction cost,
				IWeightFunction lowerBound, int source, int sink) {
<span class="fc" id="L45">			Objects.requireNonNull(lowerBound);</span>
<span class="fc" id="L46">			return computeMinCostMaxFlow(g, capacity, cost, lowerBound, Fastutil.list(source), Fastutil.list(sink));</span>
		}

		@Override
		protected IFlow computeMinCostFlow(IndexGraph g, IWeightFunction capacityOrig, IWeightFunction cost,
				IWeightFunction lowerBound, IWeightFunction supply) {
<span class="fc" id="L52">			Assertions.onlyDirected(g);</span>
<span class="fc" id="L53">			Assertions.flowCheckLowerBound(g, capacityOrig, lowerBound);</span>
<span class="fc" id="L54">			Assertions.flowCheckSupply(g, supply);</span>
<span class="fc" id="L55">			capacityOrig = IWeightFunction.replaceNullWeightFunc(capacityOrig);</span>
<span class="fc" id="L56">			cost = IWeightFunction.replaceNullWeightFunc(cost);</span>

<span class="pc bpc" id="L58" title="1 of 4 branches missed.">			final boolean integerFlow = WeightFunction.isInteger(capacityOrig) &amp;&amp; WeightFunction.isInteger(lowerBound);</span>

			/*
			 * To solve the minimum cost flow for a given supply and edges lower bounds, we perform a reduction to the
			 * problem with given supply without any edges flow lower bounds. For each edge with lower bound we subtract
			 * the lower bound from the capacity of the edge, and add/remove supply to the edge endpoints.
			 */

			/* Create a network by subtracting the lower bound from each edge capacity */
			IWeightFunction capacity;
<span class="fc bfc" id="L68" title="All 2 branches covered.">			if (integerFlow) {</span>
<span class="fc" id="L69">				IWeightFunctionInt capacityOrigInt = (IWeightFunctionInt) capacityOrig;</span>
<span class="fc" id="L70">				IWeightFunctionInt lowerBoundInt = (IWeightFunctionInt) lowerBound;</span>
<span class="fc" id="L71">				IWeightFunctionInt capacityInt =</span>
<span class="fc" id="L72">						edge -&gt; capacityOrigInt.weightInt(edge) - lowerBoundInt.weightInt(edge);</span>
<span class="fc" id="L73">				capacity = capacityInt;</span>
<span class="fc" id="L74">			} else {</span>
<span class="fc" id="L75">				IWeightFunction capacityOrig0 = capacityOrig;</span>
<span class="fc" id="L76">				IWeightFunction lowerBound0 = lowerBound;</span>
<span class="fc" id="L77">				capacity = edge -&gt; capacityOrig0.weight(edge) - lowerBound0.weight(edge);</span>
			}

			/* For each edge with lower bound we add/remove supply from the end endpoints */
<span class="fc" id="L81">			IWeightFunction supply2 = computeSupply(g, capacityOrig, lowerBound, supply);</span>

			/* Solve the reduction problem with only supply without edges lower bounds */
<span class="fc" id="L84">			IFlow flow0 = computeMinCostFlow(g, capacity, cost, supply2);</span>
<span class="fc" id="L85">			double[] flow = new double[g.edges().size()];</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">			for (int e : range(g.edges().size()))</span>
<span class="fc" id="L87">				flow[e] = flow0.getFlow(e) + lowerBound.weight(e);</span>
<span class="fc" id="L88">			return newFlow(g, flow);</span>
		}

		static double hugeCost(IndexGraph g, IWeightFunction cost) {
<span class="fc bfc" id="L92" title="All 2 branches covered.">			if (WeightFunction.isInteger(cost))</span>
<span class="fc" id="L93">				return hugeCostLong(g, (IWeightFunctionInt) cost);</span>

<span class="fc" id="L95">			double costSum = 0;</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">			for (int e : range(g.edges().size()))</span>
<span class="fc" id="L97">				costSum += Math.abs(cost.weight(e));</span>
<span class="fc" id="L98">			return 1 + costSum;</span>
		}

		static int hugeCost(IndexGraph g, IWeightFunctionInt cost) {
<span class="fc" id="L102">			long costSum = hugeCostLong(g, cost);</span>
<span class="fc" id="L103">			int costSumInt = (int) costSum;</span>
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">			if (costSum != costSumInt)</span>
<span class="nc" id="L105">				throw new AssertionError(&quot;integer overflow, huge cost can't fit in 32bit int&quot;);</span>
<span class="fc" id="L106">			return costSumInt;</span>
		}

		private static long hugeCostLong(IndexGraph g, IWeightFunctionInt cost) {
<span class="fc" id="L110">			long costSum = 0;</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">			for (int e : range(g.edges().size()))</span>
<span class="fc" id="L112">				costSum += Math.abs(cost.weightInt(e));</span>
<span class="fc" id="L113">			return costSum + 1;</span>
		}

		static IWeightFunction computeSupply(IndexGraph g, IWeightFunction capacity, IWeightFunction lowerBound,
				IWeightFunction supply) {
<span class="fc" id="L118">			boolean isInt = WeightFunction.isInteger(capacity);</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">			if (lowerBound != null)</span>
<span class="pc bpc" id="L120" title="1 of 4 branches missed.">				isInt = isInt &amp;&amp; WeightFunction.isInteger(lowerBound);</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">			if (supply != null)</span>
<span class="pc bpc" id="L122" title="1 of 4 branches missed.">				isInt = isInt &amp;&amp; WeightFunction.isInteger(lowerBound);</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">			if (isInt)</span>
<span class="fc" id="L124">				return computeSupply(g, (IWeightFunctionInt) capacity, (IWeightFunctionInt) lowerBound,</span>
						(IWeightFunctionInt) supply);

<span class="fc" id="L127">			IWeightsDouble supply2 = IWeights.createExternalVerticesWeights(g, double.class);</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">			if (supply != null) {</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">				for (int v : range(g.vertices().size()))</span>
<span class="fc" id="L130">					supply2.set(v, supply.weight(v));</span>
			}
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">			if (lowerBound != null) {</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">				for (int e : range(g.edges().size())) {</span>
<span class="fc" id="L134">					double l = lowerBound.weight(e);</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">					if (l == 0)</span>
<span class="fc" id="L136">						continue;</span>
<span class="fc" id="L137">					int u = g.edgeSource(e), v = g.edgeTarget(e);</span>
<span class="fc" id="L138">					supply2.set(u, supply2.get(u) - l);</span>
<span class="fc" id="L139">					supply2.set(v, supply2.get(v) + l);</span>
<span class="fc" id="L140">				}</span>
			}
<span class="fc" id="L142">			return supply2;</span>
		}

		static IWeightFunctionInt computeSupply(IndexGraph g, IWeightFunctionInt capacity,
				IWeightFunctionInt lowerBound, IWeightFunctionInt supply) {
<span class="fc" id="L147">			IWeightsInt supply2 = IWeights.createExternalVerticesWeights(g, int.class);</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">			if (supply != null) {</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">				for (int v : range(g.vertices().size()))</span>
<span class="fc" id="L150">					supply2.set(v, supply.weightInt(v));</span>
			}
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">			if (lowerBound != null) {</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">				for (int e : range(g.edges().size())) {</span>
<span class="fc" id="L154">					int l = lowerBound.weightInt(e);</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">					if (l == 0)</span>
<span class="fc" id="L156">						continue;</span>
<span class="fc" id="L157">					int u = g.edgeSource(e), v = g.edgeTarget(e);</span>
<span class="fc" id="L158">					supply2.set(u, supply2.get(u) - l);</span>
<span class="fc" id="L159">					supply2.set(v, supply2.get(v) + l);</span>
<span class="fc" id="L160">				}</span>
			}
<span class="fc" id="L162">			return supply2;</span>
		}

	}

	static void saturateNegativeCostSelfEdges(IndexGraph g, IWeightFunction capacity, IWeightFunction cost,
			double[] flow) {
<span class="fc bfc" id="L169" title="All 2 branches covered.">		if (!g.isAllowSelfEdges())</span>
<span class="fc" id="L170">			return;</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">		if (WeightFunction.isInteger(capacity)) {</span>
<span class="fc" id="L172">			IWeightFunctionInt capacityInt = (IWeightFunctionInt) capacity;</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">			if (WeightFunction.isInteger(cost)) {</span>
<span class="fc" id="L174">				IWeightFunctionInt costInt = (IWeightFunctionInt) cost;</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">				for (int e : Graphs.selfEdges(g))</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">					if (costInt.weightInt(e) &lt; 0)</span>
<span class="fc" id="L177">						flow[e] = capacityInt.weightInt(e);</span>
<span class="fc" id="L178">			} else {</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">				for (int e : Graphs.selfEdges(g))</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">					if (cost.weight(e) &lt; 0)</span>
<span class="nc" id="L181">						flow[e] = capacityInt.weightInt(e);</span>
			}
<span class="fc" id="L183">		} else {</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">			if (WeightFunction.isInteger(cost)) {</span>
<span class="nc" id="L185">				IWeightFunctionInt costInt = (IWeightFunctionInt) cost;</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">				for (int e : Graphs.selfEdges(g))</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">					if (costInt.weightInt(e) &lt; 0)</span>
<span class="nc" id="L188">						flow[e] = capacity.weight(e);</span>
<span class="nc" id="L189">			} else {</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">				for (int e : Graphs.selfEdges(g))</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">					if (cost.weight(e) &lt; 0)</span>
<span class="fc" id="L192">						flow[e] = capacity.weight(e);</span>
			}
		}
<span class="fc" id="L195">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>