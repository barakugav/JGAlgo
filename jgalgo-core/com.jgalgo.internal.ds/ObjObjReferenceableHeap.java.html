<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ObjObjReferenceableHeap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.internal.ds</a> &gt; <span class="el_source">ObjObjReferenceableHeap.java</span></div><h1>ObjObjReferenceableHeap.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jgalgo.internal.ds;

import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import com.jgalgo.internal.util.JGAlgoUtils;
import java.util.Comparator;

/**
 * A collection which maintains elements in order and support efficient retrieval of the minimum value, and expose
 * references to the underling elements.
 *
 * &lt;p&gt;
 * In addition to the regular Heap operations, the user can obtain a {@linkplain ObjObjReferenceableHeap.Ref
 * reference} to each inserted element via the return value of the {@link #insert(Object)} function. The reference will
 * be valid as long as the element is still in the heap. By passing the reference to the heap implementation to
 * functions such as {@link #decreaseKey(ObjObjReferenceableHeap.Ref, Object)} or
 * {@link #remove(ObjObjReferenceableHeap.Ref, Object)} the heap implementation can perform the operations efficiently as is
 * does not need to search for the element.
 *
 * &lt;p&gt;
 * Another difference from the regular Heap, is the existent of both keys and values, rather than just 'elements'. A key
 * may be changed using {@link #decreaseKey(ObjObjReferenceableHeap.Ref, Object)} while the &lt;b&gt;value&lt;/b&gt; is the same.
 * This matches the common use case of these heaps.
 *
 * &lt;p&gt;
 * Use {@link #newInstance()} to get a default implementation of this interface.
 *
 * &lt;pre&gt; {@code
 * IntObjReferenceableHeap&lt;Integer, String&gt; heap = IntObjReferenceableHeap.newInstance();
 * IntObjReferenceableHeap.Ref&lt;String&gt; r1 = heap.insert(5, &quot;Alice&quot;);
 * IntObjReferenceableHeap.Ref&lt;String&gt; r2 = heap.insert(10, &quot;Bob&quot;);
 * IntObjReferenceableHeap.Ref&lt;String&gt; r3 = heap.insert(3, &quot;Charlie&quot;);
 *
 * assert heap.findMin() == r3;
 * assert r2.key() == 10;
 * heap.decreaseKey(r2, 2);
 * assert r2.key() == 2;
 * assert r2.value().equals(&quot;Bob&quot;);
 * assert heap.findMin() == r2;
 *
 * heap.remove(r1);
 * assert heap.size() == 2;
 * }&lt;/pre&gt;
 *
 * @param  &lt;K&gt; the keys type
 * @param  &lt;V&gt; the values type
 * @author     Barak Ugav
 */
public interface ObjObjReferenceableHeap &lt;K, V&gt; extends ReferenceableHeap, Iterable&lt;ObjObjReferenceableHeap.Ref &lt;K, V&gt;&gt; {

	/**
	 * Insert a new element to the heap with {@code null} value.
	 *
	 * &lt;p&gt;
	 * Only a key is passed to this method, and a {@code null} value (or {@code 0} if values are primitive) will be
	 * used. To insert a new element with both a key and a value use {@link #insert(Object)}.
	 *
	 * @param  key the key of the new element
	 * @return     reference to the new element
	 */
	ObjObjReferenceableHeap.Ref &lt;K, V&gt; insert(K key);

	/**
	 * Insert a new element to the heap with both key and value.
	 *
	 * @param  key   the key of the new element
	 * @param  value the value of the new element
	 * @return       reference to the new element
	 */
	default ObjObjReferenceableHeap.Ref &lt;K, V&gt; insert(K key, V value) {
<span class="fc" id="L87">		ObjObjReferenceableHeap.Ref &lt;K, V&gt; ref = insert(key);</span>
<span class="fc" id="L88">		ref.setValue(value);</span>
<span class="fc" id="L89">		return ref;</span>
	}

	/**
	 * Find the element with the minimal key in the heap and return a reference to it.
	 *
	 * @return                       a reference to the element with the minimal key in the heap
	 * @throws IllegalStateException if the heap is empty
	 */
	ObjObjReferenceableHeap.Ref &lt;K, V&gt; findMin();

	/**
	 * Extract the element with the minimal key in the heap.
	 *
	 * &lt;p&gt;
	 * This method find and &lt;b&gt;remove&lt;/b&gt; the element with the minimal key.
	 *
	 * @return                       the element with the minimal key in the heap
	 * @throws IllegalStateException if the heap is empty
	 */
	ObjObjReferenceableHeap.Ref &lt;K, V&gt; extractMin();

	/**
	 * Meld with another heap.
	 *
	 * &lt;p&gt;
	 * Melding is performed by adding all elements of the given heap to this heap, and clearing the given heap. Some
	 * implementations support efficient melding due to internal structures used to maintain the heap elements.
	 *
	 * &lt;p&gt;
	 * Its only possible to meld with a heap with the same implementation of this heap.
	 *
	 * &lt;p&gt;
	 * After the melding, the references of both ({@code this} and the given {@code heap}) remain valid and its possible
	 * to use them only in this heap (they are no longer valid with respect to the given heap, which will be cleared).
	 *
	 * @param  heap                     a heap to meld with. After the operation it will be empty.
	 * @throws IllegalArgumentException if the given heap is {@code this} heap, or its of another implementation
	 */
	void meld(ObjObjReferenceableHeap &lt;K, V&gt; heap);

	/**
	 * Returns the comparator used to order the element's keys in this heap, or {@code null} if this heap uses the
	 * {@linkplain Comparable natural ordering} of its keys.
	 *
	 * @return the comparator used to order the element's keys in this heap, or {@code null} if this heap uses the
	 *         natural ordering of its keys
	 */
	Comparator &lt;K&gt; comparator();

	/**
	 * Find an element by its key in the heap and get a reference to it.
	 *
	 * &lt;p&gt;
	 * Note that this method uses the comparator of the heap to determine if two keys are equal, rather than
	 * {@link Object#equals(Object)} or primitive comparison for primitive types.
	 *
	 * @param  key a key
	 * @return     a reference to an element with the given key or {@code null} if such element was not found
	 */
	default ObjObjReferenceableHeap.Ref &lt;K, V&gt; find(K key) {
<span class="fc" id="L150">		Comparator &lt;K&gt; c = comparator();</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">		if (c == null) {</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">			for (ObjObjReferenceableHeap.Ref &lt;K, V&gt; p : this) {</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">				if (JGAlgoUtils.cmpDefault(key, p.key()) == 0)</span>
<span class="fc" id="L154">					return p;</span>
<span class="fc" id="L155">			}</span>
		} else {
<span class="fc bfc" id="L157" title="All 2 branches covered.">			for (ObjObjReferenceableHeap.Ref &lt;K, V&gt; p : this) {</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">				if (c.compare(key, p.key()) == 0)</span>
<span class="fc" id="L159">					return p;</span>
<span class="fc" id="L160">			}</span>
		}
<span class="fc" id="L162">		return null;</span>
	}

	/**
	 * Decrease the key of an element in the heap.
	 *
	 * &lt;p&gt;
	 * This method behavior is undefined if the reference is not valid, namely if it refer to an element already
	 * removed, or to an element in another heap.
	 *
	 * @param  ref                      reference to an inserted element
	 * @param  newKey                   a new key
	 * @throws IllegalArgumentException if the new key is greater than the previous key
	 */
	void decreaseKey(ObjObjReferenceableHeap.Ref &lt;K, V&gt; ref, K newKey);

	/**
	 * Increase the key of an element in the heap.
	 *
	 * &lt;p&gt;
	 * This method behavior is undefined if the reference is not valid, namely if it refer to an element already
	 * removed, or to an element in another heap.
	 *
	 * @param  ref                      reference to an inserted element
	 * @param  newKey                   a new key
	 * @throws IllegalArgumentException if the new key is smaller than the previous key
	 */
	void increaseKey(ObjObjReferenceableHeap.Ref &lt;K, V&gt; ref, K newKey);

	/**
	 * Remove an element from the heap by its reference.
	 *
	 * &lt;p&gt;
	 * This method behavior is undefined if the reference is not valid, namely if it refer to an element already
	 * removed, or to an element in another heap.
	 *
	 * @param ref a reference to an inserted element
	 */
	void remove(ObjObjReferenceableHeap.Ref &lt;K, V&gt; ref);

	/**
	 * Get a stream over the elements in this heap.
	 *
	 * @return a stream over the elements in this heap
	 */
	default Stream&lt;ObjObjReferenceableHeap.Ref &lt;K, V&gt;&gt; stream() {
<span class="fc" id="L208">		return StreamSupport.stream(spliterator(), false);</span>
	}

	/**
	 * A reference to an element in a {@linkplain ObjObjReferenceableHeap referenceable heap}.
	 *
	 * @param  &lt;K&gt; the keys type
	 * @param  &lt;V&gt; the values type
	 * @author Barak Ugav
	 */
	static interface Ref &lt;K, V&gt; {

		/**
		* Get the key of this element.
		*
		* &lt;p&gt;
		* There is no {@code setKey} method, but the key of an element can be changed (decrease only) by
		* {@link ObjObjReferenceableHeap#decreaseKey(ObjObjReferenceableHeap.Ref, Object)}.
		*
		* @return the element's key
		*/
		K key();

		/**
		* Get the value of this element.
		*
		* @return the element's key
		*/
		V value();

		/**
		* Set the value of this element.
		*
		* @param val new value for this element
		*/
		void setValue(V val);
	}

	/**
	 * Get an instance of this interface with the default implementation.
	 *
	 * @param  &lt;K&gt; the keys type
	 * @param  &lt;V&gt; the values type
	 * @return an instance of this interface with the default implementation
	 */
	static &lt;K, V&gt; ObjObjReferenceableHeap &lt;K, V&gt; newInstance() {
<span class="fc" id="L254">		return newInstance(null);</span>
	}

	/**
	 * Get an instance of this interface with the default implementation and custom comparator.
	 *
	 * @param  &lt;K&gt; the keys type
	 * @param  &lt;V&gt; the values type
	 * @param c a comparator to use for ordering the elements in the heap
	 * @return an instance of this interface with the default implementation
	 */
	static &lt;K, V&gt; ObjObjReferenceableHeap &lt;K, V&gt; newInstance(Comparator &lt;K&gt; c) {
<span class="fc" id="L266">		return new ObjObjPairingHeap &lt;&gt; (c);</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>