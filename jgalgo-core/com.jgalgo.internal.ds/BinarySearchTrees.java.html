<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BinarySearchTrees.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.internal.ds</a> &gt; <span class="el_source">BinarySearchTrees.java</span></div><h1>BinarySearchTrees.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.internal.ds;

import java.util.Iterator;
import java.util.function.BiConsumer;
import com.jgalgo.internal.util.Assertions;

<span class="fc" id="L22">class BinarySearchTrees {</span>

	private BinarySearchTrees() {}

<span class="fc" id="L26">	static enum NeighborType {</span>
<span class="fc" id="L27">		None {</span>
			@Override
			&lt;NodeT extends Node&lt;NodeT&gt;&gt; NodeT onLeftChildMissing(NodeT p) {
<span class="fc" id="L30">				return null;</span>
			}

			@Override
			&lt;NodeT extends Node&lt;NodeT&gt;&gt; NodeT onRightChildMissing(NodeT p) {
<span class="fc" id="L35">				return null;</span>
			}
		},
<span class="fc" id="L38">		Predecessor {</span>
			@Override
			&lt;NodeT extends Node&lt;NodeT&gt;&gt; NodeT onLeftChildMissing(NodeT p) {
<span class="fc" id="L41">				return BinarySearchTrees.getPredecessor(p);</span>
			}

			@Override
			&lt;NodeT extends Node&lt;NodeT&gt;&gt; NodeT onRightChildMissing(NodeT p) {
<span class="fc" id="L46">				return p;</span>
			}
		},
<span class="fc" id="L49">		Successor {</span>
			@Override
			&lt;NodeT extends Node&lt;NodeT&gt;&gt; NodeT onLeftChildMissing(NodeT p) {
<span class="fc" id="L52">				return p;</span>
			}

			@Override
			&lt;NodeT extends Node&lt;NodeT&gt;&gt; NodeT onRightChildMissing(NodeT p) {
<span class="fc" id="L57">				return BinarySearchTrees.getSuccessor(p);</span>
			}
		};

		abstract &lt;NodeT extends Node&lt;NodeT&gt;&gt; NodeT onLeftChildMissing(NodeT p);

		abstract &lt;NodeT extends Node&lt;NodeT&gt;&gt; NodeT onRightChildMissing(NodeT p);
	}

	static &lt;NodeT extends Node&lt;NodeT&gt;&gt; NodeT findMin(NodeT root) {
<span class="fc" id="L67">		for (NodeT p = root;; p = p.left)</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">			if (!p.hasLeftChild())</span>
<span class="fc" id="L69">				return p;</span>
	}

	static &lt;NodeT extends Node&lt;NodeT&gt;&gt; NodeT findMax(NodeT root) {
<span class="fc" id="L73">		for (NodeT p = root;; p = p.right)</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">			if (!p.hasRightChild())</span>
<span class="fc" id="L75">				return p;</span>
	}

	static &lt;NodeT extends Node&lt;NodeT&gt;&gt; NodeT getPredecessor(NodeT n) {
<span class="fc" id="L79">		return getPredecessorInSubtree(n, null);</span>
	}

	private static &lt;NodeT extends Node&lt;NodeT&gt;&gt; NodeT getPredecessorInSubtree(NodeT n, NodeT subtreeRoot) {
		/* predecessor in left sub tree */
<span class="fc bfc" id="L84" title="All 2 branches covered.">		if (n.hasLeftChild())</span>
<span class="fc" id="L85">			return findMax(n.left);</span>

		/* predecessor is some ancestor */
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">		NodeT subtreeParent = subtreeRoot != null ? subtreeRoot.parent : null;</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">		for (NodeT p = n; p.parent != subtreeParent; p = p.parent)</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">			if (p.isRightChild())</span>
<span class="fc" id="L91">				return p.parent;</span>
<span class="fc" id="L92">		return null;</span>
	}

	static &lt;NodeT extends Node&lt;NodeT&gt;&gt; NodeT getSuccessor(NodeT n) {
<span class="fc" id="L96">		return getSuccessorInSubtree(n, null);</span>
	}

	private static &lt;NodeT extends Node&lt;NodeT&gt;&gt; NodeT getSuccessorInSubtree(NodeT n, NodeT subtreeRoot) {
		/* successor in right sub tree */
<span class="fc bfc" id="L101" title="All 2 branches covered.">		if (n.hasRightChild())</span>
<span class="fc" id="L102">			return findMin(n.right);</span>

		/* successor is some ancestor */
<span class="fc bfc" id="L105" title="All 2 branches covered.">		NodeT subtreeParent = subtreeRoot != null ? subtreeRoot.parent : null;</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">		for (NodeT p = n; p.parent != subtreeParent; p = p.parent)</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">			if (p.isLeftChild())</span>
<span class="fc" id="L108">				return p.parent;</span>
<span class="fc" id="L109">		return null;</span>
	}

	static &lt;NodeT extends Node&lt;NodeT&gt;&gt; void clear(NodeT root) {
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">		if (root == null)</span>
<span class="nc" id="L114">			return;</span>
<span class="fc" id="L115">		for (NodeT p = root;;) {</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">			if (p.hasLeftChild()) {</span>
<span class="fc" id="L117">				p = p.left;</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">			} else if (p.hasRightChild()) {</span>
<span class="fc" id="L119">				p = p.right;</span>
			} else {
<span class="fc" id="L121">				NodeT parent = p.parent;</span>
<span class="fc" id="L122">				p.clear();</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">				if (parent == null)</span>
<span class="fc" id="L124">					return;</span>
<span class="fc" id="L125">				p = parent;</span>
<span class="fc" id="L126">			}</span>
		}
	}

	static &lt;NodeT extends Node&lt;NodeT&gt;&gt; void swap(NodeT n1, NodeT n2) {
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">		if (n2 == n1.parent) {</span>
<span class="nc" id="L132">			NodeT temp = n1;</span>
<span class="nc" id="L133">			n1 = n2;</span>
<span class="nc" id="L134">			n2 = temp;</span>
		}
<span class="fc bfc" id="L136" title="All 2 branches covered.">		if (n1.isLeftChild()) {</span>
<span class="fc" id="L137">			n1.parent.left = n2;</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">		} else if (n1.isRightChild()) {</span>
<span class="fc" id="L139">			n1.parent.right = n2;</span>
		}
<span class="fc" id="L141">		BiConsumer&lt;NodeT, NodeT&gt; setLeft = (parent, child) -&gt; {</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">			if ((parent.left = child) != null)</span>
<span class="fc" id="L143">				child.parent = parent;</span>
<span class="fc" id="L144">		};</span>
<span class="fc" id="L145">		BiConsumer&lt;NodeT, NodeT&gt; setRight = (parent, child) -&gt; {</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">			if ((parent.right = child) != null)</span>
<span class="fc" id="L147">				child.parent = parent;</span>
<span class="fc" id="L148">		};</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">		if (n1 == n2.parent) {</span>
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">			if (n1.left == n2) {</span>
<span class="nc" id="L151">				NodeT right = n1.right;</span>
<span class="nc" id="L152">				setLeft.accept(n1, n2.left);</span>
<span class="nc" id="L153">				setRight.accept(n1, n2.right);</span>
<span class="nc" id="L154">				n2.left = n1;</span>
<span class="nc" id="L155">				setRight.accept(n2, right);</span>
<span class="nc" id="L156">			} else {</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">				assert n1.right == n2;</span>
<span class="fc" id="L158">				NodeT left = n1.left;</span>
<span class="fc" id="L159">				setLeft.accept(n1, n2.left);</span>
<span class="fc" id="L160">				setRight.accept(n1, n2.right);</span>
<span class="fc" id="L161">				setLeft.accept(n2, left);</span>
<span class="fc" id="L162">				n2.right = n1;</span>
			}
<span class="fc" id="L164">			n2.parent = n1.parent;</span>
<span class="fc" id="L165">			n1.parent = n2;</span>

		} else {
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">			if (n2.isLeftChild()) {</span>
<span class="fc" id="L169">				n2.parent.left = n1;</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">			} else if (n2.isRightChild()) {</span>
<span class="nc" id="L171">				n2.parent.right = n1;</span>
			}

<span class="fc" id="L174">			NodeT parent = n1.parent;</span>
<span class="fc" id="L175">			NodeT left = n1.left;</span>
<span class="fc" id="L176">			NodeT right = n1.right;</span>
<span class="fc" id="L177">			n1.parent = n2.parent;</span>
<span class="fc" id="L178">			setLeft.accept(n1, n2.left);</span>
<span class="fc" id="L179">			setRight.accept(n1, n2.right);</span>
<span class="fc" id="L180">			n2.parent = parent;</span>
<span class="fc" id="L181">			setLeft.accept(n2, left);</span>
<span class="fc" id="L182">			setRight.accept(n2, right);</span>
		}
<span class="fc" id="L184">	}</span>

<span class="fc" id="L186">	static class Node&lt;NodeT extends Node&lt;NodeT&gt;&gt; {</span>
		NodeT parent;
		NodeT right;
		NodeT left;

		void clear() {
<span class="fc" id="L192">			clearTreePointers();</span>
<span class="fc" id="L193">		}</span>

		void clearTreePointers() {
<span class="fc" id="L196">			parent = left = right = null;</span>
<span class="fc" id="L197">		}</span>

		boolean isRoot() {
<span class="fc bfc" id="L200" title="All 2 branches covered.">			return parent == null;</span>
		}

		boolean isLeftChild() {
<span class="fc bfc" id="L204" title="All 4 branches covered.">			return !isRoot() &amp;&amp; this == parent.left;</span>
		}

		boolean isRightChild() {
<span class="fc bfc" id="L208" title="All 4 branches covered.">			return !isRoot() &amp;&amp; this == parent.right;</span>
		}

		boolean hasLeftChild() {
<span class="fc bfc" id="L212" title="All 2 branches covered.">			return left != null;</span>
		}

		boolean hasRightChild() {
<span class="fc bfc" id="L216" title="All 2 branches covered.">			return right != null;</span>
		}
	}

	static class BSTIterator&lt;NodeT extends Node&lt;NodeT&gt;&gt; implements Iterator&lt;NodeT&gt; {

		private final NodeT subtreeRoot;
		private NodeT n;

<span class="fc" id="L225">		BSTIterator(NodeT subtreeRoot) {</span>
<span class="fc" id="L226">			this.subtreeRoot = subtreeRoot;</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">			n = subtreeRoot == null ? null : findMin(subtreeRoot);</span>
<span class="fc" id="L228">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc bfc" id="L232" title="All 2 branches covered.">			return n != null;</span>
		}

		@Override
		public NodeT next() {
<span class="fc" id="L237">			Assertions.hasNext(this);</span>
<span class="fc" id="L238">			NodeT ret = n;</span>
<span class="fc" id="L239">			n = getSuccessorInSubtree(n, subtreeRoot);</span>
<span class="fc" id="L240">			return ret;</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>