<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SubtreeMergeFindMinImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.internal.ds</a> &gt; <span class="el_source">SubtreeMergeFindMinImpl.java</span></div><h1>SubtreeMergeFindMinImpl.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jgalgo.internal.ds;

import java.util.Arrays;
import java.util.Comparator;
import com.jgalgo.alg.LowestCommonAncestorDynamic;
import com.jgalgo.internal.util.JGAlgoUtils;

/**
 * Implementation of the {@link SubtreeMergeFindMin} data structure.
 *
 * &lt;p&gt;
 * AddLeaf is \(O(1)\) amortized, merge is \(O(\log n)\), addNonTreeEdge is \(O(1)\) and findMin is \(O(1)\). In total,
 * this data structure support \(m\) operations on \(n\) nodes in time \(O(m + n \log n)\).
 *
 * @author Barak Ugav
 */
<span class="fc" id="L33">class SubtreeMergeFindMinImpl&lt;E&gt; implements SubtreeMergeFindMin&lt;E&gt; {</span>

	private NodeImpl&lt;E&gt;[] nodes;
	private final UnionFind uf;
	private final HeapReferenceable&lt;SubTree&lt;E&gt;, Void&gt; heap;
	private final LowestCommonAncestorDynamic lca;

	private final Comparator&lt;? super E&gt; weightCmp;
	private int timestamp;

	/**
	 * Create a new SMF data structure with the {@linkplain Comparable natural ordering} comparator for edge weights.
	 */
	SubtreeMergeFindMinImpl() {
<span class="fc" id="L47">		this(null);</span>
<span class="fc" id="L48">	}</span>

	/**
	 * Create a new SMF data structure with the provided comparator for edge weights.
	 *
	 * @param weightCmp comparator used to compare edge weights.
	 */
	SubtreeMergeFindMinImpl(Comparator&lt;? super E&gt; weightCmp) {
<span class="fc" id="L56">		this(weightCmp, HeapReferenceable.newBuilder());</span>
<span class="fc" id="L57">	}</span>

	/**
	 * Create a new SMF data structure with the provided comparator for edge weights and a custom heap implementation.
	 *
	 * @param weightCmp   comparator used to compare edge weights.
	 * @param heapBuilder heap builder used to provide a custom heap implementation.
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L66">	SubtreeMergeFindMinImpl(Comparator&lt;? super E&gt; weightCmp, HeapReferenceable.Builder&lt;?, ?&gt; heapBuilder) {</span>
<span class="fc" id="L67">		nodes = new NodeImpl[2];</span>

<span class="fc" id="L69">		uf = UnionFind.newInstance();</span>
<span class="fc" id="L70">		lca = LowestCommonAncestorDynamic.newInstance();</span>

<span class="fc bfc" id="L72" title="All 2 branches covered.">		this.weightCmp = weightCmp != null ? weightCmp : JGAlgoUtils.getDefaultComparator();</span>
<span class="fc" id="L73">		timestamp = 0;</span>

<span class="fc" id="L75">		heap = heapBuilder.&lt;SubTree&lt;E&gt;&gt;keysTypeObj().valuesTypeVoid()</span>
<span class="fc" id="L76">				.build((t1, t2) -&gt; this.weightCmp.compare(t1.minEdge.data.data, t2.minEdge.data.data));</span>
<span class="fc" id="L77">	}</span>

	@Override
	public Node initTree() {
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">		if (size() != 0)</span>
<span class="nc" id="L82">			throw new IllegalStateException(&quot;Tree is not empty&quot;);</span>
<span class="fc" id="L83">		return newNode(null);</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	@Override
	public Node addLeaf(Node parent) {
<span class="fc" id="L89">		return newNode((NodeImpl&lt;E&gt;) parent);</span>
	}

	private Node newNode(NodeImpl&lt;E&gt; parent) {
<span class="fc" id="L93">		NodeImpl&lt;E&gt; node = new NodeImpl&lt;&gt;(parent);</span>

		/* Add to LCA data structure */
<span class="fc bfc" id="L96" title="All 2 branches covered.">		node.lcaNode = parent == null ? lca.initTree() : lca.addLeaf(parent.lcaNode);</span>
<span class="fc" id="L97">		node.lcaNode.setData(node);</span>

		/* Add to UF data structure */
<span class="fc" id="L100">		node.ufIdx = uf.make();</span>

<span class="fc bfc" id="L102" title="All 2 branches covered.">		if (node.ufIdx &gt;= nodes.length)</span>
<span class="fc" id="L103">			nodes = Arrays.copyOf(nodes, Math.max(nodes.length * 2, 2));</span>
<span class="fc" id="L104">		nodes[node.ufIdx] = node;</span>

<span class="fc" id="L106">		return node;</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	@Override
	public boolean isSameSubTree(Node u, Node v) {
<span class="fc bfc" id="L112" title="All 2 branches covered.">		return uf.find(((NodeImpl&lt;E&gt;) u).ufIdx) == uf.find(((NodeImpl&lt;E&gt;) v).ufIdx);</span>
	}

	@Override
	@SuppressWarnings(&quot;unchecked&quot;)
	public void mergeSubTrees(Node u0, Node v0) {
<span class="fc" id="L118">		NodeImpl&lt;E&gt; u = (NodeImpl&lt;E&gt;) u0, v = (NodeImpl&lt;E&gt;) v0;</span>
<span class="fc" id="L119">		SubTree&lt;E&gt; U = nodes[uf.find(u.ufIdx)].subtree, V = nodes[uf.find(v.ufIdx)].subtree;</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">		if (U == V)</span>
<span class="fc" id="L121">			return;</span>

		/* assume U is above V */
<span class="fc bfc" id="L124" title="All 2 branches covered.">		if (U.top.depth &gt; V.top.depth) {</span>
<span class="fc" id="L125">			SubTree&lt;E&gt; temp = U;</span>
<span class="fc" id="L126">			U = V;</span>
<span class="fc" id="L127">			V = temp;</span>
		}
<span class="pc bpc" id="L129" title="2 of 4 branches missed.">		if (V.top.parent == null || subTree(V.top.parent) != U)</span>
<span class="nc" id="L130">			throw new IllegalArgumentException(&quot;Subtrees are not adjacent&quot;);</span>

		/* update union find */
<span class="fc" id="L133">		int w = uf.union(U.top.ufIdx, V.top.ufIdx);</span>
<span class="fc" id="L134">		nodes[w].subtree = U;</span>

<span class="fc" id="L136">		U.size += V.size;</span>
<span class="fc" id="L137">		int rank = U.rank(), maxSet = Math.max(U.edges.length, V.edges.length);</span>
<span class="fc" id="L138">		EdgeList&lt;E&gt;[] uEdges = U.edges, vEdges = V.edges;</span>
<span class="fc" id="L139">		U.edges = Arrays.copyOf(U.edges, maxSet);</span>
<span class="fc" id="L140">		Arrays.fill(U.edges, null);</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">		if (U.heapRef != null)</span>
<span class="fc" id="L142">			heap.remove(U.heapRef);</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">		if (V.heapRef != null)</span>
<span class="fc" id="L144">			heap.remove(V.heapRef);</span>
<span class="fc" id="L145">		U.heapRef = V.heapRef = null;</span>
<span class="fc" id="L146">		U.minEdge = V.minEdge = null;</span>

		/* fix current timestamp to identify redundant edges */
<span class="fc" id="L149">		final int t = ++timestamp;</span>

		/* All edges in sets &gt;= r+1 are good, just union */
<span class="fc bfc" id="L152" title="All 2 branches covered.">		for (int setIdx = rank + 1; setIdx &lt; maxSet; setIdx++) {</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">			EdgeList&lt;E&gt; el1 = uEdges.length &gt; setIdx ? uEdges[setIdx] : null;</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">			EdgeList&lt;E&gt; el2 = vEdges.length &gt; setIdx ? vEdges[setIdx] : null;</span>
<span class="fc" id="L155">			EdgeList&lt;E&gt; el = concatenateEdgeLists(el1, el2);</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">			if (el == null)</span>
<span class="fc" id="L157">				continue;</span>
<span class="fc" id="L158">			U.edges[setIdx] = el;</span>
<span class="fc" id="L159">			compareAgainstSubTreeMin(U, el.min);</span>
		}
		/* Examine all edges in set &lt;= r */
<span class="fc bfc" id="L162" title="All 2 branches covered.">		for (int setIdx = 0; setIdx &lt;= rank; setIdx++) {</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">			EdgeList&lt;E&gt; el1 = uEdges.length &gt; setIdx ? uEdges[setIdx] : null;</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">			EdgeList&lt;E&gt; el2 = vEdges.length &gt; setIdx ? vEdges[setIdx] : null;</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">			for (EdgeList&lt;E&gt; el : new EdgeList[] { el1, el2 }) {</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">				if (el == null)</span>
<span class="fc" id="L167">					continue;</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">				for (EdgeNode&lt;E&gt; edge, next; (edge = el.head) != null; el.head = next) {</span>
<span class="fc" id="L169">					next = edge.next;</span>
<span class="fc" id="L170">					edge.next = null;</span>

<span class="fc" id="L172">					SubTree&lt;E&gt; eU = subTree(edge.u), eV = subTree(edge.v);</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">					if (eU == eV) {</span>
						/* edge is bad */
<span class="fc" id="L175">						edge.clear();</span>
<span class="fc" id="L176">						continue;</span>
					}

					/* assume eU is U */
<span class="fc bfc" id="L180" title="All 2 branches covered.">					if (eU != U) {</span>
<span class="fc" id="L181">						SubTree&lt;E&gt; temp = eU;</span>
<span class="fc" id="L182">						eU = eV;</span>
<span class="fc" id="L183">						eV = temp;</span>
					}
<span class="pc bnc" id="L185" title="All 2 branches missed.">					assert eU == U;</span>

<span class="fc bfc" id="L187" title="All 4 branches covered.">					if (eV.inEdgeTimestamp == t &amp;&amp; weightCmp.compare(eV.inEdge.data.data, edge.data.data) &lt;= 0) {</span>
						/* edge is redundant */
<span class="fc" id="L189">						edge.clear();</span>
<span class="fc" id="L190">						continue;</span>
					}

					/* update inEdge */
<span class="fc" id="L194">					eV.inEdgeTimestamp = t;</span>
<span class="fc" id="L195">					eV.inEdge = edge;</span>

					/* add edge to the appropriate set */
<span class="fc" id="L198">					addEdgeNode(edge);</span>
				}
<span class="fc" id="L200">				el.clear();</span>
			}
		}
<span class="fc" id="L203">		Arrays.fill(uEdges, null);</span>
<span class="fc" id="L204">		Arrays.fill(vEdges, null);</span>
<span class="fc" id="L205">	}</span>

	private EdgeList&lt;E&gt; concatenateEdgeLists(EdgeList&lt;E&gt; el1, EdgeList&lt;E&gt; el2) {
<span class="fc bfc" id="L208" title="All 2 branches covered.">		if (el1 == null)</span>
<span class="fc" id="L209">			return el2;</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">		if (el2 == null)</span>
<span class="fc" id="L211">			return el1;</span>

<span class="fc" id="L213">		el1.tail.next = el2.head;</span>
<span class="fc" id="L214">		el1.tail = el2.tail;</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">		if (weightCmp.compare(el2.min.data.data, el1.min.data.data) &lt; 0)</span>
<span class="fc" id="L216">			el1.min = el2.min;</span>

		/* clear el2 */
<span class="fc" id="L219">		el2.clear();</span>
<span class="fc" id="L220">		return el1;</span>
	}

	@Override
	public void addNonTreeEdge(Node u0, Node v0, E edgedata) {
<span class="fc bfc" id="L225" title="All 2 branches covered.">		if (u0 == v0)</span>
<span class="fc" id="L226">			return;</span>
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L228">		NodeImpl&lt;E&gt; u = (NodeImpl&lt;E&gt;) u0, v = (NodeImpl&lt;E&gt;) v0;</span>

		/* assume u is above v */
<span class="fc bfc" id="L231" title="All 2 branches covered.">		if (u.depth &gt; v.depth) {</span>
<span class="fc" id="L232">			NodeImpl&lt;E&gt; temp = u;</span>
<span class="fc" id="L233">			u = v;</span>
<span class="fc" id="L234">			v = temp;</span>
		}
<span class="fc" id="L236">		Edge&lt;E&gt; edge = new Edge&lt;&gt;(u, v, edgedata);</span>

		/* split edge into two edges (u, lca(u,v)), (v, lca(u,v)) */
<span class="fc" id="L239">		LowestCommonAncestorDynamic.Vertex l = lca.findLowestCommonAncestor(u.lcaNode, v.lcaNode);</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">		if (u.lcaNode != l) {</span>
<span class="fc" id="L241">			addEdgeNode(new EdgeNode&lt;&gt;(u, l.getData(), edge));</span>
<span class="fc" id="L242">			addEdgeNode(new EdgeNode&lt;&gt;(v, l.getData(), edge));</span>
		} else {
<span class="fc" id="L244">			addEdgeNode(new EdgeNode&lt;&gt;(v, u, edge));</span>
		}
<span class="fc" id="L246">	}</span>

	private void addEdgeNode(EdgeNode&lt;E&gt; edge) {
		/* assume u is deeper */
<span class="pc bnc" id="L250" title="All 2 branches missed.">		assert edge.u.depth &gt; edge.v.depth;</span>

<span class="fc" id="L252">		SubTree&lt;E&gt; u = subTree(edge.u), v = subTree(edge.v);</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">		if (u == v)</span>
<span class="fc" id="L254">			return; /* ignore edge within same sub tree */</span>

<span class="fc" id="L256">		int span = JGAlgoUtils.log2(edge.u.depth - edge.v.depth + 1);</span>
<span class="fc" id="L257">		int uRank = u.rank(), vRank = v.rank();</span>

<span class="fc bfc" id="L259" title="All 2 branches covered.">		if (uRank &lt; span)</span>
			/* long */
<span class="fc" id="L261">			addEdgeToSet(u, span, edge);</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">		else if (uRank &lt;= vRank)</span>
			/* up */
<span class="fc" id="L264">			addEdgeToSet(u, Math.max(uRank + 1, vRank), edge);</span>
		else
			/* down */
<span class="fc" id="L267">			addEdgeToSet(v, uRank, edge);</span>
<span class="fc" id="L268">	}</span>

	private void addEdgeToSet(SubTree&lt;E&gt; v, int setIdx, EdgeNode&lt;E&gt; edge) {
<span class="fc bfc" id="L271" title="All 2 branches covered.">		if (v.edges.length &lt;= setIdx) {</span>
<span class="fc" id="L272">			int newLen = v.edges.length;</span>
			do {
<span class="fc" id="L274">				newLen = Math.max(newLen * 2, 2);</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">			} while (newLen &lt;= setIdx);</span>
<span class="fc" id="L276">			v.edges = Arrays.copyOf(v.edges, newLen);</span>
		}
<span class="fc bfc" id="L278" title="All 2 branches covered.">		if (v.edges[setIdx] == null)</span>
<span class="fc" id="L279">			v.edges[setIdx] = new EdgeList&lt;&gt;();</span>
<span class="fc" id="L280">		EdgeList&lt;E&gt; edgeList = v.edges[setIdx];</span>

<span class="fc bfc" id="L282" title="All 2 branches covered.">		if (edgeList.head == null) {</span>
<span class="fc" id="L283">			edgeList.head = edgeList.tail = edgeList.min = edge;</span>
<span class="fc" id="L284">			compareAgainstSubTreeMin(v, edge);</span>
		} else {
<span class="fc" id="L286">			edgeList.tail.next = edge;</span>
<span class="fc" id="L287">			edgeList.tail = edge;</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">			if (weightCmp.compare(edge.data.data, edgeList.min.data.data) &lt; 0) {</span>
<span class="fc" id="L289">				edgeList.min = edge;</span>
<span class="fc" id="L290">				compareAgainstSubTreeMin(v, edge);</span>
			}
		}
<span class="fc" id="L293">	}</span>

	private void compareAgainstSubTreeMin(SubTree&lt;E&gt; v, EdgeNode&lt;E&gt; edge) {
<span class="fc bfc" id="L296" title="All 2 branches covered.">		if (v.minEdge == null) {</span>
<span class="fc" id="L297">			v.minEdge = edge;</span>
<span class="fc" id="L298">			v.heapRef = heap.insert(v);</span>

<span class="fc bfc" id="L300" title="All 2 branches covered.">		} else if (weightCmp.compare(edge.data.data, v.minEdge.data.data) &lt; 0) {</span>
<span class="fc" id="L301">			v.minEdge = edge;</span>
<span class="fc" id="L302">			heap.decreaseKey(v.heapRef, v);</span>
		}
<span class="fc" id="L304">	}</span>

	@Override
	public boolean hasNonTreeEdge() {
<span class="fc bfc" id="L308" title="All 2 branches covered.">		return !heap.isEmpty();</span>
	}

	@Override
	public MinEdge&lt;E&gt; findMinNonTreeEdge() {
<span class="fc bfc" id="L313" title="All 2 branches covered.">		return heap.isEmpty() ? null : heap.findMin().key().minEdge.data;</span>
	}

	@Override
	public int size() {
<span class="fc" id="L318">		return uf.size();</span>
	}

	@Override
	public void clear() {
<span class="fc" id="L323">		int size = size();</span>
<span class="fc" id="L324">		uf.clear();</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">		for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L326">			nodes[i].clear();</span>
<span class="fc" id="L327">			nodes[i] = null;</span>
		}
<span class="fc" id="L329">		heap.clear();</span>
<span class="fc" id="L330">		lca.clear();</span>
<span class="fc" id="L331">		timestamp = 0;</span>
<span class="fc" id="L332">	}</span>

	private SubTree&lt;E&gt; subTree(NodeImpl&lt;E&gt; node) {
<span class="fc" id="L335">		return nodes[uf.find(node.ufIdx)].subtree;</span>
	}

	private static class NodeImpl&lt;E&gt; implements Node {

		private Object nodeData;
		private final NodeImpl&lt;E&gt; parent;
		private final int depth;
		private int ufIdx;
		private LowestCommonAncestorDynamic.Vertex lcaNode;
		private SubTree&lt;E&gt; subtree;

<span class="fc" id="L347">		NodeImpl(NodeImpl&lt;E&gt; parent) {</span>
<span class="fc" id="L348">			this.parent = parent;</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">			depth = parent != null ? parent.depth + 1 : 0;</span>
<span class="fc" id="L350">			subtree = new SubTree&lt;&gt;(this);</span>
<span class="fc" id="L351">		}</span>

		@Override
		@SuppressWarnings(&quot;unchecked&quot;)
		public &lt;V&gt; V getNodeData() {
<span class="fc" id="L356">			return (V) nodeData;</span>
		}

		@Override
		public void setNodeData(Object data) {
<span class="fc" id="L361">			nodeData = data;</span>
<span class="fc" id="L362">		}</span>

		@Override
		public Node getParent() {
<span class="fc" id="L366">			return parent;</span>
		}

		void clear() {
<span class="fc" id="L370">			nodeData = null;</span>
<span class="fc" id="L371">			lcaNode = null;</span>
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">			if (subtree != null)</span>
<span class="fc" id="L373">				subtree.clear();</span>
<span class="fc" id="L374">			subtree = null;</span>
<span class="fc" id="L375">		}</span>

	}

	private static class SubTree&lt;E&gt; {

		NodeImpl&lt;E&gt; top;
		int size;

		EdgeList&lt;E&gt;[] edges;
		EdgeNode&lt;E&gt; minEdge;
		HeapReference&lt;SubTree&lt;E&gt;, Void&gt; heapRef;

		/* field used to detect redundant edges during merge */
		EdgeNode&lt;E&gt; inEdge;
		int inEdgeTimestamp;

<span class="fc" id="L392">		private static final EdgeList&lt;?&gt;[] EMPTY_EDGELIST_ARR = new EdgeList[0];</span>

		@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L395">		SubTree(NodeImpl&lt;E&gt; node) {</span>
<span class="fc" id="L396">			top = node;</span>
<span class="fc" id="L397">			size = 1;</span>
<span class="fc" id="L398">			edges = (EdgeList&lt;E&gt;[]) EMPTY_EDGELIST_ARR;</span>
<span class="fc" id="L399">		}</span>

		int rank() {
<span class="fc" id="L402">			return JGAlgoUtils.log2(size);</span>
		}

		void clear() {
<span class="fc bfc" id="L406" title="All 2 branches covered.">			for (int i = 0; i &lt; edges.length; i++) {</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">				if (edges[i] == null)</span>
<span class="fc" id="L408">					continue;</span>
<span class="fc" id="L409">				edges[i].clear();</span>
<span class="fc" id="L410">				edges[i] = null;</span>
			}
<span class="fc bfc" id="L412" title="All 2 branches covered.">			if (minEdge != null)</span>
<span class="fc" id="L413">				minEdge.clear();</span>
<span class="fc" id="L414">			minEdge = null;</span>
<span class="fc" id="L415">			heapRef = null;</span>
<span class="fc" id="L416">		}</span>

	}

	private static class EdgeList&lt;E&gt; {
		EdgeNode&lt;E&gt; head, tail;
		EdgeNode&lt;E&gt; min;

		void clear() {
<span class="fc" id="L425">			head = tail = min = null;</span>
<span class="fc" id="L426">		}</span>
	}

	private static class EdgeNode&lt;E&gt; {
		final NodeImpl&lt;E&gt; u, v;
		final Edge&lt;E&gt; data;
		EdgeNode&lt;E&gt; next;

<span class="fc" id="L434">		EdgeNode(NodeImpl&lt;E&gt; u, NodeImpl&lt;E&gt; v, Edge&lt;E&gt; data) {</span>
<span class="fc" id="L435">			this.u = u;</span>
<span class="fc" id="L436">			this.v = v;</span>
<span class="fc" id="L437">			this.data = data;</span>
<span class="fc" id="L438">		}</span>

		void clear() {
<span class="fc" id="L441">			next = null;</span>
<span class="fc" id="L442">		}</span>

		@Override
		public String toString() {
<span class="nc" id="L446">			return String.valueOf(data);</span>
		}
	}

	private static class Edge&lt;E&gt; implements MinEdge&lt;E&gt; {
		public final Node u, v;
		public final E data;

<span class="fc" id="L454">		Edge(Node u, Node v, E data) {</span>
<span class="fc" id="L455">			this.u = u;</span>
<span class="fc" id="L456">			this.v = v;</span>
<span class="fc" id="L457">			this.data = data;</span>
<span class="fc" id="L458">		}</span>

		@Override
		public String toString() {
<span class="nc" id="L462">			return &quot;(&quot; + u + &quot;, &quot; + v + &quot;, &quot; + data + &quot;)&quot;;</span>
		}

		@Override
		public Node source() {
<span class="fc" id="L467">			return u;</span>
		}

		@Override
		public Node target() {
<span class="fc" id="L472">			return v;</span>
		}

		@Override
		public E edgeData() {
<span class="fc" id="L477">			return data;</span>
		}

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>