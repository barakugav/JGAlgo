<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BinarySearchTree.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.internal.ds</a> &gt; <span class="el_source">BinarySearchTree.java</span></div><h1>BinarySearchTree.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jgalgo.internal.ds;

import java.util.Comparator;

/**
 * Binary search tree data structure.
 * &lt;p&gt;
 * In addition to all {@link HeapReferenceable} operations, a binary search tree (BST) allow for an efficient search of
 * an element, not just {@link Heap#findMin()}. Every element could be found in \(O(\log n)\) time, notably
 * {@link #findMax()} in addition to {@link Heap#findMin()}. Also, given an element, the nearest (smaller or larger)
 * element in the tree can be found efficiently.
 *
 * @param  &lt;K&gt; the keys type
 * @param  &lt;V&gt; the values type
 * @author     Barak Ugav
 */
public interface BinarySearchTree&lt;K, V&gt; extends HeapReferenceable&lt;K, V&gt; {

	/**
	 * Find the element with the maximal key in the tree and return a reference to it.
	 *
	 * @return                       a reference to the element with the maximal key in the tree
	 * @throws IllegalStateException if the tree is empty
	 */
	HeapReference&lt;K, V&gt; findMax();

	/**
	 * Extract the element with the maximal key in the tree.
	 * &lt;p&gt;
	 * This method find and &lt;b&gt;remove&lt;/b&gt; the element with the maximal key.
	 *
	 * @return                       the element with the maximal key in the tree
	 * @throws IllegalStateException if the tree is empty
	 */
	HeapReference&lt;K, V&gt; extractMax();

	/**
	 * Find an element in the tree by its key, or the element with the greatest strictly smaller (predecessor) key than
	 * it if it's not found.
	 *
	 * @param  key the search key
	 * @return     reference to an element with the searched key or it's predecessor if is not found, or {@code null} if
	 *             there is no predecessor
	 */
	HeapReference&lt;K, V&gt; findOrSmaller(K key);

	/**
	 * Find an element in the tree by its key, or the element with the smallest strictly greater (successor) key than it
	 * if it's not found.
	 *
	 * @param  key the search key
	 * @return     reference to an element with the searched key or it's successor if it is not found, or {@code null}
	 *             if there is no successor
	 */
	HeapReference&lt;K, V&gt; findOrGreater(K key);

	/**
	 * Find the element with the greatest strictly smaller key than a given key.
	 *
	 * @param  key a key
	 * @return     reference to the predecessor element with strictly smaller key or {@code null} if no such exists
	 */
	HeapReference&lt;K, V&gt; findSmaller(K key);

	/**
	 * Find the element with the smallest strictly greater key than a given key.
	 *
	 * @param  key a key
	 * @return     reference to the successor element with strictly greater key or {@code null} if no such exists
	 */
	HeapReference&lt;K, V&gt; findGreater(K key);

	/**
	 * Get the predecessor of a node in the tree.
	 * &lt;p&gt;
	 * The predecessor node depends on the tree structure. If there are no duplicate keys, the predecessor is the
	 * greatest value strictly smaller than the given element. If there are duplicate keys, it may be smaller or equal.
	 * &lt;p&gt;
	 * This method behavior is undefined if the reference is not valid, namely if it refer to an element already
	 * removed, or to an element in another heap.
	 *
	 * @param  ref reference to an element in the tree
	 * @return     reference to the predecessor element in the tree, that is an element with smaller or equal key to the
	 *             given referenced element's key, or {@code null} if no such predecessor exists
	 */
	HeapReference&lt;K, V&gt; getPredecessor(HeapReference&lt;K, V&gt; ref);

	/**
	 * Finds the successor of an element in the tree.
	 * &lt;p&gt;
	 * The successor node depends on the tree structure. If there are no duplicate keys, the successor is the smallest
	 * value strictly greater than the given element. If there are duplicate keys, it may be greater or equal.
	 * &lt;p&gt;
	 * This method behavior is undefined if the reference is not valid, namely if it refer to an element already
	 * removed, or to an element in another heap.
	 *
	 * @param  ref reference to an element in the tree
	 * @return     reference to the successor element in the tree, that is an element with greater or equal key to the
	 *             given referenced element's key, or {@code null} if no such successor exists
	 */
	HeapReference&lt;K, V&gt; getSuccessor(HeapReference&lt;K, V&gt; ref);

	/**
	 * Split the current BST into two different BSTs with keys strictly smaller and greater or equal than a key.
	 * &lt;p&gt;
	 * After this operation, all elements in this tree will have keys greater or equal than the given key, and the
	 * returned new tree will contain elements with keys strictly smaller than the given key.
	 *
	 * @param  key a pivot key
	 * @return     new tree with elements with keys strictly smaller than the given key
	 */
	BinarySearchTree&lt;K, V&gt; splitSmaller(K key);

	/**
	 * Split the current BST into two different BSTs with keys smaller or equal and strictly greater than a key.
	 * &lt;p&gt;
	 * After this operation, all elements in this tree will have keys be smaller or equal than the given key, and the
	 * returned new tree will contain elements with keys strictly greater than the given key.
	 *
	 * @param  key a pivot key
	 * @return     new tree with elements with keys strictly greater than the given key
	 */
	BinarySearchTree&lt;K, V&gt; splitGreater(K key);

	/**
	 * Split the current BST into two different BSTs with elements smaller and greater than an element's key.
	 * &lt;p&gt;
	 * After this operation, all elements keys in this tree will be smaller or equal to the given element's key, and the
	 * returned new tree will contain elements with keys greater than the given element's key. If the tree contains
	 * duplications of the given element's key, the elements keys in the returned tree will be greater or equal (rather
	 * than strictly greater). To split a tree more precisely, use {@link #splitSmaller(Object)} or
	 * {@link #splitGreater(Object)}.
	 * &lt;p&gt;
	 * This method behavior is undefined if the reference is not valid, namely if it refer to an element already
	 * removed, or to an element in another heap.
	 *
	 * @param  ref given element in the tree
	 * @return     new tree with elements with keys greater (greater or equal if duplicate keys of the given element's
	 *             key exists) than the given key
	 */
	BinarySearchTree&lt;K, V&gt; split(HeapReference&lt;K, V&gt; ref);

	/**
	 * Create a new binary search tree algorithm builder.
	 * &lt;p&gt;
	 * This is the recommended way to instantiate a new {@link BinarySearchTree} object.
	 *
	 * @return a new builder that can build {@link BinarySearchTree} objects
	 */
	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
	static BinarySearchTree.Builder&lt;Object, Object&gt; newBuilder() {
<span class="fc" id="L168">		return new BinarySearchTree.Builder&lt;&gt;() {</span>

			boolean splitRequired;
			boolean meldRequired;
			String impl;

			@Override
			public BinarySearchTree build(Comparator cmp) {
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">				if (impl != null) {</span>
<span class="pc bpc" id="L177" title="1 of 3 branches missed.">					switch (impl) {</span>
						case &quot;splay&quot;:
<span class="fc" id="L179">							return new SplayTree(cmp);</span>
						case &quot;red-black&quot;:
<span class="fc" id="L181">							return new RedBlackTree(cmp);</span>
						default:
<span class="nc" id="L183">							throw new IllegalArgumentException(&quot;unknown 'impl' value: &quot; + impl);</span>
					}
				}
<span class="nc bnc" id="L186" title="All 4 branches missed.">				if (splitRequired || meldRequired) {</span>
<span class="nc" id="L187">					return new SplayTree(cmp);</span>
				} else {
<span class="nc" id="L189">					return new RedBlackTree(cmp);</span>
				}
			}

			@Override
			public BinarySearchTree.Builder setSplits(boolean enable) {
<span class="nc" id="L195">				splitRequired = enable;</span>
<span class="nc" id="L196">				return this;</span>
			}

			@Override
			public BinarySearchTree.Builder setMelds(boolean enable) {
<span class="nc" id="L201">				meldRequired = enable;</span>
<span class="nc" id="L202">				return this;</span>
			}

			@Override
			public BinarySearchTree.Builder keysTypeObj() {
<span class="nc" id="L207">				return this;</span>
			}

			@Override
			public BinarySearchTree.Builder keysTypePrimitive(Class primitiveType) {
<span class="fc" id="L212">				return this;</span>
			}

			@Override
			public BinarySearchTree.Builder valuesTypeObj() {
<span class="nc" id="L217">				return this;</span>
			}

			@Override
			public BinarySearchTree.Builder valuesTypePrimitive(Class primitiveType) {
<span class="nc" id="L222">				return this;</span>
			}

			@Override
			public BinarySearchTree.Builder valuesTypeVoid() {
<span class="fc" id="L227">				return this;</span>
			}

			@Override
			public BinarySearchTree.Builder setOption(String key, Object value) {
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">				switch (key) {</span>
					case &quot;impl&quot;:
<span class="fc" id="L234">						impl = (String) value;</span>
<span class="fc" id="L235">						break;</span>
					default:
<span class="nc" id="L237">						throw new IllegalArgumentException(&quot;unknown option key: &quot; + key);</span>
				}
<span class="fc" id="L239">				return this;</span>
			}
		};
	}

	/**
	 * A builder for {@link BinarySearchTree} objects.
	 *
	 * @see    BinarySearchTree#newBuilder()
	 * @author Barak Ugav
	 */
	static interface Builder&lt;K, V&gt; extends HeapReferenceable.Builder&lt;K, V&gt; {

		@Override
		BinarySearchTree&lt;K, V&gt; build(Comparator&lt;? super K&gt; cmp);

		@Override
		default BinarySearchTree&lt;K, V&gt; build() {
<span class="nc" id="L257">			return build(null);</span>
		}

		/**
		 * Enable/disable efficient split operations.
		 *
		 * @param  enable if {@code true} the split operations such as {@link BinarySearchTree#split(HeapReference)},
		 *                    {@link BinarySearchTree#splitSmaller(Object)} and
		 *                    {@link BinarySearchTree#splitGreater(Object)} will be supported efficiently by the trees
		 *                    created by this builder
		 * @return        this builder
		 */
		BinarySearchTree.Builder&lt;K, V&gt; setSplits(boolean enable);

		/**
		 * Enable/disable efficient {@link BinarySearchTree#meld} operations.
		 *
		 * @param  enable if {@code true} the {@link BinarySearchTree#meld} operation will be supported efficiently by
		 *                    the trees created by this builder
		 * @return        this builder
		 */
		BinarySearchTree.Builder&lt;K, V&gt; setMelds(boolean enable);

		@Override
		&lt;Keys&gt; BinarySearchTree.Builder&lt;Keys, V&gt; keysTypeObj();

		@Override
		&lt;Keys&gt; BinarySearchTree.Builder&lt;Keys, V&gt; keysTypePrimitive(Class&lt;? extends Keys&gt; primitiveType);

		@Override
		&lt;Values&gt; BinarySearchTree.Builder&lt;K, Values&gt; valuesTypeObj();

		@Override
		&lt;Values&gt; BinarySearchTree.Builder&lt;K, Values&gt; valuesTypePrimitive(Class&lt;? extends Values&gt; primitiveType);

		@Override
		BinarySearchTree.Builder&lt;K, Void&gt; valuesTypeVoid();

		@Override
		default BinarySearchTree.Builder&lt;K, V&gt; setOption(String key, Object value) {
<span class="nc" id="L297">			HeapReferenceable.Builder.super.setOption(key, value);</span>
<span class="nc" id="L298">			return this;</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>