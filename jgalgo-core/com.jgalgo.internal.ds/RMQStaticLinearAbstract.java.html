<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RMQStaticLinearAbstract.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.internal.ds</a> &gt; <span class="el_source">RMQStaticLinearAbstract.java</span></div><h1>RMQStaticLinearAbstract.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jgalgo.internal.ds;

import java.util.BitSet;
import it.unimi.dsi.fastutil.bytes.Byte2IntMap;
import it.unimi.dsi.fastutil.bytes.Byte2IntOpenHashMap;
import it.unimi.dsi.fastutil.ints.Int2IntMap;
import it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap;
import it.unimi.dsi.fastutil.shorts.Short2IntMap;
import it.unimi.dsi.fastutil.shorts.Short2IntOpenHashMap;

<span class="fc" id="L27">abstract class RMQStaticLinearAbstract implements RMQStatic {</span>

	/*
	 * This implementation divides the elements sequence into blocks, for each block calculate the minimum in the block
	 * and the minimum within the block from each index to the borders of the block. In addition, we use the \(O(x \log
	 * x)\) implementation on the minimum values from each block (which we have less than n).
	 *
	 * To answer a query, if the two indices are not in the same block, we check the minimum from i to the end of the
	 * block, from j to the end of the block, and the minimum along all the blocks between them. If the two elements are
	 * not in the same block we have no implementation, and the implementations that extends this class will implement
	 * it in different methods.
	 *
	 * \(O(n)\) pre processing time, \(O(n)\) space, \(O(1)\) query.
	 */

	abstract class PreProcessor extends DsBase {

		final RMQStaticComparator cmpPadded;
		final int blockNum;

		private final RMQStatic outerRMQ;

<span class="fc" id="L49">		PreProcessor(RMQStaticComparator c, int n) {</span>
<span class="fc" id="L50">			this.n = n;</span>
<span class="fc" id="L51">			blockSize = getBlockSize(n);</span>
<span class="fc" id="L52">			blockNum = (int) Math.ceil((double) n / blockSize);</span>
<span class="fc" id="L53">			this.cmpOrig = c;</span>
<span class="fc bfc" id="L54" title="All 2 branches covered.">			this.cmpPadded = n &lt; blockNum * blockSize ? new PaddedComparator(n, c) : c;</span>
<span class="fc" id="L55">			blocksRightLeftMinimum = new byte[blockNum * (blockSize - 1) * 2];</span>

<span class="fc" id="L57">			outerRMQ = new RMQStaticPowerOf2Table();</span>

<span class="fc bfc" id="L59" title="All 2 branches covered.">			for (int b = 0; b &lt; blockNum; b++) {</span>
<span class="fc bfc" id="L60" title="All 2 branches covered.">				c = b &lt; blockNum - 1 ? cmpOrig : cmpPadded;</span>
<span class="fc" id="L61">				int base = b * blockSize;</span>

<span class="fc" id="L63">				byte min = 0;</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">				for (byte i = 0; i &lt; blockSize - 1; i++) {</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">					if (c.compare(base + i + 1, base + min) &lt; 0)</span>
<span class="fc" id="L66">						min = (byte) (i + 1);</span>
<span class="fc" id="L67">					blockLeftMinimum(b, i, min);</span>
				}

<span class="fc" id="L70">				min = (byte) (blockSize - 1);</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">				for (byte i = (byte) (blockSize - 2); i &gt;= 0; i--) {</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">					if (c.compare(base + i, base + min) &lt; 0)</span>
<span class="fc" id="L73">						min = i;</span>
<span class="fc" id="L74">					blockRightMinimum(b, i, min);</span>
				}
			}

<span class="fc" id="L78">			xlogxTableDS = outerRMQ.preProcessSequence(</span>
<span class="fc" id="L79">					(i, j) -&gt; cmpOrig.compare(i * blockSize + blockMinimum(i), j * blockSize + blockMinimum(j)),</span>
					blockNum);

<span class="fc" id="L82">		}</span>

		void preProcessInnerBlocks() {
<span class="fc" id="L85">			int keySize = getBlockKeySize();</span>
<span class="fc" id="L86">			var innerBlocksIdx = new Object() {</span>
<span class="fc" id="L87">				int val = 0;</span>
			};
<span class="fc" id="L89">			blockToInnerIdx = new int[blockNum];</span>
<span class="fc" id="L90">			final int innerBlockAllocSize = blockSize * (blockSize - 1) / 2;</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">			if (keySize &lt; Byte.SIZE) {</span>
<span class="fc" id="L92">				Byte2IntMap tables = new Byte2IntOpenHashMap();</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">				for (int b = 0; b &lt; blockNum; b++) {</span>
<span class="fc" id="L94">					byte key = (byte) calcBlockKey(b);</span>
<span class="fc" id="L95">					blockToInnerIdx[b] = key;</span>
<span class="fc" id="L96">					tables.computeIfAbsent(key, k -&gt; innerBlocksIdx.val++);</span>
				}
<span class="fc" id="L98">				final int innerBlockNum = tables.size();</span>
<span class="fc" id="L99">				BitSet builtInnerBlocks = new BitSet(innerBlockNum);</span>
<span class="fc" id="L100">				innerBlocks = new byte[innerBlockNum * innerBlockAllocSize];</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">				for (int b = 0; b &lt; blockNum; b++) {</span>
<span class="fc" id="L102">					byte key = (byte) blockToInnerIdx[b];</span>
<span class="fc" id="L103">					int innerIdx = tables.get(key);</span>
<span class="fc" id="L104">					blockToInnerIdx[b] = innerIdx;</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">					if (!builtInnerBlocks.get(innerIdx)) {</span>
<span class="fc" id="L106">						byte[] demoBlock = calcDemoBlock(key &amp; 0xff);</span>
<span class="fc" id="L107">						buildInnerBlock(innerIdx, demoBlock);</span>
<span class="fc" id="L108">						builtInnerBlocks.set(innerIdx);</span>
					}
				}
<span class="fc" id="L111">				tables.clear();</span>

<span class="pc bpc" id="L113" title="1 of 2 branches missed.">			} else if (keySize &lt; Short.SIZE) {</span>
<span class="fc" id="L114">				Short2IntMap tables = new Short2IntOpenHashMap();</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">				for (int b = 0; b &lt; blockNum; b++) {</span>
<span class="fc" id="L116">					short key = (short) calcBlockKey(b);</span>
<span class="fc" id="L117">					blockToInnerIdx[b] = key;</span>
<span class="fc" id="L118">					tables.computeIfAbsent(key, k -&gt; innerBlocksIdx.val++);</span>
				}
<span class="fc" id="L120">				final int innerBlockNum = tables.size();</span>
<span class="fc" id="L121">				BitSet builtInnerBlocks = new BitSet(innerBlockNum);</span>
<span class="fc" id="L122">				innerBlocks = new byte[innerBlockNum * innerBlockAllocSize];</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">				for (int b = 0; b &lt; blockNum; b++) {</span>
<span class="fc" id="L124">					short key = (short) blockToInnerIdx[b];</span>
<span class="fc" id="L125">					int innerIdx = tables.get(key);</span>
<span class="fc" id="L126">					blockToInnerIdx[b] = innerIdx;</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">					if (!builtInnerBlocks.get(innerIdx)) {</span>
<span class="fc" id="L128">						byte[] demoBlock = calcDemoBlock(key &amp; 0xffff);</span>
<span class="fc" id="L129">						buildInnerBlock(innerIdx, demoBlock);</span>
<span class="fc" id="L130">						builtInnerBlocks.set(innerIdx);</span>
					}
				}
<span class="fc" id="L133">				tables.clear();</span>

<span class="fc" id="L135">			} else {</span>
<span class="nc" id="L136">				Int2IntMap tables = new Int2IntOpenHashMap();</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">				for (int b = 0; b &lt; blockNum; b++) {</span>
<span class="nc" id="L138">					int key = calcBlockKey(b);</span>
<span class="nc" id="L139">					blockToInnerIdx[b] = key;</span>
<span class="nc" id="L140">					tables.computeIfAbsent(key, k -&gt; innerBlocksIdx.val++);</span>
				}
<span class="nc" id="L142">				final int innerBlockNum = tables.size();</span>
<span class="nc" id="L143">				BitSet builtInnerBlocks = new BitSet(innerBlockNum);</span>
<span class="nc" id="L144">				innerBlocks = new byte[innerBlockNum * innerBlockAllocSize];</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">				for (int b = 0; b &lt; blockNum; b++) {</span>
<span class="nc" id="L146">					int key = blockToInnerIdx[b];</span>
<span class="nc" id="L147">					int innerIdx = tables.get(key);</span>
<span class="nc" id="L148">					blockToInnerIdx[b] = innerIdx;</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">					if (!builtInnerBlocks.get(innerIdx)) {</span>
<span class="nc" id="L150">						byte[] demoBlock = calcDemoBlock(key);</span>
<span class="nc" id="L151">						buildInnerBlock(innerIdx, demoBlock);</span>
<span class="nc" id="L152">						builtInnerBlocks.set(innerIdx);</span>
					}
				}
<span class="nc" id="L155">				tables.clear();</span>
			}
<span class="fc" id="L157">		}</span>

		private void buildInnerBlock(int innerBlock, byte[] demoBlock) {
<span class="fc" id="L160">			byte[] arr = innerBlocks;</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">			for (byte i = 0; i &lt; blockSize - 1; i++)</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">				arr[innerBlockIndex(innerBlock, i, i + 1)] = demoBlock[i] &lt; demoBlock[i + 1] ? i : (byte) (i + 1);</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">			for (byte i = 0; i &lt; blockSize - 2; i++) {</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">				for (byte j = (byte) (i + 2); j &lt; blockSize; j++) {</span>
<span class="fc" id="L165">					byte m = arr[innerBlockIndex(innerBlock, i, j - 1)];</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">					arr[innerBlockIndex(innerBlock, i, j)] = demoBlock[m] &lt; demoBlock[j] ? m : j;</span>
				}
			}
<span class="fc" id="L169">		}</span>

		abstract byte getBlockSize(int n);

		abstract int getBlockKeySize();

		abstract int calcBlockKey(int b);

		abstract byte[] calcDemoBlock(int key);

		RMQStatic.DataStructure build() {
<span class="fc" id="L180">			return new DataStructure(this);</span>
		}

	}

	private static class DataStructure extends DsBase implements RMQStatic.DataStructure {

<span class="fc" id="L187">		DataStructure(RMQStaticLinearAbstract.PreProcessor ds) {</span>
<span class="fc" id="L188">			n = ds.n;</span>
<span class="fc" id="L189">			blockSize = ds.blockSize;</span>
<span class="fc" id="L190">			blocksRightLeftMinimum = ds.blocksRightLeftMinimum;</span>
<span class="fc" id="L191">			xlogxTableDS = ds.xlogxTableDS;</span>
<span class="fc" id="L192">			blockToInnerIdx = ds.blockToInnerIdx;</span>
<span class="fc" id="L193">			innerBlocks = ds.innerBlocks;</span>
<span class="fc" id="L194">			cmpOrig = ds.cmpOrig;</span>
<span class="fc" id="L195">		}</span>

		@Override
		public int findMinimumInRange(int i, int j) {
<span class="pc bpc" id="L199" title="3 of 6 branches missed.">			if (!(0 &lt;= i &amp;&amp; i &lt;= j &amp;&amp; j &lt; n))</span>
<span class="nc" id="L200">				throw new IllegalArgumentException(&quot;Illegal indices [&quot; + i + &quot;,&quot; + j + &quot;]&quot;);</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">			if (i == j)</span>
<span class="fc" id="L202">				return i;</span>

<span class="fc" id="L204">			int blk0 = i / blockSize;</span>
<span class="fc" id="L205">			int blk1 = j / blockSize;</span>
<span class="fc" id="L206">			int innerI = i % blockSize;</span>
<span class="fc" id="L207">			int innerJ = j % blockSize;</span>

<span class="fc bfc" id="L209" title="All 2 branches covered.">			if (blk0 != blk1) {</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">				int blk0min = blk0 * blockSize + (innerI == blockSize - 1 ? innerI : blockRightMinimum(blk0, innerI));</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">				int blk1min = blk1 * blockSize + (innerJ == 0 ? innerJ : blockLeftMinimum(blk1, innerJ - 1));</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">				int min = cmpOrig.compare(blk0min, blk1min) &lt; 0 ? blk0min : blk1min;</span>

<span class="fc bfc" id="L214" title="All 2 branches covered.">				if (blk0 + 1 != blk1) {</span>
<span class="fc" id="L215">					int middleBlk = xlogxTableDS.findMinimumInRange(blk0 + 1, blk1 - 1);</span>
<span class="fc" id="L216">					int middleMin = middleBlk * blockSize + blockMinimum(middleBlk);</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">					min = cmpOrig.compare(min, middleMin) &lt; 0 ? min : middleMin;</span>
				}

<span class="fc" id="L220">				return min;</span>
			} else {
<span class="fc" id="L222">				return calcRMQInnerBlock(blk0, innerI, innerJ);</span>
			}

		}

		int calcRMQInnerBlock(int block, int i, int j) {
<span class="fc" id="L228">			int r = block * blockSize;</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">			if (i == j)</span>
<span class="nc" id="L230">				return r + i;</span>
<span class="fc" id="L231">			int innerBlock = blockToInnerIdx[block];</span>
<span class="fc" id="L232">			return r + innerBlocks[innerBlockIndex(innerBlock, i, j)];</span>
		}

		@Override
		public long sizeInBytes() {
<span class="nc" id="L237">			long s = 0;</span>
<span class="nc" id="L238">			s += 4; // n</span>
<span class="nc" id="L239">			s += 4; // blockSize</span>
<span class="nc" id="L240">			s += 8 + blocksRightLeftMinimum.length;</span>
<span class="nc" id="L241">			s += 8 + xlogxTableDS.sizeInBytes();</span>
<span class="nc" id="L242">			s += 8 + 4 * blockToInnerIdx.length;</span>
<span class="nc" id="L243">			s += 8 + innerBlocks.length;</span>
<span class="nc" id="L244">			s += 8; // cmp</span>
<span class="nc" id="L245">			return s;</span>
		}

	}

	private static class DsBase {

		int n;
		int blockSize;
		byte[] blocksRightLeftMinimum;
		RMQStatic.DataStructure xlogxTableDS;
		int[] blockToInnerIdx;
		byte[] innerBlocks;
		RMQStaticComparator cmpOrig;

		int blockMinimum(int block) {
<span class="fc" id="L261">			return blockRightMinimum(block, 0);</span>
		}

		int blockRightMinimum(int block, int i) {
<span class="fc" id="L265">			return blocksRightLeftMinimum[(block * (blockSize - 1) + i) * 2 + 0];</span>
		}

		int blockLeftMinimum(int block, int i) {
<span class="fc" id="L269">			return blocksRightLeftMinimum[(block * (blockSize - 1) + i) * 2 + 1];</span>
		}

		void blockRightMinimum(int block, int i, byte val) {
<span class="fc" id="L273">			blocksRightLeftMinimum[(block * (blockSize - 1) + i) * 2 + 0] = val;</span>
<span class="fc" id="L274">		}</span>

		void blockLeftMinimum(int block, int i, byte val) {
<span class="fc" id="L277">			blocksRightLeftMinimum[(block * (blockSize - 1) + i) * 2 + 1] = val;</span>
<span class="fc" id="L278">		}</span>

		int innerBlockIndex(int innerBlock, int i, int j) {
<span class="fc" id="L281">			int innerIdx = (2 * blockSize - i - 1) * i / 2 + j - i - 1;</span>
<span class="fc" id="L282">			return innerBlock * innerBlockAllocSize() + innerIdx;</span>
		}

		int innerBlockAllocSize() {
<span class="fc" id="L286">			return blockSize * (blockSize - 1) / 2;</span>
		}

	}

	private static class PaddedComparator implements RMQStaticComparator {

		final int n;
		final RMQStaticComparator c;

<span class="fc" id="L296">		PaddedComparator(int n, RMQStaticComparator c) {</span>
<span class="fc" id="L297">			this.n = n;</span>
<span class="fc" id="L298">			this.c = c;</span>
<span class="fc" id="L299">		}</span>

		@Override
		public int compare(int i, int j) {
<span class="fc bfc" id="L303" title="All 4 branches covered.">			if (i &lt; n &amp;&amp; j &lt; n)</span>
<span class="fc" id="L304">				return c.compare(i, j);</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">			return i &gt;= n ? 1 : -1;</span>
		}

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>