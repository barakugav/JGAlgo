<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RMQStaticLinearAbstract.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.internal.ds</a> &gt; <span class="el_source">RMQStaticLinearAbstract.java</span></div><h1>RMQStaticLinearAbstract.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jgalgo.internal.ds;

import com.jgalgo.internal.util.Bitmap;
import it.unimi.dsi.fastutil.bytes.Byte2IntMap;
import it.unimi.dsi.fastutil.bytes.Byte2IntOpenHashMap;
import it.unimi.dsi.fastutil.ints.Int2IntMap;
import it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap;
import it.unimi.dsi.fastutil.shorts.Short2IntMap;
import it.unimi.dsi.fastutil.shorts.Short2IntOpenHashMap;

<span class="fc" id="L27">abstract class RMQStaticLinearAbstract implements RMQStatic {</span>

	/*
	 * This implementation divides the elements sequence into blocks, for each block calculate the minimum in the block
	 * and the minimum within the block from each index to the borders of the block. In addition, we use the \(O(x \log
	 * x)\) implementation on the minimum values from each block (which we have less than n).
	 *
	 * To answer a query, if the two indices are not in the same block, we check the minimum from i to the end of the
	 * block, from j to the end of the block, and the minimum along all the blocks between them. If the two elements are
	 * not in the same block we have no implementation, and the implementations that extends this class will implement
	 * it in different methods.
	 *
	 * \(O(n)\) pre processing time, \(O(n)\) space, \(O(1)\) query.
	 */

<span class="fc" id="L42">	private final RMQStatic outerRMQ = new RMQStaticPowerOf2Table();</span>

	abstract class PreProcessor extends DsBase {

		final RMQStaticComparator cmpPadded;
		final int blockNum;

<span class="fc" id="L49">		PreProcessor(RMQStaticComparator c, int n) {</span>
<span class="fc" id="L50">			this.n = n;</span>
<span class="fc" id="L51">			blockSize = getBlockSize(n);</span>
<span class="fc" id="L52">			blockNum = (int) Math.ceil((double) n / blockSize);</span>
<span class="fc" id="L53">			this.cmpOrig = c;</span>
<span class="fc bfc" id="L54" title="All 2 branches covered.">			this.cmpPadded = n &lt; blockNum * blockSize ? new PaddedComparator(n, c) : c;</span>
<span class="fc" id="L55">			blocksRightLeftMinimum = new byte[blockNum * (blockSize - 1) * 2];</span>

<span class="fc bfc" id="L57" title="All 2 branches covered.">			for (int b = 0; b &lt; blockNum; b++) {</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">				c = b &lt; blockNum - 1 ? cmpOrig : cmpPadded;</span>
<span class="fc" id="L59">				int base = b * blockSize;</span>

<span class="fc" id="L61">				byte min = 0;</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">				for (byte i = 0; i &lt; blockSize - 1; i++) {</span>
<span class="fc bfc" id="L63" title="All 2 branches covered.">					if (c.compare(base + i + 1, base + min) &lt; 0)</span>
<span class="fc" id="L64">						min = (byte) (i + 1);</span>
<span class="fc" id="L65">					blockLeftMinimum(b, i, min);</span>
				}

<span class="fc" id="L68">				min = (byte) (blockSize - 1);</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">				for (byte i = (byte) (blockSize - 2); i &gt;= 0; i--) {</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">					if (c.compare(base + i, base + min) &lt; 0)</span>
<span class="fc" id="L71">						min = i;</span>
<span class="fc" id="L72">					blockRightMinimum(b, i, min);</span>
				}
			}

<span class="fc" id="L76">			xlogxTableDS = outerRMQ.preProcessSequence(</span>
<span class="fc" id="L77">					(i, j) -&gt; cmpOrig.compare(i * blockSize + blockMinimum(i), j * blockSize + blockMinimum(j)),</span>
					blockNum);

<span class="fc" id="L80">		}</span>

		void preProcessInnerBlocks() {
<span class="fc" id="L83">			int keySize = getBlockKeySize();</span>
<span class="fc" id="L84">			var innerBlocksIdx = new Object() {</span>
<span class="fc" id="L85">				int val = 0;</span>
			};
<span class="fc" id="L87">			blockToInnerIdx = new int[blockNum];</span>
<span class="fc" id="L88">			final int innerBlockAllocSize = blockSize * (blockSize - 1) / 2;</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">			if (keySize &lt; Byte.SIZE) {</span>
<span class="fc" id="L90">				Byte2IntMap tables = new Byte2IntOpenHashMap();</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">				for (int b = 0; b &lt; blockNum; b++) {</span>
<span class="fc" id="L92">					byte key = (byte) calcBlockKey(b);</span>
<span class="fc" id="L93">					blockToInnerIdx[b] = key;</span>
<span class="fc" id="L94">					tables.computeIfAbsent(key, k -&gt; innerBlocksIdx.val++);</span>
				}
<span class="fc" id="L96">				final int innerBlockNum = tables.size();</span>
<span class="fc" id="L97">				Bitmap builtInnerBlocks = new Bitmap(innerBlockNum);</span>
<span class="fc" id="L98">				innerBlocks = new byte[innerBlockNum * innerBlockAllocSize];</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">				for (int b = 0; b &lt; blockNum; b++) {</span>
<span class="fc" id="L100">					byte key = (byte) blockToInnerIdx[b];</span>
<span class="fc" id="L101">					int innerIdx = tables.get(key);</span>
<span class="fc" id="L102">					blockToInnerIdx[b] = innerIdx;</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">					if (!builtInnerBlocks.get(innerIdx)) {</span>
<span class="fc" id="L104">						byte[] demoBlock = calcDemoBlock(key &amp; 0xff);</span>
<span class="fc" id="L105">						buildInnerBlock(innerIdx, demoBlock);</span>
<span class="fc" id="L106">						builtInnerBlocks.set(innerIdx);</span>
					}
				}
<span class="fc" id="L109">				tables.clear();</span>

<span class="pc bpc" id="L111" title="1 of 2 branches missed.">			} else if (keySize &lt; Short.SIZE) {</span>
<span class="fc" id="L112">				Short2IntMap tables = new Short2IntOpenHashMap();</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">				for (int b = 0; b &lt; blockNum; b++) {</span>
<span class="fc" id="L114">					short key = (short) calcBlockKey(b);</span>
<span class="fc" id="L115">					blockToInnerIdx[b] = key;</span>
<span class="fc" id="L116">					tables.computeIfAbsent(key, k -&gt; innerBlocksIdx.val++);</span>
				}
<span class="fc" id="L118">				final int innerBlockNum = tables.size();</span>
<span class="fc" id="L119">				Bitmap builtInnerBlocks = new Bitmap(innerBlockNum);</span>
<span class="fc" id="L120">				innerBlocks = new byte[innerBlockNum * innerBlockAllocSize];</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">				for (int b = 0; b &lt; blockNum; b++) {</span>
<span class="fc" id="L122">					short key = (short) blockToInnerIdx[b];</span>
<span class="fc" id="L123">					int innerIdx = tables.get(key);</span>
<span class="fc" id="L124">					blockToInnerIdx[b] = innerIdx;</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">					if (!builtInnerBlocks.get(innerIdx)) {</span>
<span class="fc" id="L126">						byte[] demoBlock = calcDemoBlock(key &amp; 0xffff);</span>
<span class="fc" id="L127">						buildInnerBlock(innerIdx, demoBlock);</span>
<span class="fc" id="L128">						builtInnerBlocks.set(innerIdx);</span>
					}
				}
<span class="fc" id="L131">				tables.clear();</span>

<span class="fc" id="L133">			} else {</span>
<span class="nc" id="L134">				Int2IntMap tables = new Int2IntOpenHashMap();</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">				for (int b = 0; b &lt; blockNum; b++) {</span>
<span class="nc" id="L136">					int key = calcBlockKey(b);</span>
<span class="nc" id="L137">					blockToInnerIdx[b] = key;</span>
<span class="nc" id="L138">					tables.computeIfAbsent(key, k -&gt; innerBlocksIdx.val++);</span>
				}
<span class="nc" id="L140">				final int innerBlockNum = tables.size();</span>
<span class="nc" id="L141">				Bitmap builtInnerBlocks = new Bitmap(innerBlockNum);</span>
<span class="nc" id="L142">				innerBlocks = new byte[innerBlockNum * innerBlockAllocSize];</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">				for (int b = 0; b &lt; blockNum; b++) {</span>
<span class="nc" id="L144">					int key = blockToInnerIdx[b];</span>
<span class="nc" id="L145">					int innerIdx = tables.get(key);</span>
<span class="nc" id="L146">					blockToInnerIdx[b] = innerIdx;</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">					if (!builtInnerBlocks.get(innerIdx)) {</span>
<span class="nc" id="L148">						byte[] demoBlock = calcDemoBlock(key);</span>
<span class="nc" id="L149">						buildInnerBlock(innerIdx, demoBlock);</span>
<span class="nc" id="L150">						builtInnerBlocks.set(innerIdx);</span>
					}
				}
<span class="nc" id="L153">				tables.clear();</span>
			}
<span class="fc" id="L155">		}</span>

		private void buildInnerBlock(int innerBlock, byte[] demoBlock) {
<span class="fc" id="L158">			byte[] arr = innerBlocks;</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">			for (byte i = 0; i &lt; blockSize - 1; i++)</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">				arr[innerBlockIndex(innerBlock, i, i + 1)] = demoBlock[i] &lt; demoBlock[i + 1] ? i : (byte) (i + 1);</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">			for (byte i = 0; i &lt; blockSize - 2; i++) {</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">				for (byte j = (byte) (i + 2); j &lt; blockSize; j++) {</span>
<span class="fc" id="L163">					byte m = arr[innerBlockIndex(innerBlock, i, j - 1)];</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">					arr[innerBlockIndex(innerBlock, i, j)] = demoBlock[m] &lt; demoBlock[j] ? m : j;</span>
				}
			}
<span class="fc" id="L167">		}</span>

		abstract byte getBlockSize(int n);

		abstract int getBlockKeySize();

		abstract int calcBlockKey(int b);

		abstract byte[] calcDemoBlock(int key);

		RMQStatic.DataStructure build() {
<span class="fc" id="L178">			return new DataStructure(this);</span>
		}

	}

	private static class DataStructure extends DsBase implements RMQStatic.DataStructure {

<span class="fc" id="L185">		DataStructure(RMQStaticLinearAbstract.PreProcessor ds) {</span>
<span class="fc" id="L186">			n = ds.n;</span>
<span class="fc" id="L187">			blockSize = ds.blockSize;</span>
<span class="fc" id="L188">			blocksRightLeftMinimum = ds.blocksRightLeftMinimum;</span>
<span class="fc" id="L189">			xlogxTableDS = ds.xlogxTableDS;</span>
<span class="fc" id="L190">			blockToInnerIdx = ds.blockToInnerIdx;</span>
<span class="fc" id="L191">			innerBlocks = ds.innerBlocks;</span>
<span class="fc" id="L192">			cmpOrig = ds.cmpOrig;</span>
<span class="fc" id="L193">		}</span>

		@Override
		public int findMinimumInRange(int i, int j) {
<span class="fc" id="L197">			RMQStatics.checkIndices(i, j, n);</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">			if (i == j)</span>
<span class="fc" id="L199">				return i;</span>

<span class="fc" id="L201">			int blk0 = i / blockSize;</span>
<span class="fc" id="L202">			int blk1 = j / blockSize;</span>
<span class="fc" id="L203">			int innerI = i % blockSize;</span>
<span class="fc" id="L204">			int innerJ = j % blockSize;</span>

<span class="fc bfc" id="L206" title="All 2 branches covered.">			if (blk0 != blk1) {</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">				int blk0min = blk0 * blockSize + (innerI == blockSize - 1 ? innerI : blockRightMinimum(blk0, innerI));</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">				int blk1min = blk1 * blockSize + (innerJ == 0 ? innerJ : blockLeftMinimum(blk1, innerJ - 1));</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">				int min = cmpOrig.compare(blk0min, blk1min) &lt; 0 ? blk0min : blk1min;</span>

<span class="fc bfc" id="L211" title="All 2 branches covered.">				if (blk0 + 1 != blk1) {</span>
<span class="fc" id="L212">					int middleBlk = xlogxTableDS.findMinimumInRange(blk0 + 1, blk1 - 1);</span>
<span class="fc" id="L213">					int middleMin = middleBlk * blockSize + blockMinimum(middleBlk);</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">					min = cmpOrig.compare(min, middleMin) &lt; 0 ? min : middleMin;</span>
				}

<span class="fc" id="L217">				return min;</span>
			} else {
<span class="fc" id="L219">				return calcRMQInnerBlock(blk0, innerI, innerJ);</span>
			}

		}

		int calcRMQInnerBlock(int block, int i, int j) {
<span class="fc" id="L225">			int r = block * blockSize;</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">			if (i == j)</span>
<span class="nc" id="L227">				return r + i;</span>
<span class="fc" id="L228">			int innerBlock = blockToInnerIdx[block];</span>
<span class="fc" id="L229">			return r + innerBlocks[innerBlockIndex(innerBlock, i, j)];</span>
		}

		@Override
		public long sizeInBytes() {
<span class="nc" id="L234">			long s = 0;</span>
<span class="nc" id="L235">			s += 4; // n</span>
<span class="nc" id="L236">			s += 4; // blockSize</span>
<span class="nc" id="L237">			s += 8 + blocksRightLeftMinimum.length;</span>
<span class="nc" id="L238">			s += 8 + xlogxTableDS.sizeInBytes();</span>
<span class="nc" id="L239">			s += 8 + 4 * blockToInnerIdx.length;</span>
<span class="nc" id="L240">			s += 8 + innerBlocks.length;</span>
<span class="nc" id="L241">			s += 8; // cmp</span>
<span class="nc" id="L242">			return s;</span>
		}

	}

	private static class DsBase {

		int n;
		int blockSize;
		byte[] blocksRightLeftMinimum;
		RMQStatic.DataStructure xlogxTableDS;
		int[] blockToInnerIdx;
		byte[] innerBlocks;
		RMQStaticComparator cmpOrig;

		int blockMinimum(int block) {
<span class="fc" id="L258">			return blockRightMinimum(block, 0);</span>
		}

		int blockRightMinimum(int block, int i) {
<span class="fc" id="L262">			return blocksRightLeftMinimum[(block * (blockSize - 1) + i) * 2 + 0];</span>
		}

		int blockLeftMinimum(int block, int i) {
<span class="fc" id="L266">			return blocksRightLeftMinimum[(block * (blockSize - 1) + i) * 2 + 1];</span>
		}

		void blockRightMinimum(int block, int i, byte val) {
<span class="fc" id="L270">			blocksRightLeftMinimum[(block * (blockSize - 1) + i) * 2 + 0] = val;</span>
<span class="fc" id="L271">		}</span>

		void blockLeftMinimum(int block, int i, byte val) {
<span class="fc" id="L274">			blocksRightLeftMinimum[(block * (blockSize - 1) + i) * 2 + 1] = val;</span>
<span class="fc" id="L275">		}</span>

		int innerBlockIndex(int innerBlock, int i, int j) {
<span class="fc" id="L278">			int innerIdx = (2 * blockSize - i - 1) * i / 2 + j - i - 1;</span>
<span class="fc" id="L279">			return innerBlock * innerBlockAllocSize() + innerIdx;</span>
		}

		int innerBlockAllocSize() {
<span class="fc" id="L283">			return blockSize * (blockSize - 1) / 2;</span>
		}

	}

	private static class PaddedComparator implements RMQStaticComparator {

		final int n;
		final RMQStaticComparator c;

<span class="fc" id="L293">		PaddedComparator(int n, RMQStaticComparator c) {</span>
<span class="fc" id="L294">			this.n = n;</span>
<span class="fc" id="L295">			this.c = c;</span>
<span class="fc" id="L296">		}</span>

		@Override
		public int compare(int i, int j) {
<span class="fc bfc" id="L300" title="All 4 branches covered.">			if (i &lt; n &amp;&amp; j &lt; n)</span>
<span class="fc" id="L301">				return c.compare(i, j);</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">			return i &gt;= n ? 1 : -1;</span>
		}

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>