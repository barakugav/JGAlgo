<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UnionGraphGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.gen</a> &gt; <span class="el_source">UnionGraphGenerator.java</span></div><h1>UnionGraphGenerator.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.gen;

import static com.jgalgo.internal.util.Range.range;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.OptionalInt;
import java.util.Set;
import java.util.function.ToLongBiFunction;
import com.jgalgo.graph.Graph;
import com.jgalgo.graph.GraphBuilder;
import com.jgalgo.graph.GraphFactory;
import com.jgalgo.graph.Graphs;
import com.jgalgo.graph.IEdgeIter;
import com.jgalgo.graph.IndexGraph;
import com.jgalgo.graph.IndexIdMap;
import com.jgalgo.graph.IntGraph;
import com.jgalgo.graph.IntGraphFactory;
import com.jgalgo.graph.Weights;
import com.jgalgo.graph.WeightsBool;
import com.jgalgo.graph.WeightsByte;
import com.jgalgo.graph.WeightsChar;
import com.jgalgo.graph.WeightsDouble;
import com.jgalgo.graph.WeightsFloat;
import com.jgalgo.graph.WeightsInt;
import com.jgalgo.graph.WeightsLong;
import com.jgalgo.graph.WeightsObj;
import com.jgalgo.graph.WeightsShort;
import com.jgalgo.internal.util.Bitmap;
import com.jgalgo.internal.util.IntPair;
import com.jgalgo.internal.util.IterTools;
import it.unimi.dsi.fastutil.longs.Long2IntMap;
import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
import it.unimi.dsi.fastutil.longs.LongArrayList;
import it.unimi.dsi.fastutil.longs.LongList;
import it.unimi.dsi.fastutil.objects.Object2IntMap;
import it.unimi.dsi.fastutil.objects.Object2IntMaps;
import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
import it.unimi.dsi.fastutil.objects.ObjectList;

/**
 * Generate the union graph of two or more given graphs.
 *
 * &lt;p&gt;
 * The union graph of two graphs is a graph with all the vertices and edges from both graphs, without duplications. The
 * set of vertices in the union graph is the union of the sets of vertices in the input graphs, as defined in sets
 * theory. As for the edges, there are two ways to define the union:
 * &lt;ul&gt;
 * &lt;li&gt;Union by id: each edge is identified by its id. All edges of the two graphs are added to the union graph, and if
 * an edge with the same id exist in both graph, it must have the same endpoints in both graphs. Otherwise, an exception
 * is thrown. See {@link #edgeUnionById()} for more details.&lt;/li&gt;
 * &lt;li&gt;Union by endpoints: Each edge is identified by its endpoints. If an edge with the same endpoints exists in both
 * graphs, it is added to the union graph only once. The edges are added by the order of the input graphs, and the first
 * edge of each equivalent class of endpoints determine the identifier of the edge in the generated graph(s). The input
 * graphs must not contains parallel edges. See {@link #edgeUnionByEndpoints()} for more details.&lt;/li&gt;
 * &lt;/ul&gt;
 * The above rules generalize to union of more than two graphs.
 *
 * &lt;p&gt;
 * By default, the edges union is by id. Use {@link #edgeUnionByEndpoints()} and {@link #edgeUnionById()} to change the
 * union of edges.
 *
 * &lt;p&gt;
 * Weights are not copied by default. Use {@link #copyWeights(boolean, boolean)} to copy the vertices/edges weights.
 *
 * @param  &lt;V&gt; the vertices type
 * @param  &lt;E&gt; the edges type
 * @author     Barak Ugav
 */
public class UnionGraphGenerator&lt;V, E&gt; implements GraphGenerator&lt;V, E&gt; {

	private final GraphFactory&lt;V, E&gt; factory;
	private final List&lt;Graph&lt;V, E&gt;&gt; graphs;
<span class="fc" id="L94">	private boolean unionById = true;</span>
	private boolean verticesWeights, edgesWeights;
	private Set&lt;String&gt; verticesWeightsKeys, edgesWeightsKeys;

	/**
	 * Create a new union graph generator that will use the default graph factory.
	 */
	public UnionGraphGenerator() {
<span class="fc" id="L102">		this(GraphFactory.undirected());</span>
<span class="fc" id="L103">	}</span>

	/**
	 * Create a new union graph generator that will use the given graph factory.
	 *
	 * &lt;p&gt;
	 * The graph factory will be used to create the generated graph(s).
	 *
	 * &lt;p&gt;
	 * To generate {@linkplain IntGraph int graphs}, pass an instance of {@linkplain IntGraphFactory} to this
	 * constructor.
	 *
	 * @param factory the graph factory that will be used to create the generated graph(s)
	 */
<span class="fc" id="L117">	public UnionGraphGenerator(GraphFactory&lt;V, E&gt; factory) {</span>
<span class="fc" id="L118">		this.factory = Objects.requireNonNull(factory);</span>
<span class="fc" id="L119">		graphs = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L120">	}</span>

	/**
	 * Get the graph factory that will be used to create the generated graph(s).
	 *
	 * &lt;p&gt;
	 * It's possible to customize the factory before generating the graph(s), for example by using
	 * {@link GraphFactory#addHint(GraphFactory.Hint)} to optimize the generated graph(s) for a specific algorithm.
	 *
	 * &lt;p&gt;
	 * During the graph(s) generation, the method {@link GraphFactory#setDirected(boolean)} of the given factory will be
	 * called to align the created graph with the generator configuration. If one of the input graphs have self edges,
	 * the method {@link GraphFactory#allowSelfEdges()} will be called. If one of the input graphs have parallel edges,
	 * or if two edges with the same endpoints and different identifiers exist in the input graphs, the method
	 * {@link GraphFactory#allowParallelEdges()} will be called. Note that parallel edges are not allowed (in each input
	 * graph independently) when union by endpoints is used (see {@link #edgeUnionByEndpoints()}).
	 *
	 * @return the graph factory that will be used to create the generated graph(s)
	 */
	public GraphFactory&lt;V, E&gt; graphFactory() {
<span class="fc" id="L140">		return factory;</span>
	}

	/**
	 * Set the input graphs whose union graph will be generated.
	 *
	 * &lt;p&gt;
	 * Given two or more graphs, the union graph of the graphs is a graph with all the vertices and edges from all the
	 * graphs, without duplications. The set of vertices in the union graph is the union of the sets of vertices in the
	 * input graphs, as defined in sets theory. As for the edges, the union can be done by the
	 * {@linkplain #edgeUnionById() edges identifiers}, or by the {@linkplain #edgeUnionByEndpoints() edges endpoints}
	 * (see the documentation of these methods for more details).
	 *
	 * @param  graphs                   the input graphs
	 * @return                          this generator
	 * @throws IllegalArgumentException if less than two input graphs are provided, or if the graphs have different
	 *                                      directionality
	 */
	public UnionGraphGenerator&lt;V, E&gt; graphs(Collection&lt;? extends Graph&lt;V, E&gt;&gt; graphs) {
<span class="fc bfc" id="L159" title="All 2 branches covered.">		if (graphs.size() &lt; 2)</span>
<span class="fc" id="L160">			throw new IllegalArgumentException(&quot;At least two graphs must be provided&quot;);</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">		if (graphs.stream().map(Graph::isDirected).distinct().count() != 1)</span>
<span class="fc" id="L162">			throw new IllegalArgumentException(&quot;Input graphs must have the same directionality&quot;);</span>
<span class="fc" id="L163">		this.graphs.clear();</span>
<span class="fc" id="L164">		this.graphs.addAll(graphs);</span>
<span class="fc" id="L165">		return this;</span>
	}

	/**
	 * Set the input graphs whose union graph will be generated (variable arguments version).
	 *
	 * &lt;p&gt;
	 * Given two or more graphs, the union graph of the graphs is a graph with all the vertices and edges from all the
	 * graphs, without duplications. The set of vertices in the union graph is the union of the sets of vertices in the
	 * input graphs, as defined in sets theory. As for the edges, the union can be done by the
	 * {@linkplain #edgeUnionById() edges identifiers}, or by the {@linkplain #edgeUnionByEndpoints() edges endpoints}
	 * (see the documentation of these methods for more details).
	 *
	 * @param  graphs                   the input graphs
	 * @return                          this generator
	 * @throws IllegalArgumentException if less than two input graphs are provided, or if the graphs have different
	 *                                      directionality
	 */
	@SafeVarargs
	public final UnionGraphGenerator&lt;V, E&gt; graphs(Graph&lt;V, E&gt;... graphs) {
<span class="fc" id="L185">		return graphs(ObjectList.of(graphs));</span>
	}

	/**
	 * Set the union of edges to be by the edges identifiers.
	 *
	 * &lt;p&gt;
	 * The union graph of two or more graphs using this method is a graph with all the vertex set that is the union of
	 * the vertex sets of the input graphs, and edge set constructed as follows: for each edge in the input graphs, if
	 * the edge identifier does not exist in the union graph, it is added to the union graph. If the edge identifier
	 * exists in the union graph, it must have the same endpoints in the input graphs and in the union graph. Otherwise,
	 * an exception is thrown.
	 *
	 * &lt;p&gt;
	 * A call to this method override a previous call to {@link #edgeUnionByEndpoints()}. By default, the union of edges
	 * is by id.
	 *
	 * &lt;p&gt;
	 * Self edges may be generated if one of the input graphs have self edges. Parallel edges may be generated if one of
	 * the input graphs have parallel edges, or if two edges with the same endpoints and different identifiers exist in
	 * the input graphs.
	 *
	 * &lt;p&gt;
	 * In the following example two directed graphs are created, and the union graph of the two graphs is generated by
	 * the edges identifiers:
	 *
	 * &lt;pre&gt; {@code
	 * Graph&lt;String, Integer&gt; graph1 = Graph.newDirected();
	 * graph1.addVertices(List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;));
	 * graph1.addEdge(&quot;A&quot;, &quot;B&quot;, 1);
	 * graph1.addEdge(&quot;A&quot;, &quot;C&quot;, 2);
	 *
	 * Graph&lt;String, Integer&gt; graph2 = Graph.newDirected();
	 * graph2.addVertices(List.of(&quot;A&quot;, &quot;B&quot;, &quot;D&quot;));
	 * graph2.addEdge(&quot;A&quot;, &quot;B&quot;, 1);
	 * graph2.addEdge(&quot;A&quot;, &quot;D&quot;, 5);
	 *
	 * Graph&lt;String, Integer&gt; unionGraph = new UnionGraphGenerator&lt;String, Integer&gt;()
	 * 		.graphs(graph1, graph2)
	 * 		.edgeUnionById() // override previous call to edgeUnionByEndpoints() if have been called
	 * 		.generate();
	 * assert Set.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;).equals(unionGraph.vertices());
	 * assert Set.of(1, 2, 5).equals(unionGraph.edges());
	 * assert unionGraph.edgeSource(1).equals(&quot;A&quot;) &amp;&amp; unionGraph.edgeTarget(1).equals(&quot;B&quot;);
	 * assert unionGraph.edgeSource(2).equals(&quot;A&quot;) &amp;&amp; unionGraph.edgeTarget(2).equals(&quot;C&quot;);
	 * assert unionGraph.edgeSource(5).equals(&quot;A&quot;) &amp;&amp; unionGraph.edgeTarget(5).equals(&quot;D&quot;);
	 * }&lt;/pre&gt;
	 *
	 * @return this generator
	 */
	public UnionGraphGenerator&lt;V, E&gt; edgeUnionById() {
<span class="fc" id="L236">		unionById = true;</span>
<span class="fc" id="L237">		return this;</span>
	}

	/**
	 * Set the union of edges to be by the edges endpoints.
	 *
	 * &lt;p&gt;
	 * The union graph of two or more graphs using this method is a graph with all the vertex set that is the union of
	 * the vertex sets of the input graphs, and edge set constructed as follows: for each edge in the input graphs, if
	 * no edge with the same endpoints exist in the union graph, it is added to the union graph, with the same
	 * identifier. If an edge with the same endpoints exists in the union graph, it is not added to the union graph.
	 *
	 * &lt;p&gt;
	 * The input graphs must not contains parallel edges. If one of the input graphs contains parallel edges, an
	 * exception is thrown during the graph(s) generation. Self edges may be generated if one of the input graphs have
	 * self edges. Parallel edges are never generated when union by endpoints is used.
	 *
	 * &lt;p&gt;
	 * A call to this method override a previous call to {@link #edgeUnionById()}. By default, the union of edges is by
	 * id.
	 *
	 * &lt;p&gt;
	 * In the following example two directed graphs are created, and the union graph of the two graphs is generated by
	 * the edges endpoints. Note that the edge \(A, B\) exists in both graphs, but with different identifiers. In the
	 * generated graph, the edge \(A, B\) will appear only once, with identifier from the first graph:
	 *
	 * &lt;pre&gt; {@code
	 * Graph&lt;String, Integer&gt; graph1 = Graph.newDirected();
	 * graph1.addVertices(List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;));
	 * graph1.addEdge(&quot;A&quot;, &quot;B&quot;, 10);
	 * graph1.addEdge(&quot;A&quot;, &quot;C&quot;, 20);
	 *
	 * Graph&lt;String, Integer&gt; graph2 = Graph.newDirected();
	 * graph2.addVertices(List.of(&quot;A&quot;, &quot;B&quot;, &quot;D&quot;));
	 * graph2.addEdge(&quot;A&quot;, &quot;B&quot;, 50);
	 * graph2.addEdge(&quot;A&quot;, &quot;D&quot;, 100);
	 *
	 * Graph&lt;String, Integer&gt; unionGraph = new UnionGraphGenerator&lt;String, Integer&gt;()
	 * 		.graphs(graph1, graph2)
	 * 		.edgeUnionByEndpoints() // override previous call to edgeUnionById() if have been called
	 * 		.generate();
	 * assert Set.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;).equals(unionGraph.vertices());
	 * assert Set.of(10, 20, 100).equals(unionGraph.edges());
	 * assert unionGraph.edgeSource(10).equals(&quot;A&quot;) &amp;&amp; unionGraph.edgeTarget(10).equals(&quot;B&quot;);
	 * assert unionGraph.edgeSource(20).equals(&quot;A&quot;) &amp;&amp; unionGraph.edgeTarget(20).equals(&quot;C&quot;);
	 * assert unionGraph.edgeSource(100).equals(&quot;A&quot;) &amp;&amp; unionGraph.edgeTarget(100).equals(&quot;D&quot;);
	 * }&lt;/pre&gt;
	 *
	 * @return this generator
	 */
	public UnionGraphGenerator&lt;V, E&gt; edgeUnionByEndpoints() {
<span class="fc" id="L288">		unionById = false;</span>
<span class="fc" id="L289">		return this;</span>
	}

	/**
	 * Determine if the vertices/edges weights will be copied from the input graphs to the generated graph(s).
	 *
	 * &lt;p&gt;
	 * When creating a union of two graphs, where both input graphs have exactly the same weights, and there are no
	 * duplicate vertices and edges (the sets of vertices (edges) are disjoint), we simply copy the weights from the
	 * input graphs to the generated graph. However, when there are duplicate vertices and/or edges, or when the input
	 * graphs have different weights, we need to decide how to copy the weights to the generated graph. To define the
	 * rules, we first define the &lt;i&gt;equivalence class&lt;/i&gt; of a vertex (edge) \(v\) in the generated graph as the set of
	 * vertices (edges) in the input graphs that are mapped to \(v\). These are the vertices with the same identifier
	 * across the input graphs. The equivalence class of an edge \(e=(u,v)\) depends on the union of edges rule: if the
	 * union of edges is by id, the equivalence class is the set of edges in the input graphs with the same identifier
	 * as \(e\). If the union of edges is by endpoints, the equivalence class is the set of edges in the input graphs
	 * with the endpoints as \((u,v)\). Given the definition of the equivalence class, we define the rules for copying
	 * the weights of each vertex (edge) \(v\) as follows: We examine the equivalence class of \(v\) ordered by the
	 * order of the input graphs. For each vertex (edge) \(v_i\) in the equivalence class, if it has a weight keyed by a
	 * key not yet seen in the equivalence class, we copy the weight to \(v\), else we ignore it. Note that we do not
	 * distinguish between {@linkplain Weights#defaultWeightAsObj() default weights} and user set weights, as long as
	 * the graph containing \(v_i\) have the weights we consider it as \(v_i\) having the weight. For each weights type
	 * in the generated graph(s), the default weight is the default weight of the first input graph that have this
	 * weights type.
	 *
	 * &lt;p&gt;
	 * By default, the vertices/edges weights are not copied. By default, if the vertices/edges weights are copied, all
	 * the weights are copied. Use {@link #verticesWeightsKeys(Set)} and {@link #edgesWeightsKeys(Set)} to copy only
	 * specific weights.
	 *
	 * &lt;p&gt;
	 * In the following example, two directed graphs are created, both have a vertices weights keyed by &quot;w1&quot;, but with
	 * different default weights. The union graph of the two graphs is generated, and the vertices weights are copied
	 * from the input graphs. The default weight of the vertices weights in the generated graph is the default weight of
	 * the first input graph that have this weights type. Vertex \(0\) exists in both graphs, so its weight is copied
	 * from the first graph. Vertex \(1\) exists only in the second graph, so its weight is copied from the second
	 * graph:
	 *
	 * &lt;pre&gt; {@code
	 * Graph&lt;Integer, Integer&gt; graph1 = Graph.newDirected();
	 * WeightsInt&lt;Integer&gt; g1_w1 = graph1.addVerticesWeights(&quot;w1&quot;, int.class, -1);
	 * graph1.addVertex(0);
	 * g1_w1.set(0, 100);
	 *
	 * Graph&lt;Integer, Integer&gt; graph2 = Graph.newDirected();
	 * WeightsInt&lt;Integer&gt; g2_w1 = graph2.addVerticesWeights(&quot;w1&quot;, int.class, -2);
	 * graph2.addVertex(0);
	 * graph2.addVertex(1);
	 * g2_w1.set(0, 200);
	 * g2_w1.set(1, 500);
	 *
	 * Graph&lt;Integer, Integer&gt; union = new UnionGraphGenerator&lt;Integer, Integer&gt;()
	 * 		.graphs(graph1, graph2)
	 * 		.copyWeights(true, false)
	 * 		.verticesWeightsKeys(Set.of(&quot;w1&quot;))
	 * 		.generate();
	 * assert union.verticesWeightsKeys().equals(Set.of(&quot;w1&quot;));
	 * WeightsInt&lt;Integer&gt; union_w1 = union.verticesWeights(&quot;w1&quot;);
	 * assert union_w1.defaultWeight() == -1;
	 * assert union_w1.get(0) == 100;
	 * assert union_w1.get(1) == 500;
	 * } &lt;/pre&gt;
	 *
	 * &lt;p&gt;
	 * If multiple input graphs have weights with the same key but different types, an exception is thrown during the
	 * graph(s) generation.
	 *
	 * @param  verticesWeights if {@code true}, the vertices weights will be copied
	 * @param  edgesWeights    if {@code true}, the edges weights will be copied
	 * @return                 this generator
	 */
	public UnionGraphGenerator&lt;V, E&gt; copyWeights(boolean verticesWeights, boolean edgesWeights) {
<span class="fc" id="L361">		this.verticesWeights = verticesWeights;</span>
<span class="fc" id="L362">		this.edgesWeights = edgesWeights;</span>
<span class="fc" id="L363">		return this;</span>
	}

	/**
	 * Set the vertices weights keys to be copied from the input graphs to the generated graph(s).
	 *
	 * &lt;p&gt;
	 * By default, no weights are copied to the union graph. Using {@link #copyWeights(boolean, boolean)} the user can
	 * determine if the vertices weights will be copied, and if the edges weights will be copied, and all vertices/edges
	 * will be copied. This method allows the user to copy only specific weights. For this method to have any effect,
	 * copying the vertices weights must be enabled in the first place.
	 *
	 * @param  keys the vertices weights keys to be copied
	 * @return      this generator
	 */
	public UnionGraphGenerator&lt;V, E&gt; verticesWeightsKeys(Set&lt;String&gt; keys) {
<span class="fc bfc" id="L379" title="All 2 branches covered.">		verticesWeightsKeys = keys == null ? null : new HashSet&lt;&gt;(keys);</span>
<span class="fc" id="L380">		return this;</span>
	}

	/**
	 * Set the edges weights keys to be copied from the input graphs to the generated graph(s).
	 *
	 * &lt;p&gt;
	 * By default, no weights are copied to the union graph. Using {@link #copyWeights(boolean, boolean)} the user can
	 * determine if the vertices weights will be copied, and if the edges weights will be copied, and all vertices/edges
	 * will be copied. This method allows the user to copy only specific weights. For this method to have any effect,
	 * copying the edges weights must be enabled in the first place.
	 *
	 * @param  keys the edges weights keys to be copied
	 * @return      this generator
	 */
	public UnionGraphGenerator&lt;V, E&gt; edgesWeightsKeys(Set&lt;String&gt; keys) {
<span class="fc bfc" id="L396" title="All 2 branches covered.">		edgesWeightsKeys = keys == null ? null : new HashSet&lt;&gt;(keys);</span>
<span class="fc" id="L397">		return this;</span>
	}

	@Override
	public GraphBuilder&lt;V, E&gt; generateIntoBuilder() {
<span class="fc bfc" id="L402" title="All 2 branches covered.">		if (graphs.isEmpty())</span>
<span class="fc" id="L403">			throw new IllegalStateException(&quot;Input graphs not provided&quot;);</span>

		/* Create a union vertex set, assign a number for each such vertex and remember its origin graph idx */
<span class="fc" id="L406">		Object2IntMap&lt;V&gt; globalVertexIndexing = new Object2IntOpenHashMap&lt;&gt;(graphs.get(0).vertices().size());</span>
<span class="fc" id="L407">		globalVertexIndexing.defaultReturnValue(-1);</span>

<span class="fc" id="L409">		final boolean trackGraphsContainingVertices = verticesWeights;</span>
		List&lt;Bitmap&gt; graphsContainingVertexBitmaps =
<span class="fc bfc" id="L411" title="All 2 branches covered.">				trackGraphsContainingVertices ? new ArrayList&lt;&gt;(graphs.get(0).vertices().size()) : null;</span>

<span class="fc bfc" id="L413" title="All 2 branches covered.">		for (int graphIdx : range(graphs.size())) {</span>
<span class="fc" id="L414">			Graph&lt;V, E&gt; graph = graphs.get(graphIdx);</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">			for (V v : graph.vertices()) {</span>
<span class="fc" id="L416">				int vGlobalIdx = globalVertexIndexing.size();</span>
<span class="fc" id="L417">				int existingIdx = globalVertexIndexing.putIfAbsent(v, vGlobalIdx);</span>

<span class="fc bfc" id="L419" title="All 2 branches covered.">				if (trackGraphsContainingVertices) {</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">					if (existingIdx &gt;= 0)</span>
<span class="fc" id="L421">						vGlobalIdx = existingIdx;</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">					if (existingIdx &lt; 0)</span>
<span class="fc" id="L423">						graphsContainingVertexBitmaps.add(new Bitmap(graphs.size()));</span>
<span class="fc" id="L424">					graphsContainingVertexBitmaps.get(vGlobalIdx).set(graphIdx);</span>
				}
<span class="fc" id="L426">			}</span>
<span class="fc" id="L427">		}</span>
<span class="fc" id="L428">		Set&lt;V&gt; unionVertices = globalVertexIndexing.keySet();</span>

<span class="fc" id="L430">		final boolean directed = graphs.get(0).isDirected();</span>
<span class="fc" id="L431">		factory.setDirected(directed);</span>

		/* Determine if there will be self edges in the union graph */
<span class="fc bfc" id="L434" title="All 4 branches covered.">		if (graphs.stream().anyMatch(g -&gt; !Graphs.selfEdges(g).isEmpty()))</span>
<span class="fc" id="L435">			factory.allowSelfEdges();</span>

		/* Determine if there will be parallel edges in the union graph */
<span class="fc bfc" id="L438" title="All 2 branches covered.">		if (unionById) {</span>
<span class="fc" id="L439">			int[] lastVisit = new int[unionVertices.size()];</span>
<span class="fc" id="L440">			int nextVisitIdx = 1;</span>
<span class="fc" id="L441">			boolean parallelEdges = false;</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">			parallelEdgesCheck: for (V u : unionVertices) {</span>
<span class="fc" id="L443">				final int visitIdx = nextVisitIdx++;</span>
				/* check all edges (u, _) in all the graphs */
<span class="fc bfc" id="L445" title="All 2 branches covered.">				for (Graph&lt;V, E&gt; g : graphs) {</span>
<span class="fc" id="L446">					IndexIdMap&lt;V&gt; viMap = g.indexGraphVerticesMap();</span>
<span class="fc" id="L447">					int uIdx = viMap.idToIndexIfExist(u);</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">					if (uIdx &lt; 0)</span>
<span class="fc" id="L449">						continue; /* g does not contain u */</span>
<span class="fc" id="L450">					IndexGraph ig = g.indexGraph();</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">					for (IEdgeIter eit = ig.outEdges(uIdx).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L452">						eit.nextInt();</span>
<span class="fc" id="L453">						V v = viMap.indexToId(eit.targetInt());</span>
<span class="fc" id="L454">						int vGlobalIdx = globalVertexIndexing.getInt(v);</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">						if (lastVisit[vGlobalIdx] == visitIdx) {</span>
<span class="fc" id="L456">							parallelEdges = true;</span>
<span class="fc" id="L457">							break parallelEdgesCheck;</span>
						}
<span class="fc" id="L459">						lastVisit[vGlobalIdx] = visitIdx;</span>
<span class="fc" id="L460">					}</span>
<span class="fc" id="L461">				}</span>
<span class="fc" id="L462">			}</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">			if (parallelEdges)</span>
<span class="fc" id="L464">				factory.allowParallelEdges();</span>
		}

<span class="fc" id="L467">		GraphBuilder&lt;V, E&gt; union = factory.newBuilder();</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">		List&lt;WeightsCopier&lt;V&gt;&gt; verticesWeightsCopiers = verticesWeights ? createVerticesWeights(union) : null;</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">		List&lt;WeightsCopier&lt;E&gt;&gt; edgesWeightsCopiers = edgesWeights ? createEdgesWeights(union) : null;</span>

		/* Add all vertices to the union graph */
<span class="fc" id="L472">		union.ensureVertexCapacity(unionVertices.size());</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">		for (var entry : Object2IntMaps.fastIterable(globalVertexIndexing)) {</span>
<span class="fc" id="L474">			V v = entry.getKey();</span>
<span class="fc" id="L475">			union.addVertex(v);</span>

<span class="fc bfc" id="L477" title="All 2 branches covered.">			if (verticesWeights) {</span>
<span class="fc" id="L478">				int vGlobalIdx = entry.getIntValue();</span>
<span class="fc" id="L479">				Bitmap graphsContainingVertex = graphsContainingVertexBitmaps.get(vGlobalIdx);</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">				for (WeightsCopier&lt;V&gt; weightsCopier : verticesWeightsCopiers) {</span>
<span class="fc" id="L481">					OptionalInt graphIdx = weightsCopier.copySrcIdx(graphsContainingVertex);</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">					if (graphIdx.isPresent())</span>
<span class="fc" id="L483">						weightsCopier.copy(v, v, graphIdx.getAsInt());</span>
<span class="fc" id="L484">				}</span>
			}
<span class="fc" id="L486">		}</span>

<span class="fc" id="L488">		ToLongBiFunction&lt;V, V&gt; endpointsFunc = (u, v) -&gt; {</span>
<span class="fc" id="L489">			int uGlobalIdx = globalVertexIndexing.getInt(u), vGlobalIdx = globalVertexIndexing.getInt(v);</span>
<span class="fc bfc" id="L490" title="All 4 branches covered.">			if (!directed &amp;&amp; uGlobalIdx &gt; vGlobalIdx) {</span>
<span class="fc" id="L491">				int temp = uGlobalIdx;</span>
<span class="fc" id="L492">				uGlobalIdx = vGlobalIdx;</span>
<span class="fc" id="L493">				vGlobalIdx = temp;</span>
			}
<span class="fc" id="L495">			return IntPair.of(uGlobalIdx, vGlobalIdx);</span>
		};

		/* Add all edges to the union graph */
<span class="fc bfc" id="L499" title="All 2 branches covered.">		if (unionById) {</span>
<span class="fc" id="L500">			Object2IntMap&lt;E&gt; globalEdgeIndexing = new Object2IntOpenHashMap&lt;&gt;(graphs.get(0).edges().size());</span>
<span class="fc" id="L501">			globalEdgeIndexing.defaultReturnValue(-1);</span>
<span class="fc" id="L502">			LongList globalEdgeEndpoints = new LongArrayList(graphs.get(0).edges().size());</span>

<span class="fc" id="L504">			final boolean trackGraphsContainingEdges = edgesWeights;</span>
			List&lt;Bitmap&gt; graphsContainingEdgeBitmaps =
<span class="fc bfc" id="L506" title="All 2 branches covered.">					trackGraphsContainingEdges ? new ArrayList&lt;&gt;(graphs.get(0).edges().size()) : null;</span>

<span class="fc bfc" id="L508" title="All 2 branches covered.">			for (int graphIdx : range(graphs.size())) {</span>
<span class="fc" id="L509">				Graph&lt;V, E&gt; graph = graphs.get(graphIdx);</span>
<span class="fc" id="L510">				IndexGraph ig = graph.indexGraph();</span>
<span class="fc" id="L511">				IndexIdMap&lt;V&gt; viMap = graph.indexGraphVerticesMap();</span>
<span class="fc" id="L512">				IndexIdMap&lt;E&gt; eiMap = graph.indexGraphEdgesMap();</span>

<span class="fc bfc" id="L514" title="All 2 branches covered.">				for (int eIdx : range(ig.edges().size())) {</span>
<span class="fc" id="L515">					int uIdx = ig.edgeSource(eIdx), vIdx = ig.edgeTarget(eIdx);</span>
<span class="fc" id="L516">					V u = viMap.indexToId(uIdx), v = viMap.indexToId(vIdx);</span>
<span class="fc" id="L517">					E e = eiMap.indexToId(eIdx);</span>

<span class="fc" id="L519">					long endpoints = endpointsFunc.applyAsLong(u, v);</span>
<span class="fc" id="L520">					int eGlobalId = globalEdgeIndexing.size();</span>
<span class="fc" id="L521">					int existingIdx = globalEdgeIndexing.putIfAbsent(e, eGlobalId);</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">					if (existingIdx &lt; 0) {</span>
<span class="fc" id="L523">						union.addEdge(u, v, e);</span>
<span class="fc" id="L524">						globalEdgeEndpoints.add(endpoints);</span>
					} else {
<span class="fc bfc" id="L526" title="All 2 branches covered.">						if (globalEdgeEndpoints.getLong(existingIdx) != endpoints)</span>
<span class="fc" id="L527">							throw new IllegalArgumentException(</span>
									&quot;Input graphs have the same edge with different endpoints&quot;);
					}
<span class="fc bfc" id="L530" title="All 2 branches covered.">					if (trackGraphsContainingEdges) {</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">						if (existingIdx &gt;= 0)</span>
<span class="fc" id="L532">							eGlobalId = existingIdx;</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">						if (existingIdx &lt; 0)</span>
<span class="fc" id="L534">							graphsContainingEdgeBitmaps.add(new Bitmap(graphs.size()));</span>
<span class="fc" id="L535">						graphsContainingEdgeBitmaps.get(eGlobalId).set(graphIdx);</span>
					}
<span class="fc" id="L537">				}</span>
<span class="fc" id="L538">			}</span>

<span class="fc bfc" id="L540" title="All 2 branches covered.">			if (edgesWeights) {</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">				for (var entry : Object2IntMaps.fastIterable(globalEdgeIndexing)) {</span>
<span class="fc" id="L542">					E e = entry.getKey();</span>
<span class="fc" id="L543">					int eGlobalIdx = entry.getIntValue();</span>
<span class="fc" id="L544">					Bitmap graphsContainingEdge = graphsContainingEdgeBitmaps.get(eGlobalIdx);</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">					for (WeightsCopier&lt;E&gt; weightsCopier : edgesWeightsCopiers) {</span>
<span class="fc" id="L546">						OptionalInt graphIdx = weightsCopier.copySrcIdx(graphsContainingEdge);</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">						if (graphIdx.isPresent())</span>
<span class="fc" id="L548">							weightsCopier.copy(e, e, graphIdx.getAsInt());</span>
<span class="fc" id="L549">					}</span>
<span class="fc" id="L550">				}</span>
			}

<span class="fc" id="L553">		} else { /* union by endpoints */</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">			if (graphs.stream().anyMatch(Graphs::containsParallelEdges))</span>
<span class="fc" id="L555">				throw new IllegalArgumentException(</span>
						&quot;Cannot union by endpoints when input graphs contain parallel edges&quot;);

<span class="fc" id="L558">			Long2IntMap globalEdgeIndexing = new Long2IntOpenHashMap(graphs.get(0).edges().size());</span>
<span class="fc" id="L559">			globalEdgeIndexing.defaultReturnValue(-1);</span>

<span class="fc" id="L561">			final boolean tackEdgeIdentifiers = edgesWeights;</span>
			List&lt;E[]&gt; globalIdxToIdentifiers =
<span class="fc bfc" id="L563" title="All 2 branches covered.">					tackEdgeIdentifiers ? new ArrayList&lt;&gt;(graphs.get(0).edges().size()) : null;</span>

<span class="fc bfc" id="L565" title="All 2 branches covered.">			for (int graphIdx : range(graphs.size())) {</span>
<span class="fc" id="L566">				Graph&lt;V, E&gt; graph = graphs.get(graphIdx);</span>
<span class="fc" id="L567">				IndexGraph ig = graph.indexGraph();</span>
<span class="fc" id="L568">				IndexIdMap&lt;V&gt; viMap = graph.indexGraphVerticesMap();</span>
<span class="fc" id="L569">				IndexIdMap&lt;E&gt; eiMap = graph.indexGraphEdgesMap();</span>

<span class="fc bfc" id="L571" title="All 2 branches covered.">				for (int eIdx : range(ig.edges().size())) {</span>
<span class="fc" id="L572">					int uIdx = ig.edgeSource(eIdx), vIdx = ig.edgeTarget(eIdx);</span>
<span class="fc" id="L573">					V u = viMap.indexToId(uIdx), v = viMap.indexToId(vIdx);</span>
<span class="fc" id="L574">					long endpoints = endpointsFunc.applyAsLong(u, v);</span>
<span class="fc" id="L575">					int eGlobalId = globalEdgeIndexing.size();</span>
<span class="fc" id="L576">					int existingIdx = globalEdgeIndexing.putIfAbsent(endpoints, eGlobalId);</span>
<span class="fc" id="L577">					E e = null;</span>

<span class="fc bfc" id="L579" title="All 2 branches covered.">					if (existingIdx &lt; 0) {</span>
<span class="fc" id="L580">						e = eiMap.indexToId(eIdx);</span>
<span class="fc" id="L581">						union.addEdge(u, v, e);</span>
					}

<span class="fc bfc" id="L584" title="All 2 branches covered.">					if (tackEdgeIdentifiers) {</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">						if (existingIdx &gt;= 0) {</span>
<span class="fc" id="L586">							eGlobalId = existingIdx;</span>
<span class="fc" id="L587">							e = eiMap.indexToId(eIdx);</span>
						}
<span class="fc bfc" id="L589" title="All 2 branches covered.">						if (existingIdx &lt; 0) {</span>
							@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L591">							E[] graphsContainingEdgeBitmap = (E[]) new Object[graphs.size()];</span>
<span class="fc" id="L592">							globalIdxToIdentifiers.add(graphsContainingEdgeBitmap);</span>
						}
<span class="fc" id="L594">						globalIdxToIdentifiers.get(eGlobalId)[graphIdx] = e;</span>
					}
<span class="fc" id="L596">				}</span>
<span class="fc" id="L597">			}</span>

<span class="fc bfc" id="L599" title="All 2 branches covered.">			if (edgesWeights) {</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">				for (int eGlobalIdx : range(globalEdgeIndexing.size())) {</span>
<span class="fc" id="L601">					E[] edgeIdentifiers = globalIdxToIdentifiers.get(eGlobalIdx);</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">					Bitmap graphsContainingEdge = Bitmap.fromPredicate(graphs.size(), i -&gt; edgeIdentifiers[i] != null);</span>
<span class="fc" id="L603">					E e = edgeIdentifiers[graphsContainingEdge.iterator().nextInt()];</span>

<span class="fc bfc" id="L605" title="All 2 branches covered.">					for (WeightsCopier&lt;E&gt; weightsCopier : edgesWeightsCopiers) {</span>
<span class="fc" id="L606">						OptionalInt graphIdx = weightsCopier.copySrcIdx(graphsContainingEdge);</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">						if (graphIdx.isPresent()) {</span>
<span class="fc" id="L608">							E srcEdge = edgeIdentifiers[graphIdx.getAsInt()];</span>
<span class="fc" id="L609">							weightsCopier.copy(srcEdge, e, graphIdx.getAsInt());</span>
						}
<span class="fc" id="L611">					}</span>
<span class="fc" id="L612">				}</span>
			}
		}
<span class="fc" id="L615">		return union;</span>
	}

	private static class WeightsCopier&lt;K&gt; {

		private final Weights&lt;K, ?&gt;[] graphIdxToWeights;
		private final Weights&lt;K, ?&gt; builderWeights;

<span class="fc" id="L623">		WeightsCopier(Weights&lt;K, ?&gt;[] graphIdxToWeights, Weights&lt;K, ?&gt; builderWeights) {</span>
<span class="fc" id="L624">			this.graphIdxToWeights = graphIdxToWeights;</span>
<span class="fc" id="L625">			this.builderWeights = builderWeights;</span>
<span class="fc" id="L626">		}</span>

		OptionalInt copySrcIdx(Bitmap graphsContainingElm) {
<span class="fc" id="L629">			return IterTools</span>
<span class="fc" id="L630">					.stream(graphsContainingElm)</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">					.filter(graphIdx -&gt; graphIdxToWeights[graphIdx] != null)</span>
<span class="fc" id="L632">					.findFirst();</span>
		}

		@SuppressWarnings(&quot;unchecked&quot;)
		void copy(K srcElm, K dstElm, int graphIdx) {
<span class="fc" id="L637">			Weights&lt;K, Object&gt; builderWeights = (Weights&lt;K, Object&gt;) this.builderWeights;</span>
<span class="fc" id="L638">			Weights&lt;K, Object&gt; inputWeights = (Weights&lt;K, Object&gt;) graphIdxToWeights[graphIdx];</span>
<span class="fc" id="L639">			builderWeights.setAsObj(dstElm, inputWeights.getAsObj(srcElm));</span>
<span class="fc" id="L640">		}</span>
	}

	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
	private List&lt;WeightsCopier&lt;V&gt;&gt; createVerticesWeights(GraphBuilder&lt;V, E&gt; builder) {
<span class="fc" id="L645">		return (List) createWeights(builder, verticesWeightsKeys, true);</span>
	}

	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
	private List&lt;WeightsCopier&lt;E&gt;&gt; createEdgesWeights(GraphBuilder&lt;V, E&gt; builder) {
<span class="fc" id="L650">		return (List) createWeights(builder, edgesWeightsKeys, false);</span>
	}

	private List&lt;WeightsCopier&lt;?&gt;&gt; createWeights(GraphBuilder&lt;V, E&gt; builder, Set&lt;String&gt; copiedKeys, boolean vertices) {
<span class="fc" id="L654">		Map&lt;String, Weights&lt;?, ?&gt;[]&gt; graphsContainingWeightsBitmaps = new HashMap&lt;&gt;();</span>
<span class="fc" id="L655">		final int graphsNum = graphs.size();</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">		for (int graphIdx : range(graphsNum)) {</span>
<span class="fc" id="L657">			Graph&lt;V, E&gt; graph = graphs.get(graphIdx);</span>
<span class="fc bfc" id="L658" title="All 4 branches covered.">			for (String key : vertices ? graph.verticesWeightsKeys() : graph.edgesWeightsKeys()) {</span>
<span class="fc bfc" id="L659" title="All 2 branches covered.">				Weights&lt;?, ?&gt; weights = vertices ? graph.verticesWeights(key) : graph.edgesWeights(key);</span>
<span class="fc" id="L660">				Weights&lt;?, ?&gt;[] weightsPerGraphArr =</span>
<span class="fc" id="L661">						graphsContainingWeightsBitmaps.computeIfAbsent(key, k -&gt; new Weights&lt;?, ?&gt;[graphsNum]);</span>
<span class="fc" id="L662">				weightsPerGraphArr[graphIdx] = weights;</span>
<span class="fc" id="L663">			}</span>
<span class="fc" id="L664">		}</span>

<span class="fc" id="L666">		List&lt;WeightsCopier&lt;?&gt;&gt; weightsFuncs = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L667" title="All 2 branches covered.">		for (var entry : graphsContainingWeightsBitmaps.entrySet()) {</span>
<span class="fc" id="L668">			String key = entry.getKey();</span>
<span class="fc bfc" id="L669" title="All 4 branches covered.">			if (copiedKeys != null &amp;&amp; !copiedKeys.contains(key))</span>
<span class="fc" id="L670">				continue;</span>
<span class="fc" id="L671">			Weights&lt;?, ?&gt;[] graphIdxToWeights = entry.getValue();</span>
<span class="fc" id="L672">			Weights&lt;?, ?&gt; weights0 = Arrays.stream(graphIdxToWeights).filter(Objects::nonNull).findFirst().get();</span>

			Class&lt;?&gt; weightsType;
<span class="fc bfc" id="L675" title="All 2 branches covered.">			if (weights0 instanceof WeightsByte) {</span>
<span class="fc" id="L676">				checkWeightsCompatibility(graphIdxToWeights, WeightsByte.class);</span>
<span class="fc" id="L677">				weightsType = byte.class;</span>

<span class="fc bfc" id="L679" title="All 2 branches covered.">			} else if (weights0 instanceof WeightsShort) {</span>
<span class="fc" id="L680">				checkWeightsCompatibility(graphIdxToWeights, WeightsShort.class);</span>
<span class="fc" id="L681">				weightsType = short.class;</span>

<span class="fc bfc" id="L683" title="All 2 branches covered.">			} else if (weights0 instanceof WeightsInt) {</span>
<span class="fc" id="L684">				checkWeightsCompatibility(graphIdxToWeights, WeightsInt.class);</span>
<span class="fc" id="L685">				weightsType = int.class;</span>

<span class="fc bfc" id="L687" title="All 2 branches covered.">			} else if (weights0 instanceof WeightsLong) {</span>
<span class="fc" id="L688">				checkWeightsCompatibility(graphIdxToWeights, WeightsLong.class);</span>
<span class="fc" id="L689">				weightsType = long.class;</span>

<span class="fc bfc" id="L691" title="All 2 branches covered.">			} else if (weights0 instanceof WeightsFloat) {</span>
<span class="fc" id="L692">				checkWeightsCompatibility(graphIdxToWeights, WeightsFloat.class);</span>
<span class="fc" id="L693">				weightsType = float.class;</span>

<span class="fc bfc" id="L695" title="All 2 branches covered.">			} else if (weights0 instanceof WeightsDouble) {</span>
<span class="fc" id="L696">				checkWeightsCompatibility(graphIdxToWeights, WeightsDouble.class);</span>
<span class="fc" id="L697">				weightsType = double.class;</span>

<span class="fc bfc" id="L699" title="All 2 branches covered.">			} else if (weights0 instanceof WeightsBool) {</span>
<span class="fc" id="L700">				checkWeightsCompatibility(graphIdxToWeights, WeightsBool.class);</span>
<span class="fc" id="L701">				weightsType = boolean.class;</span>

<span class="fc bfc" id="L703" title="All 2 branches covered.">			} else if (weights0 instanceof WeightsChar) {</span>
<span class="fc" id="L704">				checkWeightsCompatibility(graphIdxToWeights, WeightsChar.class);</span>
<span class="fc" id="L705">				weightsType = char.class;</span>

			} else {
<span class="fc" id="L708">				checkWeightsCompatibility(graphIdxToWeights, WeightsObj.class);</span>
<span class="fc" id="L709">				weightsType = Object.class;</span>
			}

			Weights&lt;?, ?&gt; builderWeights;
<span class="fc" id="L713">			Object defWeight = weights0.defaultWeightAsObj();</span>
			@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L715">			Class&lt;Object&gt; weightsType0 = (Class&lt;Object&gt;) weightsType;</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">			if (vertices) {</span>
<span class="fc" id="L717">				builderWeights = builder.addVerticesWeights(key, weightsType0, defWeight);</span>
			} else {
<span class="fc" id="L719">				builderWeights = builder.addEdgesWeights(key, weightsType0, defWeight);</span>
			}

			@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L723">			WeightsCopier&lt;?&gt; weightsCopier = new WeightsCopier(graphIdxToWeights, builderWeights);</span>
<span class="fc" id="L724">			weightsFuncs.add(weightsCopier);</span>
<span class="fc" id="L725">		}</span>
<span class="fc" id="L726">		return weightsFuncs;</span>
	}

	private static void checkWeightsCompatibility(Weights&lt;?, ?&gt;[] weights, Class&lt;?&gt; weightsType) {
<span class="fc bfc" id="L730" title="All 2 branches covered.">		if (!Arrays.stream(weights).filter(Objects::nonNull).allMatch(weightsType::isInstance))</span>
<span class="fc" id="L731">			throw new IllegalArgumentException(&quot;Weights are not compatible&quot;);</span>
<span class="fc" id="L732">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>