<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UniformTreeGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.gen</a> &gt; <span class="el_source">UniformTreeGenerator.java</span></div><h1>UniformTreeGenerator.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.gen;

import static com.jgalgo.internal.util.Range.range;
import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.Random;
import java.util.function.BiFunction;
import java.util.function.IntSupplier;
import java.util.function.Supplier;
import com.jgalgo.graph.GraphBuilder;
import com.jgalgo.graph.GraphFactory;
import com.jgalgo.graph.IntGraph;
import com.jgalgo.graph.IntGraphFactory;
import com.jgalgo.internal.util.Bitmap;
import com.jgalgo.internal.util.IntAdapters;
import it.unimi.dsi.fastutil.ints.IntArrayList;
import it.unimi.dsi.fastutil.ints.IntList;
import it.unimi.dsi.fastutil.objects.ObjectArrayList;

/**
 * Generate a uniform random tree.
 *
 * &lt;p&gt;
 * The generator uses the Prufer sequence method to generate a uniform random tree. The Prufer sequence is a sequence of
 * {@code n-2} integers sampled uniformly in the range {@code [0,n)}, where {@code n} is the number of vertices. The
 * sequence is than converted to a tree using the algorithm described in the paper &quot;An Optimal Algorithm for Prufer
 * Codes&quot; by Xiaodong Wang, Lei Wang and Yingjie Wu. The algorithm runs in linear time.
 *
 * &lt;p&gt;
 * The generator generate undirected graphs only. If zero vertices are set, an empty graph is generated.
 *
 * &lt;p&gt;
 * For deterministic behavior, set the seed of the generator using {@link #setSeed(long)}.
 *
 * @param  &lt;V&gt; the vertices type
 * @param  &lt;E&gt; the edges type
 * @author     Barak Ugav
 */
<span class="fc" id="L55">public class UniformTreeGenerator&lt;V, E&gt; implements GraphGenerator&lt;V, E&gt; {</span>

	private final boolean intGraph;
	private List&lt;V&gt; vertices;
	private BiFunction&lt;V, V, E&gt; edgeBuilder;
<span class="fc" id="L60">	private Random rand = new Random();</span>

<span class="fc" id="L62">	private UniformTreeGenerator(boolean intGraph) {</span>
<span class="fc" id="L63">		this.intGraph = intGraph;</span>
<span class="fc" id="L64">	}</span>

	/**
	 * Creates a new uniform tree generator.
	 *
	 * @param  &lt;V&gt; the vertices type
	 * @param  &lt;E&gt; the edges type
	 * @return     a new uniform tree generator
	 */
	public static &lt;V, E&gt; UniformTreeGenerator&lt;V, E&gt; newInstance() {
<span class="fc" id="L74">		return new UniformTreeGenerator&lt;&gt;(false);</span>
	}

	/**
	 * Creates a new uniform tree generator for {@link IntGraph}.
	 *
	 * @return a new uniform tree generator for {@link IntGraph}
	 */
	public static UniformTreeGenerator&lt;Integer, Integer&gt; newIntInstance() {
<span class="fc" id="L83">		return new UniformTreeGenerator&lt;&gt;(true);</span>
	}

	/**
	 * Set the vertices of the generated graph(s).
	 *
	 * &lt;p&gt;
	 * If the generator is used to generate multiple graphs, the same vertex set will be used for all of them.
	 *
	 * @param vertices the vertices of the generated graph(s)
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public void setVertices(Collection&lt;V&gt; vertices) {
<span class="fc bfc" id="L96" title="All 2 branches covered.">		if (intGraph) {</span>
<span class="fc" id="L97">			this.vertices = (List&lt;V&gt;) new IntArrayList(IntAdapters.asIntCollection((Collection&lt;Integer&gt;) vertices));</span>
		} else {
<span class="fc" id="L99">			this.vertices = new ObjectArrayList&lt;&gt;(vertices);</span>
		}
<span class="fc" id="L101">	}</span>

	/**
	 * Set the vertices set of the generated graph(s) from a supplier.
	 *
	 * &lt;p&gt;
	 * The supplier will be called exactly {@code verticesNum} times, and the same set of vertices created will be used
	 * for multiple graphs if {@link #generate()} is called multiple times.
	 *
	 * @param verticesNum    the number of vertices
	 * @param vertexSupplier the supplier of vertices
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public void setVertices(int verticesNum, Supplier&lt;V&gt; vertexSupplier) {
<span class="fc bfc" id="L115" title="All 2 branches covered.">		if (intGraph) {</span>
<span class="fc" id="L116">			IntList vertices = new IntArrayList(verticesNum);</span>
<span class="fc" id="L117">			IntSupplier vSupplier = IntAdapters.asIntSupplier((Supplier&lt;Integer&gt;) vertexSupplier);</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">			for (int i = 0; i &lt; verticesNum; i++)</span>
<span class="fc" id="L119">				vertices.add(vSupplier.getAsInt());</span>
<span class="fc" id="L120">			this.vertices = (List&lt;V&gt;) vertices;</span>
<span class="fc" id="L121">		} else {</span>
<span class="fc" id="L122">			List&lt;V&gt; vertices = new ObjectArrayList&lt;&gt;(verticesNum);</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">			for (int i = 0; i &lt; verticesNum; i++)</span>
<span class="fc" id="L124">				vertices.add(vertexSupplier.get());</span>
<span class="fc" id="L125">			this.vertices = vertices;</span>
		}
<span class="fc" id="L127">	}</span>

	/**
	 * Set the edge supplier of the generated graph(s).
	 *
	 * &lt;p&gt;
	 * The supplier will be called for any edge created, for any graph generated. This behavior is different from
	 * {@link #setVertices(int, Supplier)}, where the supplier is used to generate a set of vertices which is reused for
	 * any generated graph.
	 *
	 * @param edgeSupplier the edge supplier
	 */
	public void setEdges(Supplier&lt;E&gt; edgeSupplier) {
<span class="fc" id="L140">		Objects.requireNonNull(edgeSupplier);</span>
<span class="fc" id="L141">		setEdges((u, v) -&gt; edgeSupplier.get());</span>
<span class="fc" id="L142">	}</span>

	/**
	 * Set the edge builder function of the generated graph(s).
	 *
	 * &lt;p&gt;
	 * The function will be called for any edge created, for any graph generated. This behavior is different from
	 * {@link #setVertices(int, Supplier)}, where the supplier is used to generate a set of vertices which is reused for
	 * any generated graph.
	 *
	 * @param edgeBuilder the edge builder function
	 */
	public void setEdges(BiFunction&lt;V, V, E&gt; edgeBuilder) {
<span class="fc" id="L155">		this.edgeBuilder = Objects.requireNonNull(edgeBuilder);</span>
<span class="fc" id="L156">	}</span>

	/**
	 * Set the seed of the random number generator used to generate the graph(s).
	 *
	 * &lt;p&gt;
	 * By default, a random seed is used. For deterministic behavior, set the seed of the generator.
	 *
	 * @param seed the seed of the random number generator
	 */
	public void setSeed(long seed) {
<span class="fc" id="L167">		rand = new Random(seed);</span>
<span class="fc" id="L168">	}</span>

	@Override
	public GraphBuilder&lt;V, E&gt; generateIntoBuilder() {
<span class="fc bfc" id="L172" title="All 2 branches covered.">		if (vertices == null)</span>
<span class="fc" id="L173">			throw new IllegalStateException(&quot;Vertices not set&quot;);</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">		if (edgeBuilder == null)</span>
<span class="fc" id="L175">			throw new IllegalStateException(&quot;Edge supplier not set&quot;);</span>

		@SuppressWarnings(&quot;unchecked&quot;)
		GraphFactory&lt;V, E&gt; factory =
<span class="fc bfc" id="L179" title="All 2 branches covered.">				intGraph ? ((GraphFactory&lt;V, E&gt;) IntGraphFactory.undirected()) : GraphFactory.undirected();</span>
<span class="fc" id="L180">		GraphBuilder&lt;V, E&gt; g = factory.newBuilder();</span>

<span class="fc" id="L182">		final int n = vertices.size();</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">		if (n == 0)</span>
<span class="fc" id="L184">			return g;</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">		for (V v : vertices)</span>
<span class="fc" id="L186">			g.addVertex(v);</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">		if (n == 1)</span>
<span class="fc" id="L188">			return g;</span>

		/* generate a random Prufer code of length n-2 */
<span class="fc" id="L191">		int[] pruferCode = new int[n - 2];</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">		for (int i = 0; i &lt; n - 2; i++)</span>
<span class="fc" id="L193">			pruferCode[i] = rand.nextInt(n);</span>

		/* 'decode' the Prufer code to a tree of size n */
<span class="fc" id="L196">		int[] degree = new int[n];</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">		for (int c : pruferCode)</span>
<span class="fc" id="L198">			degree[c]++;</span>
		int index, uIdx;
<span class="fc bfc" id="L200" title="All 2 branches covered.">		V u = vertices.get(uIdx = index = range(n).filter(i -&gt; degree[i] == 0).findFirst().getAsInt());</span>
<span class="fc" id="L201">		Bitmap hasParent = new Bitmap(n);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">		for (int vIdx : pruferCode) {</span>
<span class="fc" id="L203">			V v = vertices.get(vIdx);</span>
<span class="fc" id="L204">			g.addEdge(u, v, edgeBuilder.apply(u, v));</span>
<span class="fc" id="L205">			hasParent.set(uIdx);</span>

<span class="fc" id="L207">			degree[vIdx]--;</span>
<span class="fc bfc" id="L208" title="All 4 branches covered.">			if (vIdx &lt; index &amp;&amp; degree[vIdx] == 0) {</span>
<span class="fc" id="L209">				u = v;</span>
<span class="fc" id="L210">				uIdx = vIdx;</span>
			} else {
<span class="fc bfc" id="L212" title="All 2 branches covered.">				u = vertices.get(uIdx = index = range(index + 1, n).filter(i -&gt; degree[i] == 0).findFirst().getAsInt());</span>
			}
		}

		/* After the above loop, there should be two vertices with no parent. Connect them */
<span class="pc bnc" id="L217" title="All 4 branches missed.">		assert Bitmap.fromPredicate(n, v -&gt; !hasParent.get(v)).cardinality() == 2;</span>
<span class="fc" id="L218">		int root1Idx = hasParent.nextClearBit(0);</span>
<span class="fc" id="L219">		int root2Idx = hasParent.nextClearBit(root1Idx + 1);</span>
<span class="fc" id="L220">		V root1 = vertices.get(root1Idx);</span>
<span class="fc" id="L221">		V root2 = vertices.get(root2Idx);</span>
<span class="fc" id="L222">		g.addEdge(root1, root2, edgeBuilder.apply(root1, root2));</span>

<span class="fc" id="L224">		return g;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>