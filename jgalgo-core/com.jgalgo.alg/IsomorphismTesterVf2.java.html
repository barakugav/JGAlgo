<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IsomorphismTesterVf2.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.alg</a> &gt; <span class="el_source">IsomorphismTesterVf2.java</span></div><h1>IsomorphismTesterVf2.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.alg;

import static com.jgalgo.internal.util.Range.range;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.Objects;
import java.util.function.IntBinaryOperator;
import com.jgalgo.graph.IEdgeIter;
import com.jgalgo.graph.IndexGraph;
import com.jgalgo.internal.util.Assertions;
import com.jgalgo.internal.util.IterTools;
import it.unimi.dsi.fastutil.ints.IntArrays;
import it.unimi.dsi.fastutil.ints.IntIterator;
import it.unimi.dsi.fastutil.ints.IntIterators;
import it.unimi.dsi.fastutil.objects.ObjectIterators;

/**
 * Vf2 algorithm for testing isomorphism of two graphs.
 *
 * &lt;p&gt;
 * Based on 'An Improved Algorithm for Matching Large Graphs' by L. P. Cordella, P. Foggia, C. Sansone and M. Vento. The
 * paper denote the smaller graph as G2 and the bigger graph as G1 in (induced) sub graph isomorphism. We use the
 * opposite notation, which seems more suitable as the returned mapping is from G1 to G2.
 *
 * @author Barak Ugav
 */
<span class="fc" id="L43">class IsomorphismTesterVf2 implements IsomorphismTesterBase {</span>

	@Override
	public Iterator&lt;IsomorphismIMapping&gt; isomorphicMappingsIter(IndexGraph g1, IndexGraph g2, IsomorphismType type,
			IntBinaryOperator vertexMatcher, IntBinaryOperator edgeMatcher) {
<span class="fc" id="L48">		Assertions.noParallelEdges(g1, &quot;parallel edges are not supported&quot;);</span>
<span class="fc" id="L49">		Assertions.noParallelEdges(g2, &quot;parallel edges are not supported&quot;);</span>
<span class="fc bfc" id="L50" title="All 2 branches covered.">		if (g1.isDirected() != g2.isDirected())</span>
<span class="fc" id="L51">			throw new IllegalArgumentException(&quot;directed/undirected graphs mismatch&quot;);</span>
<span class="fc" id="L52">		Objects.requireNonNull(type);</span>

<span class="fc" id="L54">		final int n1 = g1.vertices().size();</span>
<span class="fc" id="L55">		final int n2 = g2.vertices().size();</span>
<span class="fc" id="L56">		final int m1 = g1.edges().size();</span>
<span class="fc" id="L57">		final int m2 = g2.edges().size();</span>

<span class="fc bfc" id="L59" title="All 6 branches covered.">		if (type == IsomorphismType.Full &amp;&amp; (n1 != n2 || m1 != m2))</span>
<span class="fc" id="L60">			return Collections.emptyIterator();</span>

<span class="fc bfc" id="L62" title="All 10 branches covered.">		if (n1 &gt; n2 || m1 &gt; m2 || (n1 == n2 &amp;&amp; m1 != m2 &amp;&amp; type != IsomorphismType.SubGraph))</span>
<span class="fc" id="L63">			return Collections.emptyIterator();</span>

<span class="fc bfc" id="L65" title="All 2 branches covered.">		if (n1 == 0) {</span>
<span class="pc bnc" id="L66" title="All 2 branches missed.">			assert m1 == 0;</span>
<span class="fc" id="L67">			return ObjectIterators</span>
<span class="fc" id="L68">					.singleton(new IsomorphismTesters.IndexMapping(g1, g2, IntArrays.DEFAULT_EMPTY_ARRAY,</span>
							IntArrays.DEFAULT_EMPTY_ARRAY));
		}

<span class="fc bfc" id="L72" title="All 2 branches covered.">		if (g1.isDirected()) {</span>
<span class="fc" id="L73">			return new IsomorphismIterDirected(g1, g2, type, vertexMatcher, edgeMatcher);</span>
		} else {
<span class="fc" id="L75">			return new IsomorphismIterUndirected(g1, g2, type, vertexMatcher, edgeMatcher);</span>
		}
	}

<span class="fc" id="L79">	private abstract static class IsomorphismIterBase implements Iterator&lt;IsomorphismIMapping&gt; {</span>

		final IndexGraph g1;
		final IndexGraph g2;
		final int n1, n2;
		private final IntBinaryOperator vertexMatcher;
		private final IntBinaryOperator edgeMatcher;
		final IsomorphismType type;
		final boolean subGraph;
		final boolean inducedSubGraph;

		final int[] core1;
		final int[] core2;
		int stateDepth;
		final int[] statePrevV1;
		final int[] statePrevV2;
		final int[] stateNextV1;
		final IntIterator[] stateNextV2Iter;

<span class="fc" id="L98">		int nextVisitIdx = 1;</span>
		final int[] visit;
		final int[] visitData;

		int[] nextMapping;

		static final int None = -1;

		IsomorphismIterBase(IndexGraph g1, IndexGraph g2, IsomorphismType type, IntBinaryOperator vertexMatcher,
<span class="fc" id="L107">				IntBinaryOperator edgeMatcher) {</span>
<span class="fc" id="L108">			this.g1 = g1;</span>
<span class="fc" id="L109">			this.g2 = g2;</span>
<span class="fc" id="L110">			n1 = g1.vertices().size();</span>
<span class="fc" id="L111">			n2 = g2.vertices().size();</span>
<span class="fc" id="L112">			this.type = type;</span>
<span class="fc" id="L113">			this.vertexMatcher = vertexMatcher;</span>
<span class="fc" id="L114">			this.edgeMatcher = edgeMatcher;</span>

<span class="pc bnc" id="L116" title="All 2 branches missed.">			assert n1 &lt;= n2;</span>
<span class="fc bfc" id="L117" title="All 4 branches covered.">			subGraph = type == IsomorphismType.SubGraph || n1 &lt; n2;</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">			inducedSubGraph = Objects.requireNonNull(type) != IsomorphismType.SubGraph;</span>

<span class="fc" id="L120">			core1 = new int[n1];</span>
<span class="fc" id="L121">			core2 = new int[n2];</span>
<span class="fc" id="L122">			Arrays.fill(core1, None);</span>
<span class="fc" id="L123">			Arrays.fill(core2, None);</span>

<span class="fc" id="L125">			visit = new int[/* max(n1,n2) */ n2];</span>
<span class="fc" id="L126">			visitData = new int[/* max(n1,n2) */ n2];</span>

<span class="fc" id="L128">			stateDepth = 1;</span>
<span class="fc" id="L129">			final int maxStateDepth = n1 + 1;</span>
<span class="fc" id="L130">			statePrevV1 = new int[maxStateDepth];</span>
<span class="fc" id="L131">			statePrevV2 = new int[maxStateDepth];</span>
<span class="fc" id="L132">			stateNextV1 = new int[maxStateDepth];</span>
<span class="fc" id="L133">			stateNextV2Iter = new IntIterator[maxStateDepth];</span>
<span class="fc" id="L134">		}</span>

		abstract void advance();

		@Override
		public boolean hasNext() {
<span class="fc bfc" id="L140" title="All 2 branches covered.">			return nextMapping != null;</span>
		}

		@Override
		public IsomorphismIMapping next() {
<span class="fc" id="L145">			Assertions.hasNext(this);</span>
<span class="fc" id="L146">			IsomorphismIMapping mapping =</span>
<span class="fc" id="L147">					new IsomorphismTesters.IndexMapping(g1, g2, nextMapping, computeEdgeMapping(nextMapping));</span>
<span class="fc" id="L148">			advance();</span>
<span class="fc" id="L149">			return mapping;</span>
		}

		private int[] computeEdgeMapping(int[] vMapping) {
<span class="fc" id="L153">			int[] eMapping = new int[g1.edges().size()];</span>

<span class="fc" id="L155">			Arrays.fill(visit, -1);</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">			for (final int u1 : range(g1.vertices().size())) {</span>
<span class="fc" id="L157">				final int u2 = vMapping[u1];</span>
<span class="fc" id="L158">				final int visitIdx = u1;</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">				for (IEdgeIter eit = g1.outEdges(u1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L160">					int e1 = eit.nextInt();</span>
<span class="fc" id="L161">					int v1 = eit.targetInt();</span>
<span class="fc" id="L162">					int v2 = vMapping[v1];</span>
<span class="fc" id="L163">					visit[v2] = visitIdx;</span>
<span class="fc" id="L164">					visitData[v2] = e1;</span>
<span class="fc" id="L165">				}</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">				for (IEdgeIter eit = g2.outEdges(u2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L167">					int e2 = eit.nextInt();</span>
<span class="fc" id="L168">					int v2 = eit.targetInt();</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">					if (visit[v2] == visitIdx) {</span>
<span class="fc" id="L170">						int e1 = visitData[v2];</span>
<span class="fc" id="L171">						eMapping[e1] = e2;						</span>
					}
<span class="fc" id="L173">				}</span>
<span class="fc" id="L174">			}</span>
<span class="fc" id="L175">			Arrays.fill(visit, 0);</span>
<span class="fc" id="L176">			nextVisitIdx = 1;</span>

<span class="fc" id="L178">			return eMapping;</span>
		}

		boolean canMatchVertices(int v1, int v2) {
<span class="fc bfc" id="L182" title="All 4 branches covered.">			return vertexMatcher == null || vertexMatcher.applyAsInt(v1, v2) != 0;</span>
		}

		boolean canMatchEdges(int e1, int e2) {
<span class="fc bfc" id="L186" title="All 4 branches covered.">			return edgeMatcher == null || edgeMatcher.applyAsInt(e1, e2) != 0;</span>
		}
	}

<span class="fc" id="L190">	private static class IsomorphismIterDirected extends IsomorphismIterBase {</span>

		private final int[] in1;
		private final int[] in2;
		private final int[] out1;
		private final int[] out2;

		private final int[] stateT1OutSize;
		private final int[] stateT2OutSize;
		private final int[] stateT1InSize;
		private final int[] stateT2InSize;

		IsomorphismIterDirected(IndexGraph g1, IndexGraph g2, IsomorphismType type, IntBinaryOperator vertexMatcher,
				IntBinaryOperator edgeMatcher) {
<span class="fc" id="L204">			super(g1, g2, type, vertexMatcher, edgeMatcher);</span>

<span class="fc" id="L206">			in1 = new int[n1];</span>
<span class="fc" id="L207">			in2 = new int[n2];</span>
<span class="fc" id="L208">			out1 = new int[n1];</span>
<span class="fc" id="L209">			out2 = new int[n2];</span>

<span class="fc" id="L211">			final int maxStateDepth = n1 + 1;</span>
<span class="fc" id="L212">			stateT1OutSize = new int[maxStateDepth];</span>
<span class="fc" id="L213">			stateT2OutSize = new int[maxStateDepth];</span>
<span class="fc" id="L214">			stateT1InSize = new int[maxStateDepth];</span>
<span class="fc" id="L215">			stateT2InSize = new int[maxStateDepth];</span>
<span class="fc" id="L216">			newState(None, None, 0, 0, 0, 0);</span>

<span class="fc" id="L218">			advance();</span>
<span class="fc" id="L219">		}</span>

		private void newState(int v1, int v2, int t1OutSize, int t2OutSize, int t1InSize, int t2InSize) {
<span class="fc" id="L222">			statePrevV1[stateDepth] = v1;</span>
<span class="fc" id="L223">			statePrevV2[stateDepth] = v2;</span>
<span class="fc" id="L224">			stateT1OutSize[stateDepth] = t1OutSize;</span>
<span class="fc" id="L225">			stateT2OutSize[stateDepth] = t2OutSize;</span>
<span class="fc" id="L226">			stateT1InSize[stateDepth] = t1InSize;</span>
<span class="fc" id="L227">			stateT2InSize[stateDepth] = t2InSize;</span>

<span class="pc bnc" id="L229" title="All 2 branches missed.">			assert t1OutSize &lt; n1;</span>
<span class="pc bnc" id="L230" title="All 2 branches missed.">			assert t2OutSize &lt; n2;</span>
<span class="pc bnc" id="L231" title="All 2 branches missed.">			assert t1InSize &lt; n1;</span>
<span class="pc bnc" id="L232" title="All 2 branches missed.">			assert t2InSize &lt; n2;</span>

			int nextV1;
			IntIterator nextV2Iter;
			/*
			 * &quot;In case that only one of the in-terminal sets or only one of the out-terminal sets is empty, it can be
			 * demonstrated that the state s cannot be part of a matching, and it is not further explored.&quot; Although
			 * this is stated in the paper, this does not seem to be correct for non-full isomorphism.
			 */
<span class="fc bfc" id="L241" title="All 14 branches covered.">			if (type == IsomorphismType.Full</span>
					&amp;&amp; ((t1OutSize == 0 ^ t2OutSize == 0) || (t1InSize == 0 ^ t2InSize == 0))) {
<span class="fc" id="L243">				nextV1 = None;</span>
<span class="fc" id="L244">				nextV2Iter = IntIterators.EMPTY_ITERATOR;</span>

			} else {
<span class="fc bfc" id="L247" title="All 4 branches covered.">				if (t1OutSize != 0 &amp;&amp; t2OutSize != 0) {</span>
					/* P(s)=T^{out}_1 (s) \times \{\min T^{out}_2(s)\} */
					/* we use the opposite notation of G1 G2 than what used in the paper (G1 is the smaller graph) */
<span class="fc bfc" id="L250" title="All 4 branches covered.">					nextV1 = IterTools.filter(range(n1).iterator(), u1 -&gt; core1[u1] &lt; 0 &amp;&amp; out1[u1] &gt; 0).nextInt();</span>
<span class="fc bfc" id="L251" title="All 4 branches covered.">					nextV2Iter = IterTools.filter(range(n2).iterator(), u2 -&gt; core2[u2] &lt; 0 &amp;&amp; out2[u2] &gt; 0);</span>

<span class="fc bfc" id="L253" title="All 4 branches covered.">				} else if (t1InSize != 0 &amp;&amp; t2InSize != 0) {</span>
					/* P(s)=T^{in}_1 (s) \times \{\min T^{in}_2(s)\} */
					/* we use the opposite notation of G1 G2 than what used in the paper (G1 is the smaller graph) */
<span class="fc bfc" id="L256" title="All 4 branches covered.">					nextV1 = IterTools.filter(range(n1).iterator(), u1 -&gt; core1[u1] &lt; 0 &amp;&amp; in1[u1] &gt; 0).nextInt();</span>
<span class="fc bfc" id="L257" title="All 4 branches covered.">					nextV2Iter = IterTools.filter(range(n2).iterator(), u2 -&gt; core2[u2] &lt; 0 &amp;&amp; in2[u2] &gt; 0);</span>

				} else {
					/* P(s)=(N_1 - M_1(s)) \times \{\min (N_2 - M_2)\} */
<span class="fc bfc" id="L261" title="All 2 branches covered.">					nextV1 = IterTools.filter(range(n1).iterator(), u1 -&gt; core1[u1] &lt; 0).nextInt();</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">					nextV2Iter = IterTools.filter(range(n2).iterator(), u2 -&gt; core2[u2] &lt; 0);</span>
				}
<span class="pc bnc" id="L264" title="All 2 branches missed.">				assert nextV2Iter.hasNext();</span>
			}
<span class="fc" id="L266">			stateNextV1[stateDepth] = nextV1;</span>
<span class="fc" id="L267">			stateNextV2Iter[stateDepth] = nextV2Iter;</span>
<span class="fc" id="L268">		}</span>

		@Override
		void advance() {
<span class="fc bfc" id="L272" title="All 2 branches covered.">			dfs: while (stateDepth &gt; 0) {</span>
<span class="fc" id="L273">				final int v1 = stateNextV1[stateDepth];</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">				for (IntIterator v2Iter = stateNextV2Iter[stateDepth]; v2Iter.hasNext();) {</span>
<span class="fc" id="L275">					final int v2 = v2Iter.nextInt();</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">					if (!isFeasibleMatchVertices(v1, v2))</span>
<span class="fc" id="L277">						continue;</span>

<span class="fc bfc" id="L279" title="All 2 branches covered.">					if (stateDepth == n1) {</span>
						/* found a valid full matching */
<span class="fc" id="L281">						nextMapping = core1.clone();</span>
<span class="fc" id="L282">						nextMapping[v1] = v2;</span>
<span class="fc" id="L283">						return;</span>
					}
					/* match v1 to v2 and update state */
<span class="fc" id="L286">					core1[v1] = v2;</span>
<span class="fc" id="L287">					core2[v2] = v1;</span>
<span class="fc" id="L288">					stateDepth++;</span>
<span class="fc" id="L289">					updateState(v1, v2);</span>

<span class="fc bfc" id="L291" title="All 2 branches covered.">					if (!isFeasibleCurrentState()) {</span>
<span class="fc" id="L292">						popLastState();</span>
<span class="fc" id="L293">						continue;</span>
					}
					continue dfs;
				}
<span class="fc" id="L297">				popLastState();</span>
<span class="fc" id="L298">			}</span>
<span class="fc" id="L299">			nextMapping = null;</span>
<span class="fc" id="L300">		}</span>

		private boolean isFeasibleMatchVertices(int v1, int v2) {
			/* check user custom matcher */
<span class="fc bfc" id="L304" title="All 2 branches covered.">			if (!canMatchVertices(v1, v2))</span>
<span class="fc" id="L305">				return false;</span>

			/*
			 * check that out edges connecting v1 and other mapped vertices of g1 can be mapped to out edges connecting
			 * v2 and other mapped vertices of g2
			 */
<span class="fc" id="L311">			int visitIdx = nextVisitIdx++;</span>
<span class="fc" id="L312">			int edgeCount = 0;</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">			for (IEdgeIter eit = g1.outEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L314">				int e1 = eit.nextInt();</span>
<span class="fc" id="L315">				int w1 = eit.targetInt();</span>
<span class="fc" id="L316">				int w2 = core1[w1];</span>
<span class="fc bfc" id="L317" title="All 4 branches covered.">				if (w2 &lt; 0 &amp;&amp; v1 != w1)</span>
<span class="fc" id="L318">					continue;</span>
<span class="fc" id="L319">				visit[w1] = visitIdx;</span>
<span class="fc" id="L320">				visitData[w1] = e1;</span>
<span class="fc" id="L321">				edgeCount++;</span>

<span class="fc" id="L323">			}</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">			for (IEdgeIter eit = g2.outEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L325">				int e2 = eit.nextInt();</span>
<span class="fc" id="L326">				int w2 = eit.targetInt();</span>
<span class="fc" id="L327">				int w1 = core2[w2];</span>
<span class="fc bfc" id="L328" title="All 4 branches covered.">				if (w1 &lt; 0 &amp;&amp; v2 != w2)</span>
<span class="fc" id="L329">					continue;</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">				if (v2 == w2)</span>
<span class="fc" id="L331">					w1 = v1;</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">				if (visit[w1] == visitIdx) {</span>
<span class="fc" id="L333">					int e1 = visitData[w1];</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">					if (!canMatchEdges(e1, e2))</span>
<span class="fc" id="L335">						return false;</span>
<span class="fc" id="L336">					edgeCount--;</span>

<span class="fc bfc" id="L338" title="All 2 branches covered.">				} else if (inducedSubGraph) {</span>
					/* there is no edge (v1,w1) matching e2 */
<span class="fc" id="L340">					return false;</span>
				}
<span class="fc" id="L342">			}</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">			if (edgeCount != 0)</span>
				/* there are some edges connecting v1 in g1 without match in g2 */
<span class="fc" id="L345">				return false;</span>

			/*
			 * check that in edges connecting v1 and other mapped vertices of g1 can be mapped to in edges connecting v2
			 * and other mapped vertices of g2
			 */
<span class="fc" id="L351">			visitIdx = nextVisitIdx++;</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">			for (IEdgeIter eit = g1.inEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L353">				int e1 = eit.nextInt();</span>
<span class="fc" id="L354">				int u1 = eit.sourceInt();</span>
<span class="fc" id="L355">				int u2 = core1[u1];</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">				if (u2 &lt; 0)</span>
<span class="fc" id="L357">					continue;</span>
<span class="fc" id="L358">				visit[u1] = visitIdx;</span>
<span class="fc" id="L359">				visitData[u1] = e1;</span>
<span class="fc" id="L360">				edgeCount++;</span>
<span class="fc" id="L361">			}</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">			for (IEdgeIter eit = g2.inEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L363">				int e2 = eit.nextInt();</span>
<span class="fc" id="L364">				int u2 = eit.sourceInt();</span>
<span class="fc" id="L365">				int u1 = core2[u2];</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">				if (u1 &lt; 0)</span>
<span class="fc" id="L367">					continue;</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">				if (visit[u1] == visitIdx) {</span>
<span class="fc" id="L369">					int e1 = visitData[u1];</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">					if (!canMatchEdges(e1, e2))</span>
<span class="fc" id="L371">						return false;</span>
<span class="fc" id="L372">					edgeCount--;</span>

<span class="fc bfc" id="L374" title="All 2 branches covered.">				} else if (inducedSubGraph) {</span>
					/* there is no edge (u1,v1) matching e2 */
<span class="fc" id="L376">					return false;</span>
				}
<span class="fc" id="L378">			}</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">			if (edgeCount != 0)</span>
				/* there are some edges connecting v1 in g1 without match in g2 */
<span class="fc" id="L381">				return false;</span>

<span class="fc" id="L383">			return true;</span>
		}

		private boolean isFeasibleCurrentState() {
<span class="fc bfc" id="L387" title="All 2 branches covered.">			if (subGraph) {</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">				if (stateT1OutSize[stateDepth] &gt; stateT2OutSize[stateDepth])</span>
<span class="fc" id="L389">					return false;</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">				if (stateT1InSize[stateDepth] &gt; stateT2InSize[stateDepth])</span>
<span class="fc" id="L391">					return false;</span>
			} else {
<span class="fc bfc" id="L393" title="All 2 branches covered.">				if (stateT1OutSize[stateDepth] != stateT2OutSize[stateDepth])</span>
<span class="fc" id="L394">					return false;</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">				if (stateT1InSize[stateDepth] != stateT2InSize[stateDepth])</span>
<span class="fc" id="L396">					return false;</span>
			}
<span class="fc" id="L398">			return true;</span>
		}

		private void updateState(int v1, int v2) {
<span class="fc" id="L402">			final int depth = stateDepth - 1;</span>
<span class="fc" id="L403">			int t1OutSize = stateT1OutSize[depth];</span>
<span class="fc" id="L404">			int t2OutSize = stateT2OutSize[depth];</span>
<span class="fc" id="L405">			int t1InSize = stateT1InSize[depth];</span>
<span class="fc" id="L406">			int t2InSize = stateT2InSize[depth];</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">			if (in1[v1] == 0) {</span>
<span class="fc" id="L408">				in1[v1] = depth;</span>
			} else {
<span class="fc" id="L410">				t1InSize--;</span>
			}
<span class="fc bfc" id="L412" title="All 2 branches covered.">			if (out1[v1] == 0) {</span>
<span class="fc" id="L413">				out1[v1] = depth;</span>
			} else {
<span class="fc" id="L415">				t1OutSize--;</span>
			}
<span class="fc bfc" id="L417" title="All 2 branches covered.">			if (in2[v2] == 0) {</span>
<span class="fc" id="L418">				in2[v2] = depth;</span>
			} else {
<span class="fc" id="L420">				t2InSize--;</span>
			}
<span class="fc bfc" id="L422" title="All 2 branches covered.">			if (out2[v2] == 0) {</span>
<span class="fc" id="L423">				out2[v2] = depth;</span>
			} else {
<span class="fc" id="L425">				t2OutSize--;</span>
			}
<span class="fc bfc" id="L427" title="All 2 branches covered.">			for (IEdgeIter eit = g1.outEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L428">				eit.nextInt();</span>
<span class="fc" id="L429">				int w = eit.targetInt();</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">				if (out1[w] == 0) {</span>
<span class="fc" id="L431">					out1[w] = depth;</span>
<span class="fc" id="L432">					t1OutSize++;</span>
				}
<span class="fc" id="L434">			}</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">			for (IEdgeIter eit = g1.inEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L436">				eit.nextInt();</span>
<span class="fc" id="L437">				int u = eit.sourceInt();</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">				if (in1[u] == 0) {</span>
<span class="fc" id="L439">					in1[u] = depth;</span>
<span class="fc" id="L440">					t1InSize++;</span>
				}
<span class="fc" id="L442">			}</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">			for (IEdgeIter eit = g2.outEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L444">				eit.nextInt();</span>
<span class="fc" id="L445">				int w = eit.targetInt();</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">				if (out2[w] == 0) {</span>
<span class="fc" id="L447">					out2[w] = depth;</span>
<span class="fc" id="L448">					t2OutSize++;</span>
				}
<span class="fc" id="L450">			}</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">			for (IEdgeIter eit = g2.inEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L452">				eit.nextInt();</span>
<span class="fc" id="L453">				int u = eit.sourceInt();</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">				if (in2[u] == 0) {</span>
<span class="fc" id="L455">					in2[u] = depth;</span>
<span class="fc" id="L456">					t2InSize++;</span>
				}
<span class="fc" id="L458">			}</span>

<span class="fc" id="L460">			newState(v1, v2, t1OutSize, t2OutSize, t1InSize, t2InSize);</span>
<span class="fc" id="L461">		}</span>

		private void popLastState() {
<span class="fc" id="L464">			final int prevV1 = statePrevV1[stateDepth];</span>
<span class="fc" id="L465">			final int prevV2 = statePrevV2[stateDepth];</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">			if (prevV1 &gt;= 0) {</span>
<span class="fc" id="L467">				final int prevDepth = stateDepth - 1;</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">				for (IEdgeIter eit = g1.outEdges(prevV1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L469">					eit.nextInt();</span>
<span class="fc" id="L470">					int w = eit.targetInt();</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">					if (out1[w] == prevDepth)</span>
<span class="fc" id="L472">						out1[w] = 0;</span>
<span class="fc" id="L473">				}</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">				for (IEdgeIter eit = g1.inEdges(prevV1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L475">					eit.nextInt();</span>
<span class="fc" id="L476">					int u = eit.sourceInt();</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">					if (in1[u] == prevDepth)</span>
<span class="fc" id="L478">						in1[u] = 0;</span>
<span class="fc" id="L479">				}</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">				for (IEdgeIter eit = g2.outEdges(prevV2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L481">					eit.nextInt();</span>
<span class="fc" id="L482">					int w = eit.targetInt();</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">					if (out2[w] == prevDepth)</span>
<span class="fc" id="L484">						out2[w] = 0;</span>
<span class="fc" id="L485">				}</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">				for (IEdgeIter eit = g2.inEdges(prevV2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L487">					eit.nextInt();</span>
<span class="fc" id="L488">					int u = eit.sourceInt();</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">					if (in2[u] == prevDepth)</span>
<span class="fc" id="L490">						in2[u] = 0;</span>
<span class="fc" id="L491">				}</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">				if (in1[prevV1] == prevDepth)</span>
<span class="fc" id="L493">					in1[prevV1] = 0;</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">				if (out1[prevV1] == prevDepth)</span>
<span class="fc" id="L495">					out1[prevV1] = 0;</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">				if (in2[prevV2] == prevDepth)</span>
<span class="fc" id="L497">					in2[prevV2] = 0;</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">				if (out2[prevV2] == prevDepth)</span>
<span class="fc" id="L499">					out2[prevV2] = 0;</span>
<span class="fc" id="L500">				core1[prevV1] = None;</span>
<span class="fc" id="L501">				core2[prevV2] = None;</span>
			}
<span class="fc" id="L503">			stateDepth--;</span>
<span class="fc" id="L504">		}</span>
	}

<span class="fc" id="L507">	private static class IsomorphismIterUndirected extends IsomorphismIterBase {</span>

		private final int[] out1;
		private final int[] out2;

		private final int[] stateT1OutSize;
		private final int[] stateT2OutSize;

		IsomorphismIterUndirected(IndexGraph g1, IndexGraph g2, IsomorphismType type, IntBinaryOperator vertexMatcher,
				IntBinaryOperator edgeMatcher) {
<span class="fc" id="L517">			super(g1, g2, type, vertexMatcher, edgeMatcher);</span>

<span class="fc" id="L519">			out1 = new int[n1];</span>
<span class="fc" id="L520">			out2 = new int[n2];</span>

<span class="fc" id="L522">			final int maxStateDepth = n1 + 1;</span>
<span class="fc" id="L523">			stateT1OutSize = new int[maxStateDepth];</span>
<span class="fc" id="L524">			stateT2OutSize = new int[maxStateDepth];</span>
<span class="fc" id="L525">			newState(None, None, 0, 0);</span>

<span class="fc" id="L527">			advance();</span>
<span class="fc" id="L528">		}</span>

		private void newState(int v1, int v2, int t1OutSize, int t2OutSize) {
<span class="fc" id="L531">			statePrevV1[stateDepth] = v1;</span>
<span class="fc" id="L532">			statePrevV2[stateDepth] = v2;</span>
<span class="fc" id="L533">			stateT1OutSize[stateDepth] = t1OutSize;</span>
<span class="fc" id="L534">			stateT2OutSize[stateDepth] = t2OutSize;</span>

<span class="pc bnc" id="L536" title="All 2 branches missed.">			assert t1OutSize &lt; n1;</span>
<span class="pc bnc" id="L537" title="All 2 branches missed.">			assert t2OutSize &lt; n2;</span>
			int nextV1;
			IntIterator nextV2Iter;
			/*
			 * &quot;In case that only one of the in-terminal sets or only one of the out-terminal sets is empty, it can be
			 * demonstrated that the state s cannot be part of a matching, and it is not further explored.&quot; Although
			 * this is stated in the paper, this does not seem to be correct for non-full isomorphism.
			 */
<span class="fc bfc" id="L545" title="All 8 branches covered.">			if (type == IsomorphismType.Full &amp;&amp; (t1OutSize == 0 ^ t2OutSize == 0)) {</span>
<span class="fc" id="L546">				nextV1 = None;</span>
<span class="fc" id="L547">				nextV2Iter = IntIterators.EMPTY_ITERATOR;</span>

			} else {
<span class="fc bfc" id="L550" title="All 4 branches covered.">				if (t1OutSize != 0 &amp;&amp; t2OutSize != 0) {</span>
					/* P(s)=T^{out}_1 (s) \times \{\min T^{out}_2(s)\} */
					/* we use the opposite notation of G1 G2 than what used in the paper (G1 is the smaller graph) */
<span class="fc bfc" id="L553" title="All 4 branches covered.">					nextV1 = IterTools.filter(range(n1).iterator(), u1 -&gt; core1[u1] &lt; 0 &amp;&amp; out1[u1] &gt; 0).nextInt();</span>
<span class="fc bfc" id="L554" title="All 4 branches covered.">					nextV2Iter = IterTools.filter(range(n2).iterator(), u2 -&gt; core2[u2] &lt; 0 &amp;&amp; out2[u2] &gt; 0);</span>

				} else {
					/* P(s)=(N_1 - M_1(s)) \times \{\min (N_2 - M_2)\} */
					/* we use the opposite notation of G1 G2 than what used in the paper (G1 is the smaller graph) */
<span class="fc bfc" id="L559" title="All 2 branches covered.">					nextV1 = IterTools.filter(range(n1).iterator(), u1 -&gt; core1[u1] &lt; 0).nextInt();</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">					nextV2Iter = IterTools.filter(range(n2).iterator(), u2 -&gt; core2[u2] &lt; 0);</span>
				}
<span class="pc bnc" id="L562" title="All 2 branches missed.">				assert nextV2Iter.hasNext();</span>
			}
<span class="fc" id="L564">			stateNextV1[stateDepth] = nextV1;</span>
<span class="fc" id="L565">			stateNextV2Iter[stateDepth] = nextV2Iter;</span>
<span class="fc" id="L566">		}</span>

		@Override
		void advance() {
<span class="fc bfc" id="L570" title="All 2 branches covered.">			dfs: while (stateDepth &gt; 0) {</span>
<span class="fc" id="L571">				final int v1 = stateNextV1[stateDepth];</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">				for (IntIterator v2Iter = stateNextV2Iter[stateDepth]; v2Iter.hasNext();) {</span>
<span class="fc" id="L573">					final int v2 = v2Iter.nextInt();</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">					if (!isFeasibleMatchVertices(v1, v2))</span>
<span class="fc" id="L575">						continue;</span>

<span class="fc bfc" id="L577" title="All 2 branches covered.">					if (stateDepth == n1) {</span>
						/* found a valid full matching */
<span class="fc" id="L579">						nextMapping = core1.clone();</span>
<span class="fc" id="L580">						nextMapping[v1] = v2;</span>
<span class="fc" id="L581">						return;</span>
					}
					/* match v1 to v2 and update state */
<span class="fc" id="L584">					core1[v1] = v2;</span>
<span class="fc" id="L585">					core2[v2] = v1;</span>
<span class="fc" id="L586">					stateDepth++;</span>
<span class="fc" id="L587">					updateState(v1, v2);</span>

<span class="fc bfc" id="L589" title="All 2 branches covered.">					if (!isFeasibleCurrentState()) {</span>
<span class="fc" id="L590">						popLastState();</span>
<span class="fc" id="L591">						continue;</span>
					}
					continue dfs;
				}
<span class="fc" id="L595">				popLastState();</span>
<span class="fc" id="L596">			}</span>
<span class="fc" id="L597">			nextMapping = null;</span>
<span class="fc" id="L598">		}</span>

		private boolean isFeasibleMatchVertices(int v1, int v2) {
			/* check user custom matcher */
<span class="fc bfc" id="L602" title="All 2 branches covered.">			if (!canMatchVertices(v1, v2))</span>
<span class="fc" id="L603">				return false;</span>

			/*
			 * check that out edges connecting v1 and other mapped vertices of g1 can be mapped to out edges connecting
			 * v2 and other mapped vertices of g2
			 */
<span class="fc" id="L609">			int visitIdx = nextVisitIdx++;</span>
<span class="fc" id="L610">			int edgeCount = 0;</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">			for (IEdgeIter eit = g1.outEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L612">				int e1 = eit.nextInt();</span>
<span class="fc" id="L613">				int w1 = eit.targetInt();</span>
<span class="fc" id="L614">				int w2 = core1[w1];</span>
<span class="fc bfc" id="L615" title="All 4 branches covered.">				if (w2 &lt; 0 &amp;&amp; v1 != w1)</span>
<span class="fc" id="L616">					continue;</span>
<span class="fc" id="L617">				visit[w1] = visitIdx;</span>
<span class="fc" id="L618">				visitData[w1] = e1;</span>
<span class="fc" id="L619">				edgeCount++;</span>
<span class="fc" id="L620">			}</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">			for (IEdgeIter eit = g2.outEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L622">				int e2 = eit.nextInt();</span>
<span class="fc" id="L623">				int w2 = eit.targetInt();</span>
<span class="fc" id="L624">				int w1 = core2[w2];</span>
<span class="fc bfc" id="L625" title="All 4 branches covered.">				if (w1 &lt; 0 &amp;&amp; v2 != w2)</span>
<span class="fc" id="L626">					continue;</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">				if (v2 == w2)</span>
<span class="fc" id="L628">					w1 = v1;</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">				if (visit[w1] == visitIdx) {</span>
<span class="fc" id="L630">					int e1 = visitData[w1];</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">					if (!canMatchEdges(e1, e2))</span>
<span class="fc" id="L632">						return false;</span>
<span class="fc" id="L633">					edgeCount--;</span>

<span class="fc bfc" id="L635" title="All 2 branches covered.">				} else if (inducedSubGraph) {</span>
					/* there is no edge (v1,w1) matching e2 */
<span class="fc" id="L637">					return false;</span>
				}
<span class="fc" id="L639">			}</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">			if (edgeCount != 0)</span>
				/* there are some edges connecting v1 in g1 without match in g2 */
<span class="fc" id="L642">				return false;</span>

<span class="fc" id="L644">			return true;</span>
		}

		private boolean isFeasibleCurrentState() {
<span class="fc bfc" id="L648" title="All 2 branches covered.">			if (subGraph) {</span>
<span class="fc bfc" id="L649" title="All 2 branches covered.">				if (stateT1OutSize[stateDepth] &gt; stateT2OutSize[stateDepth])</span>
<span class="fc" id="L650">					return false;</span>
			} else {
<span class="fc bfc" id="L652" title="All 2 branches covered.">				if (stateT1OutSize[stateDepth] != stateT2OutSize[stateDepth])</span>
<span class="fc" id="L653">					return false;</span>
			}
<span class="fc" id="L655">			return true;</span>
		}

		private void updateState(int v1, int v2) {
<span class="fc" id="L659">			final int depth = stateDepth - 1;</span>
<span class="fc" id="L660">			int t1OutSize = stateT1OutSize[depth];</span>
<span class="fc" id="L661">			int t2OutSize = stateT2OutSize[depth];</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">			if (out1[v1] == 0) {</span>
<span class="fc" id="L663">				out1[v1] = depth;</span>
			} else {
<span class="fc" id="L665">				t1OutSize--;</span>
			}
<span class="fc bfc" id="L667" title="All 2 branches covered.">			if (out2[v2] == 0) {</span>
<span class="fc" id="L668">				out2[v2] = depth;</span>
			} else {
<span class="fc" id="L670">				t2OutSize--;</span>
			}
<span class="fc bfc" id="L672" title="All 2 branches covered.">			for (IEdgeIter eit = g1.outEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L673">				eit.nextInt();</span>
<span class="fc" id="L674">				int w = eit.targetInt();</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">				if (out1[w] == 0) {</span>
<span class="fc" id="L676">					out1[w] = depth;</span>
<span class="fc" id="L677">					t1OutSize++;</span>
				}
<span class="fc" id="L679">			}</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">			for (IEdgeIter eit = g2.outEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L681">				eit.nextInt();</span>
<span class="fc" id="L682">				int w = eit.targetInt();</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">				if (out2[w] == 0) {</span>
<span class="fc" id="L684">					out2[w] = depth;</span>
<span class="fc" id="L685">					t2OutSize++;</span>
				}
<span class="fc" id="L687">			}</span>

<span class="fc" id="L689">			newState(v1, v2, t1OutSize, t2OutSize);</span>
<span class="fc" id="L690">		}</span>

		private void popLastState() {
<span class="fc" id="L693">			final int prevV1 = statePrevV1[stateDepth];</span>
<span class="fc" id="L694">			final int prevV2 = statePrevV2[stateDepth];</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">			if (prevV1 &gt;= 0) {</span>
<span class="fc" id="L696">				final int prevDepth = stateDepth - 1;</span>
<span class="fc bfc" id="L697" title="All 2 branches covered.">				for (IEdgeIter eit = g1.outEdges(prevV1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L698">					eit.nextInt();</span>
<span class="fc" id="L699">					int w = eit.targetInt();</span>
<span class="fc bfc" id="L700" title="All 2 branches covered.">					if (out1[w] == prevDepth)</span>
<span class="fc" id="L701">						out1[w] = 0;</span>
<span class="fc" id="L702">				}</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">				for (IEdgeIter eit = g2.outEdges(prevV2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L704">					eit.nextInt();</span>
<span class="fc" id="L705">					int w = eit.targetInt();</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">					if (out2[w] == prevDepth)</span>
<span class="fc" id="L707">						out2[w] = 0;</span>
<span class="fc" id="L708">				}</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">				if (out1[prevV1] == prevDepth)</span>
<span class="fc" id="L710">					out1[prevV1] = 0;</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">				if (out2[prevV2] == prevDepth)</span>
<span class="fc" id="L712">					out2[prevV2] = 0;</span>
<span class="fc" id="L713">				core1[prevV1] = None;</span>
<span class="fc" id="L714">				core2[prevV2] = None;</span>
			}

<span class="fc" id="L717">			stateDepth--;</span>
<span class="fc" id="L718">		}</span>

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>