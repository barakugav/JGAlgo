<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IsomorphismTesterVf2.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.alg</a> &gt; <span class="el_source">IsomorphismTesterVf2.java</span></div><h1>IsomorphismTesterVf2.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.alg;

import static com.jgalgo.internal.util.Range.range;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.Objects;
import java.util.function.IntBinaryOperator;
import com.jgalgo.graph.IEdgeIter;
import com.jgalgo.graph.IndexGraph;
import com.jgalgo.internal.util.Assertions;
import com.jgalgo.internal.util.IterTools;
import it.unimi.dsi.fastutil.ints.IntIterator;
import it.unimi.dsi.fastutil.ints.IntIterators;
import it.unimi.dsi.fastutil.objects.ObjectIterators;

/**
 * Vf2 algorithm for testing isomorphism of two graphs.
 *
 * &lt;p&gt;
 * Based on 'An Improved Algorithm for Matching Large Graphs' by L. P. Cordella, P. Foggia, C. Sansone and M. Vento.
 *
 * @author Barak Ugav
 */
<span class="fc" id="L40">class IsomorphismTesterVf2 implements IsomorphismTesterBase {</span>

	@Override
	public Iterator&lt;IsomorphismIMapping&gt; isomorphicMappingsIter(IndexGraph g1, IndexGraph g2, IsomorphismType type,
			IntBinaryOperator vertexMatcher, IntBinaryOperator edgeMatcher) {
<span class="fc" id="L45">		Assertions.noParallelEdges(g1, &quot;parallel edges are not supported&quot;);</span>
<span class="fc" id="L46">		Assertions.noParallelEdges(g2, &quot;parallel edges are not supported&quot;);</span>
<span class="fc bfc" id="L47" title="All 2 branches covered.">		if (g1.isDirected() != g2.isDirected())</span>
<span class="fc" id="L48">			throw new IllegalArgumentException(&quot;directed/undirected graphs mismatch&quot;);</span>
<span class="fc" id="L49">		Objects.requireNonNull(type);</span>

<span class="fc" id="L51">		final int n1 = g1.vertices().size();</span>
<span class="fc" id="L52">		final int n2 = g2.vertices().size();</span>
<span class="fc" id="L53">		final int m1 = g1.edges().size();</span>
<span class="fc" id="L54">		final int m2 = g2.edges().size();</span>

<span class="fc bfc" id="L56" title="All 6 branches covered.">		if (type == IsomorphismType.Full &amp;&amp; (n1 != n2 || m1 != m2))</span>
<span class="fc" id="L57">			return Collections.emptyIterator();</span>

<span class="fc bfc" id="L59" title="All 10 branches covered.">		if (n1 &lt; n2 || m1 &lt; m2 || (n1 == n2 &amp;&amp; m1 != m2 &amp;&amp; type != IsomorphismType.SubGraph))</span>
<span class="fc" id="L60">			return Collections.emptyIterator();</span>

<span class="fc bfc" id="L62" title="All 2 branches covered.">		if (n2 == 0) {</span>
<span class="pc bnc" id="L63" title="All 2 branches missed.">			assert m2 == 0;</span>
<span class="fc" id="L64">			int[] vMapping = new int[n1];</span>
<span class="fc" id="L65">			int[] eMapping = new int[m1];</span>
<span class="fc" id="L66">			Arrays.fill(vMapping, -1);</span>
<span class="fc" id="L67">			Arrays.fill(eMapping, -1);</span>
<span class="fc" id="L68">			return ObjectIterators.singleton(new IsomorphismTesters.IndexMapping(g1, g2, vMapping, eMapping));</span>
		}

<span class="fc bfc" id="L71" title="All 2 branches covered.">		if (g1.isDirected()) {</span>
<span class="fc" id="L72">			return new IsomorphismIterDirected(g1, g2, type, vertexMatcher, edgeMatcher);</span>
		} else {
<span class="fc" id="L74">			return new IsomorphismIterUndirected(g1, g2, type, vertexMatcher, edgeMatcher);</span>
		}
	}

<span class="fc" id="L78">	private abstract static class IsomorphismIterBase implements Iterator&lt;IsomorphismIMapping&gt; {</span>

		final IndexGraph g1;
		final IndexGraph g2;
		final int n1, n2;
		private final IntBinaryOperator vertexMatcher;
		private final IntBinaryOperator edgeMatcher;
		final IsomorphismType type;
		final boolean subGraph;
		final boolean inducedSubGraph;

		final int[] core1;
		final int[] core2;
		int stateDepth;
		final int[] statePrevV1;
		final int[] statePrevV2;
		final IntIterator[] stateNextV1Iter;
		final int[] stateNextV2;

<span class="fc" id="L97">		int nextVisitIdx = 1;</span>
		final int[] visit;
		final int[] visitData;

		int[] nextMapping;

		static final int None = -1;

		IsomorphismIterBase(IndexGraph g1, IndexGraph g2, IsomorphismType type, IntBinaryOperator vertexMatcher,
<span class="fc" id="L106">				IntBinaryOperator edgeMatcher) {</span>
<span class="fc" id="L107">			this.g1 = g1;</span>
<span class="fc" id="L108">			this.g2 = g2;</span>
<span class="fc" id="L109">			n1 = g1.vertices().size();</span>
<span class="fc" id="L110">			n2 = g2.vertices().size();</span>
<span class="fc" id="L111">			this.type = type;</span>
<span class="fc" id="L112">			this.vertexMatcher = vertexMatcher;</span>
<span class="fc" id="L113">			this.edgeMatcher = edgeMatcher;</span>

<span class="pc bnc" id="L115" title="All 2 branches missed.">			assert n1 &gt;= n2;</span>
<span class="fc bfc" id="L116" title="All 4 branches covered.">			subGraph = type == IsomorphismType.SubGraph || n1 &gt; n2;</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">			inducedSubGraph = Objects.requireNonNull(type) != IsomorphismType.SubGraph;</span>

<span class="fc" id="L119">			core1 = new int[n1];</span>
<span class="fc" id="L120">			core2 = new int[n2];</span>
<span class="fc" id="L121">			Arrays.fill(core1, None);</span>
<span class="fc" id="L122">			Arrays.fill(core2, None);</span>

<span class="fc" id="L124">			visit = new int[/* max(n1,n2) */ n1];</span>
<span class="fc" id="L125">			visitData = new int[/* max(n1,n2) */ n1];</span>

<span class="fc" id="L127">			stateDepth = 1;</span>
<span class="fc" id="L128">			final int maxStateDepth = n2 + 1;</span>
<span class="fc" id="L129">			statePrevV1 = new int[maxStateDepth];</span>
<span class="fc" id="L130">			statePrevV2 = new int[maxStateDepth];</span>
<span class="fc" id="L131">			stateNextV1Iter = new IntIterator[maxStateDepth];</span>
<span class="fc" id="L132">			stateNextV2 = new int[maxStateDepth];</span>
<span class="fc" id="L133">		}</span>

		abstract void advance();

		@Override
		public boolean hasNext() {
<span class="fc bfc" id="L139" title="All 2 branches covered.">			return nextMapping != null;</span>
		}

		@Override
		public IsomorphismIMapping next() {
<span class="fc" id="L144">			Assertions.hasNext(this);</span>
<span class="fc" id="L145">			IsomorphismIMapping mapping =</span>
<span class="fc" id="L146">					new IsomorphismTesters.IndexMapping(g1, g2, nextMapping, computeEdgeMapping(nextMapping));</span>
<span class="fc" id="L147">			advance();</span>
<span class="fc" id="L148">			return mapping;</span>
		}

		private int[] computeEdgeMapping(int[] vMapping) {
<span class="fc" id="L152">			int[] eMapping = new int[g1.edges().size()];</span>
<span class="fc" id="L153">			Arrays.fill(eMapping, -1);</span>

<span class="fc" id="L155">			Arrays.fill(visit, -1);</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">			for (final int u1 : range(g1.vertices().size())) {</span>
<span class="fc" id="L157">				final int u2 = vMapping[u1];</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">				if (u2 &lt; 0)</span>
<span class="fc" id="L159">					continue;</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">				for (IEdgeIter eit = g1.outEdges(u1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L161">					int e1 = eit.nextInt();</span>
<span class="fc" id="L162">					int v1 = eit.targetInt();</span>
<span class="fc" id="L163">					int v2 = vMapping[v1];</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">					if (v2 &gt;= 0)</span>
<span class="fc" id="L165">						visit[v2] = e1;</span>
<span class="fc" id="L166">				}</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">				for (IEdgeIter eit = g2.outEdges(u2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L168">					int e2 = eit.nextInt();</span>
<span class="fc" id="L169">					int v2 = eit.targetInt();</span>
<span class="fc" id="L170">					int e1 = visit[v2];</span>
<span class="fc" id="L171">					eMapping[e1] = e2;</span>
<span class="fc" id="L172">				}</span>
<span class="fc" id="L173">			}</span>
<span class="fc" id="L174">			Arrays.fill(visit, -1);</span>
<span class="fc" id="L175">			nextVisitIdx = 1;</span>

<span class="fc" id="L177">			return eMapping;</span>
		}

		boolean canMatchVertices(int v1, int v2) {
<span class="fc bfc" id="L181" title="All 4 branches covered.">			return vertexMatcher == null || vertexMatcher.applyAsInt(v1, v2) != 0;</span>
		}

		boolean canMatchEdges(int e1, int e2) {
<span class="fc bfc" id="L185" title="All 4 branches covered.">			return edgeMatcher == null || edgeMatcher.applyAsInt(e1, e2) != 0;</span>
		}
	}

<span class="fc" id="L189">	private static class IsomorphismIterDirected extends IsomorphismIterBase {</span>

		private final int[] in1;
		private final int[] in2;
		private final int[] out1;
		private final int[] out2;

		private final int[] stateT1OutSize;
		private final int[] stateT2OutSize;
		private final int[] stateT1InSize;
		private final int[] stateT2InSize;

		IsomorphismIterDirected(IndexGraph g1, IndexGraph g2, IsomorphismType type, IntBinaryOperator vertexMatcher,
				IntBinaryOperator edgeMatcher) {
<span class="fc" id="L203">			super(g1, g2, type, vertexMatcher, edgeMatcher);</span>

<span class="fc" id="L205">			in1 = new int[n1];</span>
<span class="fc" id="L206">			in2 = new int[n2];</span>
<span class="fc" id="L207">			out1 = new int[n1];</span>
<span class="fc" id="L208">			out2 = new int[n2];</span>

<span class="fc" id="L210">			final int maxStateDepth = n2 + 1;</span>
<span class="fc" id="L211">			stateT1OutSize = new int[maxStateDepth];</span>
<span class="fc" id="L212">			stateT2OutSize = new int[maxStateDepth];</span>
<span class="fc" id="L213">			stateT1InSize = new int[maxStateDepth];</span>
<span class="fc" id="L214">			stateT2InSize = new int[maxStateDepth];</span>
<span class="fc" id="L215">			newState(None, None, 0, 0, 0, 0);</span>

<span class="fc" id="L217">			advance();</span>
<span class="fc" id="L218">		}</span>

		private void newState(int v1, int v2, int t1OutSize, int t2OutSize, int t1InSize, int t2InSize) {
<span class="fc" id="L221">			statePrevV1[stateDepth] = v1;</span>
<span class="fc" id="L222">			statePrevV2[stateDepth] = v2;</span>
<span class="fc" id="L223">			stateT1OutSize[stateDepth] = t1OutSize;</span>
<span class="fc" id="L224">			stateT2OutSize[stateDepth] = t2OutSize;</span>
<span class="fc" id="L225">			stateT1InSize[stateDepth] = t1InSize;</span>
<span class="fc" id="L226">			stateT2InSize[stateDepth] = t2InSize;</span>

<span class="pc bnc" id="L228" title="All 2 branches missed.">			assert t1OutSize &lt; n1;</span>
<span class="pc bnc" id="L229" title="All 2 branches missed.">			assert t2OutSize &lt; n2;</span>
<span class="pc bnc" id="L230" title="All 2 branches missed.">			assert t1InSize &lt; n1;</span>
<span class="pc bnc" id="L231" title="All 2 branches missed.">			assert t2InSize &lt; n2;</span>

			IntIterator nextV1Iter;
			int nextV2;
			/*
			 * &quot;In case that only one of the in-terminal sets or only one of the out-terminal sets is empty, it can be
			 * demonstrated that the state s cannot be part of a matching, and it is not further explored.&quot; Although
			 * this is stated in the paper, this does not seem to be correct for non-full isomorphism.
			 */
<span class="fc bfc" id="L240" title="All 14 branches covered.">			if (type == IsomorphismType.Full</span>
					&amp;&amp; ((t1OutSize == 0 ^ t2OutSize == 0) || (t1InSize == 0 ^ t2InSize == 0))) {
<span class="fc" id="L242">				nextV1Iter = IntIterators.EMPTY_ITERATOR;</span>
<span class="fc" id="L243">				nextV2 = None;</span>

			} else {
<span class="fc bfc" id="L246" title="All 4 branches covered.">				if (t1OutSize != 0 &amp;&amp; t2OutSize != 0) {</span>
					/* P(s)=T^{out}_1 (s) \times \{\min T^{out}_2(s)\} */
<span class="fc bfc" id="L248" title="All 4 branches covered.">					nextV1Iter = IterTools.filter(range(n1).iterator(), u1 -&gt; core1[u1] &lt; 0 &amp;&amp; out1[u1] &gt; 0);</span>
<span class="fc bfc" id="L249" title="All 4 branches covered.">					nextV2 = IterTools.filter(range(n2).iterator(), u2 -&gt; core2[u2] &lt; 0 &amp;&amp; out2[u2] &gt; 0).nextInt();</span>

<span class="fc bfc" id="L251" title="All 4 branches covered.">				} else if (t1InSize != 0 &amp;&amp; t2InSize != 0) {</span>
					/* P(s)=T^{in}_1 (s) \times \{\min T^{in}_2(s)\} */
<span class="fc bfc" id="L253" title="All 4 branches covered.">					nextV1Iter = IterTools.filter(range(n1).iterator(), u1 -&gt; core1[u1] &lt; 0 &amp;&amp; in1[u1] &gt; 0);</span>
<span class="fc bfc" id="L254" title="All 4 branches covered.">					nextV2 = IterTools.filter(range(n2).iterator(), u2 -&gt; core2[u2] &lt; 0 &amp;&amp; in2[u2] &gt; 0).nextInt();</span>

				} else {
					/* P(s)=(N_1 - M_1(s)) \times \{\min (N_2 - M_2)\} */
<span class="fc bfc" id="L258" title="All 2 branches covered.">					nextV1Iter = IterTools.filter(range(n1).iterator(), u1 -&gt; core1[u1] &lt; 0);</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">					nextV2 = IterTools.filter(range(n2).iterator(), u2 -&gt; core2[u2] &lt; 0).nextInt();</span>
				}
<span class="pc bnc" id="L261" title="All 2 branches missed.">				assert nextV1Iter.hasNext();</span>
			}
<span class="fc" id="L263">			stateNextV1Iter[stateDepth] = nextV1Iter;</span>
<span class="fc" id="L264">			stateNextV2[stateDepth] = nextV2;</span>
<span class="fc" id="L265">		}</span>

		@Override
		void advance() {
<span class="fc bfc" id="L269" title="All 2 branches covered.">			dfs: while (stateDepth &gt; 0) {</span>
<span class="fc" id="L270">				final int v2 = stateNextV2[stateDepth];</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">				for (IntIterator v1Iter = stateNextV1Iter[stateDepth]; v1Iter.hasNext();) {</span>
<span class="fc" id="L272">					final int v1 = v1Iter.nextInt();</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">					if (!isFeasibleMatchVertices(v1, v2))</span>
<span class="fc" id="L274">						continue;</span>

<span class="fc bfc" id="L276" title="All 2 branches covered.">					if (stateDepth == n2) {</span>
						/* found a valid full matching */
<span class="fc" id="L278">						nextMapping = core1.clone();</span>
<span class="fc" id="L279">						nextMapping[v1] = v2;</span>
<span class="fc" id="L280">						return;</span>
					}
					/* match v1 to v2 and update state */
<span class="fc" id="L283">					core1[v1] = v2;</span>
<span class="fc" id="L284">					core2[v2] = v1;</span>
<span class="fc" id="L285">					stateDepth++;</span>
<span class="fc" id="L286">					updateState(v1, v2);</span>

<span class="fc bfc" id="L288" title="All 2 branches covered.">					if (!isFeasibleCurrentState()) {</span>
<span class="fc" id="L289">						popLastState();</span>
<span class="fc" id="L290">						continue;</span>
					}
					continue dfs;
				}
<span class="fc" id="L294">				popLastState();</span>
<span class="fc" id="L295">			}</span>
<span class="fc" id="L296">			nextMapping = null;</span>
<span class="fc" id="L297">		}</span>

		private boolean isFeasibleMatchVertices(int v1, int v2) {
			/* check user custom matcher */
<span class="fc bfc" id="L301" title="All 2 branches covered.">			if (!canMatchVertices(v1, v2))</span>
<span class="fc" id="L302">				return false;</span>

			/*
			 * check that out edges connecting v2 and other mapped vertices of g2 can be mapped to out edges connecting
			 * v1 and other mapped vertices of g1
			 */
<span class="fc" id="L308">			int visitIdx = nextVisitIdx++;</span>
<span class="fc" id="L309">			int edgeCount = 0;</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">			for (IEdgeIter eit = g2.outEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L311">				int e2 = eit.nextInt();</span>
<span class="fc" id="L312">				int w2 = eit.targetInt();</span>
<span class="fc" id="L313">				int w1 = core2[w2];</span>
<span class="fc bfc" id="L314" title="All 4 branches covered.">				if (w1 &lt; 0 &amp;&amp; v2 != w2)</span>
<span class="fc" id="L315">					continue;</span>
<span class="fc" id="L316">				visit[w2] = visitIdx;</span>
<span class="fc" id="L317">				visitData[w2] = e2;</span>
<span class="fc" id="L318">				edgeCount++;</span>

<span class="fc" id="L320">			}</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">			for (IEdgeIter eit = g1.outEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L322">				int e1 = eit.nextInt();</span>
<span class="fc" id="L323">				int w1 = eit.targetInt();</span>
<span class="fc" id="L324">				int w2 = core1[w1];</span>
<span class="fc bfc" id="L325" title="All 4 branches covered.">				if (w2 &lt; 0 &amp;&amp; v1 != w1)</span>
<span class="fc" id="L326">					continue;</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">				if (v1 == w1)</span>
<span class="fc" id="L328">					w2 = v2;</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">				if (visit[w2] == visitIdx) {</span>
<span class="fc" id="L330">					int e2 = visitData[w2];</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">					if (!canMatchEdges(e1, e2))</span>
<span class="fc" id="L332">						return false;</span>
<span class="fc" id="L333">					edgeCount--;</span>

<span class="fc bfc" id="L335" title="All 2 branches covered.">				} else if (inducedSubGraph) {</span>
					/* there is no edge (v2,w2) matching e1 */
<span class="fc" id="L337">					return false;</span>
				}
<span class="fc" id="L339">			}</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">			if (edgeCount != 0)</span>
				/* there are some edges connecting v2 in g2 without match in g1 */
<span class="fc" id="L342">				return false;</span>

			/*
			 * check that in edges connecting v2 and other mapped vertices of g2 can be mapped to in edges connecting v1
			 * and other mapped vertices of g1
			 */
<span class="fc" id="L348">			visitIdx = nextVisitIdx++;</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">			for (IEdgeIter eit = g2.inEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L350">				int e2 = eit.nextInt();</span>
<span class="fc" id="L351">				int u2 = eit.sourceInt();</span>
<span class="fc" id="L352">				int u1 = core2[u2];</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">				if (u1 &lt; 0)</span>
<span class="fc" id="L354">					continue;</span>
<span class="fc" id="L355">				visit[u2] = visitIdx;</span>
<span class="fc" id="L356">				visitData[u2] = e2;</span>
<span class="fc" id="L357">				edgeCount++;</span>
<span class="fc" id="L358">			}</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">			for (IEdgeIter eit = g1.inEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L360">				int e1 = eit.nextInt();</span>
<span class="fc" id="L361">				int u1 = eit.sourceInt();</span>
<span class="fc" id="L362">				int u2 = core1[u1];</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">				if (u2 &lt; 0)</span>
<span class="fc" id="L364">					continue;</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">				if (visit[u2] == visitIdx) {</span>
<span class="fc" id="L366">					int e2 = visitData[u2];</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">					if (!canMatchEdges(e1, e2))</span>
<span class="fc" id="L368">						return false;</span>
<span class="fc" id="L369">					edgeCount--;</span>

<span class="fc bfc" id="L371" title="All 2 branches covered.">				} else if (inducedSubGraph) {</span>
					/* there is no edge (u2,v2) matching e1 */
<span class="fc" id="L373">					return false;</span>
				}
<span class="fc" id="L375">			}</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">			if (edgeCount != 0)</span>
				/* there are some edges connecting v2 in g2 without match in g1 */
<span class="fc" id="L378">				return false;</span>

<span class="fc" id="L380">			return true;</span>
		}

		private boolean isFeasibleCurrentState() {
<span class="fc bfc" id="L384" title="All 2 branches covered.">			if (subGraph) {</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">				if (stateT1OutSize[stateDepth] &lt; stateT2OutSize[stateDepth])</span>
<span class="fc" id="L386">					return false;</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">				if (stateT1InSize[stateDepth] &lt; stateT2InSize[stateDepth])</span>
<span class="fc" id="L388">					return false;</span>
			} else {
<span class="fc bfc" id="L390" title="All 2 branches covered.">				if (stateT1OutSize[stateDepth] != stateT2OutSize[stateDepth])</span>
<span class="fc" id="L391">					return false;</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">				if (stateT1InSize[stateDepth] != stateT2InSize[stateDepth])</span>
<span class="fc" id="L393">					return false;</span>
			}
<span class="fc" id="L395">			return true;</span>
		}

		private void updateState(int v1, int v2) {
<span class="fc" id="L399">			final int depth = stateDepth - 1;</span>
<span class="fc" id="L400">			int t1OutSize = stateT1OutSize[depth];</span>
<span class="fc" id="L401">			int t2OutSize = stateT2OutSize[depth];</span>
<span class="fc" id="L402">			int t1InSize = stateT1InSize[depth];</span>
<span class="fc" id="L403">			int t2InSize = stateT2InSize[depth];</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">			if (in1[v1] == 0) {</span>
<span class="fc" id="L405">				in1[v1] = depth;</span>
			} else {
<span class="fc" id="L407">				t1InSize--;</span>
			}
<span class="fc bfc" id="L409" title="All 2 branches covered.">			if (out1[v1] == 0) {</span>
<span class="fc" id="L410">				out1[v1] = depth;</span>
			} else {
<span class="fc" id="L412">				t1OutSize--;</span>
			}
<span class="fc bfc" id="L414" title="All 2 branches covered.">			if (in2[v2] == 0) {</span>
<span class="fc" id="L415">				in2[v2] = depth;</span>
			} else {
<span class="fc" id="L417">				t2InSize--;</span>
			}
<span class="fc bfc" id="L419" title="All 2 branches covered.">			if (out2[v2] == 0) {</span>
<span class="fc" id="L420">				out2[v2] = depth;</span>
			} else {
<span class="fc" id="L422">				t2OutSize--;</span>
			}
<span class="fc bfc" id="L424" title="All 2 branches covered.">			for (IEdgeIter eit = g1.outEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L425">				eit.nextInt();</span>
<span class="fc" id="L426">				int w = eit.targetInt();</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">				if (out1[w] == 0) {</span>
<span class="fc" id="L428">					out1[w] = depth;</span>
<span class="fc" id="L429">					t1OutSize++;</span>
				}
<span class="fc" id="L431">			}</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">			for (IEdgeIter eit = g1.inEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L433">				eit.nextInt();</span>
<span class="fc" id="L434">				int u = eit.sourceInt();</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">				if (in1[u] == 0) {</span>
<span class="fc" id="L436">					in1[u] = depth;</span>
<span class="fc" id="L437">					t1InSize++;</span>
				}
<span class="fc" id="L439">			}</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">			for (IEdgeIter eit = g2.outEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L441">				eit.nextInt();</span>
<span class="fc" id="L442">				int w = eit.targetInt();</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">				if (out2[w] == 0) {</span>
<span class="fc" id="L444">					out2[w] = depth;</span>
<span class="fc" id="L445">					t2OutSize++;</span>
				}
<span class="fc" id="L447">			}</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">			for (IEdgeIter eit = g2.inEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L449">				eit.nextInt();</span>
<span class="fc" id="L450">				int u = eit.sourceInt();</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">				if (in2[u] == 0) {</span>
<span class="fc" id="L452">					in2[u] = depth;</span>
<span class="fc" id="L453">					t2InSize++;</span>
				}
<span class="fc" id="L455">			}</span>

<span class="fc" id="L457">			newState(v1, v2, t1OutSize, t2OutSize, t1InSize, t2InSize);</span>
<span class="fc" id="L458">		}</span>

		private void popLastState() {
<span class="fc" id="L461">			final int prevV1 = statePrevV1[stateDepth];</span>
<span class="fc" id="L462">			final int prevV2 = statePrevV2[stateDepth];</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">			if (prevV1 &gt;= 0) {</span>
<span class="fc" id="L464">				final int prevDepth = stateDepth - 1;</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">				for (IEdgeIter eit = g1.outEdges(prevV1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L466">					eit.nextInt();</span>
<span class="fc" id="L467">					int w = eit.targetInt();</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">					if (out1[w] == prevDepth)</span>
<span class="fc" id="L469">						out1[w] = 0;</span>
<span class="fc" id="L470">				}</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">				for (IEdgeIter eit = g1.inEdges(prevV1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L472">					eit.nextInt();</span>
<span class="fc" id="L473">					int u = eit.sourceInt();</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">					if (in1[u] == prevDepth)</span>
<span class="fc" id="L475">						in1[u] = 0;</span>
<span class="fc" id="L476">				}</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">				for (IEdgeIter eit = g2.outEdges(prevV2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L478">					eit.nextInt();</span>
<span class="fc" id="L479">					int w = eit.targetInt();</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">					if (out2[w] == prevDepth)</span>
<span class="fc" id="L481">						out2[w] = 0;</span>
<span class="fc" id="L482">				}</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">				for (IEdgeIter eit = g2.inEdges(prevV2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L484">					eit.nextInt();</span>
<span class="fc" id="L485">					int u = eit.sourceInt();</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">					if (in2[u] == prevDepth)</span>
<span class="fc" id="L487">						in2[u] = 0;</span>
<span class="fc" id="L488">				}</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">				if (in1[prevV1] == prevDepth)</span>
<span class="fc" id="L490">					in1[prevV1] = 0;</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">				if (out1[prevV1] == prevDepth)</span>
<span class="fc" id="L492">					out1[prevV1] = 0;</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">				if (in2[prevV2] == prevDepth)</span>
<span class="fc" id="L494">					in2[prevV2] = 0;</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">				if (out2[prevV2] == prevDepth)</span>
<span class="fc" id="L496">					out2[prevV2] = 0;</span>
<span class="fc" id="L497">				core1[prevV1] = None;</span>
<span class="fc" id="L498">				core2[prevV2] = None;</span>
			}
<span class="fc" id="L500">			stateDepth--;</span>
<span class="fc" id="L501">		}</span>
	}

<span class="fc" id="L504">	private static class IsomorphismIterUndirected extends IsomorphismIterBase {</span>

		private final int[] out1;
		private final int[] out2;

		private final int[] stateT1OutSize;
		private final int[] stateT2OutSize;

		IsomorphismIterUndirected(IndexGraph g1, IndexGraph g2, IsomorphismType type, IntBinaryOperator vertexMatcher,
				IntBinaryOperator edgeMatcher) {
<span class="fc" id="L514">			super(g1, g2, type, vertexMatcher, edgeMatcher);</span>

<span class="fc" id="L516">			out1 = new int[n1];</span>
<span class="fc" id="L517">			out2 = new int[n2];</span>

<span class="fc" id="L519">			final int maxStateDepth = n2 + 1;</span>
<span class="fc" id="L520">			stateT1OutSize = new int[maxStateDepth];</span>
<span class="fc" id="L521">			stateT2OutSize = new int[maxStateDepth];</span>
<span class="fc" id="L522">			newState(None, None, 0, 0);</span>

<span class="fc" id="L524">			advance();</span>
<span class="fc" id="L525">		}</span>

		private void newState(int v1, int v2, int t1OutSize, int t2OutSize) {
<span class="fc" id="L528">			statePrevV1[stateDepth] = v1;</span>
<span class="fc" id="L529">			statePrevV2[stateDepth] = v2;</span>
<span class="fc" id="L530">			stateT1OutSize[stateDepth] = t1OutSize;</span>
<span class="fc" id="L531">			stateT2OutSize[stateDepth] = t2OutSize;</span>

<span class="pc bnc" id="L533" title="All 2 branches missed.">			assert t1OutSize &lt; n1;</span>
<span class="pc bnc" id="L534" title="All 2 branches missed.">			assert t2OutSize &lt; n2;</span>

			IntIterator nextV1Iter;
			int nextV2;
			/*
			 * &quot;In case that only one of the in-terminal sets or only one of the out-terminal sets is empty, it can be
			 * demonstrated that the state s cannot be part of a matching, and it is not further explored.&quot; Although
			 * this is stated in the paper, this does not seem to be correct for non-full isomorphism.
			 */
<span class="fc bfc" id="L543" title="All 8 branches covered.">			if (type == IsomorphismType.Full &amp;&amp; (t1OutSize == 0 ^ t2OutSize == 0)) {</span>
<span class="fc" id="L544">				nextV1Iter = IntIterators.EMPTY_ITERATOR;</span>
<span class="fc" id="L545">				nextV2 = None;</span>

			} else {
<span class="fc bfc" id="L548" title="All 4 branches covered.">				if (t1OutSize != 0 &amp;&amp; t2OutSize != 0) {</span>
					/* P(s)=T^{out}_1 (s) \times \{\min T^{out}_2(s)\} */
<span class="fc bfc" id="L550" title="All 4 branches covered.">					nextV1Iter = IterTools.filter(range(n1).iterator(), u1 -&gt; core1[u1] &lt; 0 &amp;&amp; out1[u1] &gt; 0);</span>
<span class="fc bfc" id="L551" title="All 4 branches covered.">					nextV2 = IterTools.filter(range(n2).iterator(), u2 -&gt; core2[u2] &lt; 0 &amp;&amp; out2[u2] &gt; 0).nextInt();</span>

				} else {
					/* P(s)=(N_1 - M_1(s)) \times \{\min (N_2 - M_2)\} */
<span class="fc bfc" id="L555" title="All 2 branches covered.">					nextV1Iter = IterTools.filter(range(n1).iterator(), u1 -&gt; core1[u1] &lt; 0);</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">					nextV2 = IterTools.filter(range(n2).iterator(), u2 -&gt; core2[u2] &lt; 0).nextInt();</span>
				}
<span class="pc bnc" id="L558" title="All 2 branches missed.">				assert nextV1Iter.hasNext();</span>
			}
<span class="fc" id="L560">			stateNextV1Iter[stateDepth] = nextV1Iter;</span>
<span class="fc" id="L561">			stateNextV2[stateDepth] = nextV2;</span>
<span class="fc" id="L562">		}</span>

		@Override
		void advance() {
<span class="fc bfc" id="L566" title="All 2 branches covered.">			dfs: while (stateDepth &gt; 0) {</span>
<span class="fc" id="L567">				final int v2 = stateNextV2[stateDepth];</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">				for (IntIterator v1Iter = stateNextV1Iter[stateDepth]; v1Iter.hasNext();) {</span>
<span class="fc" id="L569">					final int v1 = v1Iter.nextInt();</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">					if (!isFeasibleMatchVertices(v1, v2))</span>
<span class="fc" id="L571">						continue;</span>

<span class="fc bfc" id="L573" title="All 2 branches covered.">					if (stateDepth == n2) {</span>
						/* found a valid full matching */
<span class="fc" id="L575">						nextMapping = core1.clone();</span>
<span class="fc" id="L576">						nextMapping[v1] = v2;</span>
<span class="fc" id="L577">						return;</span>
					}
					/* match v1 to v2 and update state */
<span class="fc" id="L580">					core1[v1] = v2;</span>
<span class="fc" id="L581">					core2[v2] = v1;</span>
<span class="fc" id="L582">					stateDepth++;</span>
<span class="fc" id="L583">					updateState(v1, v2);</span>

<span class="fc bfc" id="L585" title="All 2 branches covered.">					if (!isFeasibleCurrentState()) {</span>
<span class="fc" id="L586">						popLastState();</span>
<span class="fc" id="L587">						continue;</span>
					}
					continue dfs;
				}
<span class="fc" id="L591">				popLastState();</span>
<span class="fc" id="L592">			}</span>
<span class="fc" id="L593">			nextMapping = null;</span>
<span class="fc" id="L594">		}</span>

		private boolean isFeasibleMatchVertices(int v1, int v2) {
			/* check user custom matcher */
<span class="fc bfc" id="L598" title="All 2 branches covered.">			if (!canMatchVertices(v1, v2))</span>
<span class="fc" id="L599">				return false;</span>

			/*
			 * check that out edges connecting v2 and other mapped vertices of g2 can be mapped to out edges connecting
			 * v1 and other mapped vertices of g1
			 */
<span class="fc" id="L605">			int visitIdx = nextVisitIdx++;</span>
<span class="fc" id="L606">			int edgeCount = 0;</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">			for (IEdgeIter eit = g2.outEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L608">				int e2 = eit.nextInt();</span>
<span class="fc" id="L609">				int w2 = eit.targetInt();</span>
<span class="fc" id="L610">				int w1 = core2[w2];</span>
<span class="fc bfc" id="L611" title="All 4 branches covered.">				if (w1 &lt; 0 &amp;&amp; v2 != w2)</span>
<span class="fc" id="L612">					continue;</span>
<span class="fc" id="L613">				visit[w2] = visitIdx;</span>
<span class="fc" id="L614">				visitData[w2] = e2;</span>
<span class="fc" id="L615">				edgeCount++;</span>
<span class="fc" id="L616">			}</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">			for (IEdgeIter eit = g1.outEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L618">				int e1 = eit.nextInt();</span>
<span class="fc" id="L619">				int w1 = eit.targetInt();</span>
<span class="fc" id="L620">				int w2 = core1[w1];</span>
<span class="fc bfc" id="L621" title="All 4 branches covered.">				if (w2 &lt; 0 &amp;&amp; v1 != w1)</span>
<span class="fc" id="L622">					continue;</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">				if (v1 == w1)</span>
<span class="fc" id="L624">					w2 = v2;</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">				if (visit[w2] == visitIdx) {</span>
<span class="fc" id="L626">					int e2 = visitData[w2];</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">					if (!canMatchEdges(e1, e2))</span>
<span class="fc" id="L628">						return false;</span>
<span class="fc" id="L629">					edgeCount--;</span>

<span class="fc bfc" id="L631" title="All 2 branches covered.">				} else if (inducedSubGraph) {</span>
					/* there is no edge (v2,w2) matching e1 */
<span class="fc" id="L633">					return false;</span>
				}
<span class="fc" id="L635">			}</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">			if (edgeCount != 0)</span>
				/* there are some edges connecting v2 in g2 without match in g1 */
<span class="fc" id="L638">				return false;</span>

<span class="fc" id="L640">			return true;</span>
		}

		private boolean isFeasibleCurrentState() {
<span class="fc bfc" id="L644" title="All 2 branches covered.">			if (subGraph) {</span>
<span class="fc bfc" id="L645" title="All 2 branches covered.">				if (stateT1OutSize[stateDepth] &lt; stateT2OutSize[stateDepth])</span>
<span class="fc" id="L646">					return false;</span>
			} else {
<span class="fc bfc" id="L648" title="All 2 branches covered.">				if (stateT1OutSize[stateDepth] != stateT2OutSize[stateDepth])</span>
<span class="fc" id="L649">					return false;</span>
			}
<span class="fc" id="L651">			return true;</span>
		}

		private void updateState(int v1, int v2) {
<span class="fc" id="L655">			final int depth = stateDepth - 1;</span>
<span class="fc" id="L656">			int t1OutSize = stateT1OutSize[depth];</span>
<span class="fc" id="L657">			int t2OutSize = stateT2OutSize[depth];</span>
<span class="fc bfc" id="L658" title="All 2 branches covered.">			if (out1[v1] == 0) {</span>
<span class="fc" id="L659">				out1[v1] = depth;</span>
			} else {
<span class="fc" id="L661">				t1OutSize--;</span>
			}
<span class="fc bfc" id="L663" title="All 2 branches covered.">			if (out2[v2] == 0) {</span>
<span class="fc" id="L664">				out2[v2] = depth;</span>
			} else {
<span class="fc" id="L666">				t2OutSize--;</span>
			}
<span class="fc bfc" id="L668" title="All 2 branches covered.">			for (IEdgeIter eit = g1.outEdges(v1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L669">				eit.nextInt();</span>
<span class="fc" id="L670">				int w = eit.targetInt();</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">				if (out1[w] == 0) {</span>
<span class="fc" id="L672">					out1[w] = depth;</span>
<span class="fc" id="L673">					t1OutSize++;</span>
				}
<span class="fc" id="L675">			}</span>
<span class="fc bfc" id="L676" title="All 2 branches covered.">			for (IEdgeIter eit = g2.outEdges(v2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L677">				eit.nextInt();</span>
<span class="fc" id="L678">				int w = eit.targetInt();</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">				if (out2[w] == 0) {</span>
<span class="fc" id="L680">					out2[w] = depth;</span>
<span class="fc" id="L681">					t2OutSize++;</span>
				}
<span class="fc" id="L683">			}</span>

<span class="fc" id="L685">			newState(v1, v2, t1OutSize, t2OutSize);</span>
<span class="fc" id="L686">		}</span>

		private void popLastState() {
<span class="fc" id="L689">			final int prevV1 = statePrevV1[stateDepth];</span>
<span class="fc" id="L690">			final int prevV2 = statePrevV2[stateDepth];</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">			if (prevV1 &gt;= 0) {</span>
<span class="fc" id="L692">				final int prevDepth = stateDepth - 1;</span>
<span class="fc bfc" id="L693" title="All 2 branches covered.">				for (IEdgeIter eit = g1.outEdges(prevV1).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L694">					eit.nextInt();</span>
<span class="fc" id="L695">					int w = eit.targetInt();</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">					if (out1[w] == prevDepth)</span>
<span class="fc" id="L697">						out1[w] = 0;</span>
<span class="fc" id="L698">				}</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">				for (IEdgeIter eit = g2.outEdges(prevV2).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L700">					eit.nextInt();</span>
<span class="fc" id="L701">					int w = eit.targetInt();</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">					if (out2[w] == prevDepth)</span>
<span class="fc" id="L703">						out2[w] = 0;</span>
<span class="fc" id="L704">				}</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">				if (out1[prevV1] == prevDepth)</span>
<span class="fc" id="L706">					out1[prevV1] = 0;</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">				if (out2[prevV2] == prevDepth)</span>
<span class="fc" id="L708">					out2[prevV2] = 0;</span>
<span class="fc" id="L709">				core1[prevV1] = None;</span>
<span class="fc" id="L710">				core2[prevV2] = None;</span>
			}

<span class="fc" id="L713">			stateDepth--;</span>
<span class="fc" id="L714">		}</span>

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>