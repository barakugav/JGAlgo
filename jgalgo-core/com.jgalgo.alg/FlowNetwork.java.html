<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FlowNetwork.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.alg</a> &gt; <span class="el_source">FlowNetwork.java</span></div><h1>FlowNetwork.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jgalgo.alg;

import com.jgalgo.graph.Graph;
import com.jgalgo.graph.WeightFunction;
import com.jgalgo.graph.Weights;
import com.jgalgo.internal.util.JGAlgoUtils;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntList;

/**
 * Flow on graph edges, with capacities and flows values.
 * &lt;p&gt;
 * A flow network on graph edges is defined as two functions: the capacity function \(C:E \rightarrow R\) and flow
 * function \( F:E \rightarrow R\). The capacity function define how many units of flow an edge can transfer from its
 * source to its target. The flow function define the number of units of flow that are currently transferred along each
 * edge. The capacity of any edge must be non negative, and the edge's flow must be smaller or equal to its capacity.
 * &lt;p&gt;
 * Problems formulated using flow networks involve a source and a sink vertices. The source is a vertex from which the
 * flow is originated, and every flow going along its edges must reach the sink vertex using the edges of the graphs
 * while not violating the capacities of the network. For each vertex except the source and sink the sum of flow units
 * going along {@link Graph#inEdges(int)} must be equal to the sum of flow units going along
 * {@link Graph#outEdges(int)}.
 * &lt;p&gt;
 * A flow is most intuitively defined on directed graphs, as the flow on an edge is transferred from one vertex to
 * another in some direction, but we can define and solve flow problem on undirected graphs as well. Technically, the
 * flows values returned by {@link #getFlow(int)} can either be positive or negative for undirected edges, with values
 * absolutely smaller than the capacity of the edge. A positive flow \(+f\) value assigned to edge {@code e} means a
 * flow directed from {@code edgeSource(e)} to {@code edgeTarget(e)} with \(f\) units of flow. A negative flow \(-f\)
 * value assigned to edge {@code e} means a flow directed from {@code edgeTarget(e)} to {@code edgeSource(e)} (opposite
 * direction) with \(|-f|\) units of flow (see {@link #getFlow(int)}).
 *
 * &lt;pre&gt; {@code
 * Graph g = ...;
 * FlowNetwork net = FlowNetwork.createAsEdgeWeight(g);
 * for (int e : g.edges())
 *  f.setCapacity(e, 1);
 *
 * int sourceVertex = ...;
 * int targetVertex = ...;
 * MaximumFlow maxFlowAlg = MaximumFlow.newBuilder().build();
 *
 * double totalFlow = maxFlowAlg.computeMaximumFlow(g, net, sourceVertex, targetVertex);
 * System.out.println(&quot;The maximum flow that can be pushed in the network is &quot; + totalFlow);
 * for (int e : g.edges()) {
 * 	double capacity = net.getCapacity(e);
 * 	double flow = net.getFlow(e);
 * 	System.out.println(&quot;flow on edge &quot; + e + &quot;: &quot; + flow + &quot;/&quot; + capacity);
 * }
 * }&lt;/pre&gt;
 *
 * @see    MaximumFlow
 * @author Barak Ugav
 */
public interface FlowNetwork {

	/**
	 * Get the capacity of an edge.
	 *
	 * @param  edge                      an edge identifier in the graph
	 * @return                           the capacity of the edge
	 * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge identifier
	 */
	double getCapacity(int edge);

	/**
	 * Set the capacity of an edge.
	 *
	 * @param  edge                      an edge identifier in the graph
	 * @param  capacity                  the new capacity of the edge
	 * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge identifier
	 * @throws IllegalArgumentException  if {@code capacity} is negative
	 */
	void setCapacity(int edge, double capacity);

	/**
	 * Get the amount of flow units going along an edge.
	 * &lt;p&gt;
	 * If the graph is directed, a flow of \(f\) units on {@code e}, for \(0 \leq f \leq cap(e)\), means a flow of \(f\)
	 * units of flow from {@code edgeSource(e)} to {@code edgeTarget(e)}.
	 * &lt;p&gt;
	 * If the graph is undirected, a flow of \(+f\) units on {@code e}, for \(0 \leq f \leq cap(e)\), means a flow of
	 * \(f\) units of flow from {@code edgeSource(e)} to {@code edgeTarget(e)}, while a flow of \(-f\) units on
	 * {@code e}, for \(-cap(e) \leq -f &amp;lt; 0\), means a flow of \(|-f|\) units of flow from {@code edgeTarget(e)} to
	 * {@code edgeSource(e)} (opposite direction).
	 *
	 * @param  edge                      an edge identifier in the graph
	 * @return                           the amount of flow units going along an edge
	 * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge identifier
	 */
	double getFlow(int edge);

	/**
	 * Set the amount of flow units going along an edge.
	 *
	 * @param  edge                      an edge identifier in the graph
	 * @param  flow                      the new flow of the edge
	 * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge identifier
	 */
	void setFlow(int edge, double flow);

	/**
	 * Get the sum of flow units going out of a source vertex.
	 *
	 * @param  g      a graph
	 * @param  source a source vertex
	 * @return        the sum of flow units going out of {@code source}
	 */
	default double getFlowSum(Graph g, int source) {
<span class="fc" id="L125">		return getFlowSum(g, IntList.of(source));</span>
	}

	/**
	 * Get the sum of flow units going out of a set of source vertices.
	 *
	 * @param  g       a graph
	 * @param  sources a set of source vertices
	 * @return         the sum of flow units going out of {@code sources}
	 */
	default double getFlowSum(Graph g, IntCollection sources) {
<span class="fc" id="L136">		double sum = 0;</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">		if (g.getCapabilities().directed()) {</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">			for (int source : sources) {</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">				for (int e : g.outEdges(source))</span>
<span class="fc" id="L140">					sum += getFlow(e);</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">				for (int e : g.inEdges(source))</span>
<span class="fc" id="L142">					sum -= getFlow(e);</span>
<span class="fc" id="L143">			}</span>
		} else {
<span class="nc bnc" id="L145" title="All 2 branches missed.">			for (int source : sources) {</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">				for (int e : g.outEdges(source)) {</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">					if (source != g.edgeTarget(e)) {</span>
<span class="nc" id="L148">						sum += getFlow(e);</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">					} else if (source != g.edgeSource(e)) {</span>
<span class="nc" id="L150">						sum -= getFlow(e);</span>
					}
<span class="nc" id="L152">				}</span>
<span class="nc" id="L153">			}</span>
		}
<span class="fc" id="L155">		return sum;</span>
	}

	/**
	 * Get the cost of the flow along a set of edges.
	 * &lt;p&gt;
	 * The cost function define the cost per unit of flow on each edge of the network. The cost of an edge in the
	 * network is defined as the flow on the edge multiplied by the cost per unit of flow on the edge.
	 *
	 * @param  edges the set of edges to sum their cost
	 * @param  cost  a edge weight cost function
	 * @return       the sum of the cost of the flow along the edges
	 */
	default double getCostSum(IntCollection edges, WeightFunction cost) {
<span class="nc" id="L169">		double sum = 0;</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">		if (cost instanceof WeightFunction.Int) {</span>
<span class="nc" id="L171">			WeightFunction.Int costInt = (WeightFunction.Int) cost;</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">			for (int e : edges)</span>
<span class="nc" id="L173">				sum += getFlow(e) * costInt.weightInt(e);</span>
<span class="nc" id="L174">		} else {</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">			for (int e : edges)</span>
<span class="nc" id="L176">				sum += getFlow(e) * cost.weight(e);</span>
		}
<span class="nc" id="L178">		return sum;</span>
	}

	/**
	 * Create a flow network by adding edge weights using {@link Graph#addEdgesWeights}.
	 * &lt;p&gt;
	 * Unless {@link #setCapacity(int, double)} or {@link #setFlow(int, double)} are used, the capacity and flow of each
	 * edge will be zero.
	 * &lt;p&gt;
	 * By using {@link Graph#addEdgesWeights}, the weights containers (and the flow network) remains valid in case the
	 * graph is modified, as they are added to the graph. This is a key difference between this function and
	 * {@link #createFromEdgeWeights(Weights.Double, Weights.Double)}, which if provided with weights containers created
	 * with {@link Weights#createExternalEdgesWeights}. doesn't remain valid if the graph is modified, but may suite in
	 * scenarios in which we are not allowed to add weights to the graph.
	 *
	 * @param  g a graph
	 * @return   a flow network implemented as edge weights containers added to the graph
	 */
	static FlowNetwork createFromEdgeWeights(Graph g) {
<span class="fc" id="L197">		Weights.Double capacities = g.addEdgesWeights(JGAlgoUtils.labeledObj(&quot;capacity&quot;), double.class);</span>
<span class="fc" id="L198">		Weights.Double flows = g.addEdgesWeights(JGAlgoUtils.labeledObj(&quot;flow&quot;), double.class);</span>
<span class="fc" id="L199">		return createFromEdgeWeights(capacities, flows);</span>
	}

	/**
	 * Create a flow network by using existing edge weights.
	 * &lt;p&gt;
	 * This method can be used together with {@link Weights#createExternalEdgesWeights}, creating a flow network for a
	 * graph without adding any new containers to it. This is useful in scenarios in which we are not allowed to modify
	 * the graph.
	 *
	 * @param  capacities a weight container containing the capacities of the edges
	 * @param  flows      a weight container that will contain the flow values of the edges
	 * @return            a flow network implemented as external edge weights containers
	 */
	static FlowNetwork createFromEdgeWeights(Weights.Double capacities, Weights.Double flows) {
<span class="fc" id="L214">		return new FlowNetworks.NetImplEdgeWeights(capacities, flows);</span>
	}

	/**
	 * Flow on graph edges, with integer capacities and flows values.
	 * &lt;p&gt;
	 * Similar to the regular {@link FlowNetwork} interface, but with integer capacities and flows. Some algorithms that
	 * work on flow networks are specifically for integers networks, or may performed faster if the capacities and flows
	 * are integers.
	 *
	 * @author Barak Ugav
	 */
	static interface Int extends FlowNetwork {

		/**
		 * Get the integer capacity of an edge.
		 *
		 * @param  edge                      an edge identifier in the graph
		 * @return                           the capacity of the edge
		 * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge identifier
		 */
		public int getCapacityInt(int edge);

		@Deprecated
		@Override
		default double getCapacity(int edge) {
<span class="fc" id="L240">			return getCapacityInt(edge);</span>
		}

		/**
		 * Set the integer capacity of an edge.
		 *
		 * @param  edge                      an edge identifier in the graph
		 * @param  capacity                  the new capacity of the edge
		 * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge identifier
		 * @throws IllegalArgumentException  if {@code capacity} is negative
		 */
		public void setCapacity(int edge, int capacity);

		@Deprecated
		@Override
		default void setCapacity(int edge, double capacity) {
<span class="nc" id="L256">			setCapacity(edge, (int) capacity);</span>
<span class="nc" id="L257">		}</span>

		/**
		 * Get the integer amount of flow units going along an edge.
		 * &lt;p&gt;
		 * If the graph is directed, a flow of \(f\) units on {@code e}, for \(0 \leq f \leq cap(e)\), means a flow of
		 * \(f\) units of flow from {@code edgeSource(e)} to {@code edgeTarget(e)}.
		 * &lt;p&gt;
		 * If the graph is undirected, a flow of \(+f\) units on {@code e}, for \(0 \leq f \leq cap(e)\), means a flow
		 * of \(f\) units of flow from {@code edgeSource(e)} to {@code edgeTarget(e)}, while a flow of \(-f\) units on
		 * {@code e}, for \(-cap(e) \leq -f &amp;lt; 0\), means a flow of \(|-f|\) units of flow from {@code edgeTarget(e)}
		 * to {@code edgeSource(e)} (opposite direction).
		 *
		 * @param  edge                      an edge identifier in the graph
		 * @return                           the amount of flow units going along an edge
		 * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge identifier
		 */
		public int getFlowInt(int edge);

		@Deprecated
		@Override
		default double getFlow(int edge) {
<span class="fc" id="L279">			return getFlowInt(edge);</span>
		}

		/**
		 * Set the integer amount of flow units going along an edge.
		 *
		 * @param  edge                      an edge identifier in the graph
		 * @param  flow                      the new flow of the edge
		 * @throws IndexOutOfBoundsException if {@code edge} is not a valid edge identifier
		 */
		public void setFlow(int edge, int flow);

		@Deprecated
		@Override
		default void setFlow(int edge, double flow) {
<span class="fc" id="L294">			setFlow(edge, (int) flow);</span>
<span class="fc" id="L295">		}</span>

		@Override
		default double getCostSum(IntCollection edges, WeightFunction cost) {
<span class="nc bnc" id="L299" title="All 2 branches missed.">			if (cost instanceof WeightFunction.Int) {</span>
<span class="nc" id="L300">				WeightFunction.Int costInt = (WeightFunction.Int) cost;</span>
<span class="nc" id="L301">				int sum = 0;</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">				for (int e : edges)</span>
<span class="nc" id="L303">					sum += getFlowInt(e) * costInt.weightInt(e);</span>
<span class="nc" id="L304">				return sum;</span>
			} else {
<span class="nc" id="L306">				double sum = 0;</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">				for (int e : edges)</span>
<span class="nc" id="L308">					sum += getFlowInt(e) * cost.weight(e);</span>
<span class="nc" id="L309">				return sum;</span>
			}
		}

		/**
		 * Create an integer flow network by adding edge weights using {@link Graph#addEdgesWeights}.
		 * &lt;p&gt;
		 * Unless {@link #setCapacity(int, int)} or {@link #setFlow(int, int)} are used, the capacity and flow of each
		 * edge will be zero.
		 * &lt;p&gt;
		 * By using {@link Graph#addEdgesWeights}, the weights containers (and the flow network) remains valid in case
		 * the graph is modified, as they are added to the graph. This is a key difference between this function and
		 * {@link #createFromEdgeWeights(Weights.Double, Weights.Double)}, which if provided with weights containers
		 * created with {@link Weights#createExternalEdgesWeights}. doesn't remain valid if the graph is modified, but
		 * may suite in scenarios in which we are not allowed to add weights to the graph.
		 *
		 * @param  g a graph
		 * @return   a flow network implemented as edge weights containers added to the graph
		 */
		static FlowNetwork.Int createFromEdgeWeights(Graph g) {
<span class="fc" id="L329">			Weights.Int capacities = g.addEdgesWeights(JGAlgoUtils.labeledObj(&quot;capacity&quot;), int.class);</span>
<span class="fc" id="L330">			Weights.Int flows = g.addEdgesWeights(JGAlgoUtils.labeledObj(&quot;flow&quot;), int.class);</span>
<span class="fc" id="L331">			return createFromEdgeWeights(capacities, flows);</span>
		}

		/**
		 * Create a flow network by using existing edge weights.
		 * &lt;p&gt;
		 * This method can be used together with {@link Weights#createExternalEdgesWeights}, creating a flow network for
		 * a graph without adding any new containers to it. This is useful in scenarios in which we are not allowed to
		 * modify the graph.
		 *
		 * @param  capacities a weight container containing the capacities of the edges
		 * @param  flows      a weight container that will contain the flow values of the edges
		 * @return            a flow network implemented as external edge weights containers
		 */
		static FlowNetwork.Int createFromEdgeWeights(Weights.Int capacities, Weights.Int flows) {
<span class="fc" id="L346">			return new FlowNetworks.NetImplEdgeWeightsInt(capacities, flows);</span>
		}

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>