<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SteinerTreeMehlhorn.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.alg</a> &gt; <span class="el_source">SteinerTreeMehlhorn.java</span></div><h1>SteinerTreeMehlhorn.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.alg;

import java.util.Arrays;
import java.util.function.IntConsumer;
import com.jgalgo.graph.IEdgeIter;
import com.jgalgo.graph.IWeightFunction;
import com.jgalgo.graph.IndexGraph;
import com.jgalgo.graph.IndexGraphBuilder;
import com.jgalgo.internal.util.Assertions;
import com.jgalgo.internal.util.Bitmap;
import com.jgalgo.internal.util.FIFOQueueIntNoReduce;
import com.jgalgo.internal.util.ImmutableIntArraySet;
import it.unimi.dsi.fastutil.doubles.DoubleArrayList;
import it.unimi.dsi.fastutil.ints.IntArrayList;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntList;
import it.unimi.dsi.fastutil.ints.IntPriorityQueue;

/**
 * Mehlhorn algorithm for Steiner tree approximation.
 *
 * &lt;p&gt;
 * The Steiner tree problem is NP-hard, and this algorithm provides a \(2(1-1/l)\)-approximation where \(l\) is the
 * minimum number of leaves in any Steiner tree for the given graph. Note that \(l\) is always smaller or equal to the
 * number of terminals vertices.
 *
 * &lt;p&gt;
 * The algorithm runs in \(O(m+n \log n)\) time and use linear space.
 *
 * &lt;p&gt;
 * Based on 'A faster approximation algorithm for the Steiner problem in graphs' by Kurt Mehlhorn.
 *
 * @author Barak Ugav
 */
<span class="fc" id="L50">class SteinerTreeMehlhorn extends SteinerTrees.AbstractImpl {</span>

<span class="fc" id="L52">	private final VoronoiAlgo voronoiAlgo = VoronoiAlgo.newInstance();</span>
<span class="fc" id="L53">	private final MinimumSpanningTree mstAlgo = MinimumSpanningTree.newInstance();</span>

	@Override
	IResult computeSteinerTree(IndexGraph g, IWeightFunction w, IntCollection terminals) {
<span class="fc" id="L57">		Assertions.Graphs.onlyUndirected(g);</span>
<span class="fc" id="L58">		final int n = g.vertices().size();</span>
<span class="pc bpc" id="L59" title="1 of 2 branches missed.">		if (terminals.isEmpty())</span>
<span class="nc" id="L60">			throw new IllegalArgumentException(&quot;no terminals provided&quot;);</span>
<span class="fc" id="L61">		final int terminalNum = terminals.size();</span>
<span class="fc" id="L62">		Bitmap isTerminal = new Bitmap(n);</span>
<span class="fc bfc" id="L63" title="All 2 branches covered.">		for (int t : terminals) {</span>
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">			if (isTerminal.get(t))</span>
<span class="nc" id="L65">				throw new IllegalArgumentException(&quot;Duplicate terminal: &quot; + t);</span>
<span class="fc" id="L66">			isTerminal.set(t);</span>
<span class="fc" id="L67">		}</span>

		/* 1.1. Compute the Voronoi cells of the terminals */
<span class="fc" id="L70">		VoronoiAlgo.IResult cells = (VoronoiAlgo.IResult) voronoiAlgo.computeVoronoiCells(g, terminals, w);</span>

		/*
		 * 1.2. Build the subgraph G'1 where each vertex is a terminal node and the edge connecting each pair of
		 * terminal nodes (s,t) is the minimum edge {d(s,u),(u,v),(v,t)} where u is in the cell of s and v is in the
		 * cell of t.
		 */
<span class="fc" id="L77">		IndexGraphBuilder g1Builder = IndexGraphBuilder.newUndirected();</span>
<span class="fc" id="L78">		g1Builder.expectedVerticesNum(terminalNum);</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">		for (int t = 0; t &lt; terminalNum; t++)</span>
<span class="fc" id="L80">			g1Builder.addVertex();</span>
<span class="fc" id="L81">		IntArrayList g1EdgeRef0 = new IntArrayList();</span>
<span class="fc" id="L82">		DoubleArrayList g1EdgeWeight0 = new DoubleArrayList();</span>
<span class="fc" id="L83">		int[] neighborsBestEdge = new int[terminalNum];</span>
<span class="fc" id="L84">		double[] neighborsBestWeight = new double[terminalNum];</span>
<span class="fc" id="L85">		Arrays.fill(neighborsBestEdge, -1);</span>
<span class="fc" id="L86">		IntList neighbors = new IntArrayList(terminalNum);</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">		for (int t = 0; t &lt; terminalNum; t++) {</span>
<span class="pc bnc" id="L88" title="All 6 branches missed.">			assert neighbors.isEmpty() &amp;&amp; Arrays.stream(neighborsBestEdge).allMatch(e -&gt; e == -1);</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">			for (int u : cells.blockVertices(t)) {</span>
<span class="fc" id="L90">				double uDistance = cells.distance(u);</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">				for (IEdgeIter eit = g.outEdges(u).iterator(); eit.hasNext();) {</span>
<span class="fc" id="L92">					int e = eit.nextInt();</span>
<span class="fc" id="L93">					int v = eit.targetInt();</span>
<span class="fc" id="L94">					int vT = cells.vertexBlock(v);</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">					if (vT &lt;= t)</span>
<span class="fc" id="L96">						continue;</span>
<span class="fc" id="L97">					double ew = uDistance + w.weight(e) + cells.distance(v);</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">					if (neighborsBestEdge[vT] == -1) {</span>
<span class="fc" id="L99">						neighborsBestEdge[vT] = e;</span>
<span class="fc" id="L100">						neighborsBestWeight[vT] = ew;</span>
<span class="fc" id="L101">						neighbors.add(vT);</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">					} else if (ew &lt; neighborsBestWeight[vT]) {</span>
<span class="fc" id="L103">						neighborsBestEdge[vT] = e;</span>
<span class="fc" id="L104">						neighborsBestWeight[vT] = ew;</span>
					}
<span class="fc" id="L106">				}</span>
<span class="fc" id="L107">			}</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">			for (int vT : neighbors) {</span>
<span class="fc" id="L109">				g1Builder.addEdge(t, vT);</span>
<span class="fc" id="L110">				g1EdgeRef0.add(neighborsBestEdge[vT]);</span>
<span class="fc" id="L111">				g1EdgeWeight0.add(neighborsBestWeight[vT]);</span>
<span class="fc" id="L112">				neighborsBestEdge[vT] = -1;</span>
<span class="fc" id="L113">			}</span>
<span class="fc" id="L114">			neighbors.clear();</span>
		}
<span class="fc" id="L116">		IndexGraph g1 = g1Builder.build();</span>
<span class="fc" id="L117">		g1Builder.clear();</span>
<span class="fc" id="L118">		int[] g1EdgeRef = g1EdgeRef0.elements();</span>
<span class="fc" id="L119">		double[] g1EdgeWeight = g1EdgeWeight0.elements();</span>
<span class="fc" id="L120">		IWeightFunction g1WeightFunc = e -&gt; g1EdgeWeight[e];</span>

		/* 2. Find a minimum spanning tree G2 of G1 */
<span class="fc" id="L123">		IntCollection g2 = ((MinimumSpanningTree.IResult) mstAlgo.computeMinimumSpanningTree(g1, g1WeightFunc)).edges();</span>

		/* 3. Construct a subgraph G3 of G by replacing each edge in G2 by its corresponding shortest path in G */
<span class="fc" id="L126">		IndexGraphBuilder g3Builder = g1Builder;</span>
<span class="fc" id="L127">		g3Builder.expectedVerticesNum(n);</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">		for (int v = 0; v &lt; n; v++)</span>
<span class="fc" id="L129">			g3Builder.addVertex();</span>
<span class="fc" id="L130">		Bitmap g3Edges = new Bitmap(g.edges().size());</span>
<span class="fc" id="L131">		IntArrayList g3EdgeRef0 = new IntArrayList();</span>
<span class="fc" id="L132">		DoubleArrayList g3EdgeWeight0 = g1EdgeWeight0;</span>
<span class="fc" id="L133">		g3EdgeWeight0.clear();</span>
<span class="fc" id="L134">		IntConsumer g3AddEdge = e -&gt; {</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">			if (!g3Edges.get(e)) {</span>
<span class="fc" id="L136">				g3Builder.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L137">				g3EdgeRef0.add(e);</span>
<span class="fc" id="L138">				g3EdgeWeight0.add(w.weight(e));</span>
<span class="fc" id="L139">				g3Edges.set(e);</span>
			}
<span class="fc" id="L141">		};</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">		for (int e2 : g2) {</span>
<span class="fc" id="L143">			int e = g1EdgeRef[e2];</span>
			/* add path from a terminal node to the original source of e */
<span class="fc bfc" id="L145" title="All 2 branches covered.">			for (int e0 : cells.getPath(g.edgeSource(e)).edges())</span>
<span class="fc" id="L146">				g3AddEdge.accept(e0);</span>
			/* add cross voronoi-cells edge e */
<span class="fc" id="L148">			g3AddEdge.accept(e);</span>
			/* add path from the original target of e to a terminal node */
<span class="fc bfc" id="L150" title="All 2 branches covered.">			for (int e0 : cells.getPath(g.edgeTarget(e)).edges())</span>
<span class="fc" id="L151">				g3AddEdge.accept(e0);</span>
<span class="fc" id="L152">		}</span>
<span class="fc" id="L153">		IndexGraph g3 = g3Builder.build();</span>
<span class="fc" id="L154">		g3Builder.clear();</span>
<span class="fc" id="L155">		int[] g3EdgeRef = g3EdgeRef0.elements();</span>
<span class="fc" id="L156">		double[] g3EdgeWeight = g3EdgeWeight0.elements();</span>
<span class="fc" id="L157">		IWeightFunction g3WeightFunc = e -&gt; g3EdgeWeight[e];</span>

		/* 4. Find the minimum spanning tree G4 of G3 */
<span class="fc" id="L160">		IntCollection g4 = ((MinimumSpanningTree.IResult) mstAlgo.computeMinimumSpanningTree(g3, g3WeightFunc)).edges();</span>
<span class="fc" id="L161">		int[] g4Edges = new int[g4.size() * 2];</span>
<span class="fc" id="L162">		int[] g4EdgesOffset = new int[n + 1];</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">		for (int e4 : g4) {</span>
<span class="fc" id="L164">			g4EdgesOffset[g3.edgeSource(e4)]++;</span>
<span class="fc" id="L165">			g4EdgesOffset[g3.edgeTarget(e4)]++;</span>
<span class="fc" id="L166">		}</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">		for (int s = 0, v = 0; v &lt; n; v++) {</span>
<span class="fc" id="L168">			int k = g4EdgesOffset[v];</span>
<span class="fc" id="L169">			g4EdgesOffset[v] = s;</span>
<span class="fc" id="L170">			s += k;</span>
		}
<span class="fc bfc" id="L172" title="All 2 branches covered.">		for (int e4 : g4) {</span>
<span class="fc" id="L173">			g4Edges[g4EdgesOffset[g3.edgeSource(e4)]++] = e4;</span>
<span class="fc" id="L174">			g4Edges[g4EdgesOffset[g3.edgeTarget(e4)]++] = e4;</span>
<span class="fc" id="L175">		}</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">		for (int v = n; v &gt; 0; v--)</span>
<span class="fc" id="L177">			g4EdgesOffset[v] = g4EdgesOffset[v - 1];</span>
<span class="pc bnc" id="L178" title="All 2 branches missed.">		assert g4EdgesOffset[n] == g4Edges.length;</span>
<span class="fc" id="L179">		g4EdgesOffset[0] = 0;</span>

		/* 5. Construct a Steiner tree G5 from G4 by deleting edges so that no leaves are Steiner vertices */
<span class="fc" id="L182">		int[] g5Degree = new int[n];</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">		for (int v = 0; v &lt; n; v++)</span>
<span class="fc" id="L184">			g5Degree[v] = g4EdgesOffset[v + 1] - g4EdgesOffset[v];</span>
<span class="fc" id="L185">		IntPriorityQueue queue = new FIFOQueueIntNoReduce();</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">		for (int v = 0; v &lt; n; v++)</span>
<span class="pc bpc" id="L187" title="1 of 4 branches missed.">			if (g5Degree[v] == 1 &amp;&amp; !isTerminal.get(v))</span>
<span class="nc" id="L188">				queue.enqueue(v);</span>
<span class="fc" id="L189">		Bitmap g5Edges = new Bitmap(g4Edges.length);</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">		for (int e4 : g4)</span>
<span class="fc" id="L191">			g5Edges.set(e4);</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">		while (!queue.isEmpty()) {</span>
<span class="nc" id="L193">			int u = queue.dequeueInt();</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">			assert g5Degree[u] &lt;= 1;</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">			if (g5Degree[u] == 0)</span>
<span class="nc" id="L196">				continue; /* parent edge already removed */</span>
			int e4;
<span class="nc" id="L198">			for (int eIdx = g4EdgesOffset[u];; eIdx++) {</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">				assert eIdx &lt; g4EdgesOffset[u + 1];</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">				if (g5Edges.get(g4Edges[eIdx])) {</span>
<span class="nc" id="L201">					e4 = g4Edges[eIdx];</span>
<span class="nc" id="L202">					break;</span>
				}
			}
<span class="nc" id="L205">			g5Edges.clear(e4);</span>
<span class="nc" id="L206">			int v = g3.edgeEndpoint(e4, u);</span>
<span class="nc" id="L207">			g5Degree[u]--;</span>
<span class="nc" id="L208">			g5Degree[v]--;</span>
<span class="nc bnc" id="L209" title="All 4 branches missed.">			if (g5Degree[v] == 1 &amp;&amp; !isTerminal.get(v))</span>
<span class="nc" id="L210">				queue.enqueue(v);</span>
<span class="nc" id="L211">		}</span>
<span class="fc" id="L212">		int[] g5 = new int[g5Edges.cardinality()];</span>
<span class="fc" id="L213">		int g5EdgeIdx = 0;</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">		for (int e3 : g5Edges)</span>
<span class="fc" id="L215">			g5[g5EdgeIdx++] = g3EdgeRef[e3];</span>

<span class="fc" id="L217">		return new SteinerTrees.ResultImpl(ImmutableIntArraySet.withNaiveContains(g5));</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>