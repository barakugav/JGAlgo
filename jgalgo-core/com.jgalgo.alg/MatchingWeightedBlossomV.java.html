<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MatchingWeightedBlossomV.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Core</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.alg</a> &gt; <span class="el_source">MatchingWeightedBlossomV.java</span></div><h1>MatchingWeightedBlossomV.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.alg;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.function.Consumer;
import com.jgalgo.graph.IWeightFunction;
import com.jgalgo.graph.IWeightFunctionInt;
import com.jgalgo.graph.IndexGraph;
import com.jgalgo.graph.IndexGraphBuilder;
import com.jgalgo.graph.WeightFunction;
import com.jgalgo.internal.ds.ObjReferenceableHeap;
import com.jgalgo.internal.ds.ReferenceableHeap;
import com.jgalgo.internal.util.Assertions;
import com.jgalgo.internal.util.DebugPrinter;
import it.unimi.dsi.fastutil.objects.Reference2IntMap;
import it.unimi.dsi.fastutil.objects.Reference2IntOpenHashMap;

/**
 * Blossom V implementation for maximum weighted matching.
 *
 * &lt;p&gt;
 * The implementation is based on 'Blossom V: A new implementation of a minimum cost perfect matching algorithm' by
 * Vladimir Kolmogorov. It is an implementation of Edmonds 'Blossom' algorithm, using priory queues
 * ({@link ReferenceableHeap}, pairing heaps) to find the next tight edge each iteration. In contrast to
 * {@link MatchingWeightedGabow1990}, it achieve a worse \(O(n^3 m)\) running time in the worst case, but runs faster in
 * practice.
 *
 * &lt;p&gt;
 * The implementation actually computes minimum perfect matching, and assume such perfect matching always exists.
 * Maximum or non-perfect matchings are computed by a reduction to a minimum perfect matching instance.
 *
 * @author Barak Ugav
 */
<span class="fc" id="L52">class MatchingWeightedBlossomV extends Matchings.AbstractMinimumMatchingImpl {</span>

<span class="fc" id="L54">	private static final Tree BfsProcessed = new Tree(null);</span>

	@Override
	IMatching computeMinimumWeightedMatching(IndexGraph g, IWeightFunction w) {
		/*
		 * The BlossomV algorithm support perfect matching only, and assume such matching always exists. To support
		 * non-perfect matching, we perform a reduction: we create a new graph containing two identical copies of the
		 * original graph, namely for each original vertex v we create two vertices v1 v2, and for each edge e(u,v) in
		 * the original graph we create two edges e1(u1,v1) e2(u2,v2) in the new graph, with the same weights as e. In
		 * addition to the two copies of the original graph, we connect each pair of duplicate vertices v1 v2 using a
		 * 'dummy' edge, with weight 0. We get a solution for the graph with the two copies and extract a matching from
		 * only one of the copies. If the perfect-matching algorithm chose to match a dummy edge (v1,v2), it means it
		 * doesn't have to match v1 or v2 with any other vertex, and it will not be included in any copy (half) of the
		 * graph. This essentially allows the algorithm to avoid matching a vertex in the original graph.
		 */

<span class="fc" id="L70">		Assertions.Graphs.onlyUndirected(g);</span>
<span class="fc" id="L71">		IndexGraphBuilder b = IndexGraphBuilder.undirected();</span>
<span class="fc" id="L72">		b.ensureVertexCapacity(g.vertices().size() * 2);</span>
<span class="fc" id="L73">		b.ensureEdgeCapacity(g.edges().size() * 2 + g.vertices().size());</span>

		/* Add two vertices for each original vertex */
<span class="fc bfc" id="L76" title="All 2 branches covered.">		for (int n = g.vertices().size(), v = 0; v &lt; n; v++) {</span>
<span class="fc" id="L77">			int v1 = b.addVertex();</span>
<span class="fc" id="L78">			int v2 = b.addVertex();</span>
<span class="pc bnc" id="L79" title="All 2 branches missed.">			assert v1 == v * 2 + 0;</span>
<span class="pc bnc" id="L80" title="All 2 branches missed.">			assert v2 == v * 2 + 1;</span>
		}
		/* Add two edges for each original edge */
<span class="fc" id="L83">		final int dummyEdgesThreshold = g.edges().size() * 2;</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">		for (int m = g.edges().size(), e = 0; e &lt; m; e++) {</span>
<span class="fc" id="L85">			int source = g.edgeSource(e);</span>
<span class="fc" id="L86">			int target = g.edgeTarget(e);</span>
<span class="fc" id="L87">			int e1 = b.addEdge(source * 2 + 0, target * 2 + 0);</span>
<span class="fc" id="L88">			int e2 = b.addEdge(source * 2 + 1, target * 2 + 1);</span>
<span class="pc bnc" id="L89" title="All 2 branches missed.">			assert e1 == e * 2 + 0;</span>
<span class="pc bnc" id="L90" title="All 2 branches missed.">			assert e2 == e * 2 + 1;</span>
<span class="pc bnc" id="L91" title="All 2 branches missed.">			assert e1 &lt; dummyEdgesThreshold;</span>
<span class="pc bnc" id="L92" title="All 2 branches missed.">			assert e2 &lt; dummyEdgesThreshold;</span>
		}

		/* Add dummy edges between each pair of duplicated vertices */
<span class="fc bfc" id="L96" title="All 2 branches covered.">		for (int n = g.vertices().size(), v = 0; v &lt; n; v++) {</span>
<span class="fc" id="L97">			int v1 = v * 2 + 0;</span>
<span class="fc" id="L98">			int v2 = v * 2 + 1;</span>
<span class="fc" id="L99">			int e = b.addEdge(v1, v2);</span>
<span class="pc bnc" id="L100" title="All 2 branches missed.">			assert e &gt;= dummyEdgesThreshold;</span>
		}

		/* Compute a perfect matching in the new graph */
		IWeightFunction wDup;
<span class="fc bfc" id="L105" title="All 2 branches covered.">		if (WeightFunction.isInteger(w)) {</span>
<span class="fc" id="L106">			IWeightFunctionInt wInt = (IWeightFunctionInt) w;</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">			IWeightFunctionInt wDupInt = e -&gt; e &lt; dummyEdgesThreshold ? wInt.weightInt(e / 2) : 0;</span>
<span class="fc" id="L108">			wDup = wDupInt;</span>
<span class="fc" id="L109">		} else {</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">			wDup = e -&gt; e &lt; dummyEdgesThreshold ? w.weight(e / 2) : 0;</span>
		}
<span class="fc" id="L112">		IndexGraph gDup = b.build();</span>
<span class="fc" id="L113">		IMatching matchDup = computeMinimumWeightedPerfectMatching(gDup, wDup);</span>

		/* Convert matching to the original graph */
<span class="fc" id="L116">		int[] matched = new int[g.vertices().size()];</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">		for (int n = g.vertices().size(), v = 0; v &lt; n; v++) {</span>
<span class="fc" id="L118">			int vDup = v * 2 + 0;</span>
<span class="fc" id="L119">			int eDup = matchDup.getMatchedEdge(vDup);</span>
<span class="pc bnc" id="L120" title="All 2 branches missed.">			assert eDup &gt;= 0 : &quot;vertex &quot; + vDup + &quot; is not matched&quot;;</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">			int e = eDup &lt; dummyEdgesThreshold ? eDup / 2 : -1;</span>
<span class="fc" id="L122">			matched[v] = e;</span>
		}
<span class="fc" id="L124">		return new Matchings.MatchingImpl(g, matched);</span>
	}

	@Override
	IMatching computeMinimumWeightedPerfectMatching(IndexGraph g, IWeightFunction w) {
<span class="fc" id="L129">		Assertions.Graphs.onlyUndirected(g);</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">		if (w == null)</span>
<span class="fc" id="L131">			w = IWeightFunction.CardinalityWeightFunction;</span>
<span class="fc" id="L132">		return new Worker(g, w).solve();</span>
	}

	private static class Worker {

		/* The input graph */
		private final IndexGraph g;
		/* A dummy blossom used as a head of a linked lists of the current roots */
		private final Blossom treeList;
		/* per original vertex blossom */
		final Blossom[] singletonNodes;
		/* current number of trees, same as number of unmatched vertices */
		/* we are done when it reaches zero */
		private int treeNum;

		/* temporary pointer to an augmentation edge found during grow/shrink/expand */
<span class="fc" id="L148">		private Edge eAugment = null;</span>

		/* Temp list used during expand */
<span class="fc" id="L151">		private final List&lt;Blossom&gt; expandTemp = new ArrayList&lt;&gt;();</span>

		private final double eps;

<span class="fc" id="L155">		private static final boolean OptimizationGrowSubTree = Boolean.parseBoolean(&quot;true&quot;);</span>

<span class="fc" id="L157">		Worker(IndexGraph g, IWeightFunction w) {</span>
<span class="fc" id="L158">			Debug.reset();</span>

<span class="fc" id="L160">			this.g = g;</span>
<span class="fc" id="L161">			final int n = g.vertices().size();</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">			if (n % 2 != 0)</span>
<span class="nc" id="L163">				throw new IllegalArgumentException(&quot;number of vertices is odd: perfect matching cannot exist&quot;);</span>
<span class="fc" id="L164">			singletonNodes = new Blossom[n];</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">			for (int v = 0; v &lt; n; v++)</span>
<span class="fc" id="L166">				singletonNodes[v] = new Blossom();</span>
<span class="fc" id="L167">			Debug.init(this);</span>

			/* Init all (singleton) blossoms to unmatched even + */
<span class="fc bfc" id="L170" title="All 2 branches covered.">			for (int v = 0; v &lt; n; v++) {</span>
<span class="fc" id="L171">				Blossom b = singletonNodes[v];</span>
<span class="fc" id="L172">				b.setEven();</span>
<span class="fc" id="L173">				b.setOuter(true);</span>
			}
<span class="fc" id="L175">			treeNum = n;</span>

			/* Create all edges objects */
<span class="fc" id="L178">			double minWeight = Double.POSITIVE_INFINITY;</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">			for (int m = g.edges().size(), e = 0; e &lt; m; e++) {</span>
<span class="fc" id="L180">				Blossom U = singletonNodes[g.edgeSource(e)];</span>
<span class="fc" id="L181">				Blossom V = singletonNodes[g.edgeTarget(e)];</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">				if (U == V)</span>
<span class="fc" id="L183">					continue; /* can't match self edges */</span>
<span class="fc" id="L184">				Edge E = new Edge(e, U, V);</span>
<span class="fc" id="L185">				U.addEdgeOut(E);</span>
<span class="fc" id="L186">				V.addEdgeIn(E);</span>

				/* We multiply here by 2 so integers weights will result in round dual values */
				/* any constant factor is fine here */
<span class="fc" id="L190">				E.slack = w.weight(e) * 2;</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">				if (E.slack != 0)</span>
<span class="fc" id="L192">					minWeight = Math.min(minWeight, E.slack);</span>
			}
<span class="fc" id="L194">			eps = minWeight * 1e-6;</span>

<span class="fc" id="L196">			treeList = new Blossom() {</span>
				@Override
				public String toString() {
<span class="nc" id="L199">					return &quot;treeList&quot;;</span>
				}
			};
<span class="fc" id="L202">		}</span>

		IMatching solve() {
<span class="fc" id="L205">			dbgLog.format(&quot;\n\nsolve()\n&quot;);</span>
<span class="fc" id="L206">			initGreedy();</span>
<span class="fc" id="L207">			Debug.assertConstraints(this);</span>

			/* initialize auxiliary graph */
<span class="fc bfc" id="L210" title="All 2 branches covered.">			for (Blossom root : roots()) {</span>
<span class="fc" id="L211">				Tree tree = root.tree;</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">				for (Edge e : root.outEdges()) {</span>
<span class="fc" id="L213">					Blossom v = e.target;</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">					if (v.isOut()) {</span>
<span class="fc" id="L215">						tree.pqInsertEvenOut(e);</span>

<span class="fc bfc" id="L217" title="All 2 branches covered.">					} else if (v.isProcessed()) {</span>
<span class="fc" id="L218">						ensureTreesEdgeExists(tree, v.tree);</span>
<span class="fc" id="L219">						v.tree.currentEdge.pqInsertEvenEven(e);</span>
					}
<span class="fc" id="L221">				}</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">				for (Edge e : root.inEdges()) {</span>
<span class="fc" id="L223">					Blossom v = e.source;</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">					if (v.isOut()) {</span>
<span class="fc" id="L225">						tree.pqInsertEvenOut(e);</span>

<span class="fc bfc" id="L227" title="All 2 branches covered.">					} else if (v.isProcessed()) {</span>
<span class="fc" id="L228">						ensureTreesEdgeExists(tree, v.tree);</span>
<span class="fc" id="L229">						v.tree.currentEdge.pqInsertEvenEven(e);</span>
					}
<span class="fc" id="L231">				}</span>
<span class="fc" id="L232">				root.setProcessed(true);</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">				for (TreesEdge e : tree.outEdges())</span>
<span class="fc" id="L234">					e.target.currentEdge = null;</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">				for (TreesEdge e : tree.inEdges())</span>
<span class="nc" id="L236">					e.source.currentEdge = null;</span>
<span class="fc" id="L237">			}</span>
<span class="fc" id="L238">			Debug.assertConstraints(this);</span>

			/* main loop */
			for (;;) {
<span class="fc" id="L242">				final int iterationTreeNum = treeNum;</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">				treesLoop: for (Blossom root : rootsDuringAugmentation()) {</span>
<span class="pc bnc" id="L244" title="All 2 branches missed.">					assert root.isTreeRoot();</span>
<span class="pc bnc" id="L245" title="All 2 branches missed.">					assert root == root.tree.root;</span>

<span class="fc" id="L247">					Tree tree = root.tree;</span>
					/* Check for augmentation, set currentEdge */
<span class="fc bfc" id="L249" title="All 2 branches covered.">					for (TreesEdge e : tree.outEdgesAndProneRemoved()) {</span>
<span class="fc" id="L250">						Tree t2 = e.target;</span>
<span class="fc" id="L251">						t2.currentEdge = e;</span>

<span class="fc bfc" id="L253" title="All 2 branches covered.">						if (e.pqEvenEven.isNotEmpty()) {</span>
<span class="fc" id="L254">							Edge minEdge = e.pqEvenEven.findMin().key();</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">							if (minEdge.slack - tree.eps &lt;= t2.eps) {</span>
<span class="fc" id="L256">								augment(minEdge);</span>
<span class="pc bnc" id="L257" title="All 2 branches missed.">								assert e.pqEvenEven.isEmpty() || e.pqEvenEven.findMin()</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">										.key() != minEdge : &quot;edge was not removed during augment&quot;;</span>
								continue treesLoop;
							}
						}
<span class="fc" id="L262">					}</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">					for (TreesEdge e : tree.inEdgesAndProneRemoved()) {</span>
<span class="fc" id="L264">						Tree t2 = e.source;</span>
<span class="fc" id="L265">						t2.currentEdge = e;</span>

						Edge minEdge;
<span class="fc bfc" id="L268" title="All 2 branches covered.">						if (e.pqEvenEven.isNotEmpty()</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">								&amp;&amp; (minEdge = e.pqEvenEven.findMin().key()).slack - tree.eps &lt;= t2.eps) {</span>
							/* Augment step */
<span class="fc" id="L271">							augment(minEdge);</span>
<span class="pc bnc" id="L272" title="All 2 branches missed.">							assert e.pqEvenEven.isEmpty()</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">									|| e.pqEvenEven.findMin().key() != minEdge : &quot;edge was not removed during augment&quot;;</span>
							continue treesLoop;
						}
<span class="fc" id="L276">					}</span>
<span class="fc" id="L277">					Debug.assertConstraints(this);</span>

					/* Grow tree */
					for (;;) {
						Edge minEdge;
						Blossom minBlossom;

<span class="fc bfc" id="L284" title="All 2 branches covered.">						if (tree.pqEvenOut.isNotEmpty()</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">								&amp;&amp; (minEdge = tree.pqEvenOut.findMin().key()).slack &lt;= tree.eps) {</span>
							/* Grow step */
							/* no need to extractMin(), all Even-Out edges of minEdge's target will be removed */
<span class="fc" id="L288">							boolean augmentPerformed = grow(minEdge);</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">							if (augmentPerformed)</span>
<span class="fc" id="L290">								continue treesLoop;</span>

<span class="fc bfc" id="L292" title="All 2 branches covered.">						} else if (tree.pqEvenEven.isNotEmpty()</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">								&amp;&amp; (minEdge = tree.pqEvenEven.findMin().key()).slack &lt;= tree.eps * 2) {</span>
							/* Shrink step */
<span class="fc" id="L295">							tree.pqRemoveEvenEven(minEdge);</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">							if (processEdgeEvenEven(minEdge, true)) {</span>
<span class="fc" id="L297">								boolean augmentPerformed = shrink(minEdge);</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">								if (augmentPerformed)</span>
<span class="fc" id="L299">									continue treesLoop;</span>
<span class="fc" id="L300">							}</span>

<span class="fc bfc" id="L302" title="All 2 branches covered.">						} else if (tree.pqOdd.isNotEmpty()</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">								&amp;&amp; (minBlossom = tree.pqOdd.findMin().key()).dual &lt;= tree.eps) {</span>
							/* Expand step */
<span class="fc" id="L305">							tree.pqRemoveOdd(minBlossom);</span>
<span class="fc" id="L306">							boolean augmentPerformed = expand(minBlossom);</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">							if (augmentPerformed)</span>
<span class="nc" id="L308">								continue treesLoop;</span>

						} else {
							break;
						}
<span class="fc" id="L313">					}</span>
<span class="fc" id="L314">					Debug.assertConstraints(this);</span>

					/* Clear currentEdge */
<span class="pc bnc" id="L317" title="All 2 branches missed.">					assert tree.currentEdge == null;</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">					for (TreesEdge e : tree.outEdges()) {</span>
<span class="pc bnc" id="L319" title="All 2 branches missed.">						assert e.source == tree;</span>
<span class="pc bnc" id="L320" title="All 2 branches missed.">						assert e.target.currentEdge == e;</span>
<span class="fc" id="L321">						e.target.currentEdge = null;</span>
<span class="fc" id="L322">					}</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">					for (TreesEdge e : tree.inEdges()) {</span>
<span class="pc bnc" id="L324" title="All 2 branches missed.">						assert e.target == tree;</span>
<span class="pc bnc" id="L325" title="All 2 branches missed.">						assert e.source.currentEdge == e;</span>
<span class="fc" id="L326">						e.source.currentEdge = null;</span>
<span class="fc" id="L327">					}</span>
<span class="fc" id="L328">				}</span>
<span class="fc" id="L329">				Debug.assertConstraints(this);</span>

<span class="fc bfc" id="L331" title="All 2 branches covered.">				if (treeNum == 0)</span>
<span class="fc" id="L332">					break;</span>

<span class="fc bfc" id="L334" title="All 2 branches covered.">				boolean augmentPerformed = treeNum != iterationTreeNum;</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">				if (!augmentPerformed) {</span>
<span class="fc" id="L336">					updateDuals();</span>
					// TODO if regular (CC) update doesnt achieve progress, try ComputeEpsSingle
				}
<span class="fc" id="L339">				Debug.assertConstraints(this);</span>
<span class="fc" id="L340">			}</span>
<span class="fc" id="L341">			return finish();</span>
		}

		private void initGreedy() {
<span class="fc" id="L345">			dbgLog.format(&quot;initGreedy()\n&quot;);</span>

			/* Init each node dual to be minVertexEdgeWeight/2 */
<span class="fc bfc" id="L348" title="All 2 branches covered.">			for (Blossom node : singletonNodes) {</span>
<span class="pc bnc" id="L349" title="All 2 branches missed.">				assert !node.isBlossom();</span>
<span class="fc" id="L350">				double minSlack = Double.POSITIVE_INFINITY;</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">				for (Edge e : node.outEdges())</span>
<span class="fc" id="L352">					minSlack = Math.min(minSlack, e.slack);</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">				for (Edge e : node.inEdges())</span>
<span class="fc" id="L354">					minSlack = Math.min(minSlack, e.slack);</span>
<span class="pc bnc" id="L355" title="All 2 branches missed.">				assert node.isOuter();</span>
<span class="fc" id="L356">				node.dual = minSlack / 2;</span>
			}
			/* Update edges slack to weight-e.source.dual-e.target.dual */
<span class="fc bfc" id="L359" title="All 2 branches covered.">			for (Blossom node : singletonNodes) {</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">				for (Edge e : node.outEdges()) {</span>
<span class="pc bnc" id="L361" title="All 2 branches missed.">					assert node == e.source;</span>
<span class="fc" id="L362">					e.slack -= (node.dual + e.target.dual);</span>
<span class="fc" id="L363">				}</span>
			}
			/* assert all edges have non negative slack */
<span class="fc bfc" id="L366" title="All 2 branches covered.">			for (Blossom node : singletonNodes)</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">				for (Edge e : node.outEdges())</span>
<span class="pc bnc" id="L368" title="All 2 branches missed.">					assert e.slack &gt;= 0;</span>

			/* Iterate over the nodes, increase dual and choose matched edge greedily */
<span class="fc bfc" id="L371" title="All 2 branches covered.">			for (Blossom node : singletonNodes) {</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">				if (node.isOut()) /* already matched */</span>
<span class="fc" id="L373">					continue;</span>
<span class="fc" id="L374">				double slackMin = Double.POSITIVE_INFINITY;</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">				for (Edge e : node.outEdges())</span>
<span class="fc" id="L376">					slackMin = Math.min(slackMin, e.slack);</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">				for (Edge e : node.inEdges())</span>
<span class="fc" id="L378">					slackMin = Math.min(slackMin, e.slack);</span>
<span class="fc" id="L379">				node.dual += slackMin;</span>

				/* After we increased the dual of the node, at least one edge should be tight */
<span class="fc" id="L382">				Iterator&lt;Edge&gt; outIter = node.outEdges().iterator();</span>
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">				if (node.isEven()) {</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">					while (outIter.hasNext()) {</span>
<span class="fc" id="L385">						Edge e = outIter.next();</span>
<span class="pc bnc" id="L386" title="All 2 branches missed.">						assert node == e.source;</span>
<span class="fc bfc" id="L387" title="All 4 branches covered.">						if (e.slack &lt;= slackMin &amp;&amp; e.target.isEven()) {</span>
<span class="fc" id="L388">							dbgLog.format(&quot;\tmatch %s\n&quot;, e);</span>
<span class="fc" id="L389">							node.setOut();</span>
<span class="fc" id="L390">							e.target.setOut();</span>
<span class="fc" id="L391">							node.match = e.target.match = e;</span>
<span class="fc" id="L392">							treeNum -= 2;</span>
<span class="fc" id="L393">							e.slack -= slackMin;</span>
<span class="fc" id="L394">							break;</span>
						}
<span class="fc" id="L396">						e.slack -= slackMin;</span>
<span class="fc" id="L397">					}</span>
				}
<span class="fc bfc" id="L399" title="All 2 branches covered.">				while (outIter.hasNext()) {</span>
<span class="fc" id="L400">					Edge e = outIter.next();</span>
<span class="pc bnc" id="L401" title="All 2 branches missed.">					assert node == e.source;</span>
<span class="fc" id="L402">					e.slack -= slackMin;</span>
<span class="fc" id="L403">				}</span>
<span class="fc" id="L404">				Iterator&lt;Edge&gt; inIter = node.inEdges().iterator();</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">				if (node.isEven()) {</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">					while (inIter.hasNext()) {</span>
<span class="fc" id="L407">						Edge e = inIter.next();</span>
<span class="pc bnc" id="L408" title="All 2 branches missed.">						assert node == e.target;</span>
<span class="pc bpc" id="L409" title="1 of 6 branches missed.">						if (e.slack &lt;= slackMin &amp;&amp; node.isEven() &amp;&amp; e.source.isEven()) {</span>
<span class="fc" id="L410">							dbgLog.format(&quot;\tmatch %s\n&quot;, e);</span>
<span class="fc" id="L411">							node.setOut();</span>
<span class="fc" id="L412">							e.source.setOut();</span>
<span class="fc" id="L413">							node.match = e.source.match = e;</span>
<span class="fc" id="L414">							treeNum -= 2;</span>
<span class="fc" id="L415">							e.slack -= slackMin;</span>
<span class="fc" id="L416">							break;</span>
						}
<span class="fc" id="L418">						e.slack -= slackMin;</span>
<span class="fc" id="L419">					}</span>
				}
<span class="fc bfc" id="L421" title="All 2 branches covered.">				while (inIter.hasNext()) {</span>
<span class="fc" id="L422">					Edge e = inIter.next();</span>
<span class="pc bnc" id="L423" title="All 2 branches missed.">					assert node == e.target;</span>
<span class="fc" id="L424">					e.slack -= slackMin;</span>
<span class="fc" id="L425">				}</span>
			}

			/* Create all trees and tree list */
<span class="fc" id="L429">			Blossom lastRoot = treeList;</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">			for (Blossom node : singletonNodes) {</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">				if (!node.isEven())</span>
<span class="fc" id="L432">					continue; /* we already matched this vertex */</span>
<span class="fc" id="L433">				node.setIsTreeRoot(true);</span>
<span class="fc" id="L434">				node.treeSiblingPrev = lastRoot;</span>
<span class="fc" id="L435">				lastRoot.treeSiblingNext = node;</span>
<span class="fc" id="L436">				lastRoot = node;</span>

<span class="fc" id="L438">				Tree tree = new Tree(node);</span>
<span class="fc" id="L439">				node.tree = tree;</span>
<span class="fc" id="L440">				dbgLog.format(&quot;\troot %s\n&quot;, node);</span>
			}
<span class="fc" id="L442">			lastRoot.treeSiblingNext = null;</span>
<span class="fc" id="L443">		}</span>

		/**
		 * Grow the forest by adding a 'grow edge' and its descending matched edge.
		 *
		 * @param  growEdge the edge from an even node to an out node
		 * @return          {@code true} if augmentation was performed
		 */
		private boolean grow(Edge growEdge) {
			Blossom u, v;
<span class="fc bfc" id="L453" title="All 2 branches covered.">			if (growEdge.target.isOut()) {</span>
<span class="fc" id="L454">				u = growEdge.getSourceOuterBlossom();</span>
<span class="fc" id="L455">				v = growEdge.target;</span>
			} else {
<span class="pc bnc" id="L457" title="All 2 branches missed.">				assert growEdge.source.isOut();</span>
<span class="fc" id="L458">				u = growEdge.getTargetOuterBlossom();</span>
<span class="fc" id="L459">				v = growEdge.source;</span>
			}
<span class="pc bnc" id="L461" title="All 4 branches missed.">			assert u.isOuter() &amp;&amp; u.isEven();</span>
<span class="pc bnc" id="L462" title="All 4 branches missed.">			assert v.isOuter() &amp;&amp; v.isOut();</span>

<span class="fc" id="L464">			addGrowBlossomsToTree(u, v, growEdge);</span>
<span class="pc bnc" id="L465" title="All 2 branches missed.">			assert v.isMatched();</span>
<span class="fc" id="L466">			Blossom w = v.matchedNode();</span>
<span class="pc bnc" id="L467" title="All 2 branches missed.">			assert w.isEven();</span>

			/* Grow the new sub tree iteratively, until no more grow step is available */
<span class="fc" id="L470">			for (Blossom j = w;;) {</span>
<span class="fc" id="L471">				boolean augmentPerformed = grow0(j);</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">				if (augmentPerformed)</span>
<span class="fc" id="L473">					return true;</span>

				/* continue exploring sub tree for more grow operations */
<span class="fc bfc" id="L476" title="All 2 branches covered.">				if (j.firstTreeChild != null) {</span>
<span class="fc" id="L477">					j = j.firstTreeChild;</span>
				} else {
					for (;;) {
<span class="fc bfc" id="L480" title="All 2 branches covered.">						if (j == w)</span>
<span class="fc" id="L481">							return false;</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">						if (j.treeSiblingNext != null)</span>
<span class="fc" id="L483">							break;</span>
<span class="fc" id="L484">						j = j.matchedNode().getTreeParent();</span>
					}
<span class="fc" id="L486">					j = j.treeSiblingNext;</span>
				}
<span class="fc" id="L488">			}</span>
		}

		private static void addGrowBlossomsToTree(Edge growEdge) {
			Blossom u, v;
<span class="fc bfc" id="L493" title="All 2 branches covered.">			if (growEdge.target.isOut()) {</span>
<span class="fc" id="L494">				u = growEdge.getSourceOuterBlossom();</span>
<span class="fc" id="L495">				v = growEdge.target;</span>
			} else {
<span class="pc bnc" id="L497" title="All 2 branches missed.">				assert growEdge.source.isOut();</span>
<span class="fc" id="L498">				u = growEdge.getTargetOuterBlossom();</span>
<span class="fc" id="L499">				v = growEdge.source;</span>
			}
<span class="fc" id="L501">			addGrowBlossomsToTree(u, v, growEdge);</span>
<span class="fc" id="L502">		}</span>

		private static void addGrowBlossomsToTree(Blossom u, Blossom v, Edge growEdge) {
<span class="pc bnc" id="L505" title="All 4 branches missed.">			assert u.isOuter() &amp;&amp; u.isEven();</span>
<span class="pc bnc" id="L506" title="All 4 branches missed.">			assert v.isOuter() &amp;&amp; v.isOut();</span>
<span class="fc" id="L507">			Tree tree = u.tree;</span>

<span class="fc" id="L509">			v.setOdd();</span>
			// assert v.tree == null;
<span class="fc" id="L511">			v.tree = tree;</span>
<span class="fc" id="L512">			v.treeParentEdge = growEdge;</span>
<span class="fc" id="L513">			v.dual += tree.eps;</span>

<span class="pc bnc" id="L515" title="All 2 branches missed.">			assert v.isMatched();</span>
<span class="fc" id="L516">			Blossom w = v.matchedNode();</span>
<span class="fc" id="L517">			w.setEven();</span>
<span class="fc" id="L518">			w.tree = tree;</span>
<span class="fc" id="L519">			w.dual -= tree.eps;</span>

			/* Although v is the direct 'parent' of w, the child-parent is a relationship between even nodes only */
<span class="fc" id="L522">			addTreeChild(u, w);</span>
<span class="fc" id="L523">		}</span>

		/**
		 * Grow the forest given the new even node grown.
		 *
		 * @param  w the new even node grown
		 * @return   {@code true} if augmentation was performed
		 */
		private boolean grow0(Blossom w) {
<span class="fc" id="L532">			Blossom v = w.matchedNode();</span>
<span class="fc" id="L533">			Blossom u = v.getTreeParent();</span>
<span class="fc" id="L534">			dbgLog.format(&quot;grow(%s, %s, %s)\n&quot;, u, v, v.matchedNode());</span>
<span class="pc bnc" id="L535" title="All 4 branches missed.">			assert u.isOuter() &amp;&amp; u.isEven();</span>
<span class="pc bnc" id="L536" title="All 4 branches missed.">			assert v.isOuter() &amp;&amp; v.isOdd();</span>
<span class="pc bnc" id="L537" title="All 4 branches missed.">			assert w.isOuter() &amp;&amp; w.isEven();</span>
<span class="fc" id="L538">			Tree tree = u.tree;</span>

			/* Add v as an odd (-) node to the tree */
			/* Handle (v,w) edges, which may become (-,+) */
<span class="fc bfc" id="L542" title="All 2 branches covered.">			for (Edge e : v.outEdges()) {</span>
<span class="fc" id="L543">				Blossom x = e.getTargetOuterBlossom();</span>
<span class="fc bfc" id="L544" title="All 4 branches covered.">				if (x.isEven() &amp;&amp; x.isProcessed()) {</span>
					// assert e.pqEvenOutRef != null;
					// if (e.pqEvenOutRef != null)
<span class="pc bpc" id="L547" title="1 of 4 branches missed.">					if (!OptimizationGrowSubTree || e.pqRef != null) {</span>
<span class="pc bnc" id="L548" title="All 2 branches missed.">						assert e.pqRef != null;</span>
<span class="fc" id="L549">						x.tree.pqRemoveEvenOut(e);</span>
					}
<span class="fc" id="L551">					e.slack -= tree.eps;</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">					if (x.tree != tree) {</span>
<span class="fc" id="L553">						ensureTreesEdgeExists(tree, x.tree);</span>
<span class="fc" id="L554">						x.tree.pqEdgeInsertEvenOdd(x.tree.currentEdge, e);</span>
					}
				} else {
<span class="fc" id="L557">					e.slack -= tree.eps;</span>
				}
<span class="fc" id="L559">			}</span>
			/* Handle (v,w) edges, which may become (-,+) */
<span class="fc bfc" id="L561" title="All 2 branches covered.">			for (Edge e : v.inEdges()) {</span>
<span class="fc" id="L562">				Blossom x = e.getSourceOuterBlossom();</span>
<span class="fc bfc" id="L563" title="All 4 branches covered.">				if (x.isEven() &amp;&amp; x.isProcessed()) {</span>
					// assert e.pqEvenOutRef != null;
					// if (e.pqEvenOutRef != null)
<span class="pc bpc" id="L566" title="1 of 4 branches missed.">					if (!OptimizationGrowSubTree || e.pqRef != null) {</span>
<span class="pc bnc" id="L567" title="All 2 branches missed.">						assert e.pqRef != null;</span>
<span class="fc" id="L568">						x.tree.pqRemoveEvenOut(e);</span>
					}
<span class="fc" id="L570">					e.slack -= tree.eps;</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">					if (x.tree != tree) {</span>
<span class="fc" id="L572">						ensureTreesEdgeExists(tree, x.tree);</span>
<span class="fc" id="L573">						x.tree.pqEdgeInsertEvenOdd(x.tree.currentEdge, e);</span>
					}
				} else {
<span class="fc" id="L576">					e.slack -= tree.eps;</span>
				}
<span class="fc" id="L578">			}</span>

			/* Add w as an even (+) node to the tree */
<span class="fc" id="L581">			eAugment = null;</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">			for (Edge e : w.outEdges()) {</span>
<span class="fc" id="L583">				Blossom x = e.getTargetOuterBlossom();</span>
<span class="fc" id="L584">				e.slack += tree.eps;</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">				if (x.isOut()) {</span>
					/* e is (+,x) edge */
<span class="pc bpc" id="L587" title="1 of 4 branches missed.">					if (OptimizationGrowSubTree &amp;&amp; e.slack &lt;= 0) {</span>
						/* grow e immediately, no need to insert into PQ and extract it in the next iteration */
<span class="fc" id="L589">						addGrowBlossomsToTree(e);</span>
					} else {
<span class="fc" id="L591">						tree.pqInsertEvenOut(e);</span>
					}

<span class="fc bfc" id="L594" title="All 4 branches covered.">				} else if (x.isEven() &amp;&amp; x.isProcessed()) {</span>
					// if (e.pqEvenOutRef != null)
<span class="pc bpc" id="L596" title="1 of 4 branches missed.">					if (!OptimizationGrowSubTree || e.pqRef != null) {</span>
<span class="pc bnc" id="L597" title="All 2 branches missed.">						assert e.pqRef != null;</span>
<span class="fc" id="L598">						x.tree.pqRemoveEvenOut(e);</span>
					}
<span class="fc bfc" id="L600" title="All 2 branches covered.">					if (tree != x.tree) {</span>
						/* Cross-trees (+,+) edge */
<span class="fc bfc" id="L602" title="All 2 branches covered.">						if (e.slack &lt;= x.tree.eps)</span>
							/* we can augment using e, prioritize augmentation over other operations */
<span class="fc" id="L604">							eAugment = e;</span>
<span class="fc" id="L605">						ensureTreesEdgeExists(tree, x.tree);</span>
<span class="fc" id="L606">						x.tree.currentEdge.pqInsertEvenEven(e);</span>
					} else {
						/* Inner (+,+) edge */
<span class="fc" id="L609">						tree.pqInsertEvenEven(e);</span>
					}
<span class="fc bfc" id="L611" title="All 4 branches covered.">				} else if (x.isOdd() &amp;&amp; tree != x.tree) {</span>
					/* Cross-trees (+,-) edge */
<span class="fc" id="L613">					ensureTreesEdgeExists(tree, x.tree);</span>
<span class="fc" id="L614">					tree.pqEdgeInsertEvenOdd(x.tree.currentEdge, e);</span>
				}
<span class="fc" id="L616">			}</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">			for (Edge e : w.inEdges()) {</span>
<span class="fc" id="L618">				Blossom x = e.getSourceOuterBlossom();</span>
<span class="fc" id="L619">				e.slack += tree.eps;</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">				if (x.isOut()) {</span>
					/* e is (+,x) edge */
<span class="pc bpc" id="L622" title="1 of 4 branches missed.">					if (OptimizationGrowSubTree &amp;&amp; e.slack &lt;= 0) {</span>
						/* grow e immediately, no need to insert into PQ and extract it in the next iteration */
<span class="fc" id="L624">						addGrowBlossomsToTree(e);</span>
					} else {
<span class="fc" id="L626">						tree.pqInsertEvenOut(e);</span>
					}

<span class="fc bfc" id="L629" title="All 4 branches covered.">				} else if (x.isEven() &amp;&amp; x.isProcessed()) {</span>
					// assert e.pqEvenOutRef != null;
<span class="pc bpc" id="L631" title="1 of 4 branches missed.">					if (!OptimizationGrowSubTree || e.pqRef != null) {</span>
<span class="pc bnc" id="L632" title="All 2 branches missed.">						assert e.pqRef != null;</span>
<span class="fc" id="L633">						x.tree.pqRemoveEvenOut(e);</span>
					}
<span class="fc bfc" id="L635" title="All 2 branches covered.">					if (tree != x.tree) {</span>
						/* Cross-trees (+,+) edge */
<span class="fc bfc" id="L637" title="All 2 branches covered.">						if (e.slack &lt;= x.tree.eps)</span>
							/* we can augment using e, prioritize augmentation over other operations */
<span class="fc" id="L639">							eAugment = e;</span>
<span class="fc" id="L640">						ensureTreesEdgeExists(tree, x.tree);</span>
<span class="fc" id="L641">						x.tree.currentEdge.pqInsertEvenEven(e);</span>
					} else {
						/* Inner (+,+) edge */
<span class="fc" id="L644">						tree.pqInsertEvenEven(e);</span>
					}
<span class="fc bfc" id="L646" title="All 4 branches covered.">				} else if (x.isOdd() &amp;&amp; tree != x.tree) {</span>
					/* Cross-trees (+,-) edge */
<span class="fc" id="L648">					ensureTreesEdgeExists(tree, x.tree);</span>
<span class="fc" id="L649">					tree.pqEdgeInsertEvenOdd(x.tree.currentEdge, e);</span>
				}
<span class="fc" id="L651">			}</span>
<span class="pc bnc" id="L652" title="All 2 branches missed.">			assert !w.isProcessed();</span>
<span class="fc" id="L653">			w.setProcessed(true);</span>

<span class="pc bnc" id="L655" title="All 2 branches missed.">			assert !v.isProcessed();</span>
<span class="fc" id="L656">			v.setProcessed(true);</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">			if (v.isBlossom())</span>
<span class="fc" id="L658">				tree.pqInsertOdd(v);</span>

			/* prioritize augmentation over other operations */
<span class="fc" id="L661">			return augmentIfEdgeFound();</span>
		}

		private static void addTreeChild(Blossom parent, Blossom child) {
<span class="pc bnc" id="L665" title="All 2 branches missed.">			assert parent.isEven();</span>
<span class="pc bnc" id="L666" title="All 2 branches missed.">			assert child.isEven();</span>

			// assert child.firstTreeChild == null;
			// assert child.treeSiblingNext == null;
			// assert child.treeSiblingPrev == null;
<span class="fc" id="L671">			child.firstTreeChild = null;</span>
<span class="fc" id="L672">			child.treeSiblingNext = null;</span>
<span class="fc" id="L673">			child.treeSiblingPrev = null;</span>

<span class="fc" id="L675">			Blossom firstChild = parent.firstTreeChild;</span>
<span class="fc bfc" id="L676" title="All 2 branches covered.">			if (firstChild != null) {</span>
<span class="fc" id="L677">				child.treeSiblingNext = firstChild;</span>
<span class="fc" id="L678">				child.treeSiblingPrev = firstChild.treeSiblingPrev;</span>
<span class="fc" id="L679">				firstChild.treeSiblingPrev = child;</span>
			} else {
<span class="fc" id="L681">				child.treeSiblingPrev = child;</span>
			}
<span class="fc" id="L683">			parent.firstTreeChild = child;</span>
<span class="fc" id="L684">		}</span>

		/**
		 * Shrink an odd alternating path in the forest to a blossom.
		 *
		 * @param  bridge the edge connecting between the two branches of the new blossom
		 * @return        {@code true} if augmentation was performed
		 */
		private boolean shrink(Edge bridge) {
<span class="fc" id="L693">			dbgLog.format(&quot;shrink(%s)\n&quot;, bridge);</span>
			Blossom root;
			{ /* Find LCA of the edge endpoints */
				Blossom rootAncestor;
<span class="fc" id="L697">				Blossom[] ptr = new Blossom[] { bridge.source, bridge.target };</span>
<span class="fc" id="L698">				for (int side = 0;; side = 1 - side) {</span>
<span class="fc" id="L699">					Blossom b = ptr[side];</span>
<span class="pc bnc" id="L700" title="All 4 branches missed.">					assert b.isOuter() &amp;&amp; b.isEven();</span>
<span class="fc bfc" id="L701" title="All 2 branches covered.">					if (b.isMarked()) {</span>
						/* Reached a node we already visited, its the LCA */
<span class="fc" id="L703">						root = b;</span>
						/* Other Ptr went to far up, clean it later */
<span class="fc" id="L705">						rootAncestor = ptr[1 - side];</span>
<span class="fc" id="L706">						break;</span>
					}
<span class="fc" id="L708">					b.setMarked(true);</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">					if (b.isTreeRoot()) {</span>
						/* This Ptr reached the root, advance other Ptr until they meet */
<span class="fc" id="L711">						rootAncestor = b;</span>
<span class="fc" id="L712">						b = ptr[1 - side];</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">						while (!b.isMarked()) {</span>
<span class="fc" id="L714">							b.setMarked(true);</span>
<span class="fc" id="L715">							b = b.matchedNode();</span>
<span class="pc bnc" id="L716" title="All 4 branches missed.">							assert b.isOuter() &amp;&amp; b.isOdd();</span>
<span class="pc bnc" id="L717" title="All 2 branches missed.">							assert !b.isMarked();</span>
<span class="fc" id="L718">							b.setMarked(true);</span>
<span class="fc" id="L719">							b = b.getTreeParent();</span>
<span class="pc bnc" id="L720" title="All 4 branches missed.">							assert b.isOuter() &amp;&amp; b.isEven();</span>
						}
<span class="fc" id="L722">						root = b;</span>
<span class="fc" id="L723">						break;</span>
					}
					/* Sides didn't merge yet, continue up */
<span class="fc" id="L726">					b = b.matchedNode();</span>
<span class="pc bnc" id="L727" title="All 2 branches missed.">					assert !b.isMarked();</span>
<span class="fc" id="L728">					b.setMarked(true);</span>
<span class="pc bnc" id="L729" title="All 4 branches missed.">					assert b.isOuter() &amp;&amp; b.isOdd();</span>
<span class="fc" id="L730">					ptr[side] = b = b.getTreeParent();</span>
<span class="pc bnc" id="L731" title="All 4 branches missed.">					assert b.isOuter() &amp;&amp; b.isEven();</span>
				}
				/* Cleanup from the LCA root to rootAncestor, which is the side that went too much up */
<span class="fc bfc" id="L734" title="All 2 branches covered.">				if (root != rootAncestor) {</span>
<span class="fc" id="L735">					for (Blossom b = root;;) {</span>
<span class="pc bnc" id="L736" title="All 4 branches missed.">						assert b.isOuter() &amp;&amp; b.isEven();</span>
<span class="fc" id="L737">						b = b.matchedNode();</span>
<span class="pc bnc" id="L738" title="All 4 branches missed.">						assert b.isOuter() &amp;&amp; b.isOdd();</span>
<span class="pc bnc" id="L739" title="All 2 branches missed.">						assert b.isMarked();</span>
<span class="fc" id="L740">						b.setMarked(false);</span>
<span class="fc" id="L741">						b = b.getTreeParent();</span>
<span class="pc bnc" id="L742" title="All 4 branches missed.">						assert b.isOuter() &amp;&amp; b.isEven();</span>
<span class="fc bfc" id="L743" title="All 2 branches covered.">						if (b == rootAncestor) {</span>
<span class="fc" id="L744">							b.setMarked(false);</span>
<span class="fc" id="L745">							break;</span>
						}
<span class="pc bnc" id="L747" title="All 2 branches missed.">						assert b.isMarked();</span>
<span class="fc" id="L748">						b.setMarked(false);</span>
					}
				}
			}

			/* Traverse over all sub-blossom, setOuter(false) and move their children to B */
<span class="fc" id="L754">			Tree tree = root.tree;</span>
<span class="fc" id="L755">			Blossom B = new Blossom();</span>
<span class="fc bfc" id="L756" title="All 2 branches covered.">			for (Blossom b : new Blossom[] { bridge.source, bridge.target }) {</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">				while (b != root) {</span>
<span class="fc" id="L758">					dbgLog.format(&quot;\t%s\n&quot;, b);</span>
<span class="pc bnc" id="L759" title="All 4 branches missed.">					assert b.isOuter() &amp;&amp; b.isEven();</span>
<span class="fc" id="L760">					removeFromTreeChildrenList(b);</span>
<span class="fc" id="L761">					moveTreeChildren(b, B);</span>
<span class="fc" id="L762">					b.setOuter(false);</span>
					// b.tree = null;

<span class="fc" id="L765">					b = b.matchedNode();</span>
<span class="fc" id="L766">					dbgLog.format(&quot;\t%s\n&quot;, b);</span>
<span class="pc bnc" id="L767" title="All 4 branches missed.">					assert b.isOuter() &amp;&amp; b.isOdd();</span>
<span class="fc" id="L768">					b.setOuter(false);</span>
					// b.tree = null;
<span class="fc bfc" id="L770" title="All 2 branches covered.">					if (b.isBlossom())</span>
<span class="fc" id="L771">						tree.pqRemoveOdd(b);</span>

<span class="fc" id="L773">					b = b.getTreeParent();</span>
				}
			}
<span class="fc" id="L776">			dbgLog.format(&quot;\t%s (root)\n&quot;, root);</span>
<span class="pc bnc" id="L777" title="All 4 branches missed.">			assert root.isOuter() &amp;&amp; root.isEven();</span>
<span class="fc" id="L778">			root.setOuter(false);</span>
<span class="fc" id="L779">			moveTreeChildren(root, B);</span>

			/* Init new blossom B */
<span class="fc" id="L782">			B.setOuter(true);</span>
<span class="fc" id="L783">			B.setEven();</span>
<span class="fc" id="L784">			B.setIsBlossom(true);</span>
<span class="fc" id="L785">			B.setIsTreeRoot(root.isTreeRoot());</span>
<span class="fc" id="L786">			B.setProcessed(true);</span>
<span class="fc" id="L787">			B.tree = tree;</span>
<span class="fc" id="L788">			B.dual = -tree.eps;</span>

			/* Swap 'root' and B in the tree (children, siblings) */
<span class="fc" id="L791">			B.treeSiblingPrev = root.treeSiblingPrev;</span>
<span class="fc" id="L792">			B.treeSiblingNext = root.treeSiblingNext;</span>
			// root.treeSiblingPrev = root.treeSiblingNext = null;
<span class="fc" id="L794">			Blossom bParent = null;</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">			if (!B.isTreeRoot())</span>
<span class="fc" id="L796">				bParent = root.matchedNode().getTreeParent();</span>
<span class="fc bfc" id="L797" title="All 2 branches covered.">			if (B.treeSiblingPrev.treeSiblingNext != null) {</span>
				/* B is not the first in the children/roots list */
<span class="fc" id="L799">				B.treeSiblingPrev.treeSiblingNext = B;</span>
			} else {
				/* B is the first in the children list */
<span class="fc" id="L802">				bParent.firstTreeChild = B;</span>
			}
<span class="fc bfc" id="L804" title="All 2 branches covered.">			if (B.treeSiblingNext != null) {</span>
				/* B is the last in the children/roots list */
<span class="fc" id="L806">				B.treeSiblingNext.treeSiblingPrev = B;</span>
<span class="fc bfc" id="L807" title="All 2 branches covered.">			} else if (bParent != null) {</span>
				/* B is the last in the children list */
<span class="fc" id="L809">				bParent.firstTreeChild.treeSiblingPrev = B;</span>
			}
<span class="fc bfc" id="L811" title="All 2 branches covered.">			if (B.isTreeRoot()) {</span>
<span class="pc bnc" id="L812" title="All 2 branches missed.">				assert tree.root == root;</span>
<span class="pc bnc" id="L813" title="All 2 branches missed.">				assert root.match == null;</span>
<span class="fc" id="L814">				tree.root = B;</span>
			} else {
<span class="pc bnc" id="L816" title="All 2 branches missed.">				assert tree.root != root;</span>
<span class="pc bnc" id="L817" title="All 2 branches missed.">				assert root.match != null;</span>
<span class="fc" id="L818">				B.match = root.match;</span>
			}

<span class="fc" id="L821">			eAugment = null;</span>
<span class="fc" id="L822">			Edge prevBlossomSibling = bridge;</span>
<span class="fc bfc" id="L823" title="All 2 branches covered.">			for (boolean sideSource : new boolean[] { true, false }) {</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">				Blossom b = sideSource ? bridge.source : bridge.target;</span>
<span class="fc bfc" id="L825" title="All 4 branches covered.">				if (!sideSource &amp;&amp; b == root)</span>
<span class="fc" id="L826">					break; /* reach root only from bridge.source side */</span>

				for (;;) {
<span class="fc bfc" id="L829" title="All 2 branches covered.">					if (b.isEven()) {</span>
<span class="fc" id="L830">						b.dual += tree.eps;</span>
					} else {
<span class="pc bnc" id="L832" title="All 2 branches missed.">						assert b.isOdd();</span>
<span class="fc" id="L833">						b.dual -= tree.eps;</span>
					}
<span class="fc" id="L835">					b.setProcessed(false);</span>

<span class="fc bfc" id="L837" title="All 2 branches covered.">					if (b.isOdd()) {</span>
						/* Update all edges that changed their type (when we change b from odd - to even +) */
<span class="fc bfc" id="L839" title="All 2 branches covered.">						for (Iterator&lt;Edge&gt; eit = b.outEdges().iterator(); eit.hasNext();) {</span>
<span class="fc" id="L840">							Edge e = eit.next();</span>
<span class="fc" id="L841">							Blossom target, oldTarget = e.target;</span>
<span class="fc bfc" id="L842" title="All 4 branches covered.">							for (target = oldTarget; !target.isOuter() &amp;&amp; !target.isMarked(); target =</span>
									target.blossomParent);
<span class="fc bfc" id="L844" title="All 2 branches covered.">							if (target != oldTarget)</span>
<span class="fc" id="L845">								e.moveEdgeIn(oldTarget, target);</span>

<span class="fc bfc" id="L847" title="All 2 branches covered.">							if (target.isMarked()) { /* inner blossom edge */</span>
<span class="fc bfc" id="L848" title="All 2 branches covered.">								if (target.isOdd())</span>
<span class="fc" id="L849">									e.slack += tree.eps;</span>

							} else { /* cross blossoms edge */

								/* Remove the edge from the list of b (inner blossom) and add it to B (outer one) */
<span class="fc" id="L854">								eit.remove();</span>
<span class="fc" id="L855">								B.addEdgeOut(e);</span>

<span class="fc" id="L857">								handleCrossBlossomOutEdgeOfOddToEven(e);</span>
							}
<span class="fc" id="L859">						}</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">						for (Iterator&lt;Edge&gt; eit = b.inEdges().iterator(); eit.hasNext();) {</span>
<span class="fc" id="L861">							Edge e = eit.next();</span>
<span class="fc" id="L862">							Blossom source, oldSource = e.source;</span>
<span class="fc bfc" id="L863" title="All 4 branches covered.">							for (source = oldSource; !source.isOuter() &amp;&amp; !source.isMarked(); source =</span>
									source.blossomParent);
<span class="fc bfc" id="L865" title="All 2 branches covered.">							if (source != oldSource)</span>
<span class="fc" id="L866">								e.moveEdgeOut(oldSource, source);</span>

<span class="fc bfc" id="L868" title="All 2 branches covered.">							if (source.isMarked()) { /* inner blossom edge */</span>
<span class="fc bfc" id="L869" title="All 2 branches covered.">								if (source.isOdd())</span>
<span class="fc" id="L870">									e.slack += tree.eps;</span>

							} else { /* cross blossoms edge */

								/* Remove the edge from the list of b (inner blossom) and add it to B (outer one) */
<span class="fc" id="L875">								eit.remove();</span>
<span class="fc" id="L876">								B.addEdgeIn(e);</span>

<span class="fc" id="L878">								handleCrossBlossomInEdgeOfOddToEven(e);</span>
							}
<span class="fc" id="L880">						}</span>
					} /* isOdd */

<span class="fc bfc" id="L883" title="All 2 branches covered.">					Edge nextBlossomSibling = b.isEven() ? b.match : b.treeParentEdge;</span>
<span class="fc" id="L884">					b.blossomParent = B;</span>
<span class="fc" id="L885">					b.blossomGrandparent = B;</span>
<span class="fc" id="L886">					b.match = null;</span>
<span class="fc" id="L887">					b.selfLoops = null;</span>

<span class="fc bfc" id="L889" title="All 2 branches covered.">					if (sideSource) {</span>
<span class="fc bfc" id="L890" title="All 2 branches covered.">						if (b == root)</span>
<span class="fc" id="L891">							break;</span>
<span class="fc" id="L892">						b.blossomSibling = nextBlossomSibling;</span>
<span class="fc" id="L893">						b = nextBlossomSibling.getOtherEndpoint(b);</span>
					} else {
<span class="fc" id="L895">						b.blossomSibling = prevBlossomSibling;</span>
<span class="fc" id="L896">						prevBlossomSibling = nextBlossomSibling;</span>
<span class="fc" id="L897">						b = nextBlossomSibling.getOtherEndpoint(b);</span>
<span class="fc bfc" id="L898" title="All 2 branches covered.">						if (b == root)</span>
<span class="fc" id="L899">							break;</span>
					}
<span class="fc" id="L901">				}</span>
			}
<span class="fc" id="L903">			root.blossomSibling = prevBlossomSibling;</span>
<span class="fc" id="L904">			root.setIsTreeRoot(false);</span>

			/* clear isMarked */
<span class="fc" id="L907">			for (Blossom p = root.blossomSibling();; p = p.blossomSibling()) {</span>
<span class="pc bnc" id="L908" title="All 2 branches missed.">				assert p.isMarked();</span>
<span class="fc" id="L909">				p.setMarked(false);</span>
<span class="fc" id="L910">				p.blossomEps = tree.eps;</span>
<span class="fc bfc" id="L911" title="All 2 branches covered.">				if (p == root)</span>
<span class="fc" id="L912">					break;</span>
			}

			/* Move matched edge to point to B instead of root */
<span class="fc bfc" id="L916" title="All 2 branches covered.">			if (B.isMatched()) {</span>
<span class="fc bfc" id="L917" title="All 2 branches covered.">				if (B.match.source == root) {</span>
<span class="fc" id="L918">					B.match.moveEdgeOut(root, B);</span>
				} else {
<span class="pc bnc" id="L920" title="All 2 branches missed.">					assert B.match.target == root;</span>
<span class="fc" id="L921">					B.match.moveEdgeIn(root, B);</span>
				}
			}
<span class="fc" id="L924">			dbgLog.format(&quot;\t%s (new blossom)\n&quot;, B);</span>

			/* prioritize augmentation over other operations */
<span class="fc" id="L927">			return augmentIfEdgeFound();</span>
		}

		private static void removeFromTreeChildrenList(Blossom b) {
<span class="pc bnc" id="L931" title="All 2 branches missed.">			assert b.isEven();</span>
<span class="fc bfc" id="L932" title="All 2 branches covered.">			if (b.treeSiblingNext != null) {</span>
<span class="fc" id="L933">				b.treeSiblingNext.treeSiblingPrev = b.treeSiblingPrev;</span>
			} else {
<span class="fc" id="L935">				Blossom next = b.matchedNode().getTreeParent().firstTreeChild;</span>
<span class="fc" id="L936">				next.treeSiblingPrev = b.treeSiblingPrev;</span>
			}
<span class="fc bfc" id="L938" title="All 2 branches covered.">			if (b.treeSiblingPrev.treeSiblingNext != null) {</span>
				/* don't set next of parent-&gt;first-&gt;prev-&gt;{next} */
<span class="fc" id="L940">				b.treeSiblingPrev.treeSiblingNext = b.treeSiblingNext;</span>
			} else {
<span class="fc" id="L942">				Blossom parent = b.matchedNode().getTreeParent();</span>
<span class="fc" id="L943">				parent.firstTreeChild = b.treeSiblingNext;</span>
			}
<span class="fc" id="L945">			b.treeSiblingNext = b.treeSiblingPrev = null;</span>
<span class="fc" id="L946">		}</span>

		private static void moveTreeChildren(Blossom from, Blossom to) {
<span class="fc bfc" id="L949" title="All 2 branches covered.">			if (from.firstTreeChild == null)</span>
<span class="fc" id="L950">				return;</span>
			/* Moves the children of 'from' to be the children of 'to' */
<span class="fc" id="L952">			Blossom fromFirst = from.firstTreeChild;</span>
<span class="fc bfc" id="L953" title="All 2 branches covered.">			if (to.firstTreeChild == null) {</span>
<span class="fc" id="L954">				to.firstTreeChild = fromFirst;</span>
			} else {
<span class="fc" id="L956">				Blossom last = fromFirst.treeSiblingPrev;</span>
<span class="fc" id="L957">				fromFirst.treeSiblingPrev = to.firstTreeChild.treeSiblingPrev;</span>
<span class="fc" id="L958">				to.firstTreeChild.treeSiblingPrev.treeSiblingNext = fromFirst;</span>
<span class="fc" id="L959">				to.firstTreeChild.treeSiblingPrev = last;</span>
			}
<span class="fc" id="L961">		}</span>

		private void handleCrossBlossomOutEdgeOfOddToEven(Edge e) {
<span class="fc" id="L964">			handleCrossBlossomEdgeOfOddToEven(e, true);</span>
<span class="fc" id="L965">		}</span>

		private void handleCrossBlossomInEdgeOfOddToEven(Edge e) {
<span class="fc" id="L968">			handleCrossBlossomEdgeOfOddToEven(e, false);</span>
<span class="fc" id="L969">		}</span>

		private void handleCrossBlossomEdgeOfOddToEven(Edge e, boolean outEdge) {
			/*
			 * When a blossom is changed from odd to even, we traverse its edges one by one, and if the edge is a
			 * cross-blossom edge, namely its endpoints does not lie in the blossoms, we need to add/remove it from/to
			 * the relevant PQs.
			 */

			Tree tree;
			Blossom other;
<span class="fc bfc" id="L980" title="All 2 branches covered.">			if (outEdge) {</span>
<span class="fc" id="L981">				tree = e.source.tree;</span>
<span class="fc" id="L982">				other = e.target;</span>
			} else {
<span class="fc" id="L984">				tree = e.target.tree;</span>
<span class="fc" id="L985">				other = e.source;</span>
			}
<span class="pc bnc" id="L987" title="All 2 branches missed.">			assert tree != null;</span>

			/* If target was even, e was part of pqOddEven - remove it */
<span class="fc bfc" id="L990" title="All 4 branches covered.">			if (other.isEven() &amp;&amp; tree != other.tree) {</span>
				/* e was (-,+) edge, remove it from PQ as b is now + (even) */
<span class="fc" id="L992">				other.tree.pqEdgeRemoveEvenOdd(other.tree.currentEdge, e);</span>
<span class="fc bfc" id="L993" title="All 2 branches covered.">				if (e.slack + tree.eps &lt;= other.tree.eps)</span>
<span class="fc" id="L994">					eAugment = e;</span>
			}

			/* Add e to all relevant PQs */
<span class="fc" id="L998">			e.slack += 2 * tree.eps;</span>
<span class="fc bfc" id="L999" title="All 2 branches covered.">			if (other.isOut()) {</span>
				/* e is an (+,out) edge */
<span class="fc" id="L1001">				tree.pqInsertEvenOut(e);</span>

<span class="fc bfc" id="L1003" title="All 2 branches covered.">			} else if (other.isEven()) {</span>
<span class="fc bfc" id="L1004" title="All 2 branches covered.">				if (tree != other.tree) {</span>
					/* e is an (+,+) edge between trees */
<span class="fc" id="L1006">					ensureTreesEdgeExists(tree, other.tree);</span>
<span class="fc" id="L1007">					other.tree.currentEdge.pqInsertEvenEven(e);</span>
				} else {
					/* e is an (+,+) edge within a tree */
<span class="fc" id="L1010">					tree.pqInsertEvenEven(e);</span>
				}
<span class="fc bfc" id="L1012" title="All 2 branches covered.">			} else if (tree != other.tree) {</span>
				/* e is an (+,-) edge between trees */
<span class="pc bnc" id="L1014" title="All 2 branches missed.">				assert other.isOdd();</span>
<span class="fc" id="L1015">				ensureTreesEdgeExists(tree, other.tree);</span>
<span class="fc" id="L1016">				tree.pqEdgeInsertEvenOdd(other.tree.currentEdge, e);</span>
			}
<span class="fc" id="L1018">		}</span>

		/**
		 * Expand an existing blossom to its sub blossoms.
		 *
		 * @param  B the blossom to expand
		 * @return   {@code true} if augmentation was performed
		 */
		private boolean expand(Blossom B) {
<span class="fc" id="L1027">			dbgLog.format(&quot;expand(%s)\n&quot;, B);</span>
<span class="pc bnc" id="L1028" title="All 2 branches missed.">			assert B.isBlossom();</span>
<span class="pc bnc" id="L1029" title="All 2 branches missed.">			assert B.isOuter();</span>
<span class="pc bnc" id="L1030" title="All 2 branches missed.">			assert B.isOdd();</span>

<span class="fc" id="L1032">			Tree tree = B.tree;</span>
<span class="fc" id="L1033">			double eps = tree.eps;</span>

<span class="fc" id="L1035">			Blossom treeParent = B.getTreeParent(); /* fix edge pointer */</span>
<span class="fc" id="L1036">			Blossom successor = B.treeParentEdge.getEndpointOrig(B).getPenultimateBlossom();</span>
<span class="fc" id="L1037">			B.treeParentEdge.moveEdge(B, successor);</span>

<span class="fc" id="L1039">			Blossom base = B.match.getEndpointOrig(B).getPenultimateBlossom();</span>
<span class="fc" id="L1040">			B.match.moveEdge(B, base);</span>

<span class="fc" id="L1042">			Consumer&lt;Blossom&gt; processSelfLoops = b -&gt; {</span>
<span class="fc" id="L1043">				b.setOuter(true);</span>
<span class="fc bfc" id="L1044" title="All 2 branches covered.">				for (Edge e = b.selfLoops, next; e != null; e = next) {</span>
<span class="fc" id="L1045">					next = e.nextOutEdge;</span>
<span class="fc" id="L1046">					Blossom source = e.source.getPenultimateBlossom();</span>
<span class="fc" id="L1047">					Blossom target = e.target.getPenultimateBlossom();</span>
<span class="fc bfc" id="L1048" title="All 2 branches covered.">					if (source != target) {</span>
<span class="fc" id="L1049">						e.nextOutEdge = null;</span>
<span class="fc" id="L1050">						source.addEdgeOut(e);</span>
<span class="fc" id="L1051">						target.addEdgeIn(e);</span>
<span class="fc" id="L1052">						e.slack -= 2 * source.blossomEps;</span>
					} else {
<span class="fc" id="L1054">						e.nextOutEdge = source.selfLoops;</span>
<span class="fc" id="L1055">						source.selfLoops = e;</span>
					}
				}
<span class="fc" id="L1058">				b.selfLoops = null;</span>
<span class="fc" id="L1059">				b.setOuter(false);</span>
<span class="fc" id="L1060">			};</span>
<span class="fc" id="L1061">			for (Blossom b1 = base.blossomSibling();;) {</span>
<span class="pc bnc" id="L1062" title="All 2 branches missed.">				assert B == b1.blossomParent;</span>
<span class="pc bnc" id="L1063" title="All 2 branches missed.">				assert B == b1.blossomGrandparent; // maybe not</span>
<span class="fc" id="L1064">				expandTemp.add(b1);</span>
<span class="fc" id="L1065">				b1.setOut();</span>
<span class="fc" id="L1066">				processSelfLoops.accept(b1);</span>
<span class="fc bfc" id="L1067" title="All 2 branches covered.">				if (b1 == base)</span>
<span class="fc" id="L1068">					break;</span>
<span class="fc" id="L1069">				b1.match = b1.blossomSibling;</span>

<span class="fc" id="L1071">				Blossom b2 = b1.matchedNode();</span>
<span class="fc" id="L1072">				expandTemp.add(b2);</span>
<span class="fc" id="L1073">				b2.setOut();</span>
<span class="fc" id="L1074">				processSelfLoops.accept(b2);</span>
<span class="fc" id="L1075">				b2.match = b1.match;</span>

<span class="fc" id="L1077">				b1 = b2.blossomSibling();</span>
<span class="fc" id="L1078">			}</span>
<span class="fc" id="L1079">			base.match = B.match;</span>

<span class="fc" id="L1081">			successor.setOdd();</span>
<span class="fc" id="L1082">			successor.tree = tree;</span>
<span class="fc" id="L1083">			successor.dual += eps;</span>
<span class="fc" id="L1084">			successor.treeParentEdge = B.treeParentEdge;</span>
<span class="fc bfc" id="L1085" title="All 2 branches covered.">			if (successor != base) {</span>
<span class="fc" id="L1086">				Blossom firstChild = null;</span>
<span class="fc bfc" id="L1087" title="All 2 branches covered.">				if (successor.match == successor.blossomSibling) {</span>
<span class="fc" id="L1088">					for (Blossom b = successor, prev = null;;) {</span>
<span class="fc" id="L1089">						b = b.match.getOtherEndpoint(b);</span>

<span class="fc" id="L1091">						final Edge aa = b.blossomSibling;</span>
<span class="fc" id="L1092">						b.setEven();</span>
<span class="fc" id="L1093">						b.tree = tree;</span>
<span class="fc" id="L1094">						b.dual -= eps;</span>
<span class="fc bfc" id="L1095" title="All 2 branches covered.">						if (prev == null) {</span>
<span class="fc" id="L1096">							firstChild = b;</span>
						} else {
<span class="fc" id="L1098">							prev.firstTreeChild = b;</span>
						}
<span class="fc" id="L1100">						prev = b;</span>
<span class="fc" id="L1101">						b.treeSiblingPrev = b;</span>
<span class="fc" id="L1102">						b.treeSiblingNext = null;</span>
<span class="fc" id="L1103">						b = aa.getOtherEndpoint(b);</span>
<span class="fc" id="L1104">						b.setOdd();</span>
<span class="fc" id="L1105">						b.tree = tree;</span>
<span class="fc" id="L1106">						b.dual += eps;</span>
<span class="fc" id="L1107">						b.treeParentEdge = aa;</span>
<span class="fc bfc" id="L1108" title="All 2 branches covered.">						if (b == base) {</span>
<span class="fc" id="L1109">							prev.firstTreeChild = base.match.getOtherEndpoint(base);</span>
<span class="fc" id="L1110">							break;</span>
						}
<span class="fc" id="L1112">					}</span>

				} else {
<span class="fc" id="L1115">					Blossom child = base.match.getOtherEndpoint(base);</span>
<span class="fc" id="L1116">					for (Blossom b = base;;) {</span>
<span class="fc" id="L1117">						b.treeParentEdge = b.blossomSibling;</span>
<span class="fc" id="L1118">						b.setOdd();</span>
<span class="fc" id="L1119">						b.tree = tree;</span>
<span class="fc" id="L1120">						b.dual += eps;</span>

<span class="fc" id="L1122">						b = b.treeParentEdge.getOtherEndpoint(b);</span>
<span class="fc" id="L1123">						b.setEven();</span>
<span class="fc" id="L1124">						b.tree = tree;</span>
<span class="fc" id="L1125">						b.dual -= eps;</span>
<span class="fc" id="L1126">						b.firstTreeChild = child;</span>
<span class="fc" id="L1127">						child = b;</span>
<span class="fc" id="L1128">						b.treeSiblingPrev = b;</span>
<span class="fc" id="L1129">						b.treeSiblingNext = null;</span>

<span class="fc" id="L1131">						b = b.match.getOtherEndpoint(b);</span>
<span class="fc bfc" id="L1132" title="All 2 branches covered.">						if (b.isOdd())</span>
<span class="fc" id="L1133">							break;</span>
					}
<span class="fc" id="L1135">					firstChild = child;</span>
				}

<span class="fc" id="L1138">				Blossom b = base.match.getOtherEndpoint(base);</span>
<span class="fc" id="L1139">				firstChild.treeSiblingPrev = b.treeSiblingPrev;</span>
<span class="fc" id="L1140">				firstChild.treeSiblingNext = b.treeSiblingNext;</span>
<span class="fc bfc" id="L1141" title="All 2 branches covered.">				if (b.treeSiblingPrev.treeSiblingNext != null) {</span>
<span class="fc" id="L1142">					b.treeSiblingPrev.treeSiblingNext = firstChild;</span>
				} else {
<span class="fc" id="L1144">					treeParent.firstTreeChild = firstChild;</span>
				}
<span class="fc bfc" id="L1146" title="All 2 branches covered.">				if (b.treeSiblingNext != null) {</span>
<span class="fc" id="L1147">					b.treeSiblingNext.treeSiblingPrev = firstChild;</span>
				} else {
<span class="fc" id="L1149">					treeParent.firstTreeChild.treeSiblingPrev = firstChild;</span>
				}
<span class="fc" id="L1151">				b.treeSiblingPrev = b;</span>
<span class="fc" id="L1152">				b.treeSiblingNext = null;</span>
			}

<span class="fc" id="L1155">			for (Blossom b = base;;) {</span>
<span class="pc bnc" id="L1156" title="All 2 branches missed.">				assert b.isOdd();</span>
<span class="fc" id="L1157">				dbgLog.format(&quot;\t%s\n&quot;, b);</span>
<span class="fc bfc" id="L1158" title="All 2 branches covered.">				if (b.isBlossom())</span>
<span class="fc" id="L1159">					tree.pqInsertOdd(b);</span>
<span class="fc bfc" id="L1160" title="All 2 branches covered.">				for (Edge e : b.outEdges())</span>
<span class="fc bfc" id="L1161" title="All 2 branches covered.">					if (!e.target.isEven())</span>
<span class="fc" id="L1162">						e.slack -= eps;</span>
<span class="fc bfc" id="L1163" title="All 2 branches covered.">				for (Edge e : b.inEdges())</span>
<span class="fc bfc" id="L1164" title="All 2 branches covered.">					if (!e.source.isEven())</span>
<span class="fc" id="L1165">						e.slack -= eps;</span>
<span class="fc" id="L1166">				b.setProcessed(true);</span>

<span class="fc bfc" id="L1168" title="All 2 branches covered.">				if (b.treeParentEdge == B.treeParentEdge)</span>
<span class="fc" id="L1169">					break;</span>

<span class="fc" id="L1171">				b = b.treeParentEdge.getOtherEndpoint(b);</span>
<span class="pc bnc" id="L1172" title="All 2 branches missed.">				assert b.isEven();</span>
<span class="fc" id="L1173">				dbgLog.format(&quot;\t%s\n&quot;, b);</span>

<span class="fc bfc" id="L1175" title="All 2 branches covered.">				for (Edge e : b.outEdges()) {</span>
<span class="fc bfc" id="L1176" title="All 2 branches covered.">					if (e.target.isOut()) {</span>
<span class="fc" id="L1177">						e.slack += eps;</span>
<span class="fc" id="L1178">						tree.pqInsertEvenOut(e);</span>
<span class="fc bfc" id="L1179" title="All 4 branches covered.">					} else if (e.target.isEven() &amp;&amp; System.identityHashCode(b) &lt; System.identityHashCode(e.target)) {</span>
<span class="fc" id="L1180">						e.slack += 2 * eps;</span>
<span class="fc" id="L1181">						tree.pqInsertEvenEven(e);</span>
					}
<span class="fc" id="L1183">				}</span>
<span class="fc bfc" id="L1184" title="All 2 branches covered.">				for (Edge e : b.inEdges()) {</span>
<span class="fc bfc" id="L1185" title="All 2 branches covered.">					if (e.source.isOut()) {</span>
<span class="fc" id="L1186">						e.slack += eps;</span>
<span class="fc" id="L1187">						tree.pqInsertEvenOut(e);</span>
<span class="fc bfc" id="L1188" title="All 4 branches covered.">					} else if (e.source.isEven() &amp;&amp; System.identityHashCode(b) &lt; System.identityHashCode(e.source)) {</span>
<span class="fc" id="L1189">						e.slack += 2 * eps;</span>
<span class="fc" id="L1190">						tree.pqInsertEvenEven(e);</span>
					}
<span class="fc" id="L1192">				}</span>
<span class="fc" id="L1193">				b.setProcessed(true);</span>
<span class="fc" id="L1194">				b = b.match.getOtherEndpoint(b);</span>
			}

<span class="pc bpc" id="L1197" title="1 of 2 branches missed.">			if (B.outEdges != null)</span>
<span class="fc" id="L1198">				B.outEdges.prevOutEdge.nextOutEdge = null;</span>
<span class="fc bfc" id="L1199" title="All 2 branches covered.">			if (B.inEdges != null)</span>
<span class="fc" id="L1200">				B.inEdges.prevInEdge.nextInEdge = null;</span>
<span class="fc" id="L1201">			eAugment = null;</span>
<span class="fc bfc" id="L1202" title="All 2 branches covered.">			for (Edge e : B.outEdges()) {</span>
<span class="fc" id="L1203">				Blossom b = e.sourceOrig.getPenultimateBlossomAndUpdateGrandparentToGrandchild();</span>
				/* its ok to modify it during iteration, e.nextOutEdge already saved in iterator */
<span class="fc" id="L1205">				e.nextOutEdge = e.prevOutEdge = null;</span>
<span class="fc" id="L1206">				b.addEdgeOut(e);</span>
<span class="fc" id="L1207">				Blossom bOther = e.getTargetOuterBlossom();</span>

<span class="fc bfc" id="L1209" title="All 2 branches covered.">				if (b.isOdd())</span>
<span class="fc" id="L1210">					continue;</span>

<span class="fc bfc" id="L1212" title="All 4 branches covered.">				if (bOther.isEven() &amp;&amp; bOther.tree != tree)</span>
<span class="fc" id="L1213">					bOther.tree.pqEdgeRemoveEvenOdd(bOther.tree.currentEdge, e);</span>

<span class="fc bfc" id="L1215" title="All 2 branches covered.">				if (b.isOut()) {</span>
<span class="fc" id="L1216">					e.slack += eps;</span>
<span class="fc bfc" id="L1217" title="All 2 branches covered.">					if (bOther.isEven())</span>
<span class="fc" id="L1218">						bOther.tree.pqInsertEvenOut(e);</span>
				} else {
<span class="fc" id="L1220">					e.slack += 2 * eps;</span>
<span class="fc bfc" id="L1221" title="All 2 branches covered.">					if (bOther.isOut()) {</span>
<span class="fc" id="L1222">						tree.pqInsertEvenOut(e);</span>

<span class="fc bfc" id="L1224" title="All 2 branches covered.">					} else if (bOther.isEven()) {</span>
<span class="fc bfc" id="L1225" title="All 2 branches covered.">						if (bOther.tree == tree) {</span>
<span class="fc" id="L1226">							tree.pqInsertEvenEven(e);</span>
						} else {
<span class="pc bpc" id="L1228" title="1 of 2 branches missed.">							if (e.slack &lt;= bOther.tree.eps + eps)</span>
<span class="nc" id="L1229">								eAugment = e;</span>
<span class="fc" id="L1230">							ensureTreesEdgeExists(tree, bOther.tree);</span>
<span class="fc" id="L1231">							bOther.tree.currentEdge.pqInsertEvenEven(e);</span>
						}
<span class="fc bfc" id="L1233" title="All 2 branches covered.">					} else if (tree != bOther.tree) {</span>
<span class="pc bnc" id="L1234" title="All 2 branches missed.">						assert bOther.isOdd();</span>
<span class="fc" id="L1235">						ensureTreesEdgeExists(tree, bOther.tree);</span>
<span class="fc" id="L1236">						tree.pqEdgeInsertEvenOdd(bOther.tree.currentEdge, e);</span>
					}
				}
<span class="fc" id="L1239">			}</span>
<span class="fc bfc" id="L1240" title="All 2 branches covered.">			for (Edge e : B.inEdges()) {</span>
<span class="fc" id="L1241">				Blossom b = e.targetOrig.getPenultimateBlossomAndUpdateGrandparentToGrandchild();</span>
				/* its ok to modify it during iteration, e.nextInEdge already saved in iterator */
<span class="fc" id="L1243">				e.nextInEdge = e.prevInEdge = null;</span>
<span class="fc" id="L1244">				b.addEdgeIn(e);</span>
<span class="fc" id="L1245">				Blossom bOther = e.getSourceOuterBlossom();</span>

<span class="fc bfc" id="L1247" title="All 2 branches covered.">				if (b.isOdd())</span>
<span class="fc" id="L1248">					continue;</span>

<span class="fc bfc" id="L1250" title="All 4 branches covered.">				if (bOther.isEven() &amp;&amp; bOther.tree != tree)</span>
<span class="fc" id="L1251">					bOther.tree.pqEdgeRemoveEvenOdd(bOther.tree.currentEdge, e);</span>

<span class="fc bfc" id="L1253" title="All 2 branches covered.">				if (b.isOut()) {</span>
<span class="fc" id="L1254">					e.slack += eps;</span>
<span class="fc bfc" id="L1255" title="All 2 branches covered.">					if (bOther.isEven())</span>
<span class="fc" id="L1256">						bOther.tree.pqInsertEvenOut(e);</span>
				} else {
<span class="fc" id="L1258">					e.slack += 2 * eps;</span>
<span class="fc bfc" id="L1259" title="All 2 branches covered.">					if (bOther.isOut()) {</span>
<span class="fc" id="L1260">						tree.pqInsertEvenOut(e);</span>

<span class="fc bfc" id="L1262" title="All 2 branches covered.">					} else if (bOther.isEven()) {</span>
<span class="fc bfc" id="L1263" title="All 2 branches covered.">						if (bOther.tree == tree) {</span>
<span class="fc" id="L1264">							tree.pqInsertEvenEven(e);</span>
						} else {
<span class="pc bpc" id="L1266" title="1 of 2 branches missed.">							if (e.slack &lt;= bOther.tree.eps + eps)</span>
<span class="nc" id="L1267">								eAugment = e;</span>
<span class="fc" id="L1268">							ensureTreesEdgeExists(tree, bOther.tree);</span>
<span class="fc" id="L1269">							bOther.tree.currentEdge.pqInsertEvenEven(e);</span>
						}
<span class="fc bfc" id="L1271" title="All 2 branches covered.">					} else if (tree != bOther.tree) {</span>
<span class="pc bnc" id="L1272" title="All 2 branches missed.">						assert bOther.isOdd();</span>
<span class="fc" id="L1273">						ensureTreesEdgeExists(tree, bOther.tree);</span>
<span class="fc" id="L1274">						tree.pqEdgeInsertEvenOdd(bOther.tree.currentEdge, e);</span>
					}
				}
<span class="fc" id="L1277">			}</span>

<span class="fc bfc" id="L1279" title="All 2 branches covered.">			for (Blossom b : expandTemp) {</span>
<span class="fc" id="L1280">				b.setOuter(true);</span>
<span class="fc" id="L1281">				b.blossomParent = null;</span>
<span class="fc" id="L1282">				b.blossomGrandparent = b;</span>
<span class="fc" id="L1283">			}</span>
<span class="fc" id="L1284">			expandTemp.clear();</span>

			/* prioritize augmentation over other operations */
<span class="fc" id="L1287">			return augmentIfEdgeFound();</span>
		}

		private boolean augmentIfEdgeFound() {
<span class="fc bfc" id="L1291" title="All 2 branches covered.">			if (eAugment != null) {</span>
<span class="fc" id="L1292">				augment(eAugment);</span>
<span class="fc" id="L1293">				eAugment = null;</span>
<span class="fc" id="L1294">				return true;</span>
			} else {
<span class="fc" id="L1296">				return false;</span>
			}
		}

		private void augment(Edge e) {
<span class="fc" id="L1301">			dbgLog.format(&quot;augment(%s)\n&quot;, e);</span>
<span class="fc" id="L1302">			Blossom u = e.getSourceOuterBlossom();</span>
<span class="fc" id="L1303">			Blossom v = e.getTargetOuterBlossom();</span>
<span class="fc" id="L1304">			augmentBranch(u);</span>
<span class="fc" id="L1305">			augmentBranch(v);</span>
<span class="fc" id="L1306">			u.match = v.match = e;</span>
<span class="fc" id="L1307">		}</span>

		private void augmentBranch(Blossom b) {
<span class="fc" id="L1310">			dbgLog.format(&quot;augmentBranch(%s)\n&quot;, b);</span>
<span class="pc bnc" id="L1311" title="All 2 branches missed.">			assert b.isEven();</span>
<span class="fc" id="L1312">			Tree tree = b.tree;</span>
<span class="fc" id="L1313">			double eps = tree.eps;</span>

			/* We want to delete the current tree */
			/* Iterate over the tree (trees) edges and remove the pointers to the tree */
<span class="fc bfc" id="L1317" title="All 2 branches covered.">			for (TreesEdge e : tree.outEdgesAndProneRemoved()) {</span>
<span class="fc" id="L1318">				Tree t2 = e.target;</span>
<span class="fc" id="L1319">				e.source = null; /* mark for deletion */</span>
<span class="fc" id="L1320">				t2.currentEdge = e;</span>
<span class="fc" id="L1321">			}</span>
<span class="fc bfc" id="L1322" title="All 2 branches covered.">			for (TreesEdge e : tree.inEdgesAndProneRemoved()) {</span>
<span class="fc" id="L1323">				Tree t2 = e.source;</span>
<span class="fc" id="L1324">				e.target = null; /* mark for deletion */</span>
<span class="fc" id="L1325">				t2.currentEdge = e;</span>
<span class="fc" id="L1326">			}</span>

<span class="fc bfc" id="L1328" title="All 2 branches covered.">			for (Blossom even : tree.evenNodesWithoutRoot()) {</span>
<span class="pc bnc" id="L1329" title="All 2 branches missed.">				assert even.isOuter();</span>
<span class="pc bnc" id="L1330" title="All 2 branches missed.">				assert even.isEven();</span>

<span class="fc" id="L1332">				Blossom odd = even.matchedNode();</span>
<span class="pc bnc" id="L1333" title="All 2 branches missed.">				assert odd.isOuter();</span>
<span class="pc bnc" id="L1334" title="All 2 branches missed.">				assert odd.isOdd();</span>

<span class="fc bfc" id="L1336" title="All 2 branches covered.">				if (odd.isProcessed()) {</span>
					/* Remove blossom expand event from PQ */
<span class="fc bfc" id="L1338" title="All 2 branches covered.">					if (odd.isBlossom())</span>
<span class="fc" id="L1339">						tree.pqRemoveOdd(odd);</span>

					/* Blossom become 'out', add even-out events from other trees to it */
<span class="fc bfc" id="L1342" title="All 2 branches covered.">					for (Edge e : odd.outEdges()) {</span>
<span class="fc" id="L1343">						Blossom target = e.getTargetOuterBlossom();</span>
<span class="fc bfc" id="L1344" title="All 4 branches covered.">						if (target.isEven() &amp;&amp; target.isProcessed()) {</span>
<span class="fc bfc" id="L1345" title="All 2 branches covered.">							if (target.tree != tree) {</span>
<span class="fc" id="L1346">								e.slack += eps;</span>
								// if (e.pqEvenOutRef == null &amp;&amp; e.pqEvenEvenRef == null &amp;&amp; e.pqEvenOddRef == null)
								// if (e.pqRef == null)
								// target.tree.pqInsertEvenOut(e);
<span class="pc bnc" id="L1350" title="All 2 branches missed.">								assert e.pqRef != null;</span>
							}
						} else {
<span class="fc" id="L1353">							e.slack += eps;</span>
						}
<span class="fc" id="L1355">					}</span>
<span class="fc bfc" id="L1356" title="All 2 branches covered.">					for (Edge e : odd.inEdges()) {</span>
<span class="fc" id="L1357">						Blossom source = e.getSourceOuterBlossom();</span>
<span class="fc bfc" id="L1358" title="All 4 branches covered.">						if (source.isEven() &amp;&amp; source.isProcessed()) {</span>
<span class="fc bfc" id="L1359" title="All 2 branches covered.">							if (source.tree != tree) {</span>
<span class="fc" id="L1360">								e.slack += eps;</span>
								// if (e.pqEvenOutRef == null &amp;&amp; e.pqEvenEvenRef == null &amp;&amp; e.pqEvenOddRef == null)
								// if (e.pqRef == null)
								// source.tree.pqInsertEvenOut(e);
<span class="pc bnc" id="L1364" title="All 2 branches missed.">								assert e.pqRef != null;</span>
							}
						} else {
<span class="fc" id="L1367">							e.slack += eps;</span>
						}
<span class="fc" id="L1369">					}</span>
				}
<span class="fc" id="L1371">			}</span>

<span class="fc" id="L1373">			Consumer&lt;Edge&gt; handleEvenPqEdge = edge -&gt; {</span>
<span class="fc" id="L1374">				edge.slack -= eps;</span>
<span class="fc" id="L1375">				edge.getSourceOuterBlossom(); /* fix source pointer */</span>
<span class="fc" id="L1376">				edge.getTargetOuterBlossom(); /* fix target pointer */</span>
<span class="fc" id="L1377">			};</span>
<span class="fc bfc" id="L1378" title="All 2 branches covered.">			for (TreesEdge e : tree.outEdges()) {</span>
<span class="fc" id="L1379">				Tree target = e.target;</span>
<span class="fc" id="L1380">				target.currentEdge = null;</span>

				/* All odd nodes of this tree become out, meld into EvenOut of the other tree */
				// for (ObjReferenceableHeap.Ref&lt;Edge&gt; ref : e.pqOddEven) {
				// Edge ePq = ref.key();
				// assert ePq.pqEvenOddRef == ref;
				// ePq.pqEvenOddRef = null;
				// assert ePq.pqEvenOutRef == null;
				// ePq.pqEvenOutRef = ref;
				// }
<span class="fc" id="L1390">				target.pqEvenOut.meld(e.pqOddEven);</span>

				/* All even nodes of this tree become out, meld into EvenOut of the other tree */
<span class="fc bfc" id="L1393" title="All 2 branches covered.">				for (ObjReferenceableHeap.Ref&lt;Edge&gt; ref : e.pqEvenEven) {</span>
<span class="fc" id="L1394">					handleEvenPqEdge.accept(ref.key());</span>
					// Edge ePq = ref.key();
					// assert ePq.pqEvenEvenRef == ref;
					// ePq.pqEvenEvenRef = null;
					// assert ePq.pqEvenOutRef == null;
					// ePq.pqEvenOutRef = ref;
<span class="fc" id="L1400">				}</span>
<span class="fc" id="L1401">				target.pqEvenOut.meld(e.pqEvenEven);</span>

				/* All even nodes of this tree become out, clear EvenOdd PQ */
<span class="fc bfc" id="L1404" title="All 2 branches covered.">				for (ObjReferenceableHeap.Ref&lt;Edge&gt; ref : e.pqEvenOdd) {</span>
<span class="fc" id="L1405">					Edge ePq = ref.key();</span>
					// assert ePq.pqEvenOddRef == ref;
					// ePq.pqEvenOddRef = null;
<span class="pc bnc" id="L1408" title="All 2 branches missed.">					assert ePq.pqRef == ref;</span>
<span class="fc" id="L1409">					ePq.pqRef = null;</span>

<span class="fc" id="L1411">					handleEvenPqEdge.accept(ePq);</span>
<span class="fc" id="L1412">				}</span>
<span class="fc" id="L1413">				e.pqEvenOdd.clear();</span>
<span class="fc" id="L1414">			}</span>
<span class="fc bfc" id="L1415" title="All 2 branches covered.">			for (TreesEdge e : tree.inEdges()) {</span>
<span class="fc" id="L1416">				Tree source = e.source;</span>
<span class="fc" id="L1417">				source.currentEdge = null;</span>

				/* All odd nodes of this tree become out, meld into EvenOut of the other tree */
				// for (ObjReferenceableHeap.Ref&lt;Edge&gt; ref : e.pqEvenOdd) {
				// Edge ePq = ref.key();
				// assert ePq.pqEvenOddRef == ref;
				// ePq.pqEvenOddRef = null;
				// assert ePq.pqEvenOutRef == null;
				// ePq.pqEvenOutRef = ref;
				// }
<span class="fc" id="L1427">				source.pqEvenOut.meld(e.pqEvenOdd);</span>

				/* All even nodes of this tree become out, meld into EvenOut of the other tree */
<span class="fc bfc" id="L1430" title="All 2 branches covered.">				for (ObjReferenceableHeap.Ref&lt;Edge&gt; ref : e.pqEvenEven) {</span>
<span class="fc" id="L1431">					handleEvenPqEdge.accept(ref.key());</span>
					// Edge ePq = ref.key();
					// assert ePq.pqEvenEvenRef == ref;
					// ePq.pqEvenEvenRef = null;
					// assert ePq.pqEvenOutRef == null;
					// ePq.pqEvenOutRef = ref;
<span class="fc" id="L1437">				}</span>
<span class="fc" id="L1438">				source.pqEvenOut.meld(e.pqEvenEven);</span>

				/* All even nodes of this tree become out, clear OddEven PQ */
<span class="fc bfc" id="L1441" title="All 2 branches covered.">				for (ObjReferenceableHeap.Ref&lt;Edge&gt; ref : e.pqOddEven) {</span>
<span class="fc" id="L1442">					Edge ePq = ref.key();</span>
					// assert ePq.pqEvenOddRef == ref;
					// ePq.pqEvenOddRef = null;
<span class="pc bnc" id="L1445" title="All 2 branches missed.">					assert ePq.pqRef == ref;</span>
<span class="fc" id="L1446">					ePq.pqRef = null;</span>

<span class="fc" id="L1448">					handleEvenPqEdge.accept(ePq);</span>
<span class="fc" id="L1449">				}</span>
<span class="fc" id="L1450">				e.pqOddEven.clear();</span>
<span class="fc" id="L1451">			}</span>

			/* All even nodes of this tree become out, clear EvenOut PQ */
<span class="fc bfc" id="L1454" title="All 2 branches covered.">			for (ObjReferenceableHeap.Ref&lt;Edge&gt; ref : tree.pqEvenOut) {</span>
<span class="fc" id="L1455">				Edge ePq = ref.key();</span>
				// assert ePq.pqEvenOutRef == ref;
				// ePq.pqEvenOutRef = null;
<span class="pc bnc" id="L1458" title="All 2 branches missed.">				assert ePq.pqRef == ref;</span>
<span class="fc" id="L1459">				ePq.pqRef = null;</span>

<span class="fc" id="L1461">				handleEvenPqEdge.accept(ePq);</span>
<span class="fc" id="L1462">			}</span>
<span class="fc" id="L1463">			tree.pqEvenOut.clear();</span>

			/* All even nodes of this tree become out, clear EvenEven PQ */
<span class="fc bfc" id="L1466" title="All 2 branches covered.">			for (ObjReferenceableHeap.Ref&lt;Edge&gt; ref : tree.pqEvenEven) {</span>
<span class="fc" id="L1467">				Edge ePq = ref.key();</span>
				// assert ePq.pqEvenEvenRef == ref;
				// ePq.pqEvenEvenRef = null;
<span class="pc bnc" id="L1470" title="All 2 branches missed.">				assert ePq.pqRef == ref;</span>
<span class="fc" id="L1471">				ePq.pqRef = null;</span>

<span class="fc" id="L1473">				processEdgeEvenEven(ePq, true);</span>
<span class="fc" id="L1474">			}</span>
<span class="fc" id="L1475">			tree.pqEvenEven.clear();</span>

			/* Set all tree nodes to be out */
<span class="fc bfc" id="L1478" title="All 2 branches covered.">			for (Blossom even : tree.evenNodesWithoutRoot()) {</span>
<span class="fc" id="L1479">				Blossom odd = even.matchedNode();</span>
<span class="pc bnc" id="L1480" title="All 2 branches missed.">				assert even.isEven();</span>
<span class="pc bnc" id="L1481" title="All 2 branches missed.">				assert odd.isOdd();</span>
<span class="fc" id="L1482">				even.setOut();</span>
<span class="fc" id="L1483">				odd.setOut();</span>
<span class="fc" id="L1484">				even.setProcessed(false);</span>
<span class="fc" id="L1485">				odd.setProcessed(false);</span>
<span class="fc" id="L1486">				even.dual += eps;</span>
<span class="fc" id="L1487">				odd.dual -= eps;</span>
<span class="fc" id="L1488">			}</span>
<span class="fc" id="L1489">			Blossom root = tree.root;</span>
<span class="fc" id="L1490">			root.setOut();</span>
<span class="fc" id="L1491">			root.setProcessed(false);</span>
<span class="fc" id="L1492">			root.dual += eps;</span>

			/* Actually augment, update matched edges along path from b to root */
<span class="fc bfc" id="L1495" title="All 2 branches covered.">			if (!b.isTreeRoot()) {</span>
<span class="fc" id="L1496">				Blossom odd = b.matchedNode();</span>
<span class="fc" id="L1497">				Blossom even = odd.getTreeParent();</span>
<span class="fc" id="L1498">				Edge match = odd.match = odd.treeParentEdge;</span>
<span class="fc bfc" id="L1499" title="All 2 branches covered.">				while (!even.isTreeRoot()) {</span>
<span class="fc" id="L1500">					odd = even.matchedNode();</span>
<span class="fc" id="L1501">					even.match = match;</span>
<span class="fc" id="L1502">					even = odd.getTreeParent();</span>
<span class="fc" id="L1503">					match = odd.match = odd.treeParentEdge;</span>
				}
<span class="fc" id="L1505">				even.match = match;</span>
			}

<span class="fc" id="L1508">			root.setIsTreeRoot(false);</span>
<span class="fc" id="L1509">			root.treeSiblingPrev.treeSiblingNext = root.treeSiblingNext;</span>
<span class="fc bfc" id="L1510" title="All 2 branches covered.">			if (root.treeSiblingNext != null)</span>
<span class="fc" id="L1511">				root.treeSiblingNext.treeSiblingPrev = root.treeSiblingPrev;</span>

			/* help GC */
<span class="fc" id="L1514">			root.treeSiblingNext = root.treeSiblingPrev = null;</span>
<span class="fc" id="L1515">			tree.clear();</span>
<span class="fc" id="L1516">			treeNum--;</span>
<span class="fc" id="L1517">		}</span>

		private IMatching finish() {
<span class="fc bfc" id="L1520" title="All 2 branches covered.">			for (Blossom blossom : singletonNodes) {</span>
<span class="fc bfc" id="L1521" title="All 2 branches covered.">				if (blossom.isMatched())</span>
<span class="fc" id="L1522">					continue;</span>
<span class="fc" id="L1523">				Blossom prev = null;</span>
				do {
<span class="fc" id="L1525">					blossom.blossomGrandparent = prev;</span>
<span class="fc" id="L1526">					prev = blossom;</span>
<span class="fc" id="L1527">					blossom = blossom.blossomParent;</span>
<span class="fc bfc" id="L1528" title="All 2 branches covered.">				} while (!blossom.isOuter());</span>
<span class="pc bnc" id="L1529" title="All 2 branches missed.">				assert blossom.isMatched();</span>

<span class="fc" id="L1531">				Blossom prevPrev = prev.blossomGrandparent;</span>
				for (;;) {
					/* find the root penultimate blossom */
					Blossom k;
<span class="fc bfc" id="L1535" title="All 2 branches covered.">					if (blossom == blossom.match.source) {</span>
<span class="fc" id="L1536">						k = blossom.match.sourceOrig;</span>
<span class="fc bfc" id="L1537" title="All 2 branches covered.">					} else if (blossom == blossom.match.target) {</span>
<span class="fc" id="L1538">						k = blossom.match.targetOrig;</span>
					} else {
<span class="fc" id="L1540">						for (Blossom k1 = blossom.match.sourceOrig, k2 = blossom.match.targetOrig;; k1 =</span>
<span class="fc" id="L1541">								k1.blossomParent, k2 = k2.blossomParent) {</span>
<span class="fc bfc" id="L1542" title="All 2 branches covered.">							if (k1 == null) {</span>
<span class="fc" id="L1543">								k = k2;</span>
<span class="fc" id="L1544">								break;</span>
							}
<span class="fc bfc" id="L1546" title="All 2 branches covered.">							if (k2 == null) {</span>
<span class="fc" id="L1547">								k = k1;</span>
<span class="fc" id="L1548">								break;</span>
							}
<span class="fc bfc" id="L1550" title="All 2 branches covered.">							if (k1.blossomParent == blossom) {</span>
<span class="fc" id="L1551">								k = k1;</span>
<span class="fc" id="L1552">								break;</span>
							}
<span class="fc bfc" id="L1554" title="All 2 branches covered.">							if (k2.blossomParent == blossom) {</span>
<span class="fc" id="L1555">								k = k2;</span>
<span class="fc" id="L1556">								break;</span>
							}
						}
					}
<span class="fc bfc" id="L1560" title="All 2 branches covered.">					while (k.blossomParent != blossom)</span>
<span class="fc" id="L1561">						k = k.blossomParent;</span>

					/* propagate the matched edge of the blossom downwards */
<span class="fc" id="L1564">					k.match = blossom.match;</span>

<span class="fc bfc" id="L1566" title="All 2 branches covered.">					for (Blossom i = k.blossomSibling(); i != k;) {</span>
<span class="pc bnc" id="L1567" title="All 2 branches missed.">						assert i.blossomParent == k.blossomParent;</span>
<span class="fc" id="L1568">						i.match = i.blossomSibling;</span>
<span class="fc" id="L1569">						Blossom j = i.matchedNode();</span>
<span class="pc bnc" id="L1570" title="All 2 branches missed.">						assert j.blossomParent == k.blossomParent;</span>
<span class="fc" id="L1571">						j.match = i.match;</span>
<span class="fc" id="L1572">						i = j.blossomSibling();</span>
<span class="fc" id="L1573">					}</span>

<span class="fc" id="L1575">					blossom = prev;</span>
<span class="fc bfc" id="L1576" title="All 2 branches covered.">					if (!blossom.isBlossom())</span>
<span class="fc" id="L1577">						break;</span>
<span class="fc" id="L1578">					prev = prevPrev;</span>
<span class="fc" id="L1579">					prevPrev = prev.blossomGrandparent;</span>
<span class="fc" id="L1580">				}</span>

				// Blossom node = blossom.matchedNode();
				// node.setProcessed(true);
			}

<span class="fc" id="L1586">			final int n = g.vertices().size();</span>
<span class="fc" id="L1587">			int[] matched = new int[n];</span>
<span class="fc bfc" id="L1588" title="All 2 branches covered.">			for (int u = 0; u &lt; n; u++) {</span>
<span class="pc bnc" id="L1589" title="All 2 branches missed.">				assert singletonNodes[u].isMatched();</span>
<span class="fc" id="L1590">				matched[u] = singletonNodes[u].match.id;</span>
			}
<span class="fc" id="L1592">			return new Matchings.MatchingImpl(g, matched);</span>
		}

		private boolean updateDuals() {
<span class="fc" id="L1596">			dbgLog.format(&quot;updateDuals()\n&quot;);</span>
<span class="fc bfc" id="L1597" title="All 2 branches covered.">			for (Blossom root : roots()) {</span>
<span class="fc" id="L1598">				Tree tree = root.tree;</span>

<span class="fc" id="L1600">				double eps = Double.POSITIVE_INFINITY, epsOther;</span>
<span class="pc bpc" id="L1601" title="1 of 4 branches missed.">				if (tree.pqEvenOut.isNotEmpty() &amp;&amp; (epsOther = tree.pqEvenOut.findMin().key().slack) &lt; eps)</span>
<span class="fc" id="L1602">					eps = epsOther;</span>
<span class="fc bfc" id="L1603" title="All 4 branches covered.">				if (tree.pqOdd.isNotEmpty() &amp;&amp; (epsOther = tree.pqOdd.findMin().key().dual) &lt; eps)</span>
<span class="fc" id="L1604">					eps = epsOther;</span>
<span class="fc bfc" id="L1605" title="All 2 branches covered.">				while (tree.pqEvenEven.isNotEmpty()) {</span>
<span class="fc" id="L1606">					Edge minEdge = tree.pqEvenEven.findMin().key();</span>
<span class="fc bfc" id="L1607" title="All 2 branches covered.">					if (processEdgeEvenEven(minEdge, false)) {</span>
<span class="fc" id="L1608">						epsOther = minEdge.slack / 2;</span>
<span class="fc bfc" id="L1609" title="All 2 branches covered.">						if (epsOther &lt; eps)</span>
<span class="fc" id="L1610">							eps = epsOther;</span>
						break;
					}
<span class="fc" id="L1613">					tree.pqRemoveEvenEven(minEdge);</span>
<span class="fc" id="L1614">				}</span>
<span class="fc" id="L1615">				tree.epsDelta = eps - tree.eps;</span>
<span class="fc" id="L1616">			}</span>

			/*
			 * Although the paper suggest multiple approaches for dual updates, we use a single one, the connected
			 * components approach
			 */
<span class="fc" id="L1622">			updateDualsCC();</span>

<span class="fc" id="L1624">			double delta = 0;</span>
<span class="fc bfc" id="L1625" title="All 2 branches covered.">			for (Blossom root : roots()) {</span>
<span class="fc" id="L1626">				Tree tree = root.tree;</span>
<span class="fc bfc" id="L1627" title="All 2 branches covered.">				if (tree.epsDelta &gt; 0) {</span>
<span class="fc" id="L1628">					delta += tree.epsDelta;</span>
<span class="fc" id="L1629">					tree.eps += tree.epsDelta;</span>
				}
<span class="fc" id="L1631">			}</span>
<span class="fc bfc" id="L1632" title="All 2 branches covered.">			return delta &gt; eps; /* epsilon error */</span>
		}

		private void updateDualsCC() {
<span class="fc bfc" id="L1636" title="All 2 branches covered.">			for (Blossom root : roots())</span>
<span class="fc" id="L1637">				root.tree.bfsNext = null;</span>

			/* Perform a BFS on the trees, starting from different each time, until all trees are visited */
<span class="fc bfc" id="L1640" title="All 2 branches covered.">			for (Blossom root : roots()) {</span>
<span class="fc" id="L1641">				Tree tree = root.tree;</span>
<span class="fc bfc" id="L1642" title="All 2 branches covered.">				if (tree.bfsNext != null) /* isVisited */</span>
<span class="fc" id="L1643">					continue;</span>
<span class="fc" id="L1644">				double eps = tree.epsDelta;</span>

				/* Perform BFS to find all trees in the connected component */
				Tree bfsBegin, bfsHead, bfsTail;
<span class="fc" id="L1648">				bfsBegin = bfsHead = bfsTail = tree;</span>
<span class="fc" id="L1649">				bfsTail.bfsNext = bfsTail; /* mark tail */</span>
				for (;;) {
<span class="fc bfc" id="L1651" title="All 2 branches covered.">					for (TreesEdge e : bfsHead.outEdges()) {</span>
<span class="fc" id="L1652">						Tree currentTree = bfsHead;</span>
<span class="fc" id="L1653">						Tree otherTree = e.target;</span>

<span class="fc bfc" id="L1655" title="All 2 branches covered.">						double epsEvenEven = e.pqEvenEven.isEmpty() ? Double.POSITIVE_INFINITY</span>
<span class="fc" id="L1656">								: e.pqEvenEven.findMin().key().slack - currentTree.eps - otherTree.eps;</span>
<span class="fc bfc" id="L1657" title="All 4 branches covered.">						if (otherTree.bfsNext != null &amp;&amp; otherTree.bfsNext != BfsProcessed) { /* isInCurrentBfs */</span>
<span class="fc bfc" id="L1658" title="All 2 branches covered.">							if (2 * eps &gt; epsEvenEven)</span>
<span class="fc" id="L1659">								eps = epsEvenEven / 2;</span>
							continue;
						}

<span class="fc bfc" id="L1663" title="All 2 branches covered.">						double epsEvenOdd = e.pqEvenOdd.isEmpty() ? Double.POSITIVE_INFINITY</span>
<span class="fc" id="L1664">								: e.pqEvenOdd.findMin().key().slack - currentTree.eps + otherTree.eps;</span>
<span class="fc bfc" id="L1665" title="All 2 branches covered.">						double epsOddEven = e.pqOddEven.isEmpty() ? Double.POSITIVE_INFINITY</span>
<span class="fc" id="L1666">								: e.pqOddEven.findMin().key().slack - otherTree.eps + currentTree.eps;</span>

						double epsTarget;
<span class="fc bfc" id="L1669" title="All 2 branches covered.">						if (otherTree.bfsNext == BfsProcessed) {</span>
<span class="fc" id="L1670">							epsTarget = otherTree.epsDelta;</span>
<span class="fc bfc" id="L1671" title="All 4 branches covered.">						} else if (epsEvenOdd &gt; 0 &amp;&amp; epsOddEven &gt; 0) {</span>
<span class="fc" id="L1672">							epsTarget = 0;</span>
						} else {
							/* append target to BFS queue end */
<span class="fc" id="L1675">							bfsTail.bfsNext = otherTree;</span>
<span class="fc" id="L1676">							bfsTail = otherTree;</span>
<span class="fc" id="L1677">							bfsTail.bfsNext = bfsTail; /* mark tail */</span>

<span class="fc" id="L1679">							eps = Math.min(eps, epsEvenEven);</span>
<span class="fc" id="L1680">							eps = Math.min(eps, otherTree.epsDelta);</span>
<span class="fc" id="L1681">							continue;</span>
						}
<span class="fc" id="L1683">						eps = Math.min(eps, epsEvenEven - epsTarget);</span>
<span class="fc" id="L1684">						eps = Math.min(eps, epsTarget + epsEvenOdd);</span>
<span class="fc" id="L1685">					}</span>
<span class="fc bfc" id="L1686" title="All 2 branches covered.">					for (TreesEdge e : bfsHead.inEdges()) {</span>
<span class="fc" id="L1687">						Tree currentTree = bfsHead;</span>
<span class="fc" id="L1688">						Tree otherTree = e.source;</span>

<span class="fc bfc" id="L1690" title="All 2 branches covered.">						double epsEvenEven = e.pqEvenEven.isEmpty() ? Double.POSITIVE_INFINITY</span>
<span class="fc" id="L1691">								: e.pqEvenEven.findMin().key().slack - currentTree.eps - otherTree.eps;</span>
<span class="fc bfc" id="L1692" title="All 4 branches covered.">						if (otherTree.bfsNext != null &amp;&amp; otherTree.bfsNext != BfsProcessed) { /* isInCurrentBfs */</span>
<span class="fc bfc" id="L1693" title="All 2 branches covered.">							if (2 * eps &gt; epsEvenEven)</span>
<span class="fc" id="L1694">								eps = epsEvenEven / 2;</span>
							continue;
						}

<span class="fc bfc" id="L1698" title="All 2 branches covered.">						double epsOddEven = e.pqOddEven.isEmpty() ? Double.POSITIVE_INFINITY</span>
<span class="fc" id="L1699">								: e.pqOddEven.findMin().key().slack - currentTree.eps + otherTree.eps;</span>
<span class="fc bfc" id="L1700" title="All 2 branches covered.">						double epsEvenOdd = e.pqEvenOdd.isEmpty() ? Double.POSITIVE_INFINITY</span>
<span class="fc" id="L1701">								: e.pqEvenOdd.findMin().key().slack - otherTree.eps + currentTree.eps;</span>

						double epsTarget;
<span class="fc bfc" id="L1704" title="All 2 branches covered.">						if (otherTree.bfsNext == BfsProcessed) {</span>
<span class="fc" id="L1705">							epsTarget = otherTree.epsDelta;</span>
<span class="fc bfc" id="L1706" title="All 4 branches covered.">						} else if (epsEvenOdd &gt; 0 &amp;&amp; epsOddEven &gt; 0) {</span>
<span class="fc" id="L1707">							epsTarget = 0;</span>
						} else {
							/* append target to BFS queue end */
<span class="fc" id="L1710">							bfsTail.bfsNext = otherTree;</span>
<span class="fc" id="L1711">							bfsTail = otherTree;</span>
<span class="fc" id="L1712">							bfsTail.bfsNext = bfsTail; /* mark tail */</span>

<span class="fc" id="L1714">							eps = Math.min(eps, epsEvenEven);</span>
<span class="fc" id="L1715">							eps = Math.min(eps, otherTree.epsDelta);</span>
<span class="fc" id="L1716">							continue;</span>
						}
<span class="fc" id="L1718">						eps = Math.min(eps, epsEvenEven - epsTarget);</span>
<span class="fc" id="L1719">						eps = Math.min(eps, epsTarget + epsOddEven);</span>
<span class="fc" id="L1720">					}</span>

<span class="fc bfc" id="L1722" title="All 2 branches covered.">					if (bfsHead.bfsNext == bfsHead)</span>
<span class="fc" id="L1723">						break; /* end of BFS queue */</span>
<span class="fc" id="L1724">					bfsHead = bfsHead.bfsNext;</span>
				}

				/* Update dual for all trees in connected components */
<span class="fc" id="L1728">				for (Tree t = bfsBegin, tNext;; t = tNext) {</span>
<span class="fc" id="L1729">					t.epsDelta = eps;</span>
<span class="fc" id="L1730">					tNext = t.bfsNext;</span>
<span class="fc" id="L1731">					t.bfsNext = BfsProcessed; /* mark as processed */</span>
<span class="fc bfc" id="L1732" title="All 2 branches covered.">					if (t == tNext)</span>
<span class="fc" id="L1733">						break;</span>
				}
<span class="fc" id="L1735">			}</span>
<span class="fc" id="L1736">		}</span>

		private Iterable&lt;Blossom&gt; roots() {
<span class="fc" id="L1739">			return new Iterable&lt;&gt;() {</span>

				@Override
				public Iterator&lt;Blossom&gt; iterator() {
<span class="fc" id="L1743">					return new Iterator&lt;&gt;() {</span>
<span class="fc" id="L1744">						Blossom root = treeList.treeSiblingNext;</span>

						@Override
						public boolean hasNext() {
<span class="fc bfc" id="L1748" title="All 2 branches covered.">							return root != null;</span>
						}

						@Override
						public Blossom next() {
<span class="fc" id="L1753">							Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L1754">							Blossom ret = root;</span>
<span class="fc" id="L1755">							root = root.treeSiblingNext;</span>
<span class="fc" id="L1756">							return ret;</span>
						}
					};
				}
			};
		}

		private Iterable&lt;Blossom&gt; rootsDuringAugmentation() {
<span class="fc" id="L1764">			return new Iterable&lt;&gt;() {</span>

				@Override
				public Iterator&lt;Blossom&gt; iterator() {
<span class="fc" id="L1768">					return new Iterator&lt;&gt;() {</span>
<span class="fc" id="L1769">						Blossom next = treeList.treeSiblingNext;</span>
<span class="fc bfc" id="L1770" title="All 2 branches covered.">						Blossom nextNext = next == null ? null : next.treeSiblingNext;</span>

						@Override
						public boolean hasNext() {
<span class="fc bfc" id="L1774" title="All 4 branches covered.">							if (next != null &amp;&amp; next.isTreeRoot())</span>
<span class="fc" id="L1775">								return true;</span>
<span class="fc" id="L1776">							next = nextNext;</span>
<span class="fc" id="L1777">							nextNext = null;</span>
<span class="fc bfc" id="L1778" title="All 2 branches covered.">							return next != null;</span>
						}

						@Override
						public Blossom next() {
<span class="fc" id="L1783">							Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L1784">							Blossom ret = next;</span>
<span class="fc" id="L1785">							next = next.treeSiblingNext;</span>
<span class="fc bfc" id="L1786" title="All 2 branches covered.">							nextNext = next == null ? null : next.treeSiblingNext;</span>
<span class="fc" id="L1787">							return ret;</span>
						}
					};
				}
			};
		}

		private static void ensureTreesEdgeExists(Tree mainTree, Tree otherTree) {
<span class="pc bnc" id="L1795" title="All 2 branches missed.">			assert mainTree != otherTree;</span>
<span class="fc bfc" id="L1796" title="All 2 branches covered.">			if (otherTree.currentEdge == null) {</span>
<span class="fc" id="L1797">				TreesEdge e = new TreesEdge();</span>
<span class="fc" id="L1798">				e.source = mainTree;</span>
<span class="fc" id="L1799">				e.target = otherTree;</span>
<span class="fc" id="L1800">				e.nextOutEdge = mainTree.outEdges;</span>
<span class="fc" id="L1801">				mainTree.outEdges = e;</span>
<span class="fc" id="L1802">				e.nextInEdge = otherTree.inEdges;</span>
<span class="fc" id="L1803">				otherTree.inEdges = e;</span>
<span class="fc" id="L1804">				otherTree.currentEdge = e;</span>
			}
<span class="fc" id="L1806">		}</span>

		private static boolean processEdgeEvenEven(Edge e, boolean updateBoundaryEdge) {
			Blossom penultimateSource, penultimateTarget;
<span class="fc" id="L1810">			Blossom source = e.source, target = e.target;</span>
<span class="fc bfc" id="L1811" title="All 2 branches covered.">			if (!source.isOuter()) {</span>
<span class="fc" id="L1812">				penultimateSource = source.getPenultimateBlossom();</span>
<span class="fc" id="L1813">				source = penultimateSource.blossomParent;</span>
			} else {
<span class="fc" id="L1815">				penultimateSource = null;</span>
			}
<span class="fc bfc" id="L1817" title="All 2 branches covered.">			if (!target.isOuter()) {</span>
<span class="fc" id="L1818">				penultimateTarget = target.getPenultimateBlossom();</span>
<span class="fc" id="L1819">				target = penultimateTarget.blossomParent;</span>
			} else {
<span class="fc" id="L1821">				penultimateTarget = null;</span>
			}

<span class="fc bfc" id="L1824" title="All 2 branches covered.">			if (source != target) {</span>
<span class="fc bfc" id="L1825" title="All 2 branches covered.">				if (e.source != source)</span>
<span class="fc" id="L1826">					e.moveEdgeOut(e.source, source);</span>
<span class="fc bfc" id="L1827" title="All 2 branches covered.">				if (e.target != target)</span>
<span class="fc" id="L1828">					e.moveEdgeIn(e.target, target);</span>
<span class="fc bfc" id="L1829" title="All 2 branches covered.">				if (updateBoundaryEdge)</span>
<span class="fc" id="L1830">					e.slack -= 2 * source.tree.eps;</span>
<span class="fc" id="L1831">				return true;</span>
			}
<span class="fc bfc" id="L1833" title="All 2 branches covered.">			if (penultimateSource != penultimateTarget) {</span>
<span class="pc bnc" id="L1834" title="All 4 branches missed.">				assert penultimateSource != null &amp;&amp; penultimateTarget != null;</span>
<span class="fc bfc" id="L1835" title="All 2 branches covered.">				if (e.source != penultimateSource)</span>
<span class="fc" id="L1836">					e.moveEdgeOut(e.source, penultimateSource);</span>
<span class="fc bfc" id="L1837" title="All 2 branches covered.">				if (e.target != penultimateTarget)</span>
<span class="fc" id="L1838">					e.moveEdgeIn(e.target, penultimateTarget);</span>
<span class="fc bfc" id="L1839" title="All 2 branches covered.">				if (updateBoundaryEdge)</span>
<span class="fc" id="L1840">					e.slack -= 2 * penultimateSource.blossomEps;</span>
			} else {
<span class="fc" id="L1842">				e.source.removeEdgeOut(e);</span>
<span class="fc" id="L1843">				e.target.removeEdgeIn(e);</span>
<span class="fc" id="L1844">				e.nextOutEdge = penultimateSource.selfLoops;</span>
<span class="fc" id="L1845">				penultimateSource.selfLoops = e;</span>
			}
<span class="fc" id="L1847">			return false;</span>
		}

	}

	/**
	 * A blossom is either a vertex of a graph, or odd number of blossoms connected by alternating matched/unmatched
	 * edges.
	 *
	 * &lt;p&gt;
	 * Edges of the blossoms (originated from the original vertices) are stored using two linked lists: out-edges and
	 * in-edges. Whether an edge is out or in is arbitrary, but it helps to manage the undirected edges. When a blossom
	 * is created from a set of other blossoms, their edges are moved to the new super blossom, unless they are fully
	 * contained in the blossom, in which case they are stored in a separated 'self-loops' linked lists. When a blossom
	 * is expanded, its edges are moved back to the sub-blossoms, and self-loops edges are handled separately.
	 *
	 * @author Barak Ugav
	 */
	private static class Blossom {

		private static final byte EvenOddOutMask;
		private static final byte EvenOddOut_Even;
		private static final byte EvenOddOut_Odd;
		private static final byte EvenOddOut_Out;
		private static final byte ProcessedMask;
		private static final byte Processed_False;
		private static final byte Processed_True;
		private static final byte OuterMask;
		private static final byte Outer_False;
		private static final byte Outer_True;
		private static final byte IsBlossomMask;
		private static final byte IsBlossom_False;
		private static final byte IsBlossom_True;
		private static final byte MarkedMask;
		private static final byte Marked_False;
		private static final byte Marked_True;
		private static final byte IsTreeRootMask;
		private static final byte IsTreeRoot_False;
		private static final byte IsTreeRoot_True;

		static {
<span class="fc" id="L1888">			BitmapBuilder b = new BitmapBuilder(byte.class);</span>
			BitmapBuilder.Field f;

<span class="fc" id="L1891">			f = b.newField(2);</span>
<span class="fc" id="L1892">			EvenOddOutMask = (byte) f.mask;</span>
<span class="fc" id="L1893">			EvenOddOut_Even = (byte) (0 &lt;&lt; f.shift);</span>
<span class="fc" id="L1894">			EvenOddOut_Odd = (byte) (1 &lt;&lt; f.shift);</span>
<span class="fc" id="L1895">			EvenOddOut_Out = (byte) (2 &lt;&lt; f.shift);</span>
<span class="fc" id="L1896">			f = b.newField(1);</span>
<span class="fc" id="L1897">			ProcessedMask = (byte) f.mask;</span>
<span class="fc" id="L1898">			Processed_False = (byte) (0 &lt;&lt; f.shift);</span>
<span class="fc" id="L1899">			Processed_True = (byte) (1 &lt;&lt; f.shift);</span>
<span class="fc" id="L1900">			f = b.newField(1);</span>
<span class="fc" id="L1901">			OuterMask = (byte) f.mask;</span>
<span class="fc" id="L1902">			Outer_False = (byte) (0 &lt;&lt; f.shift);</span>
<span class="fc" id="L1903">			Outer_True = (byte) (1 &lt;&lt; f.shift);</span>
<span class="fc" id="L1904">			f = b.newField(1);</span>
<span class="fc" id="L1905">			IsBlossomMask = (byte) f.mask;</span>
<span class="fc" id="L1906">			IsBlossom_False = (byte) (0 &lt;&lt; f.shift);</span>
<span class="fc" id="L1907">			IsBlossom_True = (byte) (1 &lt;&lt; f.shift);</span>
<span class="fc" id="L1908">			f = b.newField(1);</span>
<span class="fc" id="L1909">			MarkedMask = (byte) f.mask;</span>
<span class="fc" id="L1910">			Marked_False = (byte) (0 &lt;&lt; f.shift);</span>
<span class="fc" id="L1911">			Marked_True = (byte) (1 &lt;&lt; f.shift);</span>
<span class="fc" id="L1912">			f = b.newField(1);</span>
<span class="fc" id="L1913">			IsTreeRootMask = (byte) f.mask;</span>
<span class="fc" id="L1914">			IsTreeRoot_False = (byte) (0 &lt;&lt; f.shift);</span>
<span class="fc" id="L1915">			IsTreeRoot_True = (byte) (1 &lt;&lt; f.shift);</span>
		}

<span class="fc" id="L1918">		private static class BitmapBuilder {</span>
			private int usedBits;
			private final int maxSize;

<span class="fc" id="L1922">			BitmapBuilder(Class&lt;?&gt; intType) {</span>
<span class="pc bpc" id="L1923" title="1 of 2 branches missed.">				if (intType == long.class) {</span>
<span class="nc" id="L1924">					maxSize = Long.SIZE;</span>
<span class="pc bpc" id="L1925" title="1 of 2 branches missed.">				} else if (intType == int.class) {</span>
<span class="nc" id="L1926">					maxSize = Integer.SIZE;</span>
<span class="pc bpc" id="L1927" title="1 of 2 branches missed.">				} else if (intType == short.class) {</span>
<span class="nc" id="L1928">					maxSize = Short.SIZE;</span>
<span class="pc bpc" id="L1929" title="1 of 2 branches missed.">				} else if (intType == byte.class) {</span>
<span class="fc" id="L1930">					maxSize = Byte.SIZE;</span>
				} else {
<span class="nc" id="L1932">					throw new IllegalArgumentException(&quot;unknown int type: &quot; + intType);</span>
				}
<span class="fc" id="L1934">			}</span>

			Field newField(int size) {
<span class="pc bnc" id="L1937" title="All 2 branches missed.">				assert usedBits + size &lt; maxSize;</span>
<span class="fc" id="L1938">				int shift = usedBits;</span>
<span class="fc" id="L1939">				int mask = ((1 &lt;&lt; size) - 1) &lt;&lt; shift;</span>
<span class="fc" id="L1940">				usedBits += size;</span>
<span class="fc" id="L1941">				return new Field(shift, mask);</span>
			}

			static class Field {
				final int shift;
				final int mask;

<span class="fc" id="L1948">				Field(int shift, int mask) {</span>
<span class="fc" id="L1949">					this.shift = shift;</span>
<span class="fc" id="L1950">					this.mask = mask;</span>

<span class="fc" id="L1952">				}</span>
			}
		}

		/* Flags bitmap */
		byte flags;

		/* The tree containing this blossom */
		Tree tree;
		/* current matched edge of the blossom */
		/* may no be updated if this blossom is not outer, will be updated in finish() */
		Edge match;

		/* circular bi-directional linked lists */
		Edge outEdges;
		Edge inEdges;
		/* One directional linked list (using the nextOut/prevOut) of self edges */
		/* a self edge is an edge that both its endpoints are contained in the blossom */
		Edge selfLoops;

		/*
		 * The tree constructed from even and odd blossoms is represented by child-parent connections between even
		 * blossoms only, as each odd blossom is matched to an even blossom it can be deduced. Each even blossom point
		 * to its first even child. The children of each blossom are connected in a bidirectional linked list, with out
		 * exception: {@code firstChild-&gt;prev-&gt;next == null}, or equivalently {@code last-&gt;next == null}.
		 */
		Blossom firstTreeChild;
		Blossom treeSiblingNext;
		Blossom treeSiblingPrev;

		/* The blossom parent containing this blossom, used for non-outer blossoms */
		Blossom blossomParent;
		/* The edge connecting a blossom to its sibling, both contained as children in some other blossom */
		Edge blossomSibling;
		/* Helper pointer used to determine fast the outer blossom of a vertex/blossom */
		Blossom blossomGrandparent;

		/* Edge connecting a odd - blossom to its parent */
		Edge treeParentEdge;

		/* The dual value of this blossom/vertex */
		double dual;
		/* Temporary change in the dual value of this blossom, used dual updates */
		double blossomEps;

		/* Reference to the expand element in the PQ, used for odd non-singleton blossoms */
		ObjReferenceableHeap.Ref&lt;Blossom&gt; expandRef;

		/* Comparator that compare the dual value of blossoms, used for expand PQ */
<span class="fc" id="L2001">		static final Comparator&lt;Blossom&gt; dualComparator = (b1, b2) -&gt; Double.compare(b1.dual, b2.dual);</span>

<span class="fc" id="L2003">		Blossom() {</span>
<span class="fc" id="L2004">			flags = EvenOddOut_Out;</span>
<span class="fc" id="L2005">		}</span>

		boolean isEven() {
<span class="fc bfc" id="L2008" title="All 2 branches covered.">			return (flags &amp; EvenOddOutMask) == EvenOddOut_Even;</span>
		}

		boolean isOdd() {
<span class="fc bfc" id="L2012" title="All 2 branches covered.">			return (flags &amp; EvenOddOutMask) == EvenOddOut_Odd;</span>
		}

		boolean isOut() {
<span class="fc bfc" id="L2016" title="All 2 branches covered.">			return (flags &amp; EvenOddOutMask) == EvenOddOut_Out;</span>
		}

		void setEven() {
<span class="fc" id="L2020">			flags = (byte) ((flags &amp; ~EvenOddOutMask) | EvenOddOut_Even);</span>
<span class="fc" id="L2021">		}</span>

		void setOdd() {
<span class="fc" id="L2024">			flags = (byte) ((flags &amp; ~EvenOddOutMask) | EvenOddOut_Odd);</span>
<span class="fc" id="L2025">		}</span>

		void setOut() {
<span class="fc" id="L2028">			flags = (byte) ((flags &amp; ~EvenOddOutMask) | EvenOddOut_Out);</span>
<span class="fc" id="L2029">		}</span>

		boolean isOuter() {
<span class="fc bfc" id="L2032" title="All 2 branches covered.">			return (flags &amp; OuterMask) == Outer_True;</span>
		}

		void setOuter(boolean isOuter) {
<span class="fc bfc" id="L2036" title="All 2 branches covered.">			flags = (byte) ((flags &amp; ~OuterMask) | (isOuter ? Outer_True : Outer_False));</span>
<span class="fc" id="L2037">		}</span>

		boolean isBlossom() {
<span class="fc bfc" id="L2040" title="All 2 branches covered.">			return (flags &amp; IsBlossomMask) == IsBlossom_True;</span>
		}

		void setIsBlossom(boolean isBlossom) {
<span class="pc bpc" id="L2044" title="1 of 2 branches missed.">			flags = (byte) ((flags &amp; ~IsBlossomMask) | (isBlossom ? IsBlossom_True : IsBlossom_False));</span>
<span class="fc" id="L2045">		}</span>

		boolean isProcessed() {
<span class="fc bfc" id="L2048" title="All 2 branches covered.">			return (flags &amp; ProcessedMask) == Processed_True;</span>
		}

		void setProcessed(boolean processed) {
<span class="fc bfc" id="L2052" title="All 2 branches covered.">			flags = (byte) ((flags &amp; ~ProcessedMask) | (processed ? Processed_True : Processed_False));</span>
<span class="fc" id="L2053">		}</span>

		boolean isMarked() {
<span class="fc bfc" id="L2056" title="All 2 branches covered.">			return (flags &amp; MarkedMask) == Marked_True;</span>
		}

		void setMarked(boolean marked) {
<span class="fc bfc" id="L2060" title="All 2 branches covered.">			flags = (byte) ((flags &amp; ~MarkedMask) | (marked ? Marked_True : Marked_False));</span>
<span class="fc" id="L2061">		}</span>

		boolean isTreeRoot() {
<span class="fc bfc" id="L2064" title="All 2 branches covered.">			return (flags &amp; IsTreeRootMask) == IsTreeRoot_True;</span>
		}

		void setIsTreeRoot(boolean isTreeRoot) {
<span class="fc bfc" id="L2068" title="All 2 branches covered.">			flags = (byte) ((flags &amp; ~IsTreeRootMask) | (isTreeRoot ? IsTreeRoot_True : IsTreeRoot_False));</span>
<span class="fc" id="L2069">		}</span>

		boolean isMatched() {
<span class="fc bfc" id="L2072" title="All 2 branches covered.">			return match != null;</span>
		}

		Blossom matchedNode() {
<span class="fc" id="L2076">			return match.getOtherEndpoint(this);</span>
		}

		Blossom blossomSibling() {
<span class="fc" id="L2080">			return blossomSibling.getOtherEndpoint(this);</span>
		}

		Blossom getTreeParent() {
<span class="fc bfc" id="L2084" title="All 2 branches covered.">			if (this == treeParentEdge.source) {</span>
<span class="fc" id="L2085">				return treeParentEdge.getTargetOuterBlossom();</span>
			} else {
<span class="pc bnc" id="L2087" title="All 2 branches missed.">				assert this == treeParentEdge.target;</span>
<span class="fc" id="L2088">				return treeParentEdge.getSourceOuterBlossom();</span>
			}
		}

		private Blossom getPenultimateBlossom() {
<span class="fc" id="L2093">			Blossom b = this;</span>
			for (;;) {
<span class="fc bfc" id="L2095" title="All 2 branches covered.">				if (!b.blossomGrandparent.isOuter()) {</span>
<span class="fc" id="L2096">					b = b.blossomGrandparent;</span>
<span class="fc bfc" id="L2097" title="All 2 branches covered.">				} else if (b.blossomGrandparent != b.blossomParent) {</span>
<span class="fc" id="L2098">					b.blossomGrandparent = b.blossomParent;</span>
				} else {
					break;
				}
			}
<span class="fc bfc" id="L2103" title="All 2 branches covered.">			for (Blossom p = this, next; p != b; p = next) {</span>
<span class="fc" id="L2104">				next = p.blossomGrandparent;</span>
<span class="fc" id="L2105">				p.blossomGrandparent = b;</span>
			}
<span class="fc" id="L2107">			return b;</span>
		}

		private Blossom getPenultimateBlossomAndUpdateGrandparentToGrandchild() {
<span class="fc" id="L2111">			Blossom b = this;</span>
<span class="fc" id="L2112">			Blossom prev = null;</span>
			for (;;) {
<span class="fc bfc" id="L2114" title="All 2 branches covered.">				if (!b.blossomGrandparent.isOuter()) {</span>
<span class="fc" id="L2115">					b = (prev = b).blossomGrandparent;</span>
<span class="pc bpc" id="L2116" title="1 of 2 branches missed.">				} else if (b.blossomGrandparent != b.blossomParent) {</span>
<span class="nc" id="L2117">					b.blossomGrandparent = b.blossomParent;</span>
				} else {
					break;
				}
			}
<span class="fc bfc" id="L2122" title="All 2 branches covered.">			if (prev != null) {</span>
<span class="fc bfc" id="L2123" title="All 2 branches covered.">				for (Blossom p = this, next; p != prev; p = next) {</span>
<span class="fc" id="L2124">					next = p.blossomGrandparent;</span>
<span class="fc" id="L2125">					p.blossomGrandparent = prev;</span>
				}
			}
<span class="fc" id="L2128">			return b;</span>
		}

		private void addEdgeOut(Edge e) {
<span class="pc bnc" id="L2132" title="All 4 branches missed.">			assert e.nextOutEdge == null &amp;&amp; e.prevOutEdge == null;</span>
<span class="fc bfc" id="L2133" title="All 2 branches covered.">			if (outEdges != null) {</span>
<span class="fc" id="L2134">				e.prevOutEdge = outEdges.prevOutEdge;</span>
<span class="fc" id="L2135">				e.nextOutEdge = outEdges;</span>
<span class="fc" id="L2136">				outEdges.prevOutEdge.nextOutEdge = e;</span>
<span class="fc" id="L2137">				outEdges.prevOutEdge = e;</span>
			} else {
<span class="fc" id="L2139">				outEdges = e.prevOutEdge = e.nextOutEdge = e;</span>
			}
<span class="fc" id="L2141">			e.source = this;</span>
<span class="fc" id="L2142">		}</span>

		private void addEdgeIn(Edge e) {
<span class="pc bnc" id="L2145" title="All 4 branches missed.">			assert e.nextInEdge == null &amp;&amp; e.prevInEdge == null;</span>
<span class="fc bfc" id="L2146" title="All 2 branches covered.">			if (inEdges != null) {</span>
<span class="fc" id="L2147">				e.prevInEdge = inEdges.prevInEdge;</span>
<span class="fc" id="L2148">				e.nextInEdge = inEdges;</span>
<span class="fc" id="L2149">				inEdges.prevInEdge.nextInEdge = e;</span>
<span class="fc" id="L2150">				inEdges.prevInEdge = e;</span>
			} else {
<span class="fc" id="L2152">				inEdges = e.prevInEdge = e.nextInEdge = e;</span>
			}
<span class="fc" id="L2154">			e.target = this;</span>
<span class="fc" id="L2155">		}</span>

		private void removeEdgeOut(Edge e) {
<span class="pc bnc" id="L2158" title="All 2 branches missed.">			assert e.source == this;</span>
<span class="fc bfc" id="L2159" title="All 2 branches covered.">			if (e.prevOutEdge == e) {</span>
<span class="pc bnc" id="L2160" title="All 2 branches missed.">				assert outEdges == e;</span>
<span class="fc" id="L2161">				outEdges = null;</span>
			} else {
<span class="fc" id="L2163">				e.prevOutEdge.nextOutEdge = e.nextOutEdge;</span>
<span class="fc" id="L2164">				e.nextOutEdge.prevOutEdge = e.prevOutEdge;</span>
<span class="fc" id="L2165">				outEdges = e.nextOutEdge;</span>
			}
<span class="fc" id="L2167">			e.nextOutEdge = e.prevOutEdge = null;</span>
<span class="fc" id="L2168">		}</span>

		private void removeEdgeIn(Edge e) {
<span class="pc bnc" id="L2171" title="All 2 branches missed.">			assert e.target == this;</span>
<span class="fc bfc" id="L2172" title="All 2 branches covered.">			if (e.prevInEdge == e) {</span>
<span class="pc bnc" id="L2173" title="All 2 branches missed.">				assert inEdges == e;</span>
<span class="fc" id="L2174">				inEdges = null;</span>
			} else {
<span class="fc" id="L2176">				e.prevInEdge.nextInEdge = e.nextInEdge;</span>
<span class="fc" id="L2177">				e.nextInEdge.prevInEdge = e.prevInEdge;</span>
<span class="fc" id="L2178">				inEdges = e.nextInEdge;</span>
			}
<span class="fc" id="L2180">			e.nextInEdge = e.prevInEdge = null;</span>
<span class="fc" id="L2181">		}</span>

		Iterable&lt;Edge&gt; outEdges() {
<span class="fc" id="L2184">			return new Iterable&lt;&gt;() {</span>

				@Override
				public Iterator&lt;Edge&gt; iterator() {
<span class="fc" id="L2188">					return new Iterator&lt;&gt;() {</span>
<span class="fc" id="L2189">						Edge current = null;</span>
<span class="fc" id="L2190">						Edge nextEdge = outEdges;</span>

						@Override
						public boolean hasNext() {
<span class="fc bfc" id="L2194" title="All 2 branches covered.">							return nextEdge != null;</span>
						}

						@Override
						public Edge next() {
<span class="fc" id="L2199">							Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L2200">							current = nextEdge;</span>
<span class="fc" id="L2201">							nextEdge = nextEdge.nextOutEdge;</span>
							/* outEdges is a circular list of edges */
<span class="fc bfc" id="L2203" title="All 2 branches covered.">							if (nextEdge == outEdges)</span>
<span class="fc" id="L2204">								nextEdge = null;</span>
<span class="fc" id="L2205">							return current;</span>
						}

						@Override
						public void remove() {
<span class="pc bpc" id="L2210" title="1 of 2 branches missed.">							if (current == null)</span>
<span class="nc" id="L2211">								throw new IllegalStateException();</span>

<span class="fc bfc" id="L2213" title="All 2 branches covered.">							if (outEdges != current) {</span>
<span class="fc" id="L2214">								Edge prev = current.prevOutEdge, next = current.nextOutEdge;</span>
<span class="pc bnc" id="L2215" title="All 4 branches missed.">								assert prev != current &amp;&amp; next != current;</span>
<span class="fc" id="L2216">								prev.nextOutEdge = next;</span>
<span class="fc" id="L2217">								next.prevOutEdge = prev;</span>
<span class="fc" id="L2218">							} else {</span>
<span class="fc" id="L2219">								outEdges = nextEdge;</span>
<span class="fc bfc" id="L2220" title="All 2 branches covered.">								if (nextEdge != null) {</span>
<span class="fc" id="L2221">									Edge prev = current.prevOutEdge;</span>
<span class="fc" id="L2222">									prev.nextOutEdge = nextEdge;</span>
<span class="fc" id="L2223">									nextEdge.prevOutEdge = prev;</span>
								}
							}

<span class="fc" id="L2227">							current = current.nextOutEdge = current.prevOutEdge = null;</span>
<span class="fc" id="L2228">						}</span>
					};
				}
			};
		}

		Iterable&lt;Edge&gt; inEdges() {
<span class="fc" id="L2235">			return new Iterable&lt;&gt;() {</span>

				@Override
				public Iterator&lt;Edge&gt; iterator() {
<span class="fc" id="L2239">					return new Iterator&lt;&gt;() {</span>
<span class="fc" id="L2240">						Edge current = null;</span>
<span class="fc" id="L2241">						Edge nextEdge = inEdges;</span>

						@Override
						public boolean hasNext() {
<span class="fc bfc" id="L2245" title="All 2 branches covered.">							return nextEdge != null;</span>
						}

						@Override
						public Edge next() {
<span class="fc" id="L2250">							Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L2251">							current = nextEdge;</span>
<span class="fc" id="L2252">							nextEdge = nextEdge.nextInEdge;</span>
							/* inEdges is a circular list of edges */
<span class="fc bfc" id="L2254" title="All 2 branches covered.">							if (nextEdge == inEdges)</span>
<span class="fc" id="L2255">								nextEdge = null;</span>
<span class="fc" id="L2256">							return current;</span>
						}

						@Override
						public void remove() {
<span class="pc bpc" id="L2261" title="1 of 2 branches missed.">							if (current == null)</span>
<span class="nc" id="L2262">								throw new IllegalStateException();</span>

<span class="fc bfc" id="L2264" title="All 2 branches covered.">							if (inEdges != current) {</span>
<span class="fc" id="L2265">								Edge prev = current.prevInEdge, next = current.nextInEdge;</span>
<span class="pc bnc" id="L2266" title="All 4 branches missed.">								assert prev != current &amp;&amp; next != current;</span>
<span class="fc" id="L2267">								prev.nextInEdge = next;</span>
<span class="fc" id="L2268">								next.prevInEdge = prev;</span>
<span class="fc" id="L2269">							} else {</span>
<span class="fc" id="L2270">								inEdges = nextEdge;</span>
<span class="fc bfc" id="L2271" title="All 2 branches covered.">								if (nextEdge != null) {</span>
<span class="fc" id="L2272">									Edge prev = current.prevInEdge;</span>
<span class="fc" id="L2273">									prev.nextInEdge = nextEdge;</span>
<span class="fc" id="L2274">									nextEdge.prevInEdge = prev;</span>
								}
							}

<span class="fc" id="L2278">							current = current.nextInEdge = current.prevInEdge = null;</span>
<span class="fc" id="L2279">						}</span>
					};
				}
			};
		}

		@Override
		public String toString() {
<span class="nc bnc" id="L2287" title="All 6 branches missed.">			String b = isBlossom() ? (isOuter() ? &quot;B&quot; : &quot;b&quot;) : (isOuter() ? &quot;V&quot; : &quot;v&quot;);</span>
<span class="nc" id="L2288">			String id = Debug.blossomId(this);</span>
<span class="nc bnc" id="L2289" title="All 4 branches missed.">			String parity = isEven() ? &quot;+&quot; : (isOdd() ? &quot;-&quot; : &quot;x&quot;);</span>
<span class="nc bnc" id="L2290" title="All 2 branches missed.">			String root = isTreeRoot() ? &quot;r&quot; : &quot;&quot;;</span>
<span class="nc" id="L2291">			return String.format(&quot;%s%s%s%s&quot;, root, b, id, parity);</span>
		}
	}

	/**
	 * A edge between two blossoms.
	 *
	 * &lt;p&gt;
	 * During init, an Edge object is created for each edge in the original graph, connecting two singleton blossoms
	 * corresponding to the original vertices endpoints of the edge. When a blossom is created from a set of blossoms,
	 * edges are moved to the new super blossom. When a blossom is expanded, its edges are moved back to the
	 * sub-blossom.
	 *
	 * &lt;p&gt;
	 * Each edge is contained in out-edges linked list of its source and in-edges linked list of its target.
	 *
	 * @author Barak Ugav
	 */
	private static class Edge {
		/* The input graph id of the edge */
		final int id;
		/* The endpoints of the edge */
		/* When a blossom is created from a set of blossoms, edges are moved to the new super blossom */
		/* When a blossom is expanded, its edges are moved back to the sub-blossom */
		Blossom source, target;
		/* The original endpoints of the edge */
		final Blossom sourceOrig, targetOrig;

		/* Each edge is contained in out-edges linked list of source and in-edges linked list of target */
		/* next edge in the out-edges linked list */
		Edge nextOutEdge;
		/* prev edge in the out-edges linked list */
		Edge prevOutEdge;
		/* next edge in the in-edges linked list */
		Edge nextInEdge;
		/* prev edge in the in-edges linked list */
		Edge prevInEdge;

		/* The slack of the edge. An edge is called tight if its slack is zero */
		/* The slack is defined as 2*w(e)-dual(source)-dual(target) */
		/* The alternating tree is composed of tight edges */
		double slack;

		// ObjReferenceableHeap.Ref&lt;Edge&gt; pqEvenEvenRef;
		// ObjReferenceableHeap.Ref&lt;Edge&gt; pqEvenOddRef;
		// ObjReferenceableHeap.Ref&lt;Edge&gt; pqEvenOutRef;
		/* Reference to either to the PQ containing this edge */
		ObjReferenceableHeap.Ref&lt;Edge&gt; pqRef;

<span class="fc" id="L2340">		static final Comparator&lt;Edge&gt; slackComparator = (e1, e2) -&gt; Double.compare(e1.slack, e2.slack);</span>

<span class="fc" id="L2342">		Edge(int id, Blossom source, Blossom target) {</span>
<span class="pc bnc" id="L2343" title="All 2 branches missed.">			assert !source.isBlossom();</span>
<span class="pc bnc" id="L2344" title="All 2 branches missed.">			assert !target.isBlossom();</span>
<span class="fc" id="L2345">			this.id = id;</span>
<span class="fc" id="L2346">			this.source = sourceOrig = Objects.requireNonNull(source);</span>
<span class="fc" id="L2347">			this.target = targetOrig = Objects.requireNonNull(target);</span>
<span class="fc" id="L2348">		}</span>

		Blossom getOtherEndpoint(Blossom b) {
<span class="fc bfc" id="L2351" title="All 2 branches covered.">			if (b == source) {</span>
<span class="fc" id="L2352">				return target;</span>
			} else {
<span class="pc bnc" id="L2354" title="All 2 branches missed.">				assert b == target;</span>
<span class="fc" id="L2355">				return source;</span>
			}
		}

		Blossom getEndpointOrig(Blossom b) {
<span class="fc bfc" id="L2360" title="All 2 branches covered.">			if (b == source) {</span>
<span class="fc" id="L2361">				return sourceOrig;</span>
			} else {
<span class="pc bnc" id="L2363" title="All 2 branches missed.">				assert b == target;</span>
<span class="fc" id="L2364">				return targetOrig;</span>
			}
		}

		private void moveEdge(Blossom oldNode, Blossom newNode) {
<span class="fc bfc" id="L2369" title="All 2 branches covered.">			if (oldNode == source) {</span>
<span class="fc" id="L2370">				moveEdgeOut(oldNode, newNode);</span>
			} else {
<span class="pc bnc" id="L2372" title="All 2 branches missed.">				assert oldNode == target;</span>
<span class="fc" id="L2373">				moveEdgeIn(oldNode, newNode);</span>
			}
<span class="fc" id="L2375">		}</span>

		private void moveEdgeOut(Blossom oldSource, Blossom newSource) {
<span class="fc" id="L2378">			oldSource.removeEdgeOut(this);</span>
<span class="fc" id="L2379">			newSource.addEdgeOut(this);</span>
<span class="fc" id="L2380">		}</span>

		private void moveEdgeIn(Blossom oldTarget, Blossom newTarget) {
<span class="fc" id="L2383">			oldTarget.removeEdgeIn(this);</span>
<span class="fc" id="L2384">			newTarget.addEdgeIn(this);</span>
<span class="fc" id="L2385">		}</span>

		private Blossom getSourceOuterBlossom() {
<span class="fc" id="L2388">			Blossom b = source;</span>
<span class="fc bfc" id="L2389" title="All 2 branches covered.">			if (!b.isOuter()) {</span>
<span class="fc" id="L2390">				Blossom bOrig = b;</span>
<span class="fc" id="L2391">				b = b.getPenultimateBlossom().blossomParent;</span>
<span class="fc" id="L2392">				moveEdgeOut(bOrig, b);</span>
			}
<span class="fc" id="L2394">			return b;</span>
		}

		private Blossom getTargetOuterBlossom() {
<span class="fc" id="L2398">			Blossom b = target;</span>
<span class="fc bfc" id="L2399" title="All 2 branches covered.">			if (!b.isOuter()) {</span>
<span class="fc" id="L2400">				Blossom bOrig = b;</span>
<span class="fc" id="L2401">				b = b.getPenultimateBlossom().blossomParent;</span>
<span class="fc" id="L2402">				moveEdgeIn(bOrig, b);</span>
			}
<span class="fc" id="L2404">			return b;</span>
		}

		@SuppressWarnings(&quot;boxing&quot;)
		@Override
		public String toString() {
<span class="nc" id="L2410">			return String.format(&quot;(%s, %s, %s)&quot;, source, target, slack);</span>
		}
	}

<span class="fc" id="L2414">	private static class Tree {</span>
		/* The unmatched root blossom of the tree */
		Blossom root;

		/* PQ containing all (+,+) edges between two even blossoms in this tree, by their slack */
<span class="fc" id="L2419">		final ObjReferenceableHeap&lt;Edge&gt; pqEvenEven = ObjReferenceableHeap.newInstance(Edge.slackComparator);</span>
		/* PQ containing all (+,-) edges between even blossom in this tree to out blossoms, by their slack */
<span class="fc" id="L2421">		final ObjReferenceableHeap&lt;Edge&gt; pqEvenOut = ObjReferenceableHeap.newInstance(Edge.slackComparator);</span>
		/* PQ containing all odd non-singleton blossoms of this tree, by their expand dual value */
<span class="fc" id="L2423">		final ObjReferenceableHeap&lt;Blossom&gt; pqOdd = ObjReferenceableHeap.newInstance(Blossom.dualComparator);</span>

		/*
		 * Dual value implicitly added to all even blossoms and removed from all odd blossoms. We want to change the
		 * dual values of the tree blossoms while maintaining the tightness of the edges, so we increase it to all even
		 * blossoms and decrease it to all odd blossoms. Updating this explicitly is too expensive, so we do so
		 * implicitly by storing the eps for each tree.
		 */
		double eps;

		/* Linked lists of out and in trees-edges */
		TreesEdge outEdges, inEdges;
		TreesEdge currentEdge;

		/* change of eps during dual updates */
		double epsDelta;
		/* used during dual updates */
		Tree bfsNext;

<span class="fc" id="L2442">		Tree(Blossom root) {</span>
<span class="fc" id="L2443">			this.root = root;</span>
<span class="fc" id="L2444">		}</span>

		void clear() {
<span class="fc" id="L2447">			root = null;</span>
<span class="fc" id="L2448">			currentEdge = null;</span>
<span class="fc" id="L2449">			outEdges = inEdges = null;</span>
<span class="fc" id="L2450">			bfsNext = null;</span>
<span class="fc" id="L2451">		}</span>

		Iterable&lt;TreesEdge&gt; outEdges() {
<span class="fc" id="L2454">			return new Iterable&lt;&gt;() {</span>

				@Override
				public Iterator&lt;TreesEdge&gt; iterator() {
<span class="fc" id="L2458">					return new Iterator&lt;&gt;() {</span>
<span class="fc" id="L2459">						TreesEdge nextEdge = outEdges;</span>

						@Override
						public boolean hasNext() {
<span class="fc bfc" id="L2463" title="All 2 branches covered.">							return nextEdge != null;</span>
						}

						@Override
						public TreesEdge next() {
<span class="fc" id="L2468">							Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L2469">							TreesEdge ret = nextEdge;</span>
<span class="fc" id="L2470">							nextEdge = nextEdge.nextOutEdge;</span>
<span class="fc" id="L2471">							return ret;</span>
						}
					};
				}
			};
		}

		Iterable&lt;TreesEdge&gt; inEdges() {
<span class="fc" id="L2479">			return new Iterable&lt;&gt;() {</span>

				@Override
				public Iterator&lt;TreesEdge&gt; iterator() {
<span class="fc" id="L2483">					return new Iterator&lt;&gt;() {</span>
<span class="fc" id="L2484">						TreesEdge nextEdge = inEdges;</span>

						@Override
						public boolean hasNext() {
<span class="fc bfc" id="L2488" title="All 2 branches covered.">							return nextEdge != null;</span>
						}

						@Override
						public TreesEdge next() {
<span class="fc" id="L2493">							Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L2494">							TreesEdge ret = nextEdge;</span>
<span class="fc" id="L2495">							nextEdge = nextEdge.nextInEdge;</span>
<span class="fc" id="L2496">							return ret;</span>
						}
					};
				}
			};
		}

		Iterable&lt;TreesEdge&gt; outEdgesAndProneRemoved() {
<span class="fc" id="L2504">			return new Iterable&lt;&gt;() {</span>

				@Override
				public Iterator&lt;TreesEdge&gt; iterator() {
<span class="fc" id="L2508">					return new Iterator&lt;&gt;() {</span>
<span class="fc" id="L2509">						TreesEdge nextEdge = outEdges;</span>
<span class="fc" id="L2510">						TreesEdge prev = null;</span>

						{
<span class="fc" id="L2513">							advance();</span>
<span class="fc" id="L2514">						}</span>

						private void advance() {
<span class="fc bfc" id="L2517" title="All 4 branches covered.">							while (nextEdge != null &amp;&amp; nextEdge.target == null) {</span>
								/* marked for removal */
<span class="fc" id="L2519">								nextEdge = nextEdge.nextOutEdge;</span>
<span class="fc bfc" id="L2520" title="All 2 branches covered.">								if (prev == null) {</span>
<span class="fc" id="L2521">									outEdges = nextEdge;</span>
								} else {
<span class="fc" id="L2523">									prev.nextOutEdge = nextEdge;</span>
								}
							}
<span class="fc" id="L2526">						}</span>

						@Override
						public boolean hasNext() {
<span class="fc bfc" id="L2530" title="All 2 branches covered.">							return nextEdge != null;</span>
						}

						@Override
						public TreesEdge next() {
<span class="fc" id="L2535">							Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L2536">							prev = nextEdge;</span>
<span class="fc" id="L2537">							nextEdge = nextEdge.nextOutEdge;</span>
<span class="fc" id="L2538">							advance();</span>

<span class="pc bnc" id="L2540" title="All 2 branches missed.">							assert prev.source != null;</span>
<span class="pc bnc" id="L2541" title="All 2 branches missed.">							assert prev.target != null;</span>
<span class="fc" id="L2542">							return prev;</span>
						}
					};
				}
			};
		}

		Iterable&lt;TreesEdge&gt; inEdgesAndProneRemoved() {
<span class="fc" id="L2550">			return new Iterable&lt;&gt;() {</span>

				@Override
				public Iterator&lt;TreesEdge&gt; iterator() {
<span class="fc" id="L2554">					return new Iterator&lt;&gt;() {</span>
<span class="fc" id="L2555">						TreesEdge nextEdge = inEdges;</span>
<span class="fc" id="L2556">						TreesEdge prev = null;</span>

						{
<span class="fc" id="L2559">							advance();</span>
<span class="fc" id="L2560">						}</span>

						private void advance() {
<span class="fc bfc" id="L2563" title="All 4 branches covered.">							while (nextEdge != null &amp;&amp; nextEdge.source == null) {</span>
								/* marked for removal */
<span class="fc" id="L2565">								nextEdge = nextEdge.nextInEdge;</span>
<span class="fc bfc" id="L2566" title="All 2 branches covered.">								if (prev == null) {</span>
<span class="fc" id="L2567">									inEdges = nextEdge;</span>
								} else {
<span class="fc" id="L2569">									prev.nextInEdge = nextEdge;</span>
								}
							}
<span class="fc" id="L2572">						}</span>

						@Override
						public boolean hasNext() {
<span class="fc bfc" id="L2576" title="All 2 branches covered.">							return nextEdge != null;</span>
						}

						@Override
						public TreesEdge next() {
<span class="fc" id="L2581">							Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L2582">							prev = nextEdge;</span>
<span class="fc" id="L2583">							nextEdge = nextEdge.nextInEdge;</span>
<span class="fc" id="L2584">							advance();</span>

<span class="pc bnc" id="L2586" title="All 2 branches missed.">							assert prev.source != null;</span>
<span class="pc bnc" id="L2587" title="All 2 branches missed.">							assert prev.target != null;</span>
<span class="fc" id="L2588">							return prev;</span>
						}
					};
				}
			};
		}

		Iterable&lt;Blossom&gt; evenNodesWithoutRoot() {
<span class="fc" id="L2596">			return new Iterable&lt;&gt;() {</span>

				@Override
				public Iterator&lt;Blossom&gt; iterator() {
<span class="fc" id="L2600">					return new Iterator&lt;&gt;() {</span>

<span class="fc" id="L2602">						Blossom b = root.firstTreeChild; /* skip root */</span>

						@Override
						public boolean hasNext() {
<span class="fc bfc" id="L2606" title="All 2 branches covered.">							return b != null;</span>
						}

						@Override
						public Blossom next() {
<span class="fc" id="L2611">							Assertions.Iters.hasNext(this);</span>
<span class="fc" id="L2612">							Blossom ret = b;</span>

							/* firstTreeChild points only to even children two levels down, skipping odd nodes */
<span class="fc bfc" id="L2615" title="All 2 branches covered.">							if (b.firstTreeChild != null) {</span>
								/* Go down */
<span class="fc" id="L2617">								b = b.firstTreeChild;</span>
							} else {
								for (;;) {
<span class="fc bfc" id="L2620" title="All 2 branches covered.">									if (b.isTreeRoot()) {</span>
										/* Done */
<span class="pc bnc" id="L2622" title="All 2 branches missed.">										assert b.isEven();</span>
<span class="fc" id="L2623">										b = null;</span>
<span class="fc" id="L2624">										break;</span>
									}
<span class="fc bfc" id="L2626" title="All 2 branches covered.">									if (b.treeSiblingNext != null) {</span>
										/* Go side */
<span class="fc" id="L2628">										b = b.treeSiblingNext;</span>
<span class="fc" id="L2629">										break;</span>
									}
									/* To up (2) */
									// assert b.isEven(); // this way fail when we deconstruct a tree
<span class="fc" id="L2633">									b = b.matchedNode();</span>
									// assert b.isOdd(); // this way fail when we deconstruct a tree
<span class="fc" id="L2635">									b = b.getTreeParent();</span>
									// assert b.isEven(); // this way fail when we deconstruct a tree
								}
							}

<span class="pc bnc" id="L2640" title="All 2 branches missed.">							assert ret.isEven();</span>
<span class="pc bnc" id="L2641" title="All 2 branches missed.">							assert ret.isOuter();</span>
<span class="pc bnc" id="L2642" title="All 2 branches missed.">							assert ret.tree == Tree.this;</span>
<span class="fc" id="L2643">							return ret;</span>
						}
					};
				}
			};
		}

		private void pqInsertEvenOut(Edge edge) {
			// assert edge.pqEvenEvenRef == null;
			// assert edge.pqEvenOddRef == null;
			// assert edge.pqEvenOutRef == null;
			// edge.pqEvenOutRef = pqEvenOut.insert(edge);
<span class="pc bnc" id="L2655" title="All 2 branches missed.">			assert edge.pqRef == null;</span>
<span class="fc" id="L2656">			edge.pqRef = pqEvenOut.insert(edge);</span>
<span class="fc" id="L2657">		}</span>

		private void pqRemoveEvenOut(Edge edge) {
			// assert edge.pqEvenOutRef != null;
			// pqEvenOut.remove(edge.pqEvenOutRef);
			// edge.pqEvenOutRef = null;
			// assert edge.pqEvenEvenRef == null;
			// assert edge.pqEvenOddRef == null;
			// assert edge.pqEvenOutRef == null;
<span class="pc bnc" id="L2666" title="All 2 branches missed.">			assert edge.pqRef != null;</span>
<span class="fc" id="L2667">			pqEvenOut.remove(edge.pqRef);</span>
<span class="fc" id="L2668">			edge.pqRef = null;</span>
<span class="fc" id="L2669">		}</span>

		private void pqInsertEvenEven(Edge edge) {
			// assert edge.pqEvenEvenRef == null;
			// assert edge.pqEvenOddRef == null;
			// assert edge.pqEvenOutRef == null;
			// edge.pqEvenEvenRef = pqEvenEven.insert(edge);
<span class="pc bnc" id="L2676" title="All 2 branches missed.">			assert edge.pqRef == null;</span>
<span class="fc" id="L2677">			edge.pqRef = pqEvenEven.insert(edge);</span>
<span class="fc" id="L2678">		}</span>

		private void pqRemoveEvenEven(Edge edge) {
			// assert edge.pqEvenEvenRef != null;
			// pqEvenEven.remove(edge.pqEvenEvenRef);
			// edge.pqEvenEvenRef = null;
			// assert edge.pqEvenEvenRef == null;
			// assert edge.pqEvenOddRef == null;
			// assert edge.pqEvenOutRef == null;
<span class="pc bnc" id="L2687" title="All 2 branches missed.">			assert edge.pqRef != null;</span>
<span class="fc" id="L2688">			pqEvenEven.remove(edge.pqRef);</span>
<span class="fc" id="L2689">			edge.pqRef = null;</span>
<span class="fc" id="L2690">		}</span>

		private void pqEdgeInsertEvenOdd(TreesEdge treesEdge, Edge edge) {
			ObjReferenceableHeap&lt;Edge&gt; pqEvenOdd;
<span class="fc bfc" id="L2694" title="All 2 branches covered.">			if (this == treesEdge.source) {</span>
<span class="fc" id="L2695">				pqEvenOdd = treesEdge.pqEvenOdd;</span>
			} else {
<span class="pc bnc" id="L2697" title="All 2 branches missed.">				assert this == treesEdge.target;</span>
<span class="fc" id="L2698">				pqEvenOdd = treesEdge.pqOddEven;</span>
			}

			// assert edge.pqEvenEvenRef == null;
			// assert edge.pqEvenOddRef == null;
			// assert edge.pqEvenOutRef == null;
			// edge.pqEvenOddRef = pqEvenOdd.insert(edge);
<span class="pc bnc" id="L2705" title="All 2 branches missed.">			assert edge.pqRef == null;</span>
<span class="fc" id="L2706">			edge.pqRef = pqEvenOdd.insert(edge);</span>
<span class="fc" id="L2707">		}</span>

		private void pqEdgeRemoveEvenOdd(TreesEdge treesEdge, Edge edge) {
			ObjReferenceableHeap&lt;Edge&gt; pqEvenOdd;
<span class="fc bfc" id="L2711" title="All 2 branches covered.">			if (this == treesEdge.source) {</span>
<span class="fc" id="L2712">				pqEvenOdd = treesEdge.pqEvenOdd;</span>
			} else {
<span class="pc bnc" id="L2714" title="All 2 branches missed.">				assert this == treesEdge.target;</span>
<span class="fc" id="L2715">				pqEvenOdd = treesEdge.pqOddEven;</span>
			}
			// assert edge.pqEvenOddRef != null;
			// pqEvenOdd.remove(edge.pqEvenOddRef);
			// edge.pqEvenOddRef = null;
			// assert edge.pqEvenEvenRef == null;
			// assert edge.pqEvenOddRef == null;
			// assert edge.pqEvenOutRef == null;
<span class="pc bnc" id="L2723" title="All 2 branches missed.">			assert edge.pqRef != null;</span>
<span class="fc" id="L2724">			pqEvenOdd.remove(edge.pqRef);</span>
<span class="fc" id="L2725">			edge.pqRef = null;</span>
<span class="fc" id="L2726">		}</span>

		private void pqInsertOdd(Blossom b) {
<span class="pc bnc" id="L2729" title="All 2 branches missed.">			assert b.expandRef == null;</span>
<span class="fc" id="L2730">			b.expandRef = pqOdd.insert(b);</span>
<span class="fc" id="L2731">		}</span>

		private void pqRemoveOdd(Blossom b) {
<span class="pc bnc" id="L2734" title="All 2 branches missed.">			assert b.expandRef != null;</span>
<span class="fc" id="L2735">			pqOdd.remove(b.expandRef);</span>
<span class="fc" id="L2736">			b.expandRef = null;</span>
<span class="fc" id="L2737">		}</span>

		@Override
		public String toString() {
<span class="nc" id="L2741">			return String.format(&quot;T[%s]&quot;, root);</span>
		}
	}

	/**
	 * An edge between two trees.
	 *
	 * &lt;p&gt;
	 * The edge does not represent a real edge of the original graph, rather it is used to store information of all the
	 * edges crossing between two edges. In particular, it contain three heaps with the edges crossing between the two
	 * trees, of types (+,+), (+,-) and (-,+).
	 *
	 * @author Barak Ugav
	 */
<span class="fc" id="L2755">	private static class TreesEdge {</span>
		/* The trees endpoints of this edge */
		Tree source, target;
		/* Each edge is contained in out-edges linked list of source and in-edges linked list of target */
		/* these lists are one directional */
		TreesEdge nextOutEdge, nextInEdge;

		/* PQ containing all (+,+) edges between the two trees */
<span class="fc" id="L2763">		final ObjReferenceableHeap&lt;Edge&gt; pqEvenEven = ObjReferenceableHeap.newInstance(Edge.slackComparator);</span>
		/* PQ containing all (+,-) edges between an even blossom in source tree and odd blossom in target tree */
<span class="fc" id="L2765">		final ObjReferenceableHeap&lt;Edge&gt; pqEvenOdd = ObjReferenceableHeap.newInstance(Edge.slackComparator);</span>
		/* PQ containing all (+,-) edges between an odd blossom in source tree and even blossom in target tree */
<span class="fc" id="L2767">		final ObjReferenceableHeap&lt;Edge&gt; pqOddEven = ObjReferenceableHeap.newInstance(Edge.slackComparator);</span>

		private void pqInsertEvenEven(Edge edge) {
<span class="pc bnc" id="L2770" title="All 2 branches missed.">			assert edge.source != edge.target;</span>
			// assert edge.pqEvenEvenRef == null;
			// assert edge.pqEvenOddRef == null;
			// assert edge.pqEvenOutRef == null;
			// edge.pqEvenEvenRef = pqEvenEven.insert(edge);
<span class="pc bnc" id="L2775" title="All 2 branches missed.">			assert edge.pqRef == null;</span>
<span class="fc" id="L2776">			edge.pqRef = pqEvenEven.insert(edge);</span>
<span class="fc" id="L2777">		}</span>

		@Override
		public String toString() {
<span class="nc" id="L2781">			return String.format(&quot;(%s, %s)&quot;, source, target);</span>
		}
	}

	private static class Debug {
		private static final boolean Enable = false;
<span class="fc" id="L2787">		private static final Impl Impl = Enable ? new Impl() : null;</span>

<span class="nc" id="L2789">		private static class Impl {</span>
			private int nextBlossomId;
<span class="nc" id="L2791">			private final Reference2IntMap&lt;Blossom&gt; blossomIds = new Reference2IntOpenHashMap&lt;&gt;();</span>
		}

		static String blossomId(Blossom b) {
<span class="nc" id="L2795">			return Enable ? String.valueOf(Impl.blossomIds.computeIfAbsent(b, k -&gt; Impl.nextBlossomId++)) : &quot;&quot;;</span>
		}

		static void init(MatchingWeightedBlossomV.Worker worker) {
			if (!Enable)
<span class="fc" id="L2800">				return;</span>
			assert Impl.blossomIds.isEmpty();
			for (int i = 0; i &lt; worker.singletonNodes.length; i++)
				Impl.blossomIds.put(worker.singletonNodes[i], i);
		}

		static void reset() {
			if (!Enable)
<span class="fc" id="L2808">				return;</span>
			Impl.nextBlossomId = 0;
			Impl.blossomIds.clear();
		}

		static void assertConstraints(MatchingWeightedBlossomV.Worker worker) {
			if (!Enable)
<span class="fc" id="L2815">				return;</span>

			/* assert heaps constraints */
			// for (Blossom root : worker.roots()) {
			// Tree tree = root.tree;
			// Heaps.assertHeapConstraints(tree.pqEvenOut);
			// Heaps.assertHeapConstraints(tree.pqEvenEven);
			// Heaps.assertHeapConstraints(tree.pqOdd);
			// for (TreesEdge treesEdge : tree.outEdges()) {
			// Heaps.assertHeapConstraints(treesEdge.pqEvenEven);
			// Heaps.assertHeapConstraints(treesEdge.pqEvenOdd);
			// Heaps.assertHeapConstraints(treesEdge.pqOddEven);
			// }
			// }
		}
	}

<span class="fc" id="L2832">	private static final DebugPrinter dbgLog = new DebugPrinter(Debug.Enable);</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>