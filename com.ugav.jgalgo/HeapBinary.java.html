<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HeapBinary.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jgalgo</a> &gt; <a href="index.source.html" class="el_package">com.ugav.jgalgo</a> &gt; <span class="el_source">HeapBinary.java</span></div><h1>HeapBinary.java</h1><pre class="source lang-java linenums">package com.ugav.jgalgo;

import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class HeapBinary&lt;E&gt; extends HeapAbstract&lt;E&gt; {

	private E[] arr;
	private int size;

	public HeapBinary() {
<span class="fc" id="L15">		this(null);</span>
<span class="fc" id="L16">	}</span>

	public HeapBinary(Comparator&lt;? super E&gt; c) {
<span class="fc" id="L19">		super(c);</span>
<span class="fc" id="L20">		arr = newArr(16);</span>
<span class="fc" id="L21">		size = 0;</span>
<span class="fc" id="L22">	}</span>

	@Override
	public int size() {
<span class="fc" id="L26">		return size;</span>
	}

	private void grow() {
<span class="fc" id="L30">		E[] old = arr;</span>
<span class="fc" id="L31">		arr = newArr(arr.length * 2);</span>
<span class="fc" id="L32">		System.arraycopy(old, 0, arr, 0, size);</span>
<span class="fc" id="L33">	}</span>

	@Override
	public HeapDirectAccessed.Handle&lt;E&gt; insert(E e) {
<span class="fc bfc" id="L37" title="All 2 branches covered.">		if (arr.length == size)</span>
<span class="fc" id="L38">			grow();</span>

<span class="fc" id="L40">		moveUp(size, e);</span>
<span class="fc" id="L41">		size++;</span>

<span class="fc" id="L43">		return null;</span>
	}

	@Override
	public boolean remove(Object e0) {
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L49">		E e = (E) e0;</span>
<span class="fc" id="L50">		int s = size;</span>
<span class="fc" id="L51">		E[] a = arr;</span>

		int i;
<span class="pc bpc" id="L54" title="1 of 2 branches missed.">		for (i = 0; i &lt; s; i++)</span>
<span class="fc bfc" id="L55" title="All 2 branches covered.">			if (c.compare(e, a[i]) == 0)</span>
<span class="fc" id="L56">				break;</span>
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">		if (i == s)</span>
<span class="nc" id="L58">			return false; /* not found */</span>

<span class="fc" id="L60">		remove(i);</span>
<span class="fc" id="L61">		return true;</span>
	}

	@Override
	public void clear() {
<span class="fc" id="L66">		Arrays.fill(arr, 0, size, null);</span>
<span class="fc" id="L67">		size = 0;</span>
<span class="fc" id="L68">	}</span>

	@Override
	public E findMin() {
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">		if (size == 0)</span>
<span class="nc" id="L73">			throw new IllegalStateException();</span>
<span class="fc" id="L74">		return arr[0];</span>
	}

	private void remove(int idx) {
<span class="fc" id="L78">		E[] a = arr;</span>

<span class="fc" id="L80">		E old = a[idx];</span>
<span class="fc" id="L81">		E e = a[size-- - 1];</span>
<span class="fc" id="L82">		a[size] = null;</span>

<span class="fc bfc" id="L84" title="All 2 branches covered.">		if (c.compare(e, old) &lt;= 0)</span>
<span class="fc" id="L85">			moveUp(idx, e);</span>
		else
<span class="fc" id="L87">			moveDown(idx, e);</span>
<span class="fc" id="L88">	}</span>

	@Override
	public E extractMin() {
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">		if (size == 0)</span>
<span class="nc" id="L93">			throw new IllegalStateException();</span>
<span class="fc" id="L94">		E min = arr[0];</span>
<span class="fc" id="L95">		remove(0);</span>
<span class="fc" id="L96">		return min;</span>
	}

	@Override
	public boolean addAll(Collection&lt;? extends E&gt; other) {
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">		if (other.isEmpty())</span>
<span class="nc" id="L102">			return false;</span>
<span class="fc" id="L103">		int combinedSize = size + other.size();</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">		if (arr.length &lt;= combinedSize) {</span>
<span class="fc" id="L105">			E[] old = arr;</span>
<span class="fc" id="L106">			arr = newArr(Math.max(arr.length * 2, combinedSize * 3 / 2));</span>
<span class="fc" id="L107">			System.arraycopy(old, 0, arr, 0, size);</span>
		}

<span class="fc" id="L110">		int reconstructionCost = combinedSize;</span>
<span class="fc" id="L111">		int addAllCost = other.size() + Utils.log2ceil(combinedSize);</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">		if (reconstructionCost &gt;= addAllCost) {</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">			for (E e : other)</span>
<span class="fc" id="L114">				add(e);</span>
		} else {
<span class="fc" id="L116">			E[] a = arr;</span>
<span class="fc" id="L117">			int s = size;</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">			for (E e : other)</span>
<span class="fc" id="L119">				a[s++] = e;</span>
<span class="fc" id="L120">			size = s;</span>

<span class="pc bpc" id="L122" title="1 of 2 branches missed.">			if (s &gt; 1) {</span>
<span class="fc" id="L123">				int lastLayer = Utils.log2ceil(s + 1) - 1;</span>
<span class="fc" id="L124">				int lastParent = (1 &lt;&lt; lastLayer) - 2;</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">				for (int parent = lastParent; parent &gt;= 0; parent--)</span>
<span class="fc" id="L126">					moveDown(parent, a[parent]);</span>
			}
		}

<span class="fc" id="L130">		return true;</span>
	}

	@Override
	public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L135">		return new It();</span>
	}

	private class It implements Iterator&lt;E&gt; {

		int i;

<span class="fc" id="L142">		It() {</span>
<span class="fc" id="L143">			i = 0;</span>
<span class="fc" id="L144">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc bfc" id="L148" title="All 2 branches covered.">			return i &lt; size;</span>
		}

		@Override
		public E next() {
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">			if (i &gt;= size)</span>
<span class="nc" id="L154">				throw new NoSuchElementException();</span>
<span class="fc" id="L155">			return arr[i++];</span>
		}

	}

	private void moveUp(int i, E e) {
<span class="fc" id="L161">		E[] a = arr;</span>

		for (;;) {
			int p;
<span class="fc bfc" id="L165" title="All 4 branches covered.">			if (i == 0 || c.compare(e, a[p = (i - 1) / 2]) &gt;= 0) { /* reached root or parent is smaller */</span>
<span class="fc" id="L166">				a[i] = e;</span>
<span class="fc" id="L167">				return;</span>
			}

			/* e is smaller than parent, continue up */
<span class="fc" id="L171">			a[i] = a[p];</span>
<span class="fc" id="L172">			i = p;</span>
<span class="fc" id="L173">		}</span>
	}

	private void moveDown(int i, E e) {
<span class="fc" id="L177">		E[] a = arr;</span>
<span class="fc" id="L178">		int s = size;</span>

		for (;;) {
<span class="fc" id="L181">			int c01i, c0i = i * 2 + 1, c1i = i * 2 + 2;</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">			if (c0i &gt;= s)</span>
<span class="fc" id="L183">				break;</span>

<span class="fc" id="L185">			E c01, c0 = a[c0i], c1;</span>
<span class="fc bfc" id="L186" title="All 4 branches covered.">			if (c1i &lt; s &amp;&amp; c.compare(c1 = a[c1i], c0) &lt; 0) {</span>
<span class="fc" id="L187">				c01i = c1i;</span>
<span class="fc" id="L188">				c01 = c1;</span>
			} else {
<span class="fc" id="L190">				c01i = c0i;</span>
<span class="fc" id="L191">				c01 = c0;</span>
			}

<span class="fc bfc" id="L194" title="All 2 branches covered.">			if (c.compare(e, c01) &lt;= 0)</span>
<span class="fc" id="L195">				break;</span>

			/* continue down */
<span class="fc" id="L198">			a[i] = c01;</span>
<span class="fc" id="L199">			i = c01i;</span>
<span class="fc" id="L200">		}</span>
<span class="fc" id="L201">		a[i] = e;</span>
<span class="fc" id="L202">	}</span>

	@SuppressWarnings(&quot;unchecked&quot;)
	private static &lt;E&gt; E[] newArr(int n) {
<span class="fc" id="L206">		return (E[]) new Object[n];</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>