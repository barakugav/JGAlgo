<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Graphs.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jgalgo</a> &gt; <a href="index.source.html" class="el_package">com.ugav.jgalgo</a> &gt; <span class="el_source">Graphs.java</span></div><h1>Graphs.java</h1><pre class="source lang-java linenums">package com.ugav.jgalgo;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.NoSuchElementException;

import com.ugav.jgalgo.SSSP.SSSPResultsImpl;
import com.ugav.jgalgo.Utils.StackIntFixSize;

import it.unimi.dsi.fastutil.ints.Int2ObjectFunction;
import it.unimi.dsi.fastutil.ints.IntArrayFIFOQueue;
import it.unimi.dsi.fastutil.ints.IntArrayList;
import it.unimi.dsi.fastutil.ints.IntArrays;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntIterator;
import it.unimi.dsi.fastutil.ints.IntList;
import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
import it.unimi.dsi.fastutil.ints.IntPriorityQueue;
import it.unimi.dsi.fastutil.ints.IntSet;
import it.unimi.dsi.fastutil.longs.LongArrayFIFOQueue;
import it.unimi.dsi.fastutil.longs.LongPriorityQueue;

public class Graphs {

	private Graphs() {
	}

	public static class BFSIter implements IntIterator {

		private final Graph g;
		private final boolean[] visited;
		private final LongPriorityQueue queue;
		private int inEdge;
		private int layer;
		private int firstVInLayer;

		public BFSIter(Graph g, int source) {
<span class="fc" id="L40">			this(g, new int[] { source });</span>
<span class="fc" id="L41">		}</span>

<span class="fc" id="L43">		public BFSIter(Graph g, int[] sources) {</span>
<span class="pc bpc" id="L44" title="1 of 2 branches missed.">			if (sources.length == 0)</span>
<span class="nc" id="L45">				throw new IllegalArgumentException();</span>
<span class="fc" id="L46">			this.g = g;</span>
<span class="fc" id="L47">			int n = g.vertices().size();</span>
<span class="fc" id="L48">			visited = new boolean[n];</span>
<span class="fc" id="L49">			queue = new LongArrayFIFOQueue(n * 2);</span>
<span class="fc" id="L50">			inEdge = -1;</span>
<span class="fc" id="L51">			layer = -1;</span>

<span class="fc bfc" id="L53" title="All 2 branches covered.">			for (int source : sources) {</span>
<span class="fc" id="L54">				visited[source] = true;</span>
<span class="fc" id="L55">				queue.enqueue(toQueueEntry(source, -1));</span>
			}
<span class="fc" id="L57">			firstVInLayer = sources[0];</span>
<span class="fc" id="L58">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc bfc" id="L62" title="All 2 branches covered.">			return !queue.isEmpty();</span>
		}

		@Override
		public int nextInt() {
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">			if (!hasNext())</span>
<span class="nc" id="L68">				throw new NoSuchElementException();</span>
<span class="fc" id="L69">			long entry = queue.dequeueLong();</span>
<span class="fc" id="L70">			final int u = queueEntryToV(entry);</span>
<span class="fc" id="L71">			inEdge = queueEntryToE(entry);</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">			if (u == firstVInLayer) {</span>
<span class="fc" id="L73">				layer++;</span>
<span class="fc" id="L74">				firstVInLayer = -1;</span>
			}

<span class="fc bfc" id="L77" title="All 2 branches covered.">			for (EdgeIter eit = g.edges(u); eit.hasNext();) {</span>
<span class="fc" id="L78">				int e = eit.nextInt();</span>
<span class="fc" id="L79">				int v = eit.v();</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">				if (visited[v])</span>
<span class="fc" id="L81">					continue;</span>
<span class="fc" id="L82">				visited[v] = true;</span>
<span class="fc" id="L83">				queue.enqueue(toQueueEntry(v, e));</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">				if (firstVInLayer == -1)</span>
<span class="fc" id="L85">					firstVInLayer = v;</span>
<span class="fc" id="L86">			}</span>

<span class="fc" id="L88">			return u;</span>
		}

		public int inEdge() {
<span class="fc" id="L92">			return inEdge;</span>
		}

		public int layer() {
<span class="fc" id="L96">			return layer;</span>
		}

		private static long toQueueEntry(int v, int e) {
<span class="fc" id="L100">			return ((v &amp; 0xffffffffL) &lt;&lt; 32) | ((e &amp; 0xffffffffL) &lt;&lt; 0);</span>
		}

		private static int queueEntryToV(long entry) {
<span class="fc" id="L104">			return (int) ((entry &gt;&gt; 32) &amp; 0xffffffff);</span>
		}

		private static int queueEntryToE(long entry) {
<span class="fc" id="L108">			return (int) ((entry &gt;&gt; 0) &amp; 0xffffffff);</span>
		}
	}

<span class="fc" id="L112">	public static class DFSIter implements IntIterator {</span>

		private final Graph g;
		private final boolean[] visited;
		private final List&lt;EdgeIter&gt; edgeIters;
		private final IntList edgePath;
		private boolean isValid;

<span class="fc" id="L120">		public DFSIter(Graph g, int source) {</span>
<span class="fc" id="L121">			int n = g.vertices().size();</span>
<span class="fc" id="L122">			this.g = g;</span>
<span class="fc" id="L123">			visited = new boolean[n];</span>
<span class="fc" id="L124">			edgeIters = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L125">			edgePath = new IntArrayList();</span>

<span class="fc" id="L127">			visited[source] = true;</span>
<span class="fc" id="L128">			edgeIters.add(g.edges(source));</span>
<span class="fc" id="L129">			isValid = true;</span>
<span class="fc" id="L130">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc bfc" id="L134" title="All 2 branches covered.">			if (isValid)</span>
<span class="fc" id="L135">				return true;</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">			if (edgeIters.isEmpty())</span>
<span class="nc" id="L137">				return false;</span>
			for (;;) {
<span class="fc bfc" id="L139" title="All 2 branches covered.">				for (EdgeIter eit = edgeIters.get(edgeIters.size() - 1); eit.hasNext();) {</span>
<span class="fc" id="L140">					int e = eit.nextInt();</span>
<span class="fc" id="L141">					int v = eit.v();</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">					if (visited[v])</span>
<span class="fc" id="L143">						continue;</span>
<span class="fc" id="L144">					visited[v] = true;</span>
<span class="fc" id="L145">					edgeIters.add(g.edges(v));</span>
<span class="fc" id="L146">					edgePath.add(e);</span>
<span class="fc" id="L147">					return isValid = true;</span>
				}
<span class="fc" id="L149">				edgeIters.remove(edgeIters.size() - 1);</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">				if (edgeIters.isEmpty()) {</span>
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">					assert edgePath.isEmpty();</span>
<span class="fc" id="L152">					return false;</span>
				}
<span class="fc" id="L154">				edgePath.removeInt(edgePath.size() - 1);</span>
			}
		}

		@Override
		public int nextInt() {
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">			if (!hasNext())</span>
<span class="nc" id="L161">				throw new NoSuchElementException();</span>
<span class="fc" id="L162">			isValid = false;</span>
<span class="fc" id="L163">			return edgeIters.get(edgeIters.size() - 1).u();</span>
		}

		public IntList edgePath() {
<span class="fc" id="L167">			return edgePath;</span>
		}
	}

	/**
	 * Find a valid path from u to v
	 *
	 * This function uses BFS, which will result in the shortest path in the number
	 * of edges
	 *
	 * @param g a graph
	 * @param u source vertex
	 * @param v target vertex
	 * @return list of edges that represent a valid path from u to v, null if path
	 *         not found
	 */
	public static IntList findPath(Graph g, int u, int v) {
<span class="fc" id="L184">		IntArrayList path = new IntArrayList();</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">		if (u == v)</span>
<span class="fc" id="L186">			return path;</span>
<span class="fc" id="L187">		boolean reverse = true;</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">		if (g instanceof UGraph) {</span>
<span class="fc" id="L189">			int t = u;</span>
<span class="fc" id="L190">			u = v;</span>
<span class="fc" id="L191">			v = t;</span>
<span class="fc" id="L192">			reverse = false;</span>
		}
<span class="fc" id="L194">		int n = g.vertices().size();</span>
<span class="fc" id="L195">		int[] backtrack = new int[n];</span>
<span class="fc" id="L196">		Arrays.fill(backtrack, -1);</span>

<span class="pc bpc" id="L198" title="1 of 2 branches missed.">		for (BFSIter it = new BFSIter(g, u); it.hasNext();) {</span>
<span class="fc" id="L199">			int p = it.nextInt();</span>
<span class="fc" id="L200">			backtrack[p] = it.inEdge();</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">			if (p == v)</span>
<span class="fc" id="L202">				break;</span>
<span class="fc" id="L203">		}</span>

<span class="pc bpc" id="L205" title="1 of 2 branches missed.">		if (backtrack[v] == -1)</span>
<span class="nc" id="L206">			return null;</span>

<span class="fc bfc" id="L208" title="All 2 branches covered.">		for (int p = v; p != u;) {</span>
<span class="fc" id="L209">			int e = backtrack[p];</span>
<span class="fc" id="L210">			path.add(e);</span>
<span class="fc" id="L211">			p = g.edgeEndpoint(e, p);</span>
<span class="fc" id="L212">		}</span>

<span class="fc bfc" id="L214" title="All 2 branches covered.">		if (reverse)</span>
<span class="fc" id="L215">			IntArrays.reverse(path.elements(), 0, path.size());</span>
<span class="fc" id="L216">		return path;</span>
	}

	public static boolean isTree(Graph g) {
<span class="fc" id="L220">		return isTree(g, 0);</span>
	}

	public static boolean isTree(Graph g, int root) {
<span class="fc" id="L224">		return isForst(g, new int[] { root });</span>
	}

	public static boolean isForst(Graph g) {
<span class="nc" id="L228">		int n = g.vertices().size();</span>
<span class="nc" id="L229">		int[] roots = new int[n];</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">		for (int u = 0; u &lt; n; u++)</span>
<span class="nc" id="L231">			roots[u] = u;</span>
<span class="nc" id="L232">		return isForst(g, roots, true);</span>
	}

	public static boolean isForst(Graph g, int[] roots) {
<span class="fc" id="L236">		return isForst(g, roots, false);</span>
	}

	private static boolean isForst(Graph g, int[] roots, boolean allowVisitedRoot) {
<span class="fc" id="L240">		int n = g.vertices().size();</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">		if (n == 0)</span>
<span class="nc" id="L242">			return true;</span>
<span class="fc" id="L243">		boolean directed = g instanceof DiGraph;</span>

<span class="fc" id="L245">		boolean[] visited = new boolean[n];</span>
<span class="fc" id="L246">		int[] parent = new int[n];</span>
<span class="fc" id="L247">		Arrays.fill(parent, -1);</span>

<span class="fc" id="L249">		StackIntFixSize stack = new StackIntFixSize(n);</span>
<span class="fc" id="L250">		int visitedCount = 0;</span>

<span class="fc bfc" id="L252" title="All 2 branches covered.">		for (int i = 0; i &lt; roots.length; i++) {</span>
<span class="fc" id="L253">			int root = roots[i];</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">			if (visited[root]) {</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">				if (allowVisitedRoot)</span>
<span class="nc" id="L256">					continue;</span>
<span class="nc" id="L257">				return false;</span>
			}

<span class="fc" id="L260">			stack.push(root);</span>
<span class="fc" id="L261">			visited[root] = true;</span>

<span class="fc bfc" id="L263" title="All 2 branches covered.">			while (!stack.isEmpty()) {</span>
<span class="fc" id="L264">				int u = stack.pop();</span>
<span class="fc" id="L265">				visitedCount++;</span>

<span class="fc bfc" id="L267" title="All 2 branches covered.">				for (EdgeIter eit = g.edges(u); eit.hasNext();) {</span>
<span class="fc" id="L268">					eit.nextInt();</span>
<span class="fc" id="L269">					int v = eit.v();</span>
<span class="pc bpc" id="L270" title="1 of 4 branches missed.">					if (!directed &amp;&amp; v == parent[u])</span>
<span class="fc" id="L271">						continue;</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">					if (visited[v])</span>
<span class="fc" id="L273">						return false;</span>
<span class="fc" id="L274">					visited[v] = true;</span>
<span class="fc" id="L275">					stack.push(v);</span>
<span class="fc" id="L276">					parent[v] = u;</span>
<span class="fc" id="L277">				}</span>
<span class="fc" id="L278">			}</span>
		}

<span class="fc bfc" id="L281" title="All 2 branches covered.">		return visitedCount == n;</span>
	}

	/**
	 * Find all connectivity components in the graph
	 *
	 * The connectivity components (CC) are groups of vertices where it's possible
	 * to reach each one from one another.
	 *
	 * This function support undirected graphs only
	 *
	 * @param g an undirected graph
	 * @return (CC number, [vertex]-&gt;[CC])
	 * @throws IllegalArgumentException if the graph is directed
	 */
	public static Pair&lt;Integer, int[]&gt; findConnectivityComponents(UGraph g) {
<span class="fc" id="L297">		int n = g.vertices().size();</span>
<span class="fc" id="L298">		StackIntFixSize stack = new StackIntFixSize(n);</span>

<span class="fc" id="L300">		int[] comp = new int[n];</span>
<span class="fc" id="L301">		Arrays.fill(comp, -1);</span>
<span class="fc" id="L302">		int compNum = 0;</span>

<span class="fc bfc" id="L304" title="All 2 branches covered.">		for (int r = 0; r &lt; n; r++) {</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">			if (comp[r] != -1)</span>
<span class="fc" id="L306">				continue;</span>

<span class="fc" id="L308">			stack.push(r);</span>
<span class="fc" id="L309">			comp[r] = compNum;</span>

<span class="fc bfc" id="L311" title="All 2 branches covered.">			while (!stack.isEmpty()) {</span>
<span class="fc" id="L312">				int u = stack.pop();</span>

<span class="fc bfc" id="L314" title="All 2 branches covered.">				for (EdgeIter eit = g.edges(u); eit.hasNext();) {</span>
<span class="fc" id="L315">					eit.nextInt();</span>
<span class="fc" id="L316">					int v = eit.v();</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">					if (comp[v] != -1)</span>
<span class="fc" id="L318">						continue;</span>
<span class="fc" id="L319">					comp[v] = compNum;</span>
<span class="fc" id="L320">					stack.push(v);</span>
<span class="fc" id="L321">				}</span>
<span class="fc" id="L322">			}</span>
<span class="fc" id="L323">			compNum++;</span>
		}
<span class="fc" id="L325">		return Pair.of(Integer.valueOf(compNum), comp);</span>
	}

	/**
	 * Find all strong connectivity components
	 *
	 * The connectivity components (CC) are groups of vertices where it's possible
	 * to reach each one from one another.
	 *
	 * This function is specifically for directed graphs.
	 *
	 * @param g a directed graph
	 * @return (CC number, [vertex]-&gt;[CC])
	 */
	public static Pair&lt;Integer, int[]&gt; findStrongConnectivityComponents(DiGraph g) {
<span class="fc" id="L340">		int n = g.vertices().size();</span>

<span class="fc" id="L342">		int[] comp = new int[n];</span>
<span class="fc" id="L343">		Arrays.fill(comp, -1);</span>
<span class="fc" id="L344">		int compNum = 0;</span>

<span class="fc" id="L346">		int[] dfsPath = new int[n];</span>
<span class="fc" id="L347">		EdgeIter[] edges = new EdgeIter[n];</span>

<span class="fc" id="L349">		int[] c = new int[n];</span>
<span class="fc" id="L350">		int[] s = new int[n];</span>
<span class="fc" id="L351">		int[] p = new int[n];</span>
<span class="fc" id="L352">		int cNext = 1, sSize = 0, pSize = 0;</span>

<span class="fc bfc" id="L354" title="All 2 branches covered.">		for (int r = 0; r &lt; n; r++) {</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">			if (comp[r] != -1)</span>
<span class="fc" id="L356">				continue;</span>
<span class="fc" id="L357">			dfsPath[0] = r;</span>
<span class="fc" id="L358">			edges[0] = g.edgesOut(r);</span>
<span class="fc" id="L359">			c[r] = cNext++;</span>
<span class="fc" id="L360">			s[sSize++] = p[pSize++] = r;</span>

<span class="fc" id="L362">			dfs: for (int depth = 0;;) {</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">				for (EdgeIter eit = edges[depth]; eit.hasNext();) {</span>
<span class="fc" id="L364">					eit.nextInt();</span>
<span class="fc" id="L365">					int v = eit.v();</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">					if (c[v] == 0) {</span>
<span class="fc" id="L367">						c[v] = cNext++;</span>
<span class="fc" id="L368">						s[sSize++] = p[pSize++] = v;</span>

<span class="fc" id="L370">						dfsPath[++depth] = v;</span>
<span class="fc" id="L371">						edges[depth] = g.edgesOut(v);</span>
<span class="fc" id="L372">						continue dfs;</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">					} else if (comp[v] == -1)</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">						while (c[p[pSize - 1]] &gt; c[v])</span>
<span class="fc" id="L375">							pSize--;</span>
<span class="fc" id="L376">				}</span>
<span class="fc" id="L377">				int u = dfsPath[depth];</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">				if (p[pSize - 1] == u) {</span>
					int v;
					do {
<span class="fc" id="L381">						v = s[--sSize];</span>
<span class="fc" id="L382">						comp[v] = compNum;</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">					} while (v != u);</span>
<span class="fc" id="L384">					compNum++;</span>
<span class="fc" id="L385">					pSize--;</span>
				}

<span class="fc" id="L388">				edges[depth] = null;</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">				if (depth-- == 0)</span>
<span class="fc" id="L390">					break;</span>
<span class="fc" id="L391">			}</span>
		}
<span class="fc" id="L393">		return Pair.of(Integer.valueOf(compNum), comp);</span>
	}

	public static int[] calcTopologicalSortingDAG(DiGraph g) {
<span class="fc" id="L397">		int n = g.vertices().size();</span>
<span class="fc" id="L398">		int[] inDegree = new int[n];</span>
<span class="fc" id="L399">		IntPriorityQueue queue = new IntArrayFIFOQueue();</span>
<span class="fc" id="L400">		int[] topolSort = new int[n];</span>
<span class="fc" id="L401">		int topolSortSize = 0;</span>

		// Cache in degree of all vertices
<span class="fc bfc" id="L404" title="All 2 branches covered.">		for (int v = 0; v &lt; n; v++)</span>
<span class="fc" id="L405">			inDegree[v] = g.degreeIn(v);</span>

		// Find vertices with zero in degree and insert them to the queue
<span class="fc bfc" id="L408" title="All 2 branches covered.">		for (int v = 0; v &lt; n; v++)</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">			if (inDegree[v] == 0)</span>
<span class="fc" id="L410">				queue.enqueue(v);</span>

		// Poll vertices from the queue and &quot;remove&quot; each one from the tree and add new
		// zero in degree vertices to the queue
<span class="fc bfc" id="L414" title="All 2 branches covered.">		while (!queue.isEmpty()) {</span>
<span class="fc" id="L415">			int u = queue.dequeueInt();</span>
<span class="fc" id="L416">			topolSort[topolSortSize++] = u;</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">			for (EdgeIter eit = g.edgesOut(u); eit.hasNext();) {</span>
<span class="fc" id="L418">				eit.nextInt();</span>
<span class="fc" id="L419">				int v = eit.v();</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">				if (--inDegree[v] == 0)</span>
<span class="fc" id="L421">					queue.enqueue(v);</span>
<span class="fc" id="L422">			}</span>
<span class="fc" id="L423">		}</span>

<span class="pc bpc" id="L425" title="1 of 2 branches missed.">		if (topolSortSize != n)</span>
<span class="nc" id="L426">			throw new IllegalArgumentException(&quot;G is not a directed acyclic graph (DAG)&quot;);</span>

<span class="fc" id="L428">		return topolSort;</span>
	}

	public static SSSP.Result calcDistancesDAG(DiGraph g, EdgeWeightFunc w, int source) {
<span class="fc" id="L432">		int n = g.vertices().size();</span>
<span class="fc" id="L433">		int[] backtrack = new int[n];</span>
<span class="fc" id="L434">		Arrays.fill(backtrack, -1);</span>
<span class="fc" id="L435">		double[] distances = new double[n];</span>
<span class="fc" id="L436">		Arrays.fill(distances, Double.POSITIVE_INFINITY);</span>
<span class="fc" id="L437">		distances[source] = 0;</span>

<span class="fc" id="L439">		int[] topolSort = calcTopologicalSortingDAG(g);</span>
<span class="fc" id="L440">		boolean sourceSeen = false;</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">		for (int u : topolSort) {</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">			if (!sourceSeen) {</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">				if (u != source)</span>
<span class="fc" id="L444">					continue;</span>
<span class="fc" id="L445">				sourceSeen = true;</span>
			}
<span class="fc bfc" id="L447" title="All 2 branches covered.">			for (EdgeIter eit = g.edgesOut(u); eit.hasNext();) {</span>
<span class="fc" id="L448">				int e = eit.nextInt();</span>
<span class="fc" id="L449">				int v = eit.v();</span>
<span class="fc" id="L450">				double d = distances[u] + w.weight(e);</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">				if (d &lt; distances[v]) {</span>
<span class="fc" id="L452">					distances[v] = d;</span>
<span class="fc" id="L453">					backtrack[v] = e;</span>
				}
<span class="fc" id="L455">			}</span>
		}

<span class="fc" id="L458">		return new SSSPResultsImpl(g, distances, backtrack);</span>
	}

	public static int getFullyBranchingTreeDepth(Graph t, int root) {
<span class="fc" id="L462">		for (int parent = -1, u = root, depth = 0;; depth++) {</span>
<span class="fc" id="L463">			int v = parent;</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">			for (EdgeIter eit = t.edges(u); eit.hasNext();) {</span>
<span class="fc" id="L465">				eit.nextInt();</span>
<span class="fc" id="L466">				v = eit.v();</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">				if (v != parent)</span>
<span class="fc" id="L468">					break;</span>
			}
<span class="fc bfc" id="L470" title="All 2 branches covered.">			if (v == parent)</span>
<span class="fc" id="L471">				return depth;</span>
<span class="fc" id="L472">			parent = u;</span>
<span class="fc" id="L473">			u = v;</span>
		}
	}

	public static int[] calcDegree(UGraph g, IntCollection edges) {
<span class="fc" id="L478">		int[] degree = new int[g.vertices().size()];</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">		for (IntIterator eit = edges.iterator(); eit.hasNext();) {</span>
<span class="fc" id="L480">			int e = eit.nextInt();</span>
<span class="fc" id="L481">			degree[g.edgeSource(e)]++;</span>
<span class="fc" id="L482">			degree[g.edgeTarget(e)]++;</span>
<span class="fc" id="L483">		}</span>
<span class="fc" id="L484">		return degree;</span>
	}

	public static IntList calcEulerianTour(UGraph g) {
<span class="fc" id="L488">		int n = g.vertices().size();</span>

<span class="fc" id="L490">		int start = -1, end = -1;</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">		for (int u = 0; u &lt; n; u++) {</span>
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">			if (g.degree(u) % 2 == 0)</span>
<span class="fc" id="L493">				continue;</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">			if (start == -1)</span>
<span class="nc" id="L495">				start = u;</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">			else if (end == -1)</span>
<span class="nc" id="L497">				end = u;</span>
			else
<span class="nc" id="L499">				throw new IllegalArgumentException(</span>
						&quot;More than two vertices have an odd degree (&quot; + start + &quot;, &quot; + end + &quot;, &quot; + u + &quot;)&quot;);
		}
<span class="pc bpc" id="L502" title="3 of 4 branches missed.">		if (start != -1 &amp;&amp; end == -1)</span>
<span class="nc" id="L503">			throw new IllegalArgumentException(</span>
					&quot;Eulerian tour exists only if all vertices have even degree or only two vertices have odd degree&quot;);
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">		if (start == -1)</span>
<span class="fc" id="L506">			start = 0;</span>

<span class="fc" id="L508">		IntArrayList tour = new IntArrayList(g.edges().size());</span>
<span class="fc" id="L509">		IntSet usedEdges = new IntOpenHashSet();</span>
<span class="fc" id="L510">		EdgeIter[] iters = new EdgeIter[n];</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">		for (int u = 0; u &lt; n; u++)</span>
<span class="fc" id="L512">			iters[u] = g.edges(u);</span>

<span class="fc" id="L514">		StackIntFixSize queue = new StackIntFixSize(g.edges().size());</span>

<span class="fc" id="L516">		for (int u = start;;) {</span>
			findCycle: for (;;) {
				int e, v;
<span class="fc" id="L519">				for (EdgeIter iter = iters[u];;) {</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">					if (!iter.hasNext())</span>
<span class="fc" id="L521">						break findCycle;</span>
<span class="fc" id="L522">					e = iter.nextInt();</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">					if (!usedEdges.contains(e)) {</span>
<span class="fc" id="L524">						v = iter.v();</span>
<span class="fc" id="L525">						break;</span>
					}
				}
<span class="fc" id="L528">				usedEdges.add(e);</span>
<span class="fc" id="L529">				queue.push(e);</span>
<span class="fc" id="L530">				u = v;</span>
<span class="fc" id="L531">			}</span>

<span class="fc bfc" id="L533" title="All 2 branches covered.">			if (queue.isEmpty())</span>
<span class="fc" id="L534">				break;</span>

<span class="fc" id="L536">			int e = queue.pop();</span>
<span class="fc" id="L537">			tour.add(e);</span>
<span class="fc" id="L538">			u = g.edgeEndpoint(e, u);</span>
<span class="fc" id="L539">		}</span>

<span class="fc" id="L541">		IntArrays.reverse(tour.elements(), 0, tour.size());</span>
<span class="fc" id="L542">		return tour;</span>
	}

	public static String formatAdjacencyMatrix(Graph g) {
<span class="nc bnc" id="L546" title="All 2 branches missed.">		return formatAdjacencyMatrix(g, e -&gt; e == -1 ? &quot;0&quot; : &quot;1&quot;);</span>
	}

	public static String formatAdjacencyMatrixWeighted(Graph g, EdgeWeightFunc w) {
<span class="nc" id="L550">		double minWeight = Double.MAX_VALUE;</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">		for (IntIterator it = g.edges().iterator(); it.hasNext();) {</span>
<span class="nc" id="L552">			int e = it.nextInt();</span>
<span class="nc" id="L553">			double ew = w.weight(e);</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">			if (ew &lt; minWeight)</span>
<span class="nc" id="L555">				minWeight = ew;</span>
<span class="nc" id="L556">		}</span>

<span class="nc" id="L558">		int unlimitedPrecision = 64;</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">		int precision = minWeight &gt;= 1 ? 2 : Math.min(unlimitedPrecision, (int) -Math.log10(minWeight));</span>

<span class="nc bnc" id="L561" title="All 2 branches missed.">		return precision == unlimitedPrecision</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">				? formatAdjacencyMatrix(g, e -&gt; e == -1 ? &quot;-&quot; : Double.toString(w.weight(e)))</span>
<span class="nc" id="L563">				: formatAdjacencyMatrix(g,</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">						e -&gt; e == -1 ? &quot;-&quot; : String.format(&quot;%.&quot; + precision + &quot;f&quot;, Double.valueOf(w.weight(e))));</span>
	}

	public static String formatAdjacencyMatrixWeightedInt(Graph g, EdgeWeightFunc.Int w) {
<span class="nc bnc" id="L568" title="All 2 branches missed.">		return formatAdjacencyMatrix(g, e -&gt; e == -1 ? &quot;-&quot; : Integer.toString(w.weightInt(e)));</span>
	}

	public static String formatAdjacencyMatrix(Graph g, Int2ObjectFunction&lt;String&gt; formatter) {
<span class="nc" id="L572">		int n = g.vertices().size();</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">		if (n == 0)</span>
<span class="nc" id="L574">			return &quot;[]&quot;;</span>

		/* format all edges */
<span class="nc" id="L577">		String[][] strs = new String[n][n];</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">		for (int u = 0; u &lt; n; u++) {</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">			for (EdgeIter eit = g.edges(u); eit.hasNext();) {</span>
<span class="nc" id="L580">				int e = eit.nextInt();</span>
<span class="nc" id="L581">				strs[u][eit.v()] = formatter.apply(e);</span>
<span class="nc" id="L582">			}</span>
		}

		/* calculate cell size */
<span class="nc" id="L586">		int maxStr = 0;</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">		for (int u = 0; u &lt; n; u++) {</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">			for (int v = 0; v &lt; n; v++) {</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">				if (strs[u][v] == null)</span>
<span class="nc" id="L590">					strs[u][v] = formatter.apply(null);</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">				if (strs[u][v].length() &gt; maxStr)</span>
<span class="nc" id="L592">					maxStr = strs[u][v].length();</span>
			}
		}
<span class="nc" id="L595">		int vertexLabelCellSize = String.valueOf(n - 1).length() + 1;</span>
<span class="nc" id="L596">		int cellSize = Math.max(maxStr + 1, vertexLabelCellSize);</span>

		/* format header row */
<span class="nc" id="L599">		StringBuilder s = new StringBuilder();</span>
<span class="nc" id="L600">		s.append(strMult(&quot; &quot;, vertexLabelCellSize));</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">		for (int v = 0; v &lt; n; v++)</span>
<span class="nc" id="L602">			s.append(String.format(&quot;% &quot; + cellSize + &quot;d&quot;, Integer.valueOf(v)));</span>
<span class="nc" id="L603">		s.append('\n');</span>

		/* format adjacency matrix */
<span class="nc bnc" id="L606" title="All 2 branches missed.">		for (int u = 0; u &lt; n; u++) {</span>
<span class="nc" id="L607">			s.append(String.format(&quot;% &quot; + vertexLabelCellSize + &quot;d&quot;, Integer.valueOf(u)));</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">			for (int v = 0; v &lt; n; v++) {</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">				if (strs[u][v].length() &lt; cellSize)</span>
<span class="nc" id="L610">					s.append(strMult(&quot; &quot;, cellSize - strs[u][v].length()));</span>
<span class="nc" id="L611">				s.append(strs[u][v]);</span>
			}
<span class="nc" id="L613">			s.append('\n');</span>
		}

<span class="nc" id="L616">		return s.toString();</span>
	}

	private static String strMult(String s, int n) {
<span class="nc" id="L620">		return String.join(&quot;&quot;, Collections.nCopies(n, s));</span>
	}

	public static DiGraph referenceGraph(DiGraph g, Object refEdgeWeightKey) {
<span class="fc" id="L624">		DiGraph g0 = new GraphArrayDirected(g.vertices().size());</span>
<span class="fc" id="L625">		Weights.Int edgeRef = g0.addEdgesWeight(refEdgeWeightKey).ofInts();</span>
<span class="fc bfc" id="L626" title="All 2 branches covered.">		for (IntIterator it = g.edges().iterator(); it.hasNext();) {</span>
<span class="fc" id="L627">			int e = it.nextInt();</span>
<span class="fc" id="L628">			int e0 = g0.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L629">			edgeRef.set(e0, e);</span>
<span class="fc" id="L630">		}</span>
<span class="fc" id="L631">		return g0;</span>
	}

	public static UGraph referenceGraph(UGraph g, Object refEdgeWeightKey) {
<span class="fc" id="L635">		UGraph g0 = new GraphArrayUndirected(g.vertices().size());</span>
<span class="fc" id="L636">		Weights.Int edgeRef = g0.addEdgesWeight(refEdgeWeightKey).ofInts();</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">		for (IntIterator it = g.edges().iterator(); it.hasNext();) {</span>
<span class="fc" id="L638">			int e = it.nextInt();</span>
<span class="fc" id="L639">			int e0 = g0.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L640">			edgeRef.set(e0, e);</span>
<span class="fc" id="L641">		}</span>
<span class="fc" id="L642">		return g0;</span>
	}

	public static interface PathIter {

		public boolean hasNext();

		public int nextEdge();

		public int u();

		public int v();

		static PathIter of(Graph g0, IntList edgeList) {
<span class="fc bfc" id="L656" title="All 2 branches covered.">			if (g0 instanceof UGraph g) {</span>
<span class="fc" id="L657">				return new PathIterUndirected(g, edgeList);</span>
<span class="pc bpc" id="L658" title="1 of 2 branches missed.">			} else if (g0 instanceof DiGraph g) {</span>
<span class="fc" id="L659">				return new PathIterDirected(g, edgeList);</span>
			} else {
<span class="nc" id="L661">				throw new IllegalArgumentException();</span>
			}
		}

	}

<span class="fc" id="L667">	private static class PathIterUndirected implements PathIter {</span>

		private final UGraph g;
		private final IntIterator it;
<span class="fc" id="L671">		private int e = -1, v = -1;</span>

<span class="fc" id="L673">		PathIterUndirected(UGraph g, IntList path) {</span>
<span class="fc" id="L674">			this.g = g;</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">			if (path.size() == 1) {</span>
<span class="fc" id="L676">				v = g.edgeTarget(path.getInt(0));</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">			} else if (path.size() &gt;= 2) {</span>
<span class="fc" id="L678">				int e0 = path.getInt(0), e1 = path.getInt(1);</span>
<span class="fc" id="L679">				int u0 = g.edgeSource(e0), v0 = g.edgeTarget(e0);</span>
<span class="fc" id="L680">				int u1 = g.edgeSource(e1), v1 = g.edgeTarget(e1);</span>
<span class="fc bfc" id="L681" title="All 4 branches covered.">				if (v0 == u1 || v0 == v1) {</span>
<span class="fc" id="L682">					v = u0;</span>
				} else {
<span class="fc" id="L684">					v = v0;</span>
<span class="pc bpc" id="L685" title="1 of 4 branches missed.">					assert (u0 == u1 || u0 == v1) : &quot;not a path&quot;;</span>
				}
			}
<span class="fc" id="L688">			it = path.iterator();</span>
<span class="fc" id="L689">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc" id="L693">			return it.hasNext();</span>
		}

		@Override
		public int nextEdge() {
<span class="fc" id="L698">			e = it.nextInt();</span>
<span class="pc bpc" id="L699" title="1 of 4 branches missed.">			assert v == g.edgeSource(e) || v == g.edgeTarget(e);</span>
<span class="fc" id="L700">			v = g.edgeEndpoint(e, v);</span>
<span class="fc" id="L701">			return e;</span>
		}

		@Override
		public int u() {
<span class="fc" id="L706">			return g.edgeEndpoint(e, v);</span>
		}

		@Override
		public int v() {
<span class="fc" id="L711">			return v;</span>
		}

	}

	private static class PathIterDirected implements PathIter {

		private final DiGraph g;
		private final IntIterator it;
<span class="fc" id="L720">		private int e = -1;</span>

<span class="fc" id="L722">		PathIterDirected(DiGraph g, IntList path) {</span>
<span class="fc" id="L723">			this.g = g;</span>
<span class="fc" id="L724">			it = path.iterator();</span>
<span class="fc" id="L725">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc" id="L729">			return it.hasNext();</span>
		}

		@Override
		public int nextEdge() {
<span class="fc" id="L734">			e = it.nextInt();</span>
<span class="fc" id="L735">			return e;</span>
		}

		@Override
		public int u() {
<span class="nc" id="L740">			return g.edgeSource(e);</span>
		}

		@Override
		public int v() {
<span class="nc" id="L745">			return g.edgeTarget(e);</span>
		}

	}

	@SuppressWarnings(&quot;unchecked&quot;)
	static UGraph subGraph(UGraph g, IntCollection edgeSet) {
<span class="fc" id="L752">		final Object edgeMappingKey = new Object();</span>
<span class="fc" id="L753">		UGraph g1 = new GraphArrayUndirected(g.vertices().size());</span>

<span class="fc" id="L755">		Weights.Int sub2Edge = g1.addEdgesWeight(edgeMappingKey).ofInts();</span>
<span class="fc bfc" id="L756" title="All 2 branches covered.">		for (IntIterator it = edgeSet.iterator(); it.hasNext();) {</span>
<span class="fc" id="L757">			int e = it.nextInt();</span>
<span class="fc" id="L758">			int u = g.edgeSource(e), v = g.edgeTarget(e);</span>
<span class="fc" id="L759">			int s = g1.addEdge(u, v);</span>
<span class="fc" id="L760">			sub2Edge.set(s, e);</span>
<span class="fc" id="L761">		}</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">		for (Object key : g.getEdgesWeightsKeys()) {</span>
<span class="fc" id="L763">			Weights&lt;?&gt; data0 = g.edgesWeight(key);</span>

<span class="pc bpc" id="L765" title="1 of 2 branches missed.">			if (data0 instanceof Weights.Int data) {</span>
<span class="nc" id="L766">				int defVal = data.defaultValInt();</span>
<span class="nc" id="L767">				Weights.Int datas = g1.addEdgesWeight(key).defVal(defVal).ofInts();</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">				for (IntIterator it = g1.edges().iterator(); it.hasNext();) {</span>
<span class="nc" id="L769">					int s = it.nextInt();</span>
<span class="nc" id="L770">					int w = data.getInt(sub2Edge.getInt(s));</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">					if (w != defVal)</span>
<span class="nc" id="L772">						datas.set(s, w);</span>
<span class="nc" id="L773">				}</span>

<span class="pc bpc" id="L775" title="1 of 2 branches missed.">			} else if (data0 instanceof Weights.Double data) {</span>
<span class="nc" id="L776">				double defVal = data.defaultValDouble();</span>
<span class="nc" id="L777">				Weights.Double datas = g1.addEdgesWeight(key).defVal(defVal).ofDoubles();</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">				for (IntIterator it = g1.edges().iterator(); it.hasNext();) {</span>
<span class="nc" id="L779">					int s = it.nextInt();</span>
<span class="nc" id="L780">					double w = data.getDouble(sub2Edge.getInt(s));</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">					if (w != defVal)</span>
<span class="nc" id="L782">						datas.set(s, w);</span>
<span class="nc" id="L783">				}</span>

<span class="nc" id="L785">			} else {</span>
<span class="fc" id="L786">				Object defVal = data0.defaultVal();</span>
				@SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L788">				Weights datas = g1.addEdgesWeight(key).defVal(defVal).ofObjs();</span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">				for (IntIterator it = g1.edges().iterator(); it.hasNext();) {</span>
<span class="fc" id="L790">					int s = it.nextInt();</span>
<span class="fc" id="L791">					Object w = data0.get(sub2Edge.getInt(s));</span>
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">					if (w != defVal)</span>
<span class="fc" id="L793">						datas.set(s, w);</span>
<span class="fc" id="L794">				}</span>
			}
<span class="fc" id="L796">		}</span>
<span class="fc" id="L797">		g1.removeEdgesWeights(edgeMappingKey);</span>
<span class="fc" id="L798">		return g1;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>