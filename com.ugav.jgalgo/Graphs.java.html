<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Graphs.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jgalgo</a> &gt; <a href="index.source.html" class="el_package">com.ugav.jgalgo</a> &gt; <span class="el_source">Graphs.java</span></div><h1>Graphs.java</h1><pre class="source lang-java linenums">package com.ugav.jgalgo;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.NoSuchElementException;

import com.ugav.jgalgo.SSSP.SSSPResultsImpl;
import com.ugav.jgalgo.Utils.QueueIntFixSize;
import com.ugav.jgalgo.Utils.StackIntFixSize;

import it.unimi.dsi.fastutil.ints.Int2ObjectFunction;
import it.unimi.dsi.fastutil.ints.IntArrayList;
import it.unimi.dsi.fastutil.ints.IntArrays;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntIterator;
import it.unimi.dsi.fastutil.ints.IntList;
import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
import it.unimi.dsi.fastutil.ints.IntSet;

public class Graphs {

	private Graphs() {
	}

	public static class BFSIter implements IntIterator {

		private final Graph g;
		private final boolean[] visited;
		private final QueueIntFixSize queue;
		private int inEdge;

		public BFSIter(Graph g, int source) {
<span class="fc" id="L35">			this(g, new int[] { source });</span>
<span class="fc" id="L36">		}</span>

<span class="fc" id="L38">		public BFSIter(Graph g, int[] sources) {</span>
<span class="fc" id="L39">			this.g = g;</span>
<span class="fc" id="L40">			int n = g.vertices().size();</span>
<span class="fc" id="L41">			visited = new boolean[n];</span>
<span class="fc" id="L42">			queue = new QueueIntFixSize(n * 2);</span>
<span class="fc" id="L43">			inEdge = -1;</span>

<span class="fc bfc" id="L45" title="All 2 branches covered.">			for (int source : sources) {</span>
<span class="fc" id="L46">				visited[source] = true;</span>
<span class="fc" id="L47">				queue.push(source); /* push vertex */</span>
<span class="fc" id="L48">				queue.push(-1); /* push in edge */</span>
			}
<span class="fc" id="L50">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc bfc" id="L54" title="All 2 branches covered.">			return !queue.isEmpty();</span>
		}

		@Override
		public int nextInt() {
<span class="pc bpc" id="L59" title="1 of 2 branches missed.">			if (!hasNext())</span>
<span class="nc" id="L60">				throw new NoSuchElementException();</span>
<span class="fc" id="L61">			final int u = queue.pop(); /* pop vertex */</span>
<span class="fc" id="L62">			inEdge = queue.pop(); /* pop in edge */</span>

<span class="fc bfc" id="L64" title="All 2 branches covered.">			for (EdgeIter eit = g.edges(u); eit.hasNext();) {</span>
<span class="fc" id="L65">				int e = eit.nextInt();</span>
<span class="fc" id="L66">				int v = eit.v();</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">				if (visited[v])</span>
<span class="fc" id="L68">					continue;</span>
<span class="fc" id="L69">				visited[v] = true;</span>
<span class="fc" id="L70">				queue.push(v); /* push vertex */</span>
<span class="fc" id="L71">				queue.push(e); /* push in edge */</span>
<span class="fc" id="L72">			}</span>
<span class="fc" id="L73">			return u;</span>
		}

		public int inEdge() {
<span class="fc" id="L77">			return inEdge;</span>
		}
	}

<span class="fc" id="L81">	public static class DFSIter implements IntIterator {</span>

		private final Graph g;
		private final boolean[] visited;
		private final List&lt;EdgeIter&gt; edgeIters;
		private final IntList edgePath;
		private boolean isValid;

<span class="fc" id="L89">		public DFSIter(Graph g, int source) {</span>
<span class="fc" id="L90">			int n = g.vertices().size();</span>
<span class="fc" id="L91">			this.g = g;</span>
<span class="fc" id="L92">			visited = new boolean[n];</span>
<span class="fc" id="L93">			edgeIters = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L94">			edgePath = new IntArrayList();</span>

<span class="fc" id="L96">			visited[source] = true;</span>
<span class="fc" id="L97">			edgeIters.add(g.edges(source));</span>
<span class="fc" id="L98">			isValid = true;</span>
<span class="fc" id="L99">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc bfc" id="L103" title="All 2 branches covered.">			if (isValid)</span>
<span class="fc" id="L104">				return true;</span>
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">			if (edgeIters.isEmpty())</span>
<span class="nc" id="L106">				return false;</span>
			for (;;) {
<span class="fc bfc" id="L108" title="All 2 branches covered.">				for (EdgeIter eit = edgeIters.get(edgeIters.size() - 1); eit.hasNext();) {</span>
<span class="fc" id="L109">					int e = eit.nextInt();</span>
<span class="fc" id="L110">					int v = eit.v();</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">					if (visited[v])</span>
<span class="fc" id="L112">						continue;</span>
<span class="fc" id="L113">					visited[v] = true;</span>
<span class="fc" id="L114">					edgeIters.add(g.edges(v));</span>
<span class="fc" id="L115">					edgePath.add(e);</span>
<span class="fc" id="L116">					return isValid = true;</span>
				}
<span class="fc" id="L118">				edgeIters.remove(edgeIters.size() - 1);</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">				if (edgeIters.isEmpty()) {</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">					assert edgePath.isEmpty();</span>
<span class="fc" id="L121">					return false;</span>
				}
<span class="fc" id="L123">				edgePath.removeInt(edgePath.size() - 1);</span>
			}
		}

		@Override
		public int nextInt() {
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">			if (!hasNext())</span>
<span class="nc" id="L130">				throw new NoSuchElementException();</span>
<span class="fc" id="L131">			isValid = false;</span>
<span class="fc" id="L132">			return edgeIters.get(edgeIters.size() - 1).u();</span>
		}

		public IntList edgePath() {
<span class="fc" id="L136">			return edgePath;</span>
		}
	}

	/**
	 * Find a valid path from u to v
	 *
	 * This function uses BFS, which will result in the shortest path in the number
	 * of edges
	 *
	 * @param g a graph
	 * @param u source vertex
	 * @param v target vertex
	 * @return list of edges that represent a valid path from u to v, null if path
	 *         not found
	 */
	public static IntList findPath(Graph g, int u, int v) {
<span class="fc" id="L153">		IntArrayList path = new IntArrayList();</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">		if (u == v)</span>
<span class="fc" id="L155">			return path;</span>
<span class="fc" id="L156">		boolean reverse = true;</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">		if (g instanceof UGraph) {</span>
<span class="fc" id="L158">			int t = u;</span>
<span class="fc" id="L159">			u = v;</span>
<span class="fc" id="L160">			v = t;</span>
<span class="fc" id="L161">			reverse = false;</span>
		}
<span class="fc" id="L163">		int n = g.vertices().size();</span>
<span class="fc" id="L164">		int[] backtrack = new int[n];</span>
<span class="fc" id="L165">		Arrays.fill(backtrack, -1);</span>

<span class="pc bpc" id="L167" title="1 of 2 branches missed.">		for (BFSIter it = new BFSIter(g, u); it.hasNext();) {</span>
<span class="fc" id="L168">			int p = it.nextInt();</span>
<span class="fc" id="L169">			backtrack[p] = it.inEdge();</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">			if (p == v)</span>
<span class="fc" id="L171">				break;</span>
<span class="fc" id="L172">		}</span>

<span class="pc bpc" id="L174" title="1 of 2 branches missed.">		if (backtrack[v] == -1)</span>
<span class="nc" id="L175">			return null;</span>

<span class="fc bfc" id="L177" title="All 2 branches covered.">		for (int p = v; p != u;) {</span>
<span class="fc" id="L178">			int e = backtrack[p];</span>
<span class="fc" id="L179">			path.add(e);</span>
<span class="fc" id="L180">			p = g.edgeEndpoint(e, p);</span>
<span class="fc" id="L181">		}</span>

<span class="fc bfc" id="L183" title="All 2 branches covered.">		if (reverse)</span>
<span class="fc" id="L184">			IntArrays.reverse(path.elements(), 0, path.size());</span>
<span class="fc" id="L185">		return path;</span>
	}

	public static boolean isTree(Graph g) {
<span class="fc" id="L189">		return isTree(g, 0);</span>
	}

	public static boolean isTree(Graph g, int root) {
<span class="fc" id="L193">		return isForst(g, new int[] { root });</span>
	}

	public static boolean isForst(Graph g) {
<span class="nc" id="L197">		int n = g.vertices().size();</span>
<span class="nc" id="L198">		int[] roots = new int[n];</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">		for (int u = 0; u &lt; n; u++)</span>
<span class="nc" id="L200">			roots[u] = u;</span>
<span class="nc" id="L201">		return isForst(g, roots, true);</span>
	}

	public static boolean isForst(Graph g, int[] roots) {
<span class="fc" id="L205">		return isForst(g, roots, false);</span>
	}

	private static boolean isForst(Graph g, int[] roots, boolean allowVisitedRoot) {
<span class="fc" id="L209">		int n = g.vertices().size();</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">		if (n == 0)</span>
<span class="nc" id="L211">			return true;</span>
<span class="fc" id="L212">		boolean directed = g instanceof DiGraph;</span>

<span class="fc" id="L214">		boolean[] visited = new boolean[n];</span>
<span class="fc" id="L215">		int[] parent = new int[n];</span>
<span class="fc" id="L216">		Arrays.fill(parent, -1);</span>

<span class="fc" id="L218">		StackIntFixSize stack = new StackIntFixSize(n);</span>
<span class="fc" id="L219">		int visitedCount = 0;</span>

<span class="fc bfc" id="L221" title="All 2 branches covered.">		for (int i = 0; i &lt; roots.length; i++) {</span>
<span class="fc" id="L222">			int root = roots[i];</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">			if (visited[root]) {</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">				if (allowVisitedRoot)</span>
<span class="nc" id="L225">					continue;</span>
<span class="nc" id="L226">				return false;</span>
			}

<span class="fc" id="L229">			stack.push(root);</span>
<span class="fc" id="L230">			visited[root] = true;</span>

<span class="fc bfc" id="L232" title="All 2 branches covered.">			while (!stack.isEmpty()) {</span>
<span class="fc" id="L233">				int u = stack.pop();</span>
<span class="fc" id="L234">				visitedCount++;</span>

<span class="fc bfc" id="L236" title="All 2 branches covered.">				for (EdgeIter eit = g.edges(u); eit.hasNext();) {</span>
<span class="fc" id="L237">					eit.nextInt();</span>
<span class="fc" id="L238">					int v = eit.v();</span>
<span class="pc bpc" id="L239" title="1 of 4 branches missed.">					if (!directed &amp;&amp; v == parent[u])</span>
<span class="fc" id="L240">						continue;</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">					if (visited[v])</span>
<span class="fc" id="L242">						return false;</span>
<span class="fc" id="L243">					visited[v] = true;</span>
<span class="fc" id="L244">					stack.push(v);</span>
<span class="fc" id="L245">					parent[v] = u;</span>
<span class="fc" id="L246">				}</span>
<span class="fc" id="L247">			}</span>
		}

<span class="fc bfc" id="L250" title="All 2 branches covered.">		return visitedCount == n;</span>
	}

	/**
	 * Find all connectivity components in the graph
	 *
	 * The connectivity components (CC) are groups of vertices where it's possible
	 * to reach each one from one another.
	 *
	 * This function support undirected graphs only
	 *
	 * @param g an undirected graph
	 * @return (CC number, [vertex]-&gt;[CC])
	 * @throws IllegalArgumentException if the graph is directed
	 */
	public static Pair&lt;Integer, int[]&gt; findConnectivityComponents(UGraph g) {
<span class="fc" id="L266">		int n = g.vertices().size();</span>
<span class="fc" id="L267">		StackIntFixSize stack = new StackIntFixSize(n);</span>

<span class="fc" id="L269">		int[] comp = new int[n];</span>
<span class="fc" id="L270">		Arrays.fill(comp, -1);</span>
<span class="fc" id="L271">		int compNum = 0;</span>

<span class="fc bfc" id="L273" title="All 2 branches covered.">		for (int r = 0; r &lt; n; r++) {</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">			if (comp[r] != -1)</span>
<span class="fc" id="L275">				continue;</span>

<span class="fc" id="L277">			stack.push(r);</span>
<span class="fc" id="L278">			comp[r] = compNum;</span>

<span class="fc bfc" id="L280" title="All 2 branches covered.">			while (!stack.isEmpty()) {</span>
<span class="fc" id="L281">				int u = stack.pop();</span>

<span class="fc bfc" id="L283" title="All 2 branches covered.">				for (EdgeIter eit = g.edges(u); eit.hasNext();) {</span>
<span class="fc" id="L284">					eit.nextInt();</span>
<span class="fc" id="L285">					int v = eit.v();</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">					if (comp[v] != -1)</span>
<span class="fc" id="L287">						continue;</span>
<span class="fc" id="L288">					comp[v] = compNum;</span>
<span class="fc" id="L289">					stack.push(v);</span>
<span class="fc" id="L290">				}</span>
<span class="fc" id="L291">			}</span>
<span class="fc" id="L292">			compNum++;</span>
		}
<span class="fc" id="L294">		return Pair.of(Integer.valueOf(compNum), comp);</span>
	}

	/**
	 * Find all strong connectivity components
	 *
	 * The connectivity components (CC) are groups of vertices where it's possible
	 * to reach each one from one another.
	 *
	 * This function is specifically for directed graphs.
	 *
	 * @param g a directed graph
	 * @return (CC number, [vertex]-&gt;[CC])
	 */
	public static Pair&lt;Integer, int[]&gt; findStrongConnectivityComponents(DiGraph g) {
<span class="fc" id="L309">		int n = g.vertices().size();</span>

<span class="fc" id="L311">		int[] comp = new int[n];</span>
<span class="fc" id="L312">		Arrays.fill(comp, -1);</span>
<span class="fc" id="L313">		int compNum = 0;</span>

<span class="fc" id="L315">		int[] dfsPath = new int[n];</span>
<span class="fc" id="L316">		EdgeIter[] edges = new EdgeIter[n];</span>

<span class="fc" id="L318">		int[] c = new int[n];</span>
<span class="fc" id="L319">		int[] s = new int[n];</span>
<span class="fc" id="L320">		int[] p = new int[n];</span>
<span class="fc" id="L321">		int cNext = 1, sSize = 0, pSize = 0;</span>

<span class="fc bfc" id="L323" title="All 2 branches covered.">		for (int r = 0; r &lt; n; r++) {</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">			if (comp[r] != -1)</span>
<span class="fc" id="L325">				continue;</span>
<span class="fc" id="L326">			dfsPath[0] = r;</span>
<span class="fc" id="L327">			edges[0] = g.edgesOut(r);</span>
<span class="fc" id="L328">			c[r] = cNext++;</span>
<span class="fc" id="L329">			s[sSize++] = p[pSize++] = r;</span>

<span class="fc" id="L331">			dfs: for (int depth = 0;;) {</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">				for (EdgeIter eit = edges[depth]; eit.hasNext();) {</span>
<span class="fc" id="L333">					eit.nextInt();</span>
<span class="fc" id="L334">					int v = eit.v();</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">					if (c[v] == 0) {</span>
<span class="fc" id="L336">						c[v] = cNext++;</span>
<span class="fc" id="L337">						s[sSize++] = p[pSize++] = v;</span>

<span class="fc" id="L339">						dfsPath[++depth] = v;</span>
<span class="fc" id="L340">						edges[depth] = g.edgesOut(v);</span>
<span class="fc" id="L341">						continue dfs;</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">					} else if (comp[v] == -1)</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">						while (c[p[pSize - 1]] &gt; c[v])</span>
<span class="fc" id="L344">							pSize--;</span>
<span class="fc" id="L345">				}</span>
<span class="fc" id="L346">				int u = dfsPath[depth];</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">				if (p[pSize - 1] == u) {</span>
					int v;
					do {
<span class="fc" id="L350">						v = s[--sSize];</span>
<span class="fc" id="L351">						comp[v] = compNum;</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">					} while (v != u);</span>
<span class="fc" id="L353">					compNum++;</span>
<span class="fc" id="L354">					pSize--;</span>
				}

<span class="fc" id="L357">				edges[depth] = null;</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">				if (depth-- == 0)</span>
<span class="fc" id="L359">					break;</span>
<span class="fc" id="L360">			}</span>
		}
<span class="fc" id="L362">		return Pair.of(Integer.valueOf(compNum), comp);</span>
	}

	public static int[] calcTopologicalSortingDAG(DiGraph g) {
<span class="fc" id="L366">		int n = g.vertices().size();</span>
<span class="fc" id="L367">		int[] inDegree = new int[n];</span>
<span class="fc" id="L368">		QueueIntFixSize queue = new QueueIntFixSize(n);</span>
<span class="fc" id="L369">		int[] topolSort = new int[n];</span>
<span class="fc" id="L370">		int topolSortSize = 0;</span>

		// Cache in degree of all vertices
<span class="fc bfc" id="L373" title="All 2 branches covered.">		for (int v = 0; v &lt; n; v++)</span>
<span class="fc" id="L374">			inDegree[v] = g.degreeIn(v);</span>

		// Find vertices with zero in degree and insert them to the queue
<span class="fc bfc" id="L377" title="All 2 branches covered.">		for (int v = 0; v &lt; n; v++)</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">			if (inDegree[v] == 0)</span>
<span class="fc" id="L379">				queue.push(v);</span>

		// Poll vertices from the queue and &quot;remove&quot; each one from the tree and add new
		// zero in degree vertices to the queue
<span class="fc bfc" id="L383" title="All 2 branches covered.">		while (!queue.isEmpty()) {</span>
<span class="fc" id="L384">			int u = queue.pop();</span>
<span class="fc" id="L385">			topolSort[topolSortSize++] = u;</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">			for (EdgeIter eit = g.edgesOut(u); eit.hasNext();) {</span>
<span class="fc" id="L387">				eit.nextInt();</span>
<span class="fc" id="L388">				int v = eit.v();</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">				if (--inDegree[v] == 0)</span>
<span class="fc" id="L390">					queue.push(v);</span>
<span class="fc" id="L391">			}</span>
<span class="fc" id="L392">		}</span>

<span class="pc bpc" id="L394" title="1 of 2 branches missed.">		if (topolSortSize != n)</span>
<span class="nc" id="L395">			throw new IllegalArgumentException(&quot;G is not a directed acyclic graph (DAG)&quot;);</span>

<span class="fc" id="L397">		return topolSort;</span>
	}

	public static SSSP.Result calcDistancesDAG(DiGraph g, EdgeWeightFunc w, int source) {
<span class="fc" id="L401">		int n = g.vertices().size();</span>
<span class="fc" id="L402">		int[] backtrack = new int[n];</span>
<span class="fc" id="L403">		Arrays.fill(backtrack, -1);</span>
<span class="fc" id="L404">		double[] distances = new double[n];</span>
<span class="fc" id="L405">		Arrays.fill(distances, Double.POSITIVE_INFINITY);</span>
<span class="fc" id="L406">		distances[source] = 0;</span>

<span class="fc" id="L408">		int[] topolSort = calcTopologicalSortingDAG(g);</span>
<span class="fc" id="L409">		boolean sourceSeen = false;</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">		for (int u : topolSort) {</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">			if (!sourceSeen) {</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">				if (u != source)</span>
<span class="fc" id="L413">					continue;</span>
<span class="fc" id="L414">				sourceSeen = true;</span>
			}
<span class="fc bfc" id="L416" title="All 2 branches covered.">			for (EdgeIter eit = g.edgesOut(u); eit.hasNext();) {</span>
<span class="fc" id="L417">				int e = eit.nextInt();</span>
<span class="fc" id="L418">				int v = eit.v();</span>
<span class="fc" id="L419">				double d = distances[u] + w.weight(e);</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">				if (d &lt; distances[v]) {</span>
<span class="fc" id="L421">					distances[v] = d;</span>
<span class="fc" id="L422">					backtrack[v] = e;</span>
				}
<span class="fc" id="L424">			}</span>
		}

<span class="fc" id="L427">		return new SSSPResultsImpl(g, distances, backtrack);</span>
	}

	public static int getFullyBranchingTreeDepth(Graph t, int root) {
<span class="fc" id="L431">		for (int parent = -1, u = root, depth = 0;; depth++) {</span>
<span class="fc" id="L432">			int v = parent;</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">			for (EdgeIter eit = t.edges(u); eit.hasNext();) {</span>
<span class="fc" id="L434">				eit.nextInt();</span>
<span class="fc" id="L435">				v = eit.v();</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">				if (v != parent)</span>
<span class="fc" id="L437">					break;</span>
			}
<span class="fc bfc" id="L439" title="All 2 branches covered.">			if (v == parent)</span>
<span class="fc" id="L440">				return depth;</span>
<span class="fc" id="L441">			parent = u;</span>
<span class="fc" id="L442">			u = v;</span>
		}
	}

	public static int[] calcDegree(UGraph g, IntCollection edges) {
<span class="fc" id="L447">		int[] degree = new int[g.vertices().size()];</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">		for (IntIterator eit = edges.iterator(); eit.hasNext();) {</span>
<span class="fc" id="L449">			int e = eit.nextInt();</span>
<span class="fc" id="L450">			degree[g.edgeSource(e)]++;</span>
<span class="fc" id="L451">			degree[g.edgeTarget(e)]++;</span>
<span class="fc" id="L452">		}</span>
<span class="fc" id="L453">		return degree;</span>
	}

	public static IntList calcEulerianTour(UGraph g) {
<span class="fc" id="L457">		int n = g.vertices().size();</span>

<span class="fc" id="L459">		int start = -1, end = -1;</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">		for (int u = 0; u &lt; n; u++) {</span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">			if (g.degree(u) % 2 == 0)</span>
<span class="fc" id="L462">				continue;</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">			if (start == -1)</span>
<span class="nc" id="L464">				start = u;</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">			else if (end == -1)</span>
<span class="nc" id="L466">				end = u;</span>
			else
<span class="nc" id="L468">				throw new IllegalArgumentException(</span>
						&quot;More than two vertices have an odd degree (&quot; + start + &quot;, &quot; + end + &quot;, &quot; + u + &quot;)&quot;);
		}
<span class="pc bpc" id="L471" title="3 of 4 branches missed.">		if (start != -1 &amp;&amp; end == -1)</span>
<span class="nc" id="L472">			throw new IllegalArgumentException(</span>
					&quot;Eulerian tour exists only if all vertices have even degree or only two vertices have odd degree&quot;);
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">		if (start == -1)</span>
<span class="fc" id="L475">			start = 0;</span>

<span class="fc" id="L477">		IntArrayList tour = new IntArrayList(g.edges().size());</span>
<span class="fc" id="L478">		IntSet usedEdges = new IntOpenHashSet();</span>
<span class="fc" id="L479">		EdgeIter[] iters = new EdgeIter[n];</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">		for (int u = 0; u &lt; n; u++)</span>
<span class="fc" id="L481">			iters[u] = g.edges(u);</span>

<span class="fc" id="L483">		StackIntFixSize queue = new StackIntFixSize(g.edges().size());</span>

<span class="fc" id="L485">		for (int u = start;;) {</span>
			findCycle: for (;;) {
				int e, v;
<span class="fc" id="L488">				for (EdgeIter iter = iters[u];;) {</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">					if (!iter.hasNext())</span>
<span class="fc" id="L490">						break findCycle;</span>
<span class="fc" id="L491">					e = iter.nextInt();</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">					if (!usedEdges.contains(e)) {</span>
<span class="fc" id="L493">						v = iter.v();</span>
<span class="fc" id="L494">						break;</span>
					}
				}
<span class="fc" id="L497">				usedEdges.add(e);</span>
<span class="fc" id="L498">				queue.push(e);</span>
<span class="fc" id="L499">				u = v;</span>
<span class="fc" id="L500">			}</span>

<span class="fc bfc" id="L502" title="All 2 branches covered.">			if (queue.isEmpty())</span>
<span class="fc" id="L503">				break;</span>

<span class="fc" id="L505">			int e = queue.pop();</span>
<span class="fc" id="L506">			tour.add(e);</span>
<span class="fc" id="L507">			u = g.edgeEndpoint(e, u);</span>
<span class="fc" id="L508">		}</span>

<span class="fc" id="L510">		IntArrays.reverse(tour.elements(), 0, tour.size());</span>
<span class="fc" id="L511">		return tour;</span>
	}

	public static String formatAdjacencyMatrix(Graph g) {
<span class="nc bnc" id="L515" title="All 2 branches missed.">		return formatAdjacencyMatrix(g, e -&gt; e == -1 ? &quot;0&quot; : &quot;1&quot;);</span>
	}

	public static String formatAdjacencyMatrixWeighted(Graph g, EdgeWeightFunc w) {
<span class="nc" id="L519">		double minWeight = Double.MAX_VALUE;</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">		for (IntIterator it = g.edges().iterator(); it.hasNext();) {</span>
<span class="nc" id="L521">			int e = it.nextInt();</span>
<span class="nc" id="L522">			double ew = w.weight(e);</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">			if (ew &lt; minWeight)</span>
<span class="nc" id="L524">				minWeight = ew;</span>
<span class="nc" id="L525">		}</span>

<span class="nc" id="L527">		int unlimitedPrecision = 64;</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">		int precision = minWeight &gt;= 1 ? 2 : Math.min(unlimitedPrecision, (int) -Math.log10(minWeight));</span>

<span class="nc bnc" id="L530" title="All 2 branches missed.">		return precision == unlimitedPrecision</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">				? formatAdjacencyMatrix(g, e -&gt; e == -1 ? &quot;-&quot; : Double.toString(w.weight(e)))</span>
<span class="nc" id="L532">				: formatAdjacencyMatrix(g,</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">						e -&gt; e == -1 ? &quot;-&quot; : String.format(&quot;%.&quot; + precision + &quot;f&quot;, Double.valueOf(w.weight(e))));</span>
	}

	public static String formatAdjacencyMatrixWeightedInt(Graph g, EdgeWeightFunc.Int w) {
<span class="nc bnc" id="L537" title="All 2 branches missed.">		return formatAdjacencyMatrix(g, e -&gt; e == -1 ? &quot;-&quot; : Integer.toString(w.weightInt(e)));</span>
	}

	public static String formatAdjacencyMatrix(Graph g, Int2ObjectFunction&lt;String&gt; formatter) {
<span class="nc" id="L541">		int n = g.vertices().size();</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">		if (n == 0)</span>
<span class="nc" id="L543">			return &quot;[]&quot;;</span>

		/* format all edges */
<span class="nc" id="L546">		String[][] strs = new String[n][n];</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">		for (int u = 0; u &lt; n; u++) {</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">			for (EdgeIter eit = g.edges(u); eit.hasNext();) {</span>
<span class="nc" id="L549">				int e = eit.nextInt();</span>
<span class="nc" id="L550">				strs[u][eit.v()] = formatter.apply(e);</span>
<span class="nc" id="L551">			}</span>
		}

		/* calculate cell size */
<span class="nc" id="L555">		int maxStr = 0;</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">		for (int u = 0; u &lt; n; u++) {</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">			for (int v = 0; v &lt; n; v++) {</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">				if (strs[u][v] == null)</span>
<span class="nc" id="L559">					strs[u][v] = formatter.apply(null);</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">				if (strs[u][v].length() &gt; maxStr)</span>
<span class="nc" id="L561">					maxStr = strs[u][v].length();</span>
			}
		}
<span class="nc" id="L564">		int vertexLabelCellSize = String.valueOf(n - 1).length() + 1;</span>
<span class="nc" id="L565">		int cellSize = Math.max(maxStr + 1, vertexLabelCellSize);</span>

		/* format header row */
<span class="nc" id="L568">		StringBuilder s = new StringBuilder();</span>
<span class="nc" id="L569">		s.append(strMult(&quot; &quot;, vertexLabelCellSize));</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">		for (int v = 0; v &lt; n; v++)</span>
<span class="nc" id="L571">			s.append(String.format(&quot;% &quot; + cellSize + &quot;d&quot;, Integer.valueOf(v)));</span>
<span class="nc" id="L572">		s.append('\n');</span>

		/* format adjacency matrix */
<span class="nc bnc" id="L575" title="All 2 branches missed.">		for (int u = 0; u &lt; n; u++) {</span>
<span class="nc" id="L576">			s.append(String.format(&quot;% &quot; + vertexLabelCellSize + &quot;d&quot;, Integer.valueOf(u)));</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">			for (int v = 0; v &lt; n; v++) {</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">				if (strs[u][v].length() &lt; cellSize)</span>
<span class="nc" id="L579">					s.append(strMult(&quot; &quot;, cellSize - strs[u][v].length()));</span>
<span class="nc" id="L580">				s.append(strs[u][v]);</span>
			}
<span class="nc" id="L582">			s.append('\n');</span>
		}

<span class="nc" id="L585">		return s.toString();</span>
	}

	private static String strMult(String s, int n) {
<span class="nc" id="L589">		return String.join(&quot;&quot;, Collections.nCopies(n, s));</span>
	}

	public static DiGraph referenceGraph(DiGraph g, Object refEdgeWeightKey) {
<span class="fc" id="L593">		DiGraph g0 = new GraphArrayDirected(g.vertices().size());</span>
<span class="fc" id="L594">		Weights.Int edgeRef = g0.addEdgesWeight(refEdgeWeightKey).ofInts();</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">		for (IntIterator it = g.edges().iterator(); it.hasNext();) {</span>
<span class="fc" id="L596">			int e = it.nextInt();</span>
<span class="fc" id="L597">			int e0 = g0.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L598">			edgeRef.set(e0, e);</span>
<span class="fc" id="L599">		}</span>
<span class="fc" id="L600">		return g0;</span>
	}

	public static UGraph referenceGraph(UGraph g, Object refEdgeWeightKey) {
<span class="fc" id="L604">		UGraph g0 = new GraphArrayUndirected(g.vertices().size());</span>
<span class="fc" id="L605">		Weights.Int edgeRef = g0.addEdgesWeight(refEdgeWeightKey).ofInts();</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">		for (IntIterator it = g.edges().iterator(); it.hasNext();) {</span>
<span class="fc" id="L607">			int e = it.nextInt();</span>
<span class="fc" id="L608">			int e0 = g0.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L609">			edgeRef.set(e0, e);</span>
<span class="fc" id="L610">		}</span>
<span class="fc" id="L611">		return g0;</span>
	}

	public static interface PathIter {

		public boolean hasNext();

		public int nextEdge();

		public int u();

		public int v();

		static PathIter of(Graph g0, IntList edgeList) {
<span class="fc bfc" id="L625" title="All 2 branches covered.">			if (g0 instanceof UGraph g) {</span>
<span class="fc" id="L626">				return new PathIterUndirected(g, edgeList);</span>
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">			} else if (g0 instanceof DiGraph g) {</span>
<span class="fc" id="L628">				return new PathIterDirected(g, edgeList);</span>
			} else {
<span class="nc" id="L630">				throw new IllegalArgumentException();</span>
			}
		}

	}

<span class="fc" id="L636">	private static class PathIterUndirected implements PathIter {</span>

		private final UGraph g;
		private final IntIterator it;
<span class="fc" id="L640">		private int e = -1, v = -1;</span>

<span class="fc" id="L642">		PathIterUndirected(UGraph g, IntList path) {</span>
<span class="fc" id="L643">			this.g = g;</span>
<span class="fc bfc" id="L644" title="All 2 branches covered.">			if (path.size() == 1) {</span>
<span class="fc" id="L645">				v = g.edgeTarget(path.getInt(0));</span>
<span class="fc bfc" id="L646" title="All 2 branches covered.">			} else if (path.size() &gt;= 2) {</span>
<span class="fc" id="L647">				int e0 = path.getInt(0), e1 = path.getInt(1);</span>
<span class="fc" id="L648">				int u0 = g.edgeSource(e0), v0 = g.edgeTarget(e0);</span>
<span class="fc" id="L649">				int u1 = g.edgeSource(e1), v1 = g.edgeTarget(e1);</span>
<span class="fc bfc" id="L650" title="All 4 branches covered.">				if (v0 == u1 || v0 == v1) {</span>
<span class="fc" id="L651">					v = u0;</span>
				} else {
<span class="fc" id="L653">					v = v0;</span>
<span class="pc bpc" id="L654" title="1 of 4 branches missed.">					assert (u0 == u1 || u0 == v1) : &quot;not a path&quot;;</span>
				}
			}
<span class="fc" id="L657">			it = path.iterator();</span>
<span class="fc" id="L658">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc" id="L662">			return it.hasNext();</span>
		}

		@Override
		public int nextEdge() {
<span class="fc" id="L667">			e = it.nextInt();</span>
<span class="pc bpc" id="L668" title="1 of 4 branches missed.">			assert v == g.edgeSource(e) || v == g.edgeTarget(e);</span>
<span class="fc" id="L669">			v = g.edgeEndpoint(e, v);</span>
<span class="fc" id="L670">			return e;</span>
		}

		@Override
		public int u() {
<span class="fc" id="L675">			return g.edgeEndpoint(e, v);</span>
		}

		@Override
		public int v() {
<span class="fc" id="L680">			return v;</span>
		}

	}

	private static class PathIterDirected implements PathIter {

		private final DiGraph g;
		private final IntIterator it;
<span class="fc" id="L689">		private int e = -1;</span>

<span class="fc" id="L691">		PathIterDirected(DiGraph g, IntList path) {</span>
<span class="fc" id="L692">			this.g = g;</span>
<span class="fc" id="L693">			it = path.iterator();</span>
<span class="fc" id="L694">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc" id="L698">			return it.hasNext();</span>
		}

		@Override
		public int nextEdge() {
<span class="fc" id="L703">			e = it.nextInt();</span>
<span class="fc" id="L704">			return e;</span>
		}

		@Override
		public int u() {
<span class="nc" id="L709">			return g.edgeSource(e);</span>
		}

		@Override
		public int v() {
<span class="nc" id="L714">			return g.edgeTarget(e);</span>
		}

	}

	@SuppressWarnings(&quot;unchecked&quot;)
	static UGraph subGraph(UGraph g, IntCollection edgeSet) {
<span class="fc" id="L721">		final Object edgeMappingKey = new Object();</span>
<span class="fc" id="L722">		UGraph g1 = new GraphArrayUndirected(g.vertices().size());</span>

<span class="fc" id="L724">		Weights.Int sub2Edge = g1.addEdgesWeight(edgeMappingKey).ofInts();</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">		for (IntIterator it = edgeSet.iterator(); it.hasNext();) {</span>
<span class="fc" id="L726">			int e = it.nextInt();</span>
<span class="fc" id="L727">			int u = g.edgeSource(e), v = g.edgeTarget(e);</span>
<span class="fc" id="L728">			int s = g1.addEdge(u, v);</span>
<span class="fc" id="L729">			sub2Edge.set(s, e);</span>
<span class="fc" id="L730">		}</span>
<span class="fc bfc" id="L731" title="All 2 branches covered.">		for (Object key : g.getEdgesWeightsKeys()) {</span>
<span class="fc" id="L732">			Weights&lt;?&gt; data0 = g.edgesWeight(key);</span>

<span class="pc bpc" id="L734" title="1 of 2 branches missed.">			if (data0 instanceof Weights.Int data) {</span>
<span class="nc" id="L735">				int defVal = data.defaultValInt();</span>
<span class="nc" id="L736">				Weights.Int datas = g1.addEdgesWeight(key).defVal(defVal).ofInts();</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">				for (IntIterator it = g1.edges().iterator(); it.hasNext();) {</span>
<span class="nc" id="L738">					int s = it.nextInt();</span>
<span class="nc" id="L739">					int w = data.getInt(sub2Edge.getInt(s));</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">					if (w != defVal)</span>
<span class="nc" id="L741">						datas.set(s, w);</span>
<span class="nc" id="L742">				}</span>

<span class="pc bpc" id="L744" title="1 of 2 branches missed.">			} else if (data0 instanceof Weights.Double data) {</span>
<span class="nc" id="L745">				double defVal = data.defaultValDouble();</span>
<span class="nc" id="L746">				Weights.Double datas = g1.addEdgesWeight(key).defVal(defVal).ofDoubles();</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">				for (IntIterator it = g1.edges().iterator(); it.hasNext();) {</span>
<span class="nc" id="L748">					int s = it.nextInt();</span>
<span class="nc" id="L749">					double w = data.getDouble(sub2Edge.getInt(s));</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">					if (w != defVal)</span>
<span class="nc" id="L751">						datas.set(s, w);</span>
<span class="nc" id="L752">				}</span>

<span class="nc" id="L754">			} else {</span>
<span class="fc" id="L755">				Object defVal = data0.defaultVal();</span>
				@SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L757">				Weights datas = g1.addEdgesWeight(key).defVal(defVal).ofObjs();</span>
<span class="fc bfc" id="L758" title="All 2 branches covered.">				for (IntIterator it = g1.edges().iterator(); it.hasNext();) {</span>
<span class="fc" id="L759">					int s = it.nextInt();</span>
<span class="fc" id="L760">					Object w = data0.get(sub2Edge.getInt(s));</span>
<span class="pc bpc" id="L761" title="1 of 2 branches missed.">					if (w != defVal)</span>
<span class="fc" id="L762">						datas.set(s, w);</span>
<span class="fc" id="L763">				}</span>
			}
<span class="fc" id="L765">		}</span>
<span class="fc" id="L766">		g1.removeEdgesWeights(edgeMappingKey);</span>
<span class="fc" id="L767">		return g1;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>