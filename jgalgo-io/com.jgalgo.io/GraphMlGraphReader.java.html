<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GraphMlGraphReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - IO</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.io</a> &gt; <span class="el_source">GraphMlGraphReader.java</span></div><h1>GraphMlGraphReader.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.io;

import java.io.IOException;
import java.io.Reader;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.function.BiConsumer;
import java.util.function.Function;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import com.jgalgo.graph.Graph;
import com.jgalgo.graph.GraphBuilder;
import com.jgalgo.graph.GraphFactory;
import com.jgalgo.graph.IdBuilder;
import com.jgalgo.graph.IntGraphFactory;
import com.jgalgo.graph.Weights;
import com.jgalgo.graph.WeightsBool;
import com.jgalgo.graph.WeightsDouble;
import com.jgalgo.graph.WeightsFloat;
import com.jgalgo.graph.WeightsInt;
import com.jgalgo.graph.WeightsLong;
import com.jgalgo.graph.WeightsObj;

/**
 * Read a graph in 'GraphML' format.
 *
 * &lt;p&gt;
 * GraphML is an XML-based format for graphs. Both directed and undirected graphs are supported, along with mixed graphs
 * (some edges are directed while others are undirected) although the {@link Graph} does not supported mixed graphs
 * (therefore the reader also doesn't support it). The format support graphs with vertices and edges of any type, as
 * long as they can be written as an XML attribute string. The format also support multiple weights for vertices and
 * edges, of type {@code int}, {@code long}, {@code float}, {@code double}, {@code boolean} and {@code String}, and a
 * default value for each weight type.
 *
 * &lt;p&gt;
 * Identifiers of vertices are mandatory, and must be unique. Identifiers of edges are optional, if not specified the
 * reader will try generate them using a builder provided by the user, or a default builder for certain types (see
 * {@link #setEdgeBuilder(IdBuilder)} and {@link #setEdgeBuilderDefault(Class)}). Vertices identifiers (and edges
 * identifiers if specified) are parsed using a parser provided by the user, or a default parser for certain types (see
 * {@link #setVertexParserDefault(Class)} and {@link #setEdgeParserDefault(Class)}).
 *
 * &lt;p&gt;
 * The GraphML format support both self edges and parallel edges.
 *
 * @see    GraphMlGraphWriter
 * @author Barak Ugav
 */
public class GraphMlGraphReader&lt;V, E&gt; extends GraphIoUtils.AbstractGraphReader&lt;V, E&gt; {

	private Class&lt;V&gt; vertexType;
	private Class&lt;E&gt; edgeType;
	private Function&lt;String, V&gt; vertexParser;
	private Function&lt;String, E&gt; edgeParser;
	private IdBuilder&lt;E&gt; edgeBuilder;

	/**
	 * Create a new reader.
	 *
	 * &lt;p&gt;
	 * The user should set the vertex/edge parsers and edge builder manually using {@link #setVertexParser(Function)},
	 * {@link #setEdgeParser(Function)} and {@link #setEdgeBuilder(IdBuilder)}. Setting the vertex parser is mandatory,
	 * while setting the edge parser is only required if edges identifiers are specified. Similarly, setting the edge
	 * builder is only required if edges identifiers are not specified.
	 */
<span class="fc" id="L86">	public GraphMlGraphReader() {}</span>

	/**
	 * Create a new reader with default parsers and builders for the given vertex and edge types.
	 *
	 * &lt;p&gt;
	 * During the reading process, the reader will use the parser to convert the vertex identifiers from string to the
	 * given type, and similarly for edges if edges identifiers are specified. If edges identifiers are not specified,
	 * the reader will use the builder to generate them. Default parsers exists for types {@code byte}, {@code short},
	 * {@code int}, {@code long}, {@code float}, {@code double} and {@code String}. Default edge builder is instantiated
	 * using {@link IdBuilder#defaultBuilder(Class)}, see it documentation for supported types If the given types are
	 * not supported by the default parsers and builder, the reader will throw an exception. In such case, the
	 * constructor {@link #GraphMlGraphReader()} should be used, and the user should set the vertex/edge parsers and
	 * edge builder manually using {@link #setVertexParser(Function)}, {@link #setEdgeParser(Function)} and
	 * {@link #setEdgeBuilder(IdBuilder)}.
	 *
	 * @param  vertexType               the type of the vertices
	 * @param  edgeType                 the type of the edges
	 * @throws IllegalArgumentException if the given types are not supported by the default vertex/edge parsers and edge
	 *                                      builder. The supported types are {@code byte}, {@code short}, {@code int},
	 *                                      {@code long}, {@code float}, {@code double} and {@code String}.
	 * @see                             #setVertexParserDefault(Class)
	 * @see                             #setEdgeParserDefault(Class)
	 * @see                             #setEdgeBuilderDefault(Class)
	 */
<span class="fc" id="L111">	public GraphMlGraphReader(Class&lt;V&gt; vertexType, Class&lt;E&gt; edgeType) {</span>
<span class="fc" id="L112">		setVertexParserDefault(this.vertexType = vertexType);</span>
<span class="fc" id="L113">		setEdgeParserDefault(this.edgeType = edgeType);</span>
<span class="fc" id="L114">		setEdgeBuilderDefault(this.edgeType);</span>
<span class="fc" id="L115">	}</span>

	/**
	 * Set the parser for the vertices identifiers.
	 *
	 * &lt;p&gt;
	 * The parser is used to convert the vertex identifiers from string to the given vertex type. The parser is
	 * mandatory, and must be set before reading a graph. For default parsers for certain types, see
	 * {@link #setVertexParserDefault(Class)}.
	 *
	 * @param vertexParser a parser for the vertices identifiers
	 */
	public void setVertexParser(Function&lt;String, V&gt; vertexParser) {
<span class="fc" id="L128">		this.vertexParser = Objects.requireNonNull(vertexParser);</span>
<span class="fc" id="L129">	}</span>

	/**
	 * Set the parser for the vertices identifiers, using a default parser for the given vertex type.
	 *
	 * &lt;p&gt;
	 * The parser is used to convert the vertex identifiers from string to the given vertex type. The parser is
	 * mandatory, and must be set before reading a graph. The default parser exists for types {@code byte},
	 * {@code short}, {@code int}, {@code long}, {@code float}, {@code double} and {@code String}. If the given type is
	 * not supported by the default parser, the reader will throw an exception. In such case, the method
	 * {@link #setVertexParser(Function)} should be used for custom parsing.
	 *
	 * @param  vertexType               the type of the vertices
	 * @throws IllegalArgumentException if the given type is not supported by the default parser. The supported types
	 *                                      are {@code byte}, {@code short}, {@code int}, {@code long}, {@code float},
	 *                                      {@code double} and {@code String}.
	 */
	public void setVertexParserDefault(Class&lt;V&gt; vertexType) {
<span class="fc" id="L147">		this.vertexParser = GraphIoUtils.defaultParser(vertexType);</span>
<span class="fc" id="L148">		this.vertexType = vertexType;</span>
<span class="fc" id="L149">	}</span>

	/**
	 * Set the parser for the edges identifiers.
	 *
	 * &lt;p&gt;
	 * The parser is used to convert the edges identifiers from string to the given edge type. The parser is mandatory
	 * if edges identifiers are specified. In case edge identifiers are not specified, an edge builder must be set (see
	 * {@link #setEdgeBuilder(IdBuilder)}). For default parsers for certain types, see
	 * {@link #setEdgeParserDefault(Class)}.
	 *
	 * @param edgeParser a parser for the edges identifiers
	 */
	public void setEdgeParser(Function&lt;String, E&gt; edgeParser) {
<span class="fc" id="L163">		this.edgeParser = Objects.requireNonNull(edgeParser);</span>
<span class="fc" id="L164">	}</span>

	/**
	 * Set the parser for the edges identifiers, using a default parser for the given edge type.
	 *
	 * &lt;p&gt;
	 * The parser is used to convert the edges identifiers from string to the given edge type. The parser is mandatory
	 * if edges identifiers are specified. In case edge identifiers are not specified, an edge builder must be set (see
	 * {@link #setEdgeBuilder(IdBuilder)}). The default parser exists for types {@code byte}, {@code short},
	 * {@code int}, {@code long}, {@code float}, {@code double} and {@code String}. If the given type is not supported
	 * by the default parser, the reader will throw an exception. In such case, the method
	 * {@link #setEdgeParser(Function)} should be used for custom parsing.
	 *
	 * @param  edgeType                 the type of the edges
	 * @throws IllegalArgumentException if the given type is not supported by the default parser. The supported types
	 *                                      are {@code byte}, {@code short}, {@code int}, {@code long}, {@code float},
	 *                                      {@code double} and {@code String}.
	 */
	public void setEdgeParserDefault(Class&lt;E&gt; edgeType) {
<span class="fc" id="L183">		this.edgeParser = GraphIoUtils.defaultParser(edgeType);</span>
<span class="fc" id="L184">		this.edgeType = edgeType;</span>
<span class="fc" id="L185">	}</span>

	/**
	 * Set the builder for the edges identifiers.
	 *
	 * &lt;p&gt;
	 * The builder is used to generate edges identifiers if edges identifiers are not specified. The builder is
	 * mandatory if edges identifiers are not specified. In case edge identifiers are specified, an edge parser must be
	 * set (see {@link #setEdgeParser(Function)}). For default builders for certain types, see
	 * {@link #setEdgeBuilderDefault(Class)}.
	 *
	 * &lt;p&gt;
	 * The edge builder accepts a set of existing edges, and should return a new edge identifier that is not in the set.
	 *
	 * @param edgeBuilder a builder for the edges identifiers
	 */
	public void setEdgeBuilder(IdBuilder&lt;E&gt; edgeBuilder) {
<span class="fc" id="L202">		this.edgeBuilder = Objects.requireNonNull(edgeBuilder);</span>
<span class="fc" id="L203">	}</span>

	/**
	 * Set the builder for the edges identifiers, using a default builder for the given edge type.
	 *
	 * &lt;p&gt;
	 * The builder is used to generate edges identifiers if edges identifiers are not specified. The builder is
	 * mandatory if edges identifiers are not specified. In case edge identifiers are specified, an edge parser must be
	 * set (see {@link #setEdgeParser(Function)}). The default builder is instantiated using
	 * {@link IdBuilder#defaultBuilder(Class)}, see it documentation for supported types. If the given type is not
	 * supported by the default builder, the reader will throw an exception. In such case, the method
	 * {@link #setEdgeBuilder(IdBuilder)} should be used for custom builder.
	 *
	 * @param  edgeType                 the type of the edges
	 * @throws IllegalArgumentException if the given type is not supported by the default builder. See
	 *                                      {@link IdBuilder#defaultBuilder(Class)} for supported types
	 */
	public void setEdgeBuilderDefault(Class&lt;E&gt; edgeType) {
<span class="fc" id="L221">		edgeBuilder = IdBuilder.defaultBuilder(edgeType);</span>
<span class="fc" id="L222">		this.edgeType = edgeType;</span>
<span class="fc" id="L223">	}</span>

	@Override
	GraphBuilder&lt;V, E&gt; readIntoBuilderImpl(Reader reader) throws IOException {
<span class="fc bfc" id="L227" title="All 2 branches covered.">		if (vertexParser == null)</span>
<span class="fc" id="L228">			throw new IllegalStateException(&quot;Vertex parser was not set&quot;);</span>
		try {
			Document document =
<span class="fc" id="L231">					DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(new InputSource(reader));</span>
<span class="fc" id="L232">			Element doc = document.getDocumentElement();</span>
<span class="fc" id="L233">			doc.normalize();</span>

<span class="fc bfc" id="L235" title="All 2 branches covered.">			if (!doc.getTagName().equals(&quot;graphml&quot;))</span>
<span class="fc" id="L236">				throw new IllegalArgumentException(&quot;root element is not 'graphml'&quot;);</span>

			// searchUnexpectedChildren(doc, &quot;graph&quot;, &quot;key&quot;);

<span class="fc" id="L240">			Element graph = XmlUtils.requiredChild(doc, &quot;graph&quot;);</span>
			// searchUnexpectedChildren(graph, &quot;node&quot;, &quot;edge&quot;);

<span class="fc" id="L243">			boolean directed = XmlUtils.requiredAttribute(graph, &quot;edgedefault&quot;).equals(&quot;directed&quot;);</span>
			GraphFactory&lt;V, E&gt; factory;
<span class="fc bfc" id="L245" title="All 4 branches covered.">			if (vertexType == int.class &amp;&amp; edgeType == int.class) {</span>
				@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L247">				GraphFactory&lt;V, E&gt; factory0 = (GraphFactory&lt;V, E&gt;) IntGraphFactory.newInstance(directed);</span>
<span class="fc" id="L248">				factory = factory0;</span>
<span class="fc" id="L249">			} else {</span>
<span class="fc" id="L250">				factory = GraphFactory.newInstance(directed);</span>
			}
<span class="fc" id="L252">			GraphBuilder&lt;V, E&gt; g = factory.allowSelfEdges().allowParallelEdges().newBuilder();</span>
<span class="fc" id="L253">			XmlUtils.optionalAttribute(graph, &quot;parse.nodes&quot;).map(Integer::parseInt).ifPresent(g::ensureVertexCapacity);</span>
<span class="fc" id="L254">			XmlUtils.optionalAttribute(graph, &quot;parse.edges&quot;).map(Integer::parseInt).ifPresent(g::ensureEdgeCapacity);</span>

<span class="fc" id="L256">			Map&lt;String, BiConsumer&lt;V, String&gt;&gt; vWeights = new HashMap&lt;&gt;();</span>
<span class="fc" id="L257">			Map&lt;String, BiConsumer&lt;E, String&gt;&gt; eWeights = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">			for (Element key : XmlUtils.children(doc, &quot;key&quot;)) {</span>
<span class="fc" id="L259">				String weightId = XmlUtils.requiredAttribute(key, &quot;id&quot;);</span>
<span class="fc" id="L260">				String domain = XmlUtils.requiredAttribute(key, &quot;for&quot;);</span>
<span class="fc" id="L261">				String attrName = XmlUtils.requiredAttribute(key, &quot;attr.name&quot;);</span>
<span class="fc" id="L262">				String attrTypeStr = XmlUtils.requiredAttribute(key, &quot;attr.type&quot;);</span>
<span class="fc" id="L263">				String defValStr = XmlUtils.optionalChild(key, &quot;default&quot;).map(Element::getTextContent).orElse(null);</span>

				Class&lt;?&gt; attrType;
				Object defVal;
				Function&lt;Weights&lt;Object, Object&gt;, BiConsumer&lt;Object, String&gt;&gt; setterFactory;
<span class="fc bfc" id="L268" title="All 7 branches covered.">				switch (attrTypeStr) {</span>
					case &quot;int&quot;: {
<span class="fc" id="L270">						attrType = int.class;</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">						defVal = defValStr == null ? null : Integer.valueOf(defValStr);</span>
<span class="fc" id="L272">						setterFactory = weights -&gt; {</span>
							@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L274">							WeightsInt&lt;Object&gt; weights2 = (WeightsInt) weights;</span>
<span class="fc" id="L275">							return (o, val) -&gt; weights2.set(o, Integer.parseInt(val));</span>
						};
<span class="fc" id="L277">						break;</span>
					}
					case &quot;long&quot;: {
<span class="fc" id="L280">						attrType = long.class;</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">						defVal = defValStr == null ? null : Long.valueOf(defValStr);</span>
<span class="fc" id="L282">						setterFactory = weights -&gt; {</span>
							@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L284">							WeightsLong&lt;Object&gt; weights2 = (WeightsLong) weights;</span>
<span class="fc" id="L285">							return (o, val) -&gt; weights2.set(o, Long.parseLong(val));</span>
						};
<span class="fc" id="L287">						break;</span>
					}
					case &quot;float&quot;: {
<span class="fc" id="L290">						attrType = float.class;</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">						defVal = defValStr == null ? null : Float.valueOf(defValStr);</span>
<span class="fc" id="L292">						setterFactory = weights -&gt; {</span>
							@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L294">							WeightsFloat&lt;Object&gt; weights2 = (WeightsFloat) weights;</span>
<span class="fc" id="L295">							return (o, val) -&gt; weights2.set(o, Float.parseFloat(val));</span>
						};
<span class="fc" id="L297">						break;</span>
					}
					case &quot;double&quot;: {
<span class="fc" id="L300">						attrType = double.class;</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">						defVal = defValStr == null ? null : Double.valueOf(defValStr);</span>
<span class="fc" id="L302">						setterFactory = weights -&gt; {</span>
							@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L304">							WeightsDouble&lt;Object&gt; weights2 = (WeightsDouble) weights;</span>
<span class="fc" id="L305">							return (o, val) -&gt; weights2.set(o, Double.parseDouble(val));</span>
						};
<span class="fc" id="L307">						break;</span>
					}
					case &quot;boolean&quot;: {
<span class="fc" id="L310">						attrType = boolean.class;</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">						defVal = defValStr == null ? null : Boolean.valueOf(defValStr);</span>
<span class="fc" id="L312">						setterFactory = weights -&gt; {</span>
							@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L314">							WeightsBool&lt;Object&gt; weights2 = (WeightsBool) weights;</span>
<span class="fc" id="L315">							return (o, val) -&gt; weights2.set(o, Boolean.parseBoolean(val));</span>
						};
<span class="fc" id="L317">						break;</span>
					}
					case &quot;string&quot;: {
<span class="fc" id="L320">						attrType = String.class;</span>
<span class="fc" id="L321">						defVal = defValStr;</span>
<span class="fc" id="L322">						setterFactory = weights -&gt; {</span>
							@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L324">							WeightsObj&lt;Object, String&gt; weights2 = (WeightsObj) weights;</span>
<span class="fc" id="L325">							return (o, val) -&gt; weights2.set(o, val);</span>
						};
<span class="fc" id="L327">						break;</span>
					}
					default:
<span class="fc" id="L330">						throw new IllegalArgumentException(&quot;unknown attr.type: '&quot; + attrTypeStr + &quot;'&quot;);</span>
				}
				boolean isVertexWeight;
				boolean isEdgeWeight;
<span class="fc bfc" id="L334" title="All 4 branches covered.">				switch (domain) {</span>
					case &quot;node&quot;:
<span class="fc" id="L336">						isVertexWeight = true;</span>
<span class="fc" id="L337">						isEdgeWeight = false;</span>
<span class="fc" id="L338">						break;</span>
					case &quot;edge&quot;:
<span class="fc" id="L340">						isVertexWeight = false;</span>
<span class="fc" id="L341">						isEdgeWeight = true;</span>
<span class="fc" id="L342">						break;</span>
					case &quot;all&quot;:
<span class="fc" id="L344">						isVertexWeight = true;</span>
<span class="fc" id="L345">						isEdgeWeight = true;</span>
<span class="fc" id="L346">						break;</span>
					default:
<span class="fc" id="L348">						throw new IllegalArgumentException(&quot;unknown domain: &quot; + domain);</span>
				}
<span class="fc bfc" id="L350" title="All 2 branches covered.">				if (isVertexWeight) {</span>
					@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L352">					Class&lt;Object&gt; attrType0 = (Class&lt;Object&gt;) attrType;</span>
<span class="fc" id="L353">					Weights&lt;V, Object&gt; weights = g.addVerticesWeights(attrName, attrType0, defVal);</span>
					@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L355">					BiConsumer&lt;V, String&gt; setter =</span>
<span class="fc" id="L356">							(BiConsumer&lt;V, String&gt;) setterFactory.apply((Weights&lt;Object, Object&gt;) weights);</span>
<span class="fc" id="L357">					Object oldVal = vWeights.put(weightId, setter);</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">					if (oldVal != null)</span>
<span class="fc" id="L359">						throw new IllegalArgumentException(&quot;duplicate vertex weight key: &quot; + weightId);</span>
				}
<span class="fc bfc" id="L361" title="All 2 branches covered.">				if (isEdgeWeight) {</span>
					@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L363">					Class&lt;Object&gt; attrType0 = (Class&lt;Object&gt;) attrType;</span>
<span class="fc" id="L364">					Weights&lt;E, Object&gt; weights = g.addEdgesWeights(attrName, attrType0, defVal);</span>
					@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L366">					BiConsumer&lt;E, String&gt; setter =</span>
<span class="fc" id="L367">							(BiConsumer&lt;E, String&gt;) setterFactory.apply((Weights&lt;Object, Object&gt;) weights);</span>
<span class="fc" id="L368">					Object oldVal = eWeights.put(weightId, setter);</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">					if (oldVal != null)</span>
<span class="fc" id="L370">						throw new IllegalArgumentException(&quot;duplicate edge weight key: &quot; + weightId);</span>
				}
<span class="fc" id="L372">			}</span>

<span class="fc bfc" id="L374" title="All 2 branches covered.">			for (Element vElm : XmlUtils.children(graph, &quot;node&quot;)) {</span>
<span class="fc" id="L375">				V v = vertexParser.apply(XmlUtils.requiredAttribute(vElm, &quot;id&quot;));</span>
<span class="fc" id="L376">				g.addVertex(v);</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">				for (Element dataElm : XmlUtils.children(vElm, &quot;data&quot;)) {</span>
<span class="fc" id="L378">					String weightId = XmlUtils.requiredAttribute(dataElm, &quot;key&quot;);</span>
<span class="fc" id="L379">					BiConsumer&lt;V, String&gt; vWeight = vWeights.get(weightId);</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">					if (vWeight == null)</span>
<span class="fc" id="L381">						throw new IllegalArgumentException(&quot;unknown weight key: &quot; + weightId);</span>
<span class="fc" id="L382">					vWeight.accept(v, dataElm.getTextContent());</span>
<span class="fc" id="L383">				}</span>
				// searchUnexpectedChildren(vElm, &quot;data&quot;);
<span class="fc" id="L385">			}</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">			for (Element eElm : XmlUtils.children(graph, &quot;edge&quot;)) {</span>
				E e;
<span class="fc" id="L388">				Optional&lt;String&gt; id = XmlUtils.optionalAttribute(eElm, &quot;id&quot;);</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">				if (id.isPresent()) {</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">					if (edgeParser == null)</span>
<span class="fc" id="L391">						throw new IllegalStateException(&quot;Edge parser was not set&quot;);</span>
<span class="fc" id="L392">					e = edgeParser.apply(id.get());</span>
				} else {
<span class="fc bfc" id="L394" title="All 2 branches covered.">					if (edgeBuilder == null)</span>
<span class="fc" id="L395">						throw new IllegalStateException(&quot;Edge builder was not set&quot;);</span>
<span class="fc" id="L396">					e = edgeBuilder.build(g.edges());</span>
				}
<span class="fc" id="L398">				V u = vertexParser.apply(XmlUtils.requiredAttribute(eElm, &quot;source&quot;));</span>
<span class="fc" id="L399">				V v = vertexParser.apply(XmlUtils.requiredAttribute(eElm, &quot;target&quot;));</span>
<span class="fc" id="L400">				g.addEdge(u, v, e);</span>

<span class="fc bfc" id="L402" title="All 2 branches covered.">				if (eElm.hasAttribute(&quot;directed&quot;))</span>
<span class="fc" id="L403">					throw new IllegalArgumentException(&quot;directed attribute per-edge is not supported&quot;);</span>

<span class="fc bfc" id="L405" title="All 2 branches covered.">				for (Element dataElm : XmlUtils.children(eElm, &quot;data&quot;)) {</span>
<span class="fc" id="L406">					String weightId = XmlUtils.requiredAttribute(dataElm, &quot;key&quot;);</span>
<span class="fc" id="L407">					BiConsumer&lt;E, String&gt; eWeight = eWeights.get(weightId);</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">					if (eWeight == null)</span>
<span class="fc" id="L409">						throw new IllegalArgumentException(&quot;unknown weight key: &quot; + weightId);</span>
<span class="fc" id="L410">					eWeight.accept(e, dataElm.getTextContent());</span>
<span class="fc" id="L411">				}</span>
				// searchUnexpectedChildren(eElm, &quot;data&quot;);
<span class="fc" id="L413">			}</span>

<span class="fc" id="L415">			return g;</span>

<span class="fc" id="L417">		} catch (ParserConfigurationException | SAXException e) {</span>
<span class="fc" id="L418">			throw new IllegalArgumentException(e);</span>
		}
	}

	// private static void searchUnexpectedChildren(Element element, String... tags) {
	// List&lt;String&gt; tagsList = ObjectImmutableList.of(tags);
	// for (Element child : children(element))
	// if (!tagsList.contains(child.getTagName()))
	// throw new IllegalArgumentException(&quot;unexpected element: &quot; + child.getTagName());
	// }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>