<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GmlGraphReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - IO</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.io</a> &gt; <span class="el_source">GmlGraphReader.java</span></div><h1>GmlGraphReader.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.io;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.function.BiFunction;
import java.util.function.Supplier;
import com.jgalgo.graph.Graph;
import com.jgalgo.graph.GraphBuilder;
import com.jgalgo.graph.GraphFactory;
import com.jgalgo.graph.IntGraph;
import com.jgalgo.graph.IntGraphBuilder;
import com.jgalgo.graph.IntGraphFactory;
import com.jgalgo.graph.Weights;
import com.jgalgo.graph.WeightsDouble;
import com.jgalgo.graph.WeightsInt;
import com.jgalgo.graph.WeightsObj;
import com.jgalgo.internal.util.IterTools;
import it.unimi.dsi.fastutil.Pair;
import it.unimi.dsi.fastutil.Stack;
import it.unimi.dsi.fastutil.chars.CharPredicate;
import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
import it.unimi.dsi.fastutil.objects.ObjectArrayList;
import it.unimi.dsi.fastutil.objects.ObjectList;
import it.unimi.dsi.fastutil.objects.ObjectObjectMutablePair;

/**
 * Read a graph in 'GML' format.
 *
 * &lt;p&gt;
 * The GML format is a simple text format for describing graphs. It can represent directed and undirected graphs, and
 * supports integers, floats and strings as vertices/edges identifiers and weights. The format is described in
 * &lt;a href=&quot;https://en.wikipedia.org/wiki/Graph_Modelling_Language&quot;&gt;Wikipedia&lt;/a&gt;. The format uses a tree-like
 * structure, similar to JSON or XML. The root of the tree is a node with the key &quot;graph&quot;, and its children are the
 * vertices, edges, and additional properties such as whether the graph is directed or not. Each node has a property
 * 'id', which is used as identifier in the built graph. Edges are not required to have an 'id' property by the format,
 * and we try to choose valid ids if they are missing, but its recommended to always provide an 'id' property for edges,
 * which will be used as the edge identifier in the built graph. In addition to 'id', each edge node should have a
 * property 'source' and 'target', specifying the endpoints vertices of the edge. Except for the 'id' property for
 * vertices, and 'id','source' and 'target' for edges, all other properties are added as weights to the graph. An
 * example of a GML file:
 *
 * &lt;pre&gt;
 * graph [
 * 	# This is a comment about this sample graph
 * 	comment &quot;This is another comment about this sample graph&quot;
 * 	directed 1
 * 	node [
 * 		id 1
 * 		label &quot;node 1&quot;
 * 		thisIsASampleAttribute 42
 * 	]
 * 	node [
 * 		id 2
 * 		label &quot;node 2&quot;
 * 		thisIsASampleAttribute 43
 * 	]
 * 	node [
 * 		id 3
 * 		label &quot;node 3&quot;
 * 		thisIsASampleAttribute 44
 * 	]
 * 	edge [
 * 		id 1
 * 		source 1
 * 		target 2
 * 		label &quot;Edge from node 1 to node 2&quot;
 * 		weight 22.7
 * 	]
 * 	edge [
 * 		id 2
 * 		source 2
 * 		target 3
 * 		label &quot;Edge from node 2 to node 3&quot;
 * 		weight 1.5
 * 	]
 * 	edge [
 * 		id 3
 * 		source 3
 * 		target 1
 * 		label &quot;Edge from node 3 to node 1&quot;
 * 		weight -13.54
 * 	]
 * ]
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * The GML format supports comments in the form of a node with the key 'comment', or lines that starts with '#'. Both
 * are completely ignored by the reader.
 *
 * &lt;p&gt;
 * The GML reader must know the type of vertices and edges during runtime in order to safely read the vertices and edges
 * into a graph. The types can be set using {@link #setVertexType(Class)} and {@link #setEdgeType(Class)}, or passed in
 * the {@linkplain #GmlGraphReader(Class, Class) constructor}. The supported types are integers, doubles and strings. If
 * both the vertices and edges types are {@code int.class}, an {@link IntGraph} will be built.
 *
 * &lt;p&gt;
 * The weights of the vertices will added to the built graph, and will be accessed later by the
 * {@link Graph#getVerticesWeights(String)} method, and similarly for the edges weights. GML supports integers, doubles
 * and strings as weights, and the weights will be added to the graph using {@link WeightsInt}, {@link WeightsDouble} or
 * {@link WeightsObj}. If the vertices (edges) contains weights with the same key but different type, the weights will
 * be added to the graph using a 'supertype' of the weights type. For example, if the vertices contains weights with key
 * 'weight' of type {@code int.class} and {@code double.class}, the weights will be added to the graph using
 * {@link WeightsDouble}. If the vertices contains weights with key 'weight' of type {@code int.class} and
 * {@code String.class}, the weights will be added to the graph using {@link WeightsObj}. If a vertex do not contain a
 * weight with a certain key but others do, the vertex will be assigned the default value of the weights type. All these
 * rules apply also for the edges weights.
 *
 * &lt;p&gt;
 * The format was presented in a paper 'GML: A portable Graph File Format' by Michael Himsolt.
 *
 * @param  &lt;V&gt; the vertices type
 * @param  &lt;E&gt; the edges type
 * @author     Barak Ugav
 */
<span class="fc" id="L136">public class GmlGraphReader&lt;V, E&gt; extends GraphIoUtils.AbstractGraphReader&lt;V, E&gt; {</span>

	private Class&lt;V&gt; vType;
	private Class&lt;E&gt; eType;
	private Class&lt;V&gt; vTypeBoxed;
	private Class&lt;E&gt; eTypeBoxed;

	/**
	 * Create a new reader.
	 *
	 * &lt;p&gt;
	 * Before any graph can be parsed, the vertices and edges types must be set using {@link #setVertexType(Class)} and
	 * {@link #setEdgeType(Class)}. Alternatively, the types can be passed in the
	 * {@linkplain #GmlGraphReader(Class, Class) constructor}.
	 */
<span class="fc" id="L151">	public GmlGraphReader() {}</span>

	/**
	 * Create a new reader and provide the types of vertices and edges.
	 *
	 * @param vType the type of vertices
	 * @param eType the type of edges
	 * @see         #setVertexType(Class)
	 * @see         #setEdgeType(Class)
	 */
<span class="fc" id="L161">	public GmlGraphReader(Class&lt;V&gt; vType, Class&lt;E&gt; eType) {</span>
<span class="fc" id="L162">		setVertexType(vType);</span>
<span class="fc" id="L163">		setEdgeType(eType);</span>
<span class="fc" id="L164">	}</span>

	/**
	 * Set the type of vertices.
	 *
	 * &lt;p&gt;
	 * The GML reader must know the type of vertices during runtime in order to safely read the vertices into a graph.
	 * This method must be called before any graph can be built, unless the vertices type was passed in the constructor.
	 *
	 * &lt;p&gt;
	 * The supported types are integers, doubles and strings. If both the vertices and edges types are
	 * {@code int.class}, an {@link IntGraph} will be built.
	 *
	 * @param vType the type of vertices
	 */
	public void setVertexType(Class&lt;V&gt; vType) {
<span class="fc" id="L180">		checkVertexEdgeType(vType);</span>
<span class="fc" id="L181">		this.vType = vType;</span>
<span class="fc" id="L182">	}</span>

	/**
	 * Set the type of edges.
	 *
	 * &lt;p&gt;
	 * The GML reader must know the type of edges during runtime in order to safely read the edges into a graph. This
	 * method must be called before any graph can be built, unless the edges type was passed in the constructor.
	 *
	 * &lt;p&gt;
	 * The supported types are integers, doubles and strings. If both the vertices and edges types are
	 * {@code int.class}, an {@link IntGraph} will be built.
	 *
	 * @param eType the type of edges
	 */
	public void setEdgeType(Class&lt;E&gt; eType) {
<span class="fc" id="L198">		checkVertexEdgeType(eType);</span>
<span class="fc" id="L199">		this.eType = eType;</span>
<span class="fc" id="L200">	}</span>

	private static void checkVertexEdgeType(Class&lt;?&gt; type) {
<span class="fc" id="L203">		Objects.requireNonNull(type);</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">		if (!List.of(int.class, Integer.class, double.class, Double.class, String.class).contains(type))</span>
<span class="fc" id="L205">			throw new IllegalArgumentException(</span>
					&quot;Only integers, doubles and strings are supported. Unsupported: &quot; + type);
<span class="fc" id="L207">	}</span>

	@Override
	public GraphBuilder&lt;V, E&gt; readIntoBuilderImpl(Reader reader) throws IOException {
<span class="fc bfc" id="L211" title="All 2 branches covered.">		if (vType == null)</span>
<span class="fc" id="L212">			throw new IllegalStateException(&quot;Type of vertices was not set&quot;);</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">		if (eType == null)</span>
<span class="fc" id="L214">			throw new IllegalStateException(&quot;Type of edges was not set&quot;);</span>
<span class="fc" id="L215">		vTypeBoxed = boxedType(vType);</span>
<span class="fc" id="L216">		eTypeBoxed = boxedType(eType);</span>

<span class="fc" id="L218">		List&lt;Pair&lt;String, Object&gt;&gt; roots = parseHierarchy(new CharReader(GraphIoUtils.bufferedReader(reader)));</span>
<span class="fc" id="L219">		return readIntoBuilder(roots);</span>
	}

	private GraphBuilder&lt;V, E&gt; readIntoBuilder(List&lt;Pair&lt;String, Object&gt;&gt; roots) {
		Pair&lt;String, Object&gt; root;
<span class="fc bfc" id="L224" title="All 4 branches covered.">		if (roots.size() != 1 || !(root = roots.get(0)).first().equals(&quot;graph&quot;))</span>
<span class="fc" id="L225">			throw new IllegalArgumentException(&quot;expected a single root list 'graph'&quot;);</span>

<span class="fc" id="L227">		KeySearcher directedSearcher = new KeySearcher(&quot;directed&quot;, &quot;graph&quot;);</span>
<span class="fc" id="L228">		searchChildren(root, directedSearcher);</span>
<span class="fc" id="L229">		final boolean directed = Integer.valueOf(1).equals(directedSearcher.value);</span>

<span class="fc bfc" id="L231" title="All 4 branches covered.">		final boolean intGraph = vType == int.class &amp;&amp; eType == int.class;</span>
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc bfc" id="L233" title="All 2 branches covered.">		GraphFactory&lt;V, E&gt; factory = intGraph ? (GraphFactory&lt;V, E&gt;) IntGraphFactory.newInstance(directed)</span>
<span class="fc" id="L234">				: GraphFactory.newInstance(directed);</span>

<span class="fc" id="L236">		GraphBuilder&lt;V, E&gt; b = factory.allowSelfEdges().newBuilder();</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">		IntGraphBuilder bInt = intGraph ? (IntGraphBuilder) b : null;</span>

<span class="fc" id="L239">		Map&lt;String, List&lt;Pair&lt;V, Object&gt;&gt;&gt; vWeights = new Object2ObjectOpenHashMap&lt;&gt;();</span>
<span class="fc" id="L240">		Map&lt;String, List&lt;Pair&lt;E, Object&gt;&gt;&gt; eWeights = new Object2ObjectOpenHashMap&lt;&gt;();</span>

<span class="fc bfc" id="L242" title="All 2 branches covered.">		for (Pair&lt;String, Object&gt; n : children(root)) {</span>
<span class="fc bfc" id="L243" title="All 4 branches covered.">			switch (n.first()) {</span>
				case &quot;node&quot;: {
<span class="fc" id="L245">					checkNoNestedLists(n);</span>

					/* search for id */
<span class="fc" id="L248">					KeySearcher idSearcher = new KeySearcher(&quot;id&quot;, &quot;vertex&quot;);</span>
<span class="fc" id="L249">					searchChildren(n, idSearcher);</span>
<span class="fc" id="L250">					V id = vertex(idSearcher.get());</span>
<span class="fc" id="L251">					b.addVertex(id);</span>

					/* add all other children as weights */
<span class="fc bfc" id="L254" title="All 2 branches covered.">					for (Pair&lt;String, Object&gt; prop : children(n))</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">						if (!ObjectList.of(&quot;id&quot;).contains(prop.first()))</span>
<span class="fc" id="L256">							vWeights.computeIfAbsent(prop.first(), k -&gt; new ArrayList&lt;&gt;())</span>
<span class="fc" id="L257">									.add(Pair.of(id, prop.second()));</span>
<span class="fc" id="L258">					break;</span>
				}
				case &quot;edge&quot;: {
<span class="fc" id="L261">					checkNoNestedLists(n);</span>

					/* search for id, source and target */
<span class="fc" id="L264">					KeySearcher idSearcher = new KeySearcher(&quot;id&quot;, &quot;edge&quot;);</span>
<span class="fc" id="L265">					KeySearcher sourceSearcher = new KeySearcher(&quot;source&quot;, &quot;edge&quot;);</span>
<span class="fc" id="L266">					KeySearcher targetSearcher = new KeySearcher(&quot;target&quot;, &quot;edge&quot;);</span>
<span class="fc" id="L267">					searchChildren(n, idSearcher, sourceSearcher, targetSearcher);</span>
<span class="fc" id="L268">					V source = vertex(sourceSearcher.get());</span>
<span class="fc" id="L269">					V target = vertex(targetSearcher.get());</span>
					E id;
<span class="fc bfc" id="L271" title="All 4 branches covered.">					if (intGraph &amp;&amp; !idSearcher.found) {</span>
						/* no id found, let IntGraphBuilder choose the id itself */
<span class="fc" id="L273">						int source0 = ((Integer) source).intValue();</span>
<span class="fc" id="L274">						int target0 = ((Integer) target).intValue();</span>
						@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L276">						E id0 = (E) Integer.valueOf(bInt.addEdge(source0, target0));</span>
<span class="fc" id="L277">						id = id0;</span>

<span class="fc" id="L279">					} else {</span>
<span class="fc" id="L280">						id = edge(idSearcher.get());</span>
<span class="fc" id="L281">						b.addEdge(source, target, id);</span>
					}

					/* add all other children as weights */
<span class="fc bfc" id="L285" title="All 2 branches covered.">					for (Pair&lt;String, Object&gt; prop : children(n))</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">						if (!ObjectList.of(&quot;id&quot;, &quot;source&quot;, &quot;target&quot;).contains(prop.first()))</span>
<span class="fc" id="L287">							eWeights.computeIfAbsent(prop.first(), k -&gt; new ArrayList&lt;&gt;())</span>
<span class="fc" id="L288">									.add(Pair.of(id, prop.second()));</span>
<span class="fc" id="L289">					break;</span>
				}
				case &quot;directed&quot;:
<span class="fc" id="L292">					break; /* already searched this key */</span>
				default:
<span class="fc" id="L294">					throw new IllegalArgumentException(&quot;unexpected key: '&quot; + n.first() + &quot;'&quot;);</span>
			}
<span class="fc" id="L296">		}</span>

<span class="fc" id="L298">		addWeights(vWeights, b::addVerticesWeights);</span>
<span class="fc" id="L299">		addWeights(eWeights, b::addEdgesWeights);</span>

<span class="fc" id="L301">		return b;</span>
	}

	static class KeySearcher {
		boolean found;
		private String key;
		private Object value;
		private final String parentNode;

<span class="fc" id="L310">		KeySearcher(String key, String parentNode) {</span>
<span class="fc" id="L311">			this.key = key;</span>
<span class="fc" id="L312">			this.parentNode = parentNode;</span>
<span class="fc" id="L313">		}</span>

		boolean accept(Pair&lt;String, Object&gt; node) {
<span class="fc bfc" id="L316" title="All 2 branches covered.">			if (!key.equals(node.first()))</span>
<span class="fc" id="L317">				return false;</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">			if (found)</span>
<span class="fc" id="L319">				throw new IllegalArgumentException(&quot;duplicate '&quot; + key + &quot;' property&quot;);</span>
<span class="fc" id="L320">			value = node.second();</span>
<span class="fc" id="L321">			return found = true;</span>
		}

		Object get() {
<span class="fc bfc" id="L325" title="All 2 branches covered.">			if (!found)</span>
<span class="fc" id="L326">				throw new IllegalArgumentException(&quot;no '&quot; + key + &quot;' property for &quot; + parentNode);</span>
<span class="fc" id="L327">			return value;</span>
		}
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	private static &lt;K&gt; void addWeights(Map&lt;String, List&lt;Pair&lt;K, Object&gt;&gt;&gt; weights,
			BiFunction&lt;String, Class&lt;?&gt;, Weights&lt;K, ?&gt;&gt; weightsAdder) {
<span class="fc bfc" id="L334" title="All 2 branches covered.">		for (var entry : weights.entrySet()) {</span>
<span class="fc" id="L335">			String key = entry.getKey();</span>
<span class="fc" id="L336">			Class&lt;?&gt; weightType = chooseWeightType(entry.getValue());</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">			if (weightType == int.class) {</span>
<span class="fc" id="L338">				WeightsInt&lt;K&gt; w = (WeightsInt&lt;K&gt;) weightsAdder.apply(key, int.class);</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">				for (var pair : entry.getValue())</span>
<span class="fc" id="L340">					w.set(pair.first(), ((Integer) pair.second()).intValue());</span>

<span class="fc bfc" id="L342" title="All 2 branches covered.">			} else if (weightType == double.class) {</span>
<span class="fc" id="L343">				WeightsDouble&lt;K&gt; w = (WeightsDouble&lt;K&gt;) weightsAdder.apply(key, double.class);</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">				for (var pair : entry.getValue())</span>
<span class="fc" id="L345">					w.set(pair.first(), ((Number) pair.second()).doubleValue());</span>

<span class="fc bfc" id="L347" title="All 2 branches covered.">			} else if (weightType == String.class) {</span>
<span class="fc" id="L348">				WeightsObj&lt;K, String&gt; w = (WeightsObj&lt;K, String&gt;) weightsAdder.apply(key, String.class);</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">				for (var pair : entry.getValue())</span>
<span class="fc" id="L350">					w.set(pair.first(), (String) pair.second());</span>

<span class="fc" id="L352">			} else {</span>
<span class="fc" id="L353">				WeightsObj&lt;K, Object&gt; w = (WeightsObj&lt;K, Object&gt;) weightsAdder.apply(key, Object.class);</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">				for (var pair : entry.getValue())</span>
<span class="fc" id="L355">					w.set(pair.first(), pair.second());</span>
			}
<span class="fc" id="L357">		}</span>
<span class="fc" id="L358">	}</span>

	private static &lt;K&gt; Class&lt;?&gt; chooseWeightType(List&lt;Pair&lt;K, Object&gt;&gt; weights) {
<span class="fc" id="L361">		Iterator&lt;Class&lt;?&gt;&gt; typeIt = IterTools.map(weights.iterator(), pair -&gt; {</span>
<span class="fc" id="L362">			Object weight = pair.second();</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">			if (weight instanceof Integer) {</span>
<span class="fc" id="L364">				return int.class;</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">			} else if (weight instanceof Double) {</span>
<span class="fc" id="L366">				return double.class;</span>
			} else {
<span class="pc bnc" id="L368" title="All 2 branches missed.">				assert weight instanceof String;</span>
<span class="fc" id="L369">				return String.class;</span>
			}
		});
<span class="fc" id="L372">		Class&lt;?&gt; weightType = typeIt.next();</span>

<span class="fc bfc" id="L374" title="All 4 branches covered.">		while (weightType == int.class &amp;&amp; typeIt.hasNext()) {</span>
<span class="fc" id="L375">			Class&lt;?&gt; type = typeIt.next();</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">			if (type != int.class) {</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">				if (type == double.class) {</span>
<span class="fc" id="L378">					weightType = double.class;</span>
				} else {
<span class="fc" id="L380">					weightType = Object.class;</span>
				}
			}
<span class="fc" id="L383">		}</span>
<span class="fc bfc" id="L384" title="All 4 branches covered.">		while (weightType == double.class &amp;&amp; typeIt.hasNext()) {</span>
<span class="fc" id="L385">			Class&lt;?&gt; type = typeIt.next();</span>
<span class="fc bfc" id="L386" title="All 4 branches covered.">			if (type != int.class &amp;&amp; type != double.class)</span>
<span class="fc" id="L387">				weightType = Object.class;</span>
<span class="fc" id="L388">		}</span>
<span class="fc bfc" id="L389" title="All 4 branches covered.">		while (weightType == String.class &amp;&amp; typeIt.hasNext()) {</span>
<span class="fc" id="L390">			Class&lt;?&gt; type = typeIt.next();</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">			if (type != String.class)</span>
<span class="fc" id="L392">				weightType = Object.class;</span>
<span class="fc" id="L393">		}</span>
<span class="fc" id="L394">		return weightType;</span>
	}

	private V vertex(Object v) {
		try {
<span class="fc" id="L399">			return vTypeBoxed.cast(v);</span>
<span class="fc" id="L400">		} catch (ClassCastException e) {</span>
<span class="fc" id="L401">			throw new ClassCastException(&quot;expected vertex type &quot; + vType + &quot; but got &quot; + v.getClass());</span>
		}
	}

	private E edge(Object e) {
		try {
<span class="fc" id="L407">			return eTypeBoxed.cast(e);</span>
<span class="fc" id="L408">		} catch (ClassCastException ex) {</span>
<span class="fc" id="L409">			throw new ClassCastException(&quot;expected edge type &quot; + eType + &quot; but got &quot; + e.getClass());</span>
		}
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	private static &lt;T&gt; Class&lt;T&gt; boxedType(Class&lt;T&gt; type) {
<span class="fc bfc" id="L415" title="All 2 branches covered.">		if (type == int.class)</span>
<span class="fc" id="L416">			return (Class&lt;T&gt;) Integer.class;</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">		if (type == double.class)</span>
<span class="fc" id="L418">			return (Class&lt;T&gt;) Double.class;</span>
<span class="fc" id="L419">		return type;</span>
	}

	private static List&lt;Pair&lt;String, Object&gt;&gt; parseHierarchy(CharReader reader) throws IOException {
<span class="fc" id="L423">		StringBuilder strBuilder = new StringBuilder();</span>
<span class="fc" id="L424">		List&lt;Pair&lt;String, Object&gt;&gt; roots = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L425">		Stack&lt;Pair&lt;String, Object&gt;&gt; stack = new ObjectArrayList&lt;&gt;();</span>
		mainLoop: for (;;) {
<span class="fc" id="L427">			Pair&lt;String, Object&gt; node = new ObjectObjectMutablePair&lt;&gt;(null, null);</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">			if (stack.isEmpty()) {</span>
<span class="fc" id="L429">				roots.add(node);</span>
			} else {
<span class="fc" id="L431">				children(stack.top()).add(node);</span>
			}

			/* parse key */
<span class="fc" id="L435">			StringBuilder key = strBuilder;</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">			if (!reader.appendIf(Gml::isKeyCharPrefix, key))</span>
<span class="fc" id="L437">				throw new IllegalArgumentException(&quot;invalid key&quot;);</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">			while (reader.appendIf(Gml::isKeyChar, key));</span>

<span class="fc" id="L440">			node.first(key.toString());</span>
<span class="fc" id="L441">			key.setLength(0);</span>

<span class="fc" id="L443">			readWhitespace(reader, true);</span>

<span class="fc" id="L445">			char c = reader.getChar(() -&gt; &quot;no value of key '&quot; + key + &quot;'&quot;);</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">			if (c == '&quot;') { /* string */</span>
<span class="fc" id="L447">				reader.advance();</span>

<span class="fc" id="L449">				StringBuilder strVal = strBuilder;</span>
				for (;;) {
<span class="fc" id="L451">					c = reader.getCharAndAdvance(&quot;string value without terminating character&quot;);</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">					if (c == '&quot;')</span>
<span class="fc" id="L453">						break;</span>
<span class="fc" id="L454">					strVal.append(c);</span>
				}
<span class="fc" id="L456">				node.second(strVal.toString());</span>
<span class="fc" id="L457">				strVal.setLength(0);</span>

<span class="fc bfc" id="L459" title="All 2 branches covered.">			} else if (c == '[') { /* list */</span>
<span class="fc" id="L460">				reader.advance();</span>
<span class="fc" id="L461">				node.second(new ArrayList&lt;&gt;());</span>
<span class="fc" id="L462">				stack.push(node);</span>
<span class="fc" id="L463">				readWhitespace(reader, false);</span>
<span class="fc" id="L464">				continue;</span>

			} else { /* number */
<span class="fc" id="L467">				StringBuilder num = strBuilder;</span>

				/* read all digits */
<span class="fc" id="L470">				reader.appendIf(Gml::isNumSign, num);</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">				while (reader.appendIf(Gml::isDigit, num));</span>

				/* floating number */
<span class="fc bfc" id="L474" title="All 4 branches covered.">				if (reader.appendIf(ch -&gt; ch == '.', num)) {</span>

					/* read all digits after the period */
<span class="fc bfc" id="L477" title="All 2 branches covered.">					while (reader.appendIf(Gml::isDigit, num));</span>

					/* scientific format */
<span class="fc bfc" id="L480" title="All 4 branches covered.">					if (reader.appendIf(ch -&gt; ch == 'E', num)) {</span>

						/* read all digits of exponent */
<span class="fc bfc" id="L483" title="All 2 branches covered.">						if (!reader.appendIf(Gml::isNumSign, num))</span>
<span class="fc" id="L484">							throw new IllegalArgumentException(&quot;expected a sign in float num exponent&quot;);</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">						while (reader.appendIf(Gml::isDigit, num));</span>
					}
<span class="fc" id="L487">					node.second(Double.valueOf(num.toString()));</span>

				} else {
					/* integer */
<span class="fc" id="L491">					node.second(Integer.valueOf(num.toString()));</span>
				}

<span class="fc" id="L494">				num.setLength(0);</span>
			}

<span class="fc" id="L497">			boolean hadWhitespace = readWhitespace(reader, false);</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">			if (!reader.hasChar())</span>
<span class="fc" id="L499">				break mainLoop;</span>
<span class="fc bfc" id="L500" title="All 4 branches covered.">			if (!hadWhitespace &amp;&amp; reader.getChar() != ']')</span>
<span class="fc" id="L501">				throw new IllegalArgumentException(&quot;expected ']&quot;);</span>
			for (;;) {
<span class="fc bfc" id="L503" title="All 2 branches covered.">				if (!reader.hasChar())</span>
<span class="fc" id="L504">					break mainLoop;</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">				if (reader.getChar() == ']') {</span>
<span class="fc" id="L506">					reader.advance();</span>
<span class="fc" id="L507">					readWhitespace(reader, false);</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">					if (stack.isEmpty())</span>
<span class="fc" id="L509">						throw new IllegalArgumentException(&quot;']' without list in scope&quot;);</span>
<span class="fc" id="L510">					stack.pop();</span>
				} else {
					break;
				}
			}
<span class="fc" id="L515">		}</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">		if (!stack.isEmpty())</span>
<span class="fc" id="L517">			throw new IllegalArgumentException(&quot;lists without termination&quot;);</span>

		/* remove nodes with 'comment' key */
<span class="fc" id="L520">		roots.removeIf(n -&gt; n.first().equals(&quot;comment&quot;));</span>
<span class="fc" id="L521">		roots.forEach(stack::push);</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">		while (!stack.isEmpty()) {</span>
<span class="fc" id="L523">			Pair&lt;String, Object&gt; node = stack.pop();</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">			if (hasChildren(node)) {</span>
<span class="fc" id="L525">				children(node).removeIf(n -&gt; n.first().equals(&quot;comment&quot;));</span>
<span class="fc" id="L526">				children(node).forEach(stack::push);</span>
			}
<span class="fc" id="L528">		}</span>

<span class="fc" id="L530">		return roots;</span>
	}

	private static boolean readWhitespace(CharReader reader, boolean required) throws IOException {
<span class="fc" id="L534">		int count = 0;</span>
		for (;;) {
<span class="fc bfc" id="L536" title="All 2 branches covered.">			if (!reader.hasChar())</span>
<span class="fc" id="L537">				break;</span>
<span class="fc" id="L538">			char c = reader.getChar();</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">			if (!Character.isWhitespace(c))</span>
<span class="fc" id="L540">				break;</span>
<span class="fc" id="L541">			reader.advance();</span>
<span class="fc" id="L542">			count++;</span>
<span class="fc" id="L543">		}</span>
<span class="fc bfc" id="L544" title="All 4 branches covered.">		if (required &amp;&amp; count == 0)</span>
<span class="fc" id="L545">			throw new IllegalArgumentException(&quot;expected whitespace&quot;);</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">		return count &gt; 0;</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	static List&lt;Pair&lt;String, Object&gt;&gt; children(Pair&lt;String, Object&gt; parent) {
<span class="fc bfc" id="L551" title="All 2 branches covered.">		if (!hasChildren(parent))</span>
<span class="fc" id="L552">			throw new IllegalArgumentException(&quot;node doesn't have a list as value&quot;);</span>
<span class="fc" id="L553">		return (List&lt;Pair&lt;String, Object&gt;&gt;) parent.second();</span>
	}

	static boolean hasChildren(Pair&lt;String, Object&gt; parent) {
<span class="fc" id="L557">		return parent.second() instanceof List&lt;?&gt;;</span>
	}

	static void searchChildren(Pair&lt;String, Object&gt; parent, KeySearcher... searchers) {
<span class="fc bfc" id="L561" title="All 2 branches covered.">		for (Pair&lt;String, Object&gt; child : children(parent))</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">			for (KeySearcher searcher : searchers)</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">				if (searcher.accept(child))</span>
<span class="fc" id="L564">					break;</span>
<span class="fc" id="L565">	}</span>

	static void checkNoNestedLists(Pair&lt;String, Object&gt; parent) {
<span class="fc bfc" id="L568" title="All 2 branches covered.">		for (Pair&lt;String, Object&gt; child : children(parent))</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">			if (hasChildren(child))</span>
<span class="fc" id="L570">				throw new IllegalArgumentException(&quot;unexpected nested list&quot;);</span>
<span class="fc" id="L571">	}</span>

	private static class CharReader {
		private final BufferedReader reader;
		private String line;
		private int linePos;
		private int nextChar;

<span class="fc" id="L579">		CharReader(BufferedReader reader) throws IOException {</span>
<span class="fc" id="L580">			this.reader = Objects.requireNonNull(reader);</span>
<span class="fc" id="L581">			nextLine();</span>
<span class="fc" id="L582">		}</span>

		char getChar() {
<span class="fc" id="L585">			return getChar(&quot;&quot;);</span>
		}

		char getChar(String errMsgOnEOF) {
<span class="fc" id="L589">			return getChar(() -&gt; errMsgOnEOF);</span>
		}

		char getChar(Supplier&lt;String&gt; errMsgOnEOF) {
<span class="fc bfc" id="L593" title="All 2 branches covered.">			if (!hasChar())</span>
<span class="fc" id="L594">				throw new IllegalArgumentException(errMsgOnEOF.get());</span>
<span class="fc" id="L595">			return (char) nextChar;</span>
		}

		boolean hasChar() {
<span class="fc bfc" id="L599" title="All 2 branches covered.">			return nextChar != -1;</span>
		}

		void advance() throws IOException {
<span class="fc bfc" id="L603" title="All 2 branches covered.">			if (linePos &lt;= line.length()) {</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">				if (linePos &lt; line.length()) {</span>
<span class="fc" id="L605">					nextChar = line.charAt(linePos);</span>
				} else {
<span class="fc" id="L607">					nextChar = '\n';</span>
				}
<span class="fc" id="L609">				linePos++;</span>

			} else {
<span class="fc" id="L612">				nextLine();</span>
			}
<span class="fc" id="L614">		}</span>

		private void nextLine() throws IOException {
			/* ignore lines that start with '#' */
			for (;;) {
<span class="fc" id="L619">				line = reader.readLine();</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">				if (line == null) {</span>
<span class="fc" id="L621">					nextChar = -1;</span>
<span class="fc" id="L622">					return;</span>
				}
<span class="fc" id="L624">				char firstChar = ' ';</span>
<span class="pc bpc" id="L625" title="1 of 4 branches missed.">				for (int i = 0; i &lt; line.length() &amp;&amp; Character.isWhitespace(firstChar = line.charAt(i)); i++);</span>
<span class="fc bfc" id="L626" title="All 2 branches covered.">				if (firstChar != '#')</span>
<span class="fc" id="L627">					break;</span>
<span class="fc" id="L628">			}</span>

<span class="fc" id="L630">			linePos = 0;</span>
<span class="fc" id="L631">			advance();</span>
<span class="fc" id="L632">		}</span>

		boolean appendIf(CharPredicate pred, StringBuilder sb) throws IOException {
<span class="pc bpc" id="L635" title="1 of 4 branches missed.">			if (hasChar() &amp;&amp; pred.test((char) nextChar)) {</span>
<span class="fc" id="L636">				sb.append(getChar());</span>
<span class="fc" id="L637">				advance();</span>
<span class="fc" id="L638">				return true;</span>
			} else {
<span class="fc" id="L640">				return false;</span>
			}
		}

		char getCharAndAdvance(String errMsgOnEOF) throws IOException {
<span class="fc" id="L645">			char c = getChar(errMsgOnEOF);</span>
<span class="fc" id="L646">			advance();</span>
<span class="fc" id="L647">			return c;</span>
		}

		// char getCharAndAdvance() throws IOException {
		// return getCharAndAdvance(&quot;&quot;);
		// }
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>