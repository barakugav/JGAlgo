<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GexfGraphReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - IO</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.io</a> &gt; <span class="el_source">GexfGraphReader.java</span></div><h1>GexfGraphReader.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.io;

import static com.jgalgo.internal.util.Range.range;
import java.io.IOException;
import java.io.Reader;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.URI;
import java.net.URISyntaxException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.Function;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import com.jgalgo.graph.Graph;
import com.jgalgo.graph.GraphBuilder;
import com.jgalgo.graph.GraphFactory;
import com.jgalgo.graph.IdBuilder;
import com.jgalgo.graph.IntGraphFactory;
import com.jgalgo.graph.Weights;
import com.jgalgo.graph.WeightsBool;
import com.jgalgo.graph.WeightsByte;
import com.jgalgo.graph.WeightsChar;
import com.jgalgo.graph.WeightsDouble;
import com.jgalgo.graph.WeightsFloat;
import com.jgalgo.graph.WeightsInt;
import com.jgalgo.graph.WeightsLong;
import com.jgalgo.graph.WeightsObj;
import com.jgalgo.graph.WeightsShort;
import it.unimi.dsi.fastutil.booleans.BooleanSet;
import it.unimi.dsi.fastutil.booleans.BooleanUnaryOperator;
import it.unimi.dsi.fastutil.bytes.ByteSet;
import it.unimi.dsi.fastutil.bytes.ByteUnaryOperator;
import it.unimi.dsi.fastutil.chars.CharSet;
import it.unimi.dsi.fastutil.chars.CharUnaryOperator;
import it.unimi.dsi.fastutil.doubles.DoubleSet;
import it.unimi.dsi.fastutil.doubles.DoubleUnaryOperator;
import it.unimi.dsi.fastutil.floats.FloatSet;
import it.unimi.dsi.fastutil.floats.FloatUnaryOperator;
import it.unimi.dsi.fastutil.ints.IntSet;
import it.unimi.dsi.fastutil.ints.IntUnaryOperator;
import it.unimi.dsi.fastutil.longs.LongSet;
import it.unimi.dsi.fastutil.longs.LongUnaryOperator;
import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
import it.unimi.dsi.fastutil.shorts.ShortSet;
import it.unimi.dsi.fastutil.shorts.ShortUnaryOperator;

/**
 * Read a graph in 'GEXF' format.
 *
 * &lt;p&gt;
 * GEXF is an XML-based format for graphs. Both directed and undirected graphs are supported, along with mixed graphs
 * (some edges are directed while others are undirected) although the {@link Graph} does not supported mixed graphs
 * (therefore the reader also doesn't support it). The format support graphs with vertices and edges of any type, as
 * long as they can be written as an XML attribute string. The format also support multiple weights for vertices and
 * edges, of any primitive Java type ({@code int}, {@code long}, {@code double}, {@code boolean}, ect.), {@link String},
 * {@link Date}, {@link URI}, {@link BigInteger}, {@link BigDecimal}, along with 'list' (arrays) of any of the above
 * except {@link Date} and {@link URI}.
 *
 * &lt;p&gt;
 * Identifiers of vertices are mandatory, and must be unique. Identifiers of edges are optional, if not specified the
 * reader will try generate them using a builder provided by the user, or a default builder for certain types (see
 * {@link #setEdgeBuilder(IdBuilder)} and {@link #setEdgeBuilderDefault(Class)}). Vertices identifiers (and edges
 * identifiers if specified) are parsed using a parser provided by the user, or a default parser for certain types (see
 * {@link #setVertexParserDefault(Class)} and {@link #setEdgeParserDefault(Class)}).
 *
 * &lt;p&gt;
 * When the reader reads a graph with weights, it will create a {@link Weights} object for each type of weights. For any
 * of the primitive types such as {@code int}, {@code long}, {@code double}, {@code boolean}, ect., the reader will
 * create a {@link Weights} object of the corresponding type, such as {@link WeightsInt}, {@link WeightsLong},
 * {@link WeightsDouble}, {@link WeightsBool}, ect. For {@link String}, {@link Date}, {@link URI}, {@link BigInteger},
 * {@link BigDecimal}, the reader will create a {@link Weights} object of type {@link WeightsObj}. For 'list' types,
 * which are supported for any primitive, {@link String}, {@link BigInteger} and {@link BigDecimal}, the reader will
 * create a {@link Weights} object of type {@link WeightsObj} and will populate it with arrays of the corresponding
 * type, such as {@code int[]}, {@code long[]}, {@code String[]}, {@code BigInteger[]}, ect. Default values are
 * supported for all types of weights, and will be available after reading via {@link Weights#defaultWeightAsObj()} or
 * any of the specific types weights such as {@link WeightsInt#defaultWeight()}. Note that the default value of 'list'
 * types is an array, which is shared between all vertices/edges that do not explicitly specify a value for the weight,
 * and should not be modified.
 *
 * &lt;p&gt;
 * The GEXF format support both self edges and parallel edges. The format documentation can be found
 * &lt;a href= &quot;https://gexf.net/&quot;&gt;here&lt;/a&gt;.
 *
 * @see    GexfGraphWriter
 * @author Barak Ugav
 */
public class GexfGraphReader&lt;V, E&gt; extends GraphIoUtils.AbstractGraphReader&lt;V, E&gt; {

	private Class&lt;V&gt; vertexType;
	private Class&lt;E&gt; edgeType;
	private Function&lt;String, V&gt; vertexParser;
	private Function&lt;String, E&gt; edgeParser;
	private IdBuilder&lt;E&gt; edgeBuilder;
<span class="fc" id="L122">	private final SimpleDateFormat dateFormat = new SimpleDateFormat(Gexf.DateFormat);</span>

	/**
	 * Create a new reader.
	 *
	 * &lt;p&gt;
	 * The user should set the vertex/edge parsers and edge builder manually using {@link #setVertexParser(Function)},
	 * {@link #setEdgeParser(Function)} and {@link #setEdgeBuilder(IdBuilder)}. Setting the vertex parser is mandatory,
	 * while setting the edge parser is only required if edges identifiers are specified. Similarly, setting the edge
	 * builder is only required if edges identifiers are not specified.
	 */
<span class="fc" id="L133">	public GexfGraphReader() {}</span>

	/**
	 * Create a new reader with default parsers and builders for the given vertex and edge types.
	 *
	 * &lt;p&gt;
	 * During the reading process, the reader will use the parser to convert the vertex identifiers from string to the
	 * given type, and similarly for edges if edges identifiers are specified. If edges identifiers are not specified,
	 * the reader will use the builder to generate them. Default parsers exist for types {@code byte}, {@code short},
	 * {@code int}, {@code long}, {@code float}, {@code double} and {@code String}. Default edge builder is instantiated
	 * using {@link IdBuilder#defaultBuilder(Class)}, see it documentation for supported types. If the given types are
	 * not supported by the default parsers and builder, the reader will throw an exception. In such case, the
	 * constructor {@link #GexfGraphReader()} should be used, and the user should set the vertex/edge parsers and edge
	 * builder manually using {@link #setVertexParser(Function)}, {@link #setEdgeParser(Function)} and
	 * {@link #setEdgeBuilder(IdBuilder)}.
	 *
	 *
	 * @param  vertexType               the type of the vertices
	 * @param  edgeType                 the type of the edges
	 * @throws IllegalArgumentException if the given types are not supported by the default vertex/edge parsers and edge
	 *                                      builder. The supported types are {@code byte}, {@code short}, {@code int},
	 *                                      {@code long}, {@code float}, {@code double} and {@code String}.
	 * @see                             #setVertexParserDefault(Class)
	 * @see                             #setEdgeParserDefault(Class)
	 * @see                             #setEdgeBuilderDefault(Class)
	 */
<span class="fc" id="L159">	public GexfGraphReader(Class&lt;V&gt; vertexType, Class&lt;E&gt; edgeType) {</span>
<span class="fc" id="L160">		setVertexParserDefault(this.vertexType = vertexType);</span>
<span class="fc" id="L161">		setEdgeParserDefault(this.edgeType = edgeType);</span>
<span class="fc" id="L162">		setEdgeBuilderDefault(this.edgeType);</span>
<span class="fc" id="L163">	}</span>

	/**
	 * Set the parser for the vertices identifiers.
	 *
	 * &lt;p&gt;
	 * The parser is used to convert the vertex identifiers from string to the given vertex type. The parser is
	 * mandatory, and must be set before reading a graph. For default parsers for certain types, see
	 * {@link #setVertexParserDefault(Class)}.
	 *
	 * @param vertexParser a parser for the vertices identifiers
	 */
	public void setVertexParser(Function&lt;String, V&gt; vertexParser) {
<span class="fc" id="L176">		this.vertexParser = Objects.requireNonNull(vertexParser);</span>
<span class="fc" id="L177">	}</span>

	/**
	 * Set the parser for the vertices identifiers, using a default parser for the given vertex type.
	 *
	 * &lt;p&gt;
	 * The parser is used to convert the vertex identifiers from string to the given vertex type. The parser is
	 * mandatory, and must be set before reading a graph. The default parser exists for types {@code byte},
	 * {@code short}, {@code int}, {@code long}, {@code float}, {@code double} and {@code String}. If the given type is
	 * not supported by the default parser, the reader will throw an exception. In such case, the method
	 * {@link #setVertexParser(Function)} should be used for custom parsing.
	 *
	 * @param  vertexType               the type of the vertices
	 * @throws IllegalArgumentException if the given type is not supported by the default parser. The supported types
	 *                                      are {@code byte}, {@code short}, {@code int}, {@code long}, {@code float},
	 *                                      {@code double} and {@code String}.
	 */
	public void setVertexParserDefault(Class&lt;V&gt; vertexType) {
<span class="fc" id="L195">		this.vertexParser = GraphIoUtils.defaultParser(vertexType);</span>
<span class="fc" id="L196">		this.vertexType = vertexType;</span>
<span class="fc" id="L197">	}</span>

	/**
	 * Set the parser for the edges identifiers.
	 *
	 * &lt;p&gt;
	 * The parser is used to convert the edges identifiers from string to the given edge type. The parser is mandatory
	 * if edges identifiers are specified. In case edge identifiers are not specified, an edge builder must be set (see
	 * {@link #setEdgeBuilder(IdBuilder)}). For default parsers for certain types, see
	 * {@link #setEdgeParserDefault(Class)}.
	 *
	 * @param edgeParser a parser for the edges identifiers
	 */
	public void setEdgeParser(Function&lt;String, E&gt; edgeParser) {
<span class="fc" id="L211">		this.edgeParser = Objects.requireNonNull(edgeParser);</span>
<span class="fc" id="L212">	}</span>

	/**
	 * Set the parser for the edges identifiers, using a default parser for the given edge type.
	 *
	 * &lt;p&gt;
	 * The parser is used to convert the edges identifiers from string to the given edge type. The parser is mandatory
	 * if edges identifiers are specified. In case edge identifiers are not specified, an edge builder must be set (see
	 * {@link #setEdgeBuilder(IdBuilder)}). The default parser exists for types {@code byte}, {@code short},
	 * {@code int}, {@code long}, {@code float}, {@code double} and {@code String}. If the given type is not supported
	 * by the default parser, the reader will throw an exception. In such case, the method
	 * {@link #setEdgeParser(Function)} should be used for custom parsing.
	 *
	 * @param  edgeType                 the type of the edges
	 * @throws IllegalArgumentException if the given type is not supported by the default parser. The supported types
	 *                                      are {@code byte}, {@code short}, {@code int}, {@code long}, {@code float},
	 *                                      {@code double} and {@code String}.
	 */
	public void setEdgeParserDefault(Class&lt;E&gt; edgeType) {
<span class="fc" id="L231">		this.edgeParser = GraphIoUtils.defaultParser(edgeType);</span>
<span class="fc" id="L232">		this.edgeType = edgeType;</span>
<span class="fc" id="L233">	}</span>

	/**
	 * Set the builder for the edges identifiers.
	 *
	 * &lt;p&gt;
	 * The builder is used to generate edges identifiers if edges identifiers are not specified. The builder is
	 * mandatory if edges identifiers are not specified. In case edge identifiers are specified, an edge parser must be
	 * set (see {@link #setEdgeParser(Function)}). For default builders for certain types, see
	 * {@link #setEdgeBuilderDefault(Class)}.
	 *
	 * &lt;p&gt;
	 * The edge builder accepts a set of existing edges, and should return a new edge identifier that is not in the set.
	 *
	 * @param edgeBuilder a builder for the edges identifiers
	 */
	public void setEdgeBuilder(IdBuilder&lt;E&gt; edgeBuilder) {
<span class="fc" id="L250">		this.edgeBuilder = Objects.requireNonNull(edgeBuilder);</span>
<span class="fc" id="L251">	}</span>

	/**
	 * Set the builder for the edges identifiers, using a default builder for the given edge type.
	 *
	 * &lt;p&gt;
	 * The builder is used to generate edges identifiers if edges identifiers are not specified. The builder is
	 * mandatory if edges identifiers are not specified. In case edge identifiers are specified, an edge parser must be
	 * set (see {@link #setEdgeParser(Function)}). The default builder is instantiated using
	 * {@link IdBuilder#defaultBuilder(Class)}, see it documentation for supported types. If the given type is not
	 * supported by the default builder, the reader will throw an exception. In such case, the method
	 * {@link #setEdgeBuilder(IdBuilder)} should be used for custom builder.
	 *
	 * @param  edgeType                 the type of the edges
	 * @throws IllegalArgumentException if the given type is not supported by the default builder. See
	 *                                      {@link IdBuilder#defaultBuilder(Class)} for supported types
	 */
	public void setEdgeBuilderDefault(Class&lt;E&gt; edgeType) {
<span class="fc" id="L269">		edgeBuilder = IdBuilder.defaultBuilder(edgeType);</span>
<span class="fc" id="L270">		this.edgeType = edgeType;</span>
<span class="fc" id="L271">	}</span>

	@Override
	GraphBuilder&lt;V, E&gt; readIntoBuilderImpl(Reader reader) throws IOException {
<span class="fc bfc" id="L275" title="All 2 branches covered.">		if (vertexParser == null)</span>
<span class="fc" id="L276">			throw new IllegalStateException(&quot;Vertex parser was not set&quot;);</span>
		try {
			Document document =
<span class="fc" id="L279">					DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(new InputSource(reader));</span>
<span class="fc" id="L280">			Element doc = document.getDocumentElement();</span>
<span class="fc" id="L281">			doc.normalize();</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">			if (!doc.getTagName().equals(&quot;gexf&quot;))</span>
<span class="fc" id="L283">				throw new IllegalArgumentException(&quot;root element is not 'gexf'&quot;);</span>
<span class="fc" id="L284">			Element graph = XmlUtils.requiredChild(doc, &quot;graph&quot;);</span>

<span class="fc" id="L286">			boolean directed = graph.getAttribute(&quot;defaultedgetype&quot;).equals(&quot;directed&quot;);</span>
			GraphFactory&lt;V, E&gt; factory;
<span class="fc bfc" id="L288" title="All 4 branches covered.">			if (vertexType == int.class &amp;&amp; edgeType == int.class) {</span>
				@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L290">				GraphFactory&lt;V, E&gt; factory0 = (GraphFactory&lt;V, E&gt;) IntGraphFactory.newInstance(directed);</span>
<span class="fc" id="L291">				factory = factory0;</span>
<span class="fc" id="L292">			} else {</span>
<span class="fc" id="L293">				factory = GraphFactory.newInstance(directed);</span>
			}
<span class="fc" id="L295">			GraphBuilder&lt;V, E&gt; g = factory.allowSelfEdges().allowParallelEdges().newBuilder();</span>

<span class="fc bfc" id="L297" title="All 2 branches covered.">			if (XmlUtils.optionalAttribute(graph, &quot;mode&quot;).orElse(&quot;static&quot;).equals(&quot;dynamic&quot;))</span>
<span class="fc" id="L298">				throw new IllegalArgumentException(&quot;dynamic graphs are not supported&quot;);</span>

<span class="fc" id="L300">			Map&lt;String, BiConsumer&lt;V, String&gt;&gt; vWeights = new HashMap&lt;&gt;();</span>
<span class="fc" id="L301">			Map&lt;String, BiConsumer&lt;E, String&gt;&gt; eWeights = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L303" title="All 2 branches covered.">			for (Element attributesElm : XmlUtils.children(graph, &quot;attributes&quot;)) {</span>
<span class="fc" id="L304">				String clazz = XmlUtils.requiredAttribute(attributesElm, &quot;class&quot;);</span>
				boolean isVertices;
<span class="fc bfc" id="L306" title="All 2 branches covered.">				if (clazz.equals(&quot;node&quot;)) {</span>
<span class="fc" id="L307">					isVertices = true;</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">				} else if (clazz.equals(&quot;edge&quot;)) {</span>
<span class="fc" id="L309">					isVertices = false;</span>
				} else {
<span class="fc" id="L311">					throw new IllegalArgumentException(&quot;unknown attributes class: &quot; + clazz);</span>
				}

<span class="fc bfc" id="L314" title="All 2 branches covered.">				for (Element attributeElm : XmlUtils.children(attributesElm, &quot;attribute&quot;)) {</span>
<span class="fc" id="L315">					String weightsId = XmlUtils.requiredAttribute(attributeElm, &quot;id&quot;);</span>
<span class="fc" id="L316">					String weightsName = XmlUtils.requiredAttribute(attributeElm, &quot;title&quot;);</span>
<span class="fc" id="L317">					String typeStr = XmlUtils.requiredAttribute(attributeElm, &quot;type&quot;);</span>
<span class="fc" id="L318">					String defValStr =</span>
<span class="fc" id="L319">							XmlUtils.optionalChild(attributeElm, &quot;default&quot;).map(Element::getTextContent).orElse(null);</span>
<span class="fc" id="L320">					String optionsStr =</span>
<span class="fc" id="L321">							XmlUtils.optionalChild(attributeElm, &quot;options&quot;).map(Element::getTextContent).orElse(null);</span>

					Class&lt;?&gt; type;
					Object defVal;
					Function&lt;Weights&lt;Object, Object&gt;, BiConsumer&lt;Object, String&gt;&gt; setterFactory;
<span class="fc bfc" id="L326" title="All 10 branches covered.">					switch (typeStr) {</span>
						case &quot;byte&quot;: {
<span class="fc" id="L328">							type = byte.class;</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">							ByteSet options = optionsStr == null ? null : ByteSet.of(parseListByte(optionsStr));</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">							ByteUnaryOperator checkOptions = options == null ? ByteUnaryOperator.identity() : b -&gt; {</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">								if (!options.contains(b))</span>
<span class="fc" id="L332">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + b + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L334">								return b;</span>
							};
<span class="fc bfc" id="L336" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L337">									: Byte.valueOf(checkOptions.apply(Byte.parseByte(defValStr)));</span>
<span class="fc" id="L338">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L340">								WeightsByte&lt;Object&gt; weights2 = (WeightsByte) weights;</span>
<span class="fc" id="L341">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Byte.parseByte(val)));</span>
							};
<span class="fc" id="L343">							break;</span>
						}
						case &quot;short&quot;: {
<span class="fc" id="L346">							type = short.class;</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">							ShortSet options = optionsStr == null ? null : ShortSet.of(parseListShort(optionsStr));</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">							ShortUnaryOperator checkOptions = options == null ? ShortUnaryOperator.identity() : s -&gt; {</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">								if (!options.contains(s))</span>
<span class="fc" id="L350">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + s + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L352">								return s;</span>
							};
<span class="fc bfc" id="L354" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L355">									: Short.valueOf(checkOptions.apply(Short.parseShort(defValStr)));</span>
<span class="fc" id="L356">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L358">								WeightsShort&lt;Object&gt; weights2 = (WeightsShort) weights;</span>
<span class="fc" id="L359">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Short.parseShort(val)));</span>
							};
<span class="fc" id="L361">							break;</span>
						}
						case &quot;integer&quot;: {
<span class="fc" id="L364">							type = int.class;</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">							IntSet options = optionsStr == null ? null : IntSet.of(parseListInt(optionsStr));</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">							IntUnaryOperator checkOptions = options == null ? IntUnaryOperator.identity() : i -&gt; {</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">								if (!options.contains(i))</span>
<span class="fc" id="L368">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + i + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L370">								return i;</span>
							};
<span class="fc bfc" id="L372" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L373">									: Integer.valueOf(checkOptions.apply(Integer.parseInt(defValStr)));</span>
<span class="fc" id="L374">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L376">								WeightsInt&lt;Object&gt; weights2 = (WeightsInt) weights;</span>
<span class="fc" id="L377">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Integer.parseInt(val)));</span>
							};
<span class="fc" id="L379">							break;</span>
						}
						case &quot;long&quot;: {
<span class="fc" id="L382">							type = long.class;</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">							LongSet options = optionsStr == null ? null : LongSet.of(parseListLong(optionsStr));</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">							LongUnaryOperator checkOptions = options == null ? LongUnaryOperator.identity() : l -&gt; {</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">								if (!options.contains(l))</span>
<span class="fc" id="L386">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + l + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L388">								return l;</span>
							};
<span class="fc bfc" id="L390" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L391">									: Long.valueOf(checkOptions.apply(Long.parseLong(defValStr)));</span>
<span class="fc" id="L392">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L394">								WeightsLong&lt;Object&gt; weights2 = (WeightsLong) weights;</span>
<span class="fc" id="L395">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Long.parseLong(val)));</span>
							};
<span class="fc" id="L397">							break;</span>
						}
						case &quot;float&quot;: {
<span class="fc" id="L400">							type = float.class;</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">							FloatSet options = optionsStr == null ? null : FloatSet.of(parseListFloat(optionsStr));</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">							FloatUnaryOperator checkOptions = options == null ? FloatUnaryOperator.identity() : f -&gt; {</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">								if (!options.contains(f))</span>
<span class="fc" id="L404">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + f + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L406">								return f;</span>
							};
<span class="fc bfc" id="L408" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L409">									: Float.valueOf(checkOptions.apply(Float.parseFloat(defValStr)));</span>
<span class="fc" id="L410">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L412">								WeightsFloat&lt;Object&gt; weights2 = (WeightsFloat) weights;</span>
<span class="fc" id="L413">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Float.parseFloat(val)));</span>
							};
<span class="fc" id="L415">							break;</span>
						}
						case &quot;double&quot;: {
<span class="fc" id="L418">							type = double.class;</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">							DoubleSet options = optionsStr == null ? null : DoubleSet.of(parseListDouble(optionsStr));</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">							DoubleUnaryOperator checkOptions = options == null ? DoubleUnaryOperator.identity() : d -&gt; {</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">								if (!options.contains(d))</span>
<span class="fc" id="L422">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + d + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L424">								return d;</span>
							};
<span class="fc bfc" id="L426" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L427">									: Double.valueOf(checkOptions.apply(Double.parseDouble(defValStr)));</span>
<span class="fc" id="L428">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L430">								WeightsDouble&lt;Object&gt; weights2 = (WeightsDouble) weights;</span>
<span class="fc" id="L431">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Double.parseDouble(val)));</span>
							};
<span class="fc" id="L433">							break;</span>
						}
						case &quot;boolean&quot;: {
<span class="fc" id="L436">							type = boolean.class;</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">							BooleanSet options = optionsStr == null ? null : BooleanSet.of(parseListBool(optionsStr));</span>
							BooleanUnaryOperator checkOptions =
<span class="fc bfc" id="L439" title="All 2 branches covered.">									options == null ? BooleanUnaryOperator.identity() : b -&gt; {</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">										if (!options.contains(b))</span>
<span class="fc" id="L441">											throw new IllegalArgumentException(</span>
													&quot;invalid value: &quot; + b + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L443">										return b;</span>
									};
<span class="fc bfc" id="L445" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L446">									: Boolean.valueOf(checkOptions.apply(Boolean.parseBoolean(defValStr)));</span>
<span class="fc" id="L447">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L449">								WeightsBool&lt;Object&gt; weights2 = (WeightsBool) weights;</span>
<span class="fc" id="L450">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Boolean.parseBoolean(val)));</span>
							};
<span class="fc" id="L452">							break;</span>
						}
						case &quot;char&quot;: {
<span class="fc" id="L455">							type = char.class;</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">							CharSet options = optionsStr == null ? null : CharSet.of(parseListChar(optionsStr));</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">							CharUnaryOperator checkOptions = options == null ? CharUnaryOperator.identity() : c -&gt; {</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">								if (!options.contains(c))</span>
<span class="fc" id="L459">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + c + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L461">								return c;</span>
							};
<span class="fc bfc" id="L463" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L464">									: Character.valueOf(checkOptions.apply(GraphIoUtils.parseChar(defValStr)));</span>
<span class="fc" id="L465">							setterFactory = weights -&gt; {</span>
<span class="fc" id="L466">								return (o, val) -&gt; {</span>
									@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L468">									WeightsChar&lt;Object&gt; weights2 = (WeightsChar) weights;</span>
<span class="fc" id="L469">									weights2.set(o, checkOptions.apply(GraphIoUtils.parseChar(val)));</span>
<span class="fc" id="L470">								};</span>
							};
<span class="fc" id="L472">							break;</span>
						}

						/* common for all Object weights */
						case &quot;string&quot;:
						case &quot;date&quot;:
						case &quot;anyURI&quot;:
						case &quot;bigdecimal&quot;:
						case &quot;biginteger&quot;:
						case &quot;listbyte&quot;:
						case &quot;listshort&quot;:
						case &quot;listinteger&quot;:
						case &quot;listlong&quot;:
						case &quot;listfloat&quot;:
						case &quot;listdouble&quot;:
						case &quot;listboolean&quot;:
						case &quot;listchar&quot;:
						case &quot;liststring&quot;:
						case &quot;listbigdecimal&quot;:
						case &quot;listbiginteger&quot;: {
							Function&lt;String, Object&gt; parser;
<span class="fc" id="L493">							Set&lt;Object&gt; objOptions = null;</span>

<span class="pc bpc" id="L495" title="1 of 17 branches missed.">							switch (typeStr) {</span>
								case &quot;string&quot;:
<span class="fc" id="L497">									type = String.class;</span>
									objOptions =
<span class="fc bfc" id="L499" title="All 2 branches covered.">											optionsStr == null ? null : new ObjectOpenHashSet&lt;&gt;(splitList(optionsStr));</span>
<span class="fc" id="L500">									parser = s -&gt; s;</span>
<span class="fc" id="L501">									break;</span>
								case &quot;date&quot;:
<span class="fc" id="L503">									type = Date.class;</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">									objOptions = optionsStr == null ? null</span>
<span class="fc" id="L505">											: new ObjectOpenHashSet&lt;&gt;(parseListDate(optionsStr));</span>
<span class="fc" id="L506">									parser = this::parseDate;</span>
<span class="fc" id="L507">									break;</span>
								case &quot;anyURI&quot;:
<span class="fc" id="L509">									type = URI.class;</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">									objOptions = optionsStr == null ? null</span>
<span class="fc" id="L511">											: new ObjectOpenHashSet&lt;&gt;(parseListURI(optionsStr));</span>
<span class="fc" id="L512">									parser = GexfGraphReader::parseURI;</span>
<span class="fc" id="L513">									break;</span>
								case &quot;bigdecimal&quot;:
<span class="fc" id="L515">									type = BigDecimal.class;</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">									objOptions = optionsStr == null ? null</span>
<span class="fc" id="L517">											: new ObjectOpenHashSet&lt;&gt;(parseListBigDecimal(optionsStr));</span>
<span class="fc" id="L518">									parser = BigDecimal::new;</span>
<span class="fc" id="L519">									break;</span>
								case &quot;biginteger&quot;:
<span class="fc" id="L521">									type = BigInteger.class;</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">									objOptions = optionsStr == null ? null</span>
<span class="fc" id="L523">											: new ObjectOpenHashSet&lt;&gt;(parseListBigInteger(optionsStr));</span>
<span class="fc" id="L524">									parser = BigInteger::new;</span>
<span class="fc" id="L525">									break;</span>
								case &quot;listbyte&quot;:
<span class="fc" id="L527">									type = byte[].class;</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L529">										parser = GexfGraphReader::parseListByte;</span>
									} else {
<span class="fc" id="L531">										ByteSet options = ByteSet.of(parseListByte(optionsStr));</span>
<span class="fc" id="L532">										parser = val -&gt; {</span>
<span class="fc" id="L533">											byte[] list = GexfGraphReader.parseListByte(val);</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">											for (byte i : list)</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L536">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L538">											return list;</span>
										};
									}
<span class="fc" id="L541">									break;</span>
								case &quot;listshort&quot;:
<span class="fc" id="L543">									type = short[].class;</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L545">										parser = GexfGraphReader::parseListShort;</span>
									} else {
<span class="fc" id="L547">										ShortSet options = ShortSet.of(parseListShort(optionsStr));</span>
<span class="fc" id="L548">										parser = val -&gt; {</span>
<span class="fc" id="L549">											short[] list = GexfGraphReader.parseListShort(val);</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">											for (short i : list)</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L552">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L554">											return list;</span>
										};
									}
<span class="fc" id="L557">									break;</span>
								case &quot;listinteger&quot;:
<span class="fc" id="L559">									type = int[].class;</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L561">										parser = GexfGraphReader::parseListInt;</span>
									} else {
<span class="fc" id="L563">										IntSet options = IntSet.of(parseListInt(optionsStr));</span>
<span class="fc" id="L564">										parser = val -&gt; {</span>
<span class="fc" id="L565">											int[] list = GexfGraphReader.parseListInt(val);</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">											for (int i : list)</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L568">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L570">											return list;</span>
										};
									}
<span class="fc" id="L573">									break;</span>
								case &quot;listlong&quot;:
<span class="fc" id="L575">									type = long[].class;</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L577">										parser = GexfGraphReader::parseListLong;</span>
									} else {
<span class="fc" id="L579">										LongSet options = LongSet.of(parseListLong(optionsStr));</span>
<span class="fc" id="L580">										parser = val -&gt; {</span>
<span class="fc" id="L581">											long[] list = GexfGraphReader.parseListLong(val);</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">											for (long i : list)</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L584">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L586">											return list;</span>
										};
									}
<span class="fc" id="L589">									break;</span>
								case &quot;listfloat&quot;:
<span class="fc" id="L591">									type = float[].class;</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L593">										parser = GexfGraphReader::parseListFloat;</span>
									} else {
<span class="fc" id="L595">										FloatSet options = FloatSet.of(parseListFloat(optionsStr));</span>
<span class="fc" id="L596">										parser = val -&gt; {</span>
<span class="fc" id="L597">											float[] list = GexfGraphReader.parseListFloat(val);</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">											for (float i : list)</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L600">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L602">											return list;</span>
										};
									}
<span class="fc" id="L605">									break;</span>
								case &quot;listdouble&quot;:
<span class="fc" id="L607">									type = double[].class;</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L609">										parser = GexfGraphReader::parseListDouble;</span>
									} else {
<span class="fc" id="L611">										DoubleSet options = DoubleSet.of(parseListDouble(optionsStr));</span>
<span class="fc" id="L612">										parser = val -&gt; {</span>
<span class="fc" id="L613">											double[] list = GexfGraphReader.parseListDouble(val);</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">											for (double i : list)</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L616">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L618">											return list;</span>
										};
									}
<span class="fc" id="L621">									break;</span>
								case &quot;listboolean&quot;:
<span class="fc" id="L623">									type = boolean[].class;</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L625">										parser = GexfGraphReader::parseListBool;</span>
									} else {
<span class="fc" id="L627">										BooleanSet options = BooleanSet.of(parseListBool(optionsStr));</span>
<span class="fc" id="L628">										parser = val -&gt; {</span>
<span class="fc" id="L629">											boolean[] list = GexfGraphReader.parseListBool(val);</span>
<span class="fc bfc" id="L630" title="All 2 branches covered.">											for (boolean i : list)</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L632">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L634">											return list;</span>
										};
									}
<span class="fc" id="L637">									break;</span>
								case &quot;listchar&quot;:
<span class="fc" id="L639">									type = char[].class;</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L641">										parser = GexfGraphReader::parseListChar;</span>
									} else {
<span class="fc" id="L643">										CharSet options = CharSet.of(parseListChar(optionsStr));</span>
<span class="fc" id="L644">										parser = val -&gt; {</span>
<span class="fc" id="L645">											char[] list = GexfGraphReader.parseListChar(val);</span>
<span class="fc bfc" id="L646" title="All 2 branches covered.">											for (char i : list)</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L648">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L650">											return list;</span>
										};
									}
<span class="fc" id="L653">									break;</span>
								case &quot;liststring&quot;:
<span class="fc" id="L655">									type = String[].class;</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L657">										parser = GexfGraphReader::splitList;</span>
									} else {
<span class="fc" id="L659">										Set&lt;String&gt; options = new ObjectOpenHashSet&lt;&gt;(splitList(optionsStr));</span>
<span class="fc" id="L660">										parser = val -&gt; {</span>
<span class="fc" id="L661">											String[] list = splitList(val);</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">											for (String i : list)</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L664">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L666">											return list;</span>
										};
									}
<span class="fc" id="L669">									break;</span>
								case &quot;listbigdecimal&quot;:
<span class="fc" id="L671">									type = BigDecimal[].class;</span>
<span class="fc bfc" id="L672" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L673">										parser = GexfGraphReader::parseListBigDecimal;</span>
									} else {
<span class="fc" id="L675">										Set&lt;BigDecimal&gt; options =</span>
<span class="fc" id="L676">												new ObjectOpenHashSet&lt;&gt;(parseListBigDecimal(optionsStr));</span>
<span class="fc" id="L677">										parser = val -&gt; {</span>
<span class="fc" id="L678">											BigDecimal[] list = parseListBigDecimal(val);</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">											for (BigDecimal i : list)</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L681">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L683">											return list;</span>
										};
									}
<span class="fc" id="L686">									break;</span>
								case &quot;listbiginteger&quot;:
<span class="fc" id="L688">									type = BigInteger[].class;</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L690">										parser = GexfGraphReader::parseListBigInteger;</span>
									} else {
<span class="fc" id="L692">										Set&lt;BigInteger&gt; options =</span>
<span class="fc" id="L693">												new ObjectOpenHashSet&lt;&gt;(parseListBigInteger(optionsStr));</span>
<span class="fc" id="L694">										parser = val -&gt; {</span>
<span class="fc" id="L695">											BigInteger[] list = parseListBigInteger(val);</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">											for (BigInteger i : list)</span>
<span class="fc bfc" id="L697" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L698">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L700">											return list;</span>
										};
									}
<span class="fc" id="L703">									break;</span>
								default:
									/* can't each here, already matched the first switch to one of the object types */
<span class="nc" id="L706">									throw new AssertionError();</span>
							}

<span class="fc bfc" id="L709" title="All 2 branches covered.">							if (objOptions != null) {</span>
<span class="fc" id="L710">								Function&lt;String, Object&gt; parser0 = parser;</span>
<span class="fc" id="L711">								Set&lt;Object&gt; objOptions0 = objOptions;</span>
<span class="fc" id="L712">								parser = val -&gt; {</span>
<span class="fc" id="L713">									Object weight = parser0.apply(val);</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">									if (!objOptions0.contains(weight))</span>
<span class="fc" id="L715">										throw new IllegalArgumentException(</span>
												&quot;invalid value: &quot; + weight + &quot; (not in options: &quot; + objOptions0 + &quot;)&quot;);
<span class="fc" id="L717">									return weight;</span>
								};
							}
<span class="fc bfc" id="L720" title="All 2 branches covered.">							defVal = defValStr == null ? null : parser.apply(defValStr);</span>
<span class="fc" id="L721">							Function&lt;String, Object&gt; parser0 = parser;</span>
<span class="fc" id="L722">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L724">								WeightsObj&lt;Object, Object&gt; weights2 = (WeightsObj) weights;</span>
<span class="fc" id="L725">								return (o, val) -&gt; weights2.set(o, parser0.apply(val));</span>
							};
<span class="fc" id="L727">							break;</span>
						}
						default:
<span class="fc" id="L730">							throw new IllegalArgumentException(&quot;unknown attribute type: &quot; + typeStr);</span>
					}
<span class="fc bfc" id="L732" title="All 2 branches covered.">					if (isVertices) {</span>
						@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L734">						Class&lt;Object&gt; attrType0 = (Class&lt;Object&gt;) type;</span>
<span class="fc" id="L735">						Weights&lt;V, Object&gt; weights = g.addVerticesWeights(weightsName, attrType0, defVal);</span>
						@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L737">						BiConsumer&lt;V, String&gt; setter =</span>
<span class="fc" id="L738">								(BiConsumer&lt;V, String&gt;) setterFactory.apply((Weights&lt;Object, Object&gt;) weights);</span>
<span class="fc" id="L739">						Object oldVal = vWeights.put(weightsId, setter);</span>
<span class="fc bfc" id="L740" title="All 2 branches covered.">						if (oldVal != null)</span>
<span class="fc" id="L741">							throw new IllegalArgumentException(&quot;duplicate node attribute id: &quot; + weightsId);</span>
<span class="fc" id="L742">					} else {</span>
						@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L744">						Class&lt;Object&gt; type0 = (Class&lt;Object&gt;) type;</span>
<span class="fc" id="L745">						Weights&lt;E, Object&gt; weights = g.addEdgesWeights(weightsName, type0, defVal);</span>
						@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L747">						BiConsumer&lt;E, String&gt; setter =</span>
<span class="fc" id="L748">								(BiConsumer&lt;E, String&gt;) setterFactory.apply((Weights&lt;Object, Object&gt;) weights);</span>
<span class="fc" id="L749">						Object oldVal = eWeights.put(weightsId, setter);</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">						if (oldVal != null)</span>
<span class="fc" id="L751">							throw new IllegalArgumentException(&quot;duplicate edge attribute id: &quot; + weightsId);</span>
					}
<span class="fc" id="L753">				}</span>
<span class="fc" id="L754">			}</span>

<span class="fc" id="L756">			WeightsObj&lt;V, String&gt; vLabels = null;</span>
<span class="fc" id="L757">			WeightsObj&lt;E, String&gt; eLabels = null;</span>
<span class="fc" id="L758">			WeightsDouble&lt;E&gt; eWeight = null;</span>

<span class="fc" id="L760">			Iterable&lt;Element&gt; nodes = XmlUtils</span>
<span class="fc" id="L761">					.optionalChild(graph, &quot;nodes&quot;)</span>
<span class="fc" id="L762">					.map(nodesElm -&gt; XmlUtils.children(nodesElm, &quot;node&quot;))</span>
<span class="fc" id="L763">					.orElse(Collections.emptyList());</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">			for (Element vElm : nodes) {</span>
<span class="fc" id="L765">				V v = vertexParser.apply(XmlUtils.requiredAttribute(vElm, &quot;id&quot;));</span>
<span class="fc" id="L766">				g.addVertex(v);</span>

<span class="fc" id="L768">				Optional&lt;String&gt; label = XmlUtils.optionalAttribute(vElm, &quot;label&quot;);</span>
<span class="fc bfc" id="L769" title="All 2 branches covered.">				if (label.isPresent()) {</span>
<span class="fc bfc" id="L770" title="All 2 branches covered.">					if (vLabels == null)</span>
<span class="fc" id="L771">						vLabels = g.addVerticesWeights(&quot;label&quot;, String.class);</span>
<span class="fc" id="L772">					vLabels.set(v, label.get());</span>
				}

<span class="fc" id="L775">				Optional&lt;Element&gt; attvaluesElm0 = XmlUtils.optionalChild(vElm, &quot;attvalues&quot;);</span>
<span class="fc bfc" id="L776" title="All 2 branches covered.">				if (attvaluesElm0.isPresent()) {</span>
<span class="fc" id="L777">					Element attvaluesElm = attvaluesElm0.get();</span>
<span class="fc bfc" id="L778" title="All 2 branches covered.">					for (Element attvalueElm : XmlUtils.children(attvaluesElm, &quot;attvalue&quot;)) {</span>
<span class="fc" id="L779">						String weightsId = XmlUtils.requiredAttribute(attvalueElm, &quot;for&quot;);</span>
<span class="fc" id="L780">						String value = XmlUtils.requiredAttribute(attvalueElm, &quot;value&quot;);</span>
<span class="fc" id="L781">						BiConsumer&lt;V, String&gt; setter = vWeights.get(weightsId);</span>
<span class="fc bfc" id="L782" title="All 2 branches covered.">						if (setter == null)</span>
<span class="fc" id="L783">							throw new IllegalArgumentException(&quot;unknown attribute id: &quot; + weightsId);</span>
<span class="fc" id="L784">						setter.accept(v, value);</span>
<span class="fc" id="L785">					}</span>
				}
<span class="fc" id="L787">			}</span>

<span class="fc" id="L789">			Iterable&lt;Element&gt; edges = XmlUtils</span>
<span class="fc" id="L790">					.optionalChild(graph, &quot;edges&quot;)</span>
<span class="fc" id="L791">					.map(edgesElm -&gt; XmlUtils.children(edgesElm, &quot;edge&quot;))</span>
<span class="fc" id="L792">					.orElse(Collections.emptyList());</span>
<span class="fc bfc" id="L793" title="All 2 branches covered.">			for (Element eElm : edges) {</span>
				E e;
<span class="fc" id="L795">				Optional&lt;String&gt; id = XmlUtils.optionalAttribute(eElm, &quot;id&quot;);</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">				if (id.isPresent()) {</span>
<span class="fc bfc" id="L797" title="All 2 branches covered.">					if (edgeParser == null)</span>
<span class="fc" id="L798">						throw new IllegalStateException(&quot;Edge parser was not set&quot;);</span>
<span class="fc" id="L799">					e = edgeParser.apply(id.get());</span>
				} else {
<span class="fc bfc" id="L801" title="All 2 branches covered.">					if (edgeBuilder == null)</span>
<span class="fc" id="L802">						throw new IllegalStateException(&quot;Edge builder was not set&quot;);</span>
<span class="fc" id="L803">					e = edgeBuilder.build(g.edges());</span>
				}
<span class="fc" id="L805">				V u = vertexParser.apply(XmlUtils.requiredAttribute(eElm, &quot;source&quot;));</span>
<span class="fc" id="L806">				V v = vertexParser.apply(XmlUtils.requiredAttribute(eElm, &quot;target&quot;));</span>
<span class="fc" id="L807">				g.addEdge(u, v, e);</span>

<span class="fc bfc" id="L809" title="All 2 branches covered.">				if (eElm.hasAttribute(&quot;type&quot;))</span>
<span class="fc" id="L810">					throw new IllegalArgumentException(&quot;directed attribute per-edge is not supported&quot;);</span>

<span class="fc" id="L812">				Optional&lt;String&gt; label = XmlUtils.optionalAttribute(eElm, &quot;label&quot;);</span>
<span class="fc bfc" id="L813" title="All 2 branches covered.">				if (label.isPresent()) {</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">					if (eLabels == null)</span>
<span class="fc" id="L815">						eLabels = g.addEdgesWeights(&quot;label&quot;, String.class);</span>
<span class="fc" id="L816">					eLabels.set(e, label.get());</span>
				}

<span class="fc" id="L819">				Optional&lt;String&gt; weight = XmlUtils.optionalAttribute(eElm, &quot;weight&quot;);</span>
<span class="fc bfc" id="L820" title="All 2 branches covered.">				if (weight.isPresent()) {</span>
<span class="fc bfc" id="L821" title="All 2 branches covered.">					if (eWeight == null)</span>
<span class="fc" id="L822">						eWeight = g.addEdgesWeights(&quot;weight&quot;, double.class, Double.valueOf(1.0));</span>
<span class="fc" id="L823">					eWeight.set(e, Double.parseDouble(weight.get()));</span>
				}

<span class="fc" id="L826">				Optional&lt;Element&gt; attvaluesElm0 = XmlUtils.optionalChild(eElm, &quot;attvalues&quot;);</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">				if (attvaluesElm0.isPresent()) {</span>
<span class="fc" id="L828">					Element attvaluesElm = attvaluesElm0.get();</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">					for (Element attvalueElm : XmlUtils.children(attvaluesElm, &quot;attvalue&quot;)) {</span>
<span class="fc" id="L830">						String weightsId = XmlUtils.requiredAttribute(attvalueElm, &quot;for&quot;);</span>
<span class="fc" id="L831">						String value = XmlUtils.requiredAttribute(attvalueElm, &quot;value&quot;);</span>
<span class="fc" id="L832">						BiConsumer&lt;E, String&gt; setter = eWeights.get(weightsId);</span>
<span class="fc bfc" id="L833" title="All 2 branches covered.">						if (setter == null)</span>
<span class="fc" id="L834">							throw new IllegalArgumentException(&quot;unknown attribute id: &quot; + weightsId);</span>
<span class="fc" id="L835">						setter.accept(e, value);</span>
<span class="fc" id="L836">					}</span>
				}
<span class="fc" id="L838">			}</span>

<span class="fc" id="L840">			return g;</span>
<span class="fc" id="L841">		} catch (SAXException | ParserConfigurationException e) {</span>
<span class="fc" id="L842">			throw new IllegalArgumentException(e);</span>
		}
	}

	private Date parseDate(String s) {
		try {
<span class="fc" id="L848">			return dateFormat.parse(s);</span>
<span class="fc" id="L849">		} catch (ParseException e) {</span>
<span class="fc" id="L850">			throw new IllegalArgumentException(e);</span>
		}
	}

	private static URI parseURI(String s) {
		try {
<span class="fc" id="L856">			return new URI(s);</span>
<span class="fc" id="L857">		} catch (URISyntaxException e) {</span>
<span class="fc" id="L858">			throw new IllegalArgumentException(e);</span>
		}
	}

	private static byte[] parseListByte(String val) {
<span class="fc" id="L863">		String[] words = splitList(val);</span>
<span class="fc" id="L864">		byte[] list = new byte[words.length];</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">		for (int i : range(words.length))</span>
<span class="fc" id="L866">			list[i] = Byte.parseByte(words[i]);</span>
<span class="fc" id="L867">		return list;</span>
	}

	private static short[] parseListShort(String val) {
<span class="fc" id="L871">		String[] words = splitList(val);</span>
<span class="fc" id="L872">		short[] list = new short[words.length];</span>
<span class="fc bfc" id="L873" title="All 2 branches covered.">		for (int i : range(words.length))</span>
<span class="fc" id="L874">			list[i] = Short.parseShort(words[i]);</span>
<span class="fc" id="L875">		return list;</span>
	}

	private static int[] parseListInt(String val) {
<span class="fc" id="L879">		String[] words = splitList(val);</span>
<span class="fc" id="L880">		int[] list = new int[words.length];</span>
<span class="fc bfc" id="L881" title="All 2 branches covered.">		for (int i : range(words.length))</span>
<span class="fc" id="L882">			list[i] = Integer.parseInt(words[i]);</span>
<span class="fc" id="L883">		return list;</span>
	}

	private static long[] parseListLong(String val) {
<span class="fc" id="L887">		String[] words = splitList(val);</span>
<span class="fc" id="L888">		long[] list = new long[words.length];</span>
<span class="fc bfc" id="L889" title="All 2 branches covered.">		for (int i : range(words.length))</span>
<span class="fc" id="L890">			list[i] = Long.parseLong(words[i]);</span>
<span class="fc" id="L891">		return list;</span>
	}

	private static float[] parseListFloat(String val) {
<span class="fc" id="L895">		String[] words = splitList(val);</span>
<span class="fc" id="L896">		float[] list = new float[words.length];</span>
<span class="fc bfc" id="L897" title="All 2 branches covered.">		for (int i : range(words.length))</span>
<span class="fc" id="L898">			list[i] = Float.parseFloat(words[i]);</span>
<span class="fc" id="L899">		return list;</span>
	}

	private static double[] parseListDouble(String val) {
<span class="fc" id="L903">		String[] words = splitList(val);</span>
<span class="fc" id="L904">		double[] list = new double[words.length];</span>
<span class="fc bfc" id="L905" title="All 2 branches covered.">		for (int i : range(words.length))</span>
<span class="fc" id="L906">			list[i] = Double.parseDouble(words[i]);</span>
<span class="fc" id="L907">		return list;</span>
	}

	private static boolean[] parseListBool(String val) {
<span class="fc" id="L911">		String[] words = splitList(val);</span>
<span class="fc" id="L912">		boolean[] list = new boolean[words.length];</span>
<span class="fc bfc" id="L913" title="All 2 branches covered.">		for (int i : range(words.length))</span>
<span class="fc" id="L914">			list[i] = Boolean.parseBoolean(words[i]);</span>
<span class="fc" id="L915">		return list;</span>
	}

	private static char[] parseListChar(String val) {
<span class="fc" id="L919">		String[] words = splitList(val);</span>
<span class="fc" id="L920">		char[] list = new char[words.length];</span>
<span class="fc bfc" id="L921" title="All 2 branches covered.">		for (int i : range(words.length))</span>
<span class="fc" id="L922">			list[i] = GraphIoUtils.parseChar(words[i]);</span>
<span class="fc" id="L923">		return list;</span>
	}

	private static BigDecimal[] parseListBigDecimal(String val) {
<span class="fc" id="L927">		String[] words = splitList(val);</span>
<span class="fc" id="L928">		BigDecimal[] list = new BigDecimal[words.length];</span>
<span class="fc bfc" id="L929" title="All 2 branches covered.">		for (int i : range(words.length))</span>
<span class="fc" id="L930">			list[i] = new BigDecimal(words[i]);</span>
<span class="fc" id="L931">		return list;</span>
	}

	private static BigInteger[] parseListBigInteger(String val) {
<span class="fc" id="L935">		String[] words = splitList(val);</span>
<span class="fc" id="L936">		BigInteger[] list = new BigInteger[words.length];</span>
<span class="fc bfc" id="L937" title="All 2 branches covered.">		for (int i : range(words.length))</span>
<span class="fc" id="L938">			list[i] = new BigInteger(words[i]);</span>
<span class="fc" id="L939">		return list;</span>
	}

	private static URI[] parseListURI(String val) {
<span class="fc" id="L943">		String[] words = splitList(val);</span>
<span class="fc" id="L944">		URI[] list = new URI[words.length];</span>
<span class="fc bfc" id="L945" title="All 2 branches covered.">		for (int i : range(words.length))</span>
<span class="fc" id="L946">			list[i] = parseURI(words[i]);</span>
<span class="fc" id="L947">		return list;</span>
	}

	private Date[] parseListDate(String val) {
<span class="fc" id="L951">		String[] words = splitList(val);</span>
<span class="fc" id="L952">		Date[] list = new Date[words.length];</span>
<span class="fc bfc" id="L953" title="All 2 branches covered.">		for (int i : range(words.length))</span>
<span class="fc" id="L954">			list[i] = parseDate(words[i]);</span>
<span class="fc" id="L955">		return list;</span>
	}

	private static String[] splitList(String s) {
<span class="fc bfc" id="L959" title="All 4 branches covered.">		if (!s.startsWith(&quot;[&quot;) || !s.endsWith(&quot;]&quot;))</span>
<span class="fc" id="L960">			throw new IllegalArgumentException(&quot;list attribute must be of the form [val1, val2,...]&quot;);</span>
<span class="fc" id="L961">		s = s.substring(1, s.length() - 1);</span>
<span class="fc" id="L962">		String[] words = s.split(&quot;,&quot;);</span>
<span class="fc bfc" id="L963" title="All 2 branches covered.">		for (int i : range(words.length))</span>
<span class="fc" id="L964">			words[i] = words[i].trim();</span>
<span class="fc" id="L965">		return words;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>