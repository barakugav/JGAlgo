<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GexfGraphReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - IO</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.io</a> &gt; <span class="el_source">GexfGraphReader.java</span></div><h1>GexfGraphReader.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.io;

import java.io.IOException;
import java.io.Reader;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.URI;
import java.net.URISyntaxException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.Function;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import com.jgalgo.graph.Graph;
import com.jgalgo.graph.GraphBuilder;
import com.jgalgo.graph.GraphFactory;
import com.jgalgo.graph.IdBuilder;
import com.jgalgo.graph.IntGraphFactory;
import com.jgalgo.graph.Weights;
import com.jgalgo.graph.WeightsBool;
import com.jgalgo.graph.WeightsByte;
import com.jgalgo.graph.WeightsChar;
import com.jgalgo.graph.WeightsDouble;
import com.jgalgo.graph.WeightsFloat;
import com.jgalgo.graph.WeightsInt;
import com.jgalgo.graph.WeightsLong;
import com.jgalgo.graph.WeightsObj;
import com.jgalgo.graph.WeightsShort;
import it.unimi.dsi.fastutil.booleans.BooleanSet;
import it.unimi.dsi.fastutil.booleans.BooleanUnaryOperator;
import it.unimi.dsi.fastutil.bytes.ByteSet;
import it.unimi.dsi.fastutil.bytes.ByteUnaryOperator;
import it.unimi.dsi.fastutil.chars.CharSet;
import it.unimi.dsi.fastutil.chars.CharUnaryOperator;
import it.unimi.dsi.fastutil.doubles.DoubleSet;
import it.unimi.dsi.fastutil.doubles.DoubleUnaryOperator;
import it.unimi.dsi.fastutil.floats.FloatSet;
import it.unimi.dsi.fastutil.floats.FloatUnaryOperator;
import it.unimi.dsi.fastutil.ints.IntSet;
import it.unimi.dsi.fastutil.ints.IntUnaryOperator;
import it.unimi.dsi.fastutil.longs.LongSet;
import it.unimi.dsi.fastutil.longs.LongUnaryOperator;
import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
import it.unimi.dsi.fastutil.shorts.ShortSet;
import it.unimi.dsi.fastutil.shorts.ShortUnaryOperator;

/**
 * Read a graph in 'GEXF' format.
 *
 * &lt;p&gt;
 * GEXF is an XML-based format for graphs. Both directed and undirected graphs are supported, along with mixed graphs
 * (some edges are directed while others are undirected) although the {@link Graph} does not supported mixed graphs
 * (therefore the reader also doesn't support it). The format support graphs with vertices and edges of any type, as
 * long as they can be written as an XML attribute string. The format also support multiple weights for vertices and
 * edges, of any primitive Java type ({@code int}, {@code long}, {@code double}, {@code boolean}, ect.), {@link String},
 * {@link Date}, {@link URI}, {@link BigInteger}, {@link BigDecimal}, along with 'list' (arrays) of any of the above
 * except {@link Date} and {@link URI}.
 *
 * &lt;p&gt;
 * Identifiers of vertices are mandatory, and must be unique. Identifiers of edges are optional, if not specified the
 * reader will try generate them using a builder provided by the user, or a default builder for certain types (see
 * {@link #setEdgeBuilder(IdBuilder)} and {@link #setEdgeBuilderDefault(Class)}). Vertices identifiers (and edges
 * identifiers if specified) are parsed using a parser provided by the user, or a default parser for certain types (see
 * {@link #setVertexParserDefault(Class)} and {@link #setEdgeParserDefault(Class)}).
 *
 * &lt;p&gt;
 * When the reader reads a graph with weights, it will create a {@link Weights} object for each type of weights. For any
 * of the primitive types such as {@code int}, {@code long}, {@code double}, {@code boolean}, ect., the reader will
 * create a {@link Weights} object of the corresponding type, such as {@link WeightsInt}, {@link WeightsLong},
 * {@link WeightsDouble}, {@link WeightsBool}, ect. For {@link String}, {@link Date}, {@link URI}, {@link BigInteger},
 * {@link BigDecimal}, the reader will create a {@link Weights} object of type {@link WeightsObj}. For 'list' types,
 * which are supported for any primitive, {@link String}, {@link BigInteger} and {@link BigDecimal}, the reader will
 * create a {@link Weights} object of type {@link WeightsObj} and will populate it with arrays of the corresponding
 * type, such as {@code int[]}, {@code long[]}, {@code String[]}, {@code BigInteger[]}, ect. Default values are
 * supported for all types of weights, and will be available after reading via {@link Weights#defaultWeightAsObj()} or
 * any of the specific types weights such as {@link WeightsInt#defaultWeight()}. Note that the default value of 'list'
 * types is an array, which is shared between all vertices/edges that do not explicitly specify a value for the weight,
 * and should not be modified.
 *
 * &lt;p&gt;
 * The GEXF format support both self edges and parallel edges. The format documentation can be found
 * &lt;a href= &quot;https://gexf.net/&quot;&gt;here&lt;/a&gt;.
 *
 * @see    GexfGraphWriter
 * @author Barak Ugav
 */
public class GexfGraphReader&lt;V, E&gt; extends GraphIoUtils.AbstractGraphReader&lt;V, E&gt; {

	private Class&lt;V&gt; vertexType;
	private Class&lt;E&gt; edgeType;
	private Function&lt;String, V&gt; vertexParser;
	private Function&lt;String, E&gt; edgeParser;
	private IdBuilder&lt;E&gt; edgeBuilder;
<span class="fc" id="L121">	private final SimpleDateFormat dateFormat = new SimpleDateFormat(Gexf.DateFormat);</span>

	/**
	 * Create a new reader.
	 *
	 * &lt;p&gt;
	 * The user should set the vertex/edge parsers and edge builder manually using {@link #setVertexParser(Function)},
	 * {@link #setEdgeParser(Function)} and {@link #setEdgeBuilder(IdBuilder)}. Setting the vertex parser is mandatory,
	 * while setting the edge parser is only required if edges identifiers are specified. Similarly, setting the edge
	 * builder is only required if edges identifiers are not specified.
	 */
<span class="fc" id="L132">	public GexfGraphReader() {}</span>

	/**
	 * Create a new reader with default parsers and builders for the given vertex and edge types.
	 *
	 * &lt;p&gt;
	 * During the reading process, the reader will use the parser to convert the vertex identifiers from string to the
	 * given type, and similarly for edges if edges identifiers are specified. If edges identifiers are not specified,
	 * the reader will use the builder to generate them. Default parsers exist for types {@code byte}, {@code short},
	 * {@code int}, {@code long}, {@code float}, {@code double} and {@code String}. Default edge builder is instantiated
	 * using {@link IdBuilder#defaultBuilder(Class)}, see it documentation for supported types. If the given types are
	 * not supported by the default parsers and builder, the reader will throw an exception. In such case, the
	 * constructor {@link #GexfGraphReader()} should be used, and the user should set the vertex/edge parsers and edge
	 * builder manually using {@link #setVertexParser(Function)}, {@link #setEdgeParser(Function)} and
	 * {@link #setEdgeBuilder(IdBuilder)}.
	 *
	 *
	 * @param  vertexType               the type of the vertices
	 * @param  edgeType                 the type of the edges
	 * @throws IllegalArgumentException if the given types are not supported by the default vertex/edge parsers and edge
	 *                                      builder. The supported types are {@code byte}, {@code short}, {@code int},
	 *                                      {@code long}, {@code float}, {@code double} and {@code String}.
	 * @see                             #setVertexParserDefault(Class)
	 * @see                             #setEdgeParserDefault(Class)
	 * @see                             #setEdgeBuilderDefault(Class)
	 */
<span class="fc" id="L158">	public GexfGraphReader(Class&lt;V&gt; vertexType, Class&lt;E&gt; edgeType) {</span>
<span class="fc" id="L159">		setVertexParserDefault(this.vertexType = vertexType);</span>
<span class="fc" id="L160">		setEdgeParserDefault(this.edgeType = edgeType);</span>
<span class="fc" id="L161">		setEdgeBuilderDefault(this.edgeType);</span>
<span class="fc" id="L162">	}</span>

	/**
	 * Set the parser for the vertices identifiers.
	 *
	 * &lt;p&gt;
	 * The parser is used to convert the vertex identifiers from string to the given vertex type. The parser is
	 * mandatory, and must be set before reading a graph. For default parsers for certain types, see
	 * {@link #setVertexParserDefault(Class)}.
	 *
	 * @param vertexParser a parser for the vertices identifiers
	 */
	public void setVertexParser(Function&lt;String, V&gt; vertexParser) {
<span class="fc" id="L175">		this.vertexParser = Objects.requireNonNull(vertexParser);</span>
<span class="fc" id="L176">	}</span>

	/**
	 * Set the parser for the vertices identifiers, using a default parser for the given vertex type.
	 *
	 * &lt;p&gt;
	 * The parser is used to convert the vertex identifiers from string to the given vertex type. The parser is
	 * mandatory, and must be set before reading a graph. The default parser exists for types {@code byte},
	 * {@code short}, {@code int}, {@code long}, {@code float}, {@code double} and {@code String}. If the given type is
	 * not supported by the default parser, the reader will throw an exception. In such case, the method
	 * {@link #setVertexParser(Function)} should be used for custom parsing.
	 *
	 * @param  vertexType               the type of the vertices
	 * @throws IllegalArgumentException if the given type is not supported by the default parser. The supported types
	 *                                      are {@code byte}, {@code short}, {@code int}, {@code long}, {@code float},
	 *                                      {@code double} and {@code String}.
	 */
	public void setVertexParserDefault(Class&lt;V&gt; vertexType) {
<span class="fc" id="L194">		this.vertexParser = GraphIoUtils.defaultParser(vertexType);</span>
<span class="fc" id="L195">		this.vertexType = vertexType;</span>
<span class="fc" id="L196">	}</span>

	/**
	 * Set the parser for the edges identifiers.
	 *
	 * &lt;p&gt;
	 * The parser is used to convert the edges identifiers from string to the given edge type. The parser is mandatory
	 * if edges identifiers are specified. In case edge identifiers are not specified, an edge builder must be set (see
	 * {@link #setEdgeBuilder(IdBuilder)}). For default parsers for certain types, see
	 * {@link #setEdgeParserDefault(Class)}.
	 *
	 * @param edgeParser a parser for the edges identifiers
	 */
	public void setEdgeParser(Function&lt;String, E&gt; edgeParser) {
<span class="fc" id="L210">		this.edgeParser = Objects.requireNonNull(edgeParser);</span>
<span class="fc" id="L211">	}</span>

	/**
	 * Set the parser for the edges identifiers, using a default parser for the given edge type.
	 *
	 * &lt;p&gt;
	 * The parser is used to convert the edges identifiers from string to the given edge type. The parser is mandatory
	 * if edges identifiers are specified. In case edge identifiers are not specified, an edge builder must be set (see
	 * {@link #setEdgeBuilder(IdBuilder)}). The default parser exists for types {@code byte}, {@code short},
	 * {@code int}, {@code long}, {@code float}, {@code double} and {@code String}. If the given type is not supported
	 * by the default parser, the reader will throw an exception. In such case, the method
	 * {@link #setEdgeParser(Function)} should be used for custom parsing.
	 *
	 * @param  edgeType                 the type of the edges
	 * @throws IllegalArgumentException if the given type is not supported by the default parser. The supported types
	 *                                      are {@code byte}, {@code short}, {@code int}, {@code long}, {@code float},
	 *                                      {@code double} and {@code String}.
	 */
	public void setEdgeParserDefault(Class&lt;E&gt; edgeType) {
<span class="fc" id="L230">		this.edgeParser = GraphIoUtils.defaultParser(edgeType);</span>
<span class="fc" id="L231">		this.edgeType = edgeType;</span>
<span class="fc" id="L232">	}</span>

	/**
	 * Set the builder for the edges identifiers.
	 *
	 * &lt;p&gt;
	 * The builder is used to generate edges identifiers if edges identifiers are not specified. The builder is
	 * mandatory if edges identifiers are not specified. In case edge identifiers are specified, an edge parser must be
	 * set (see {@link #setEdgeParser(Function)}). For default builders for certain types, see
	 * {@link #setEdgeBuilderDefault(Class)}.
	 *
	 * &lt;p&gt;
	 * The edge builder accepts a set of existing edges, and should return a new edge identifier that is not in the set.
	 *
	 * @param edgeBuilder a builder for the edges identifiers
	 */
	public void setEdgeBuilder(IdBuilder&lt;E&gt; edgeBuilder) {
<span class="fc" id="L249">		this.edgeBuilder = Objects.requireNonNull(edgeBuilder);</span>
<span class="fc" id="L250">	}</span>

	/**
	 * Set the builder for the edges identifiers, using a default builder for the given edge type.
	 *
	 * &lt;p&gt;
	 * The builder is used to generate edges identifiers if edges identifiers are not specified. The builder is
	 * mandatory if edges identifiers are not specified. In case edge identifiers are specified, an edge parser must be
	 * set (see {@link #setEdgeParser(Function)}). The default builder is instantiated using
	 * {@link IdBuilder#defaultBuilder(Class)}, see it documentation for supported types. If the given type is not
	 * supported by the default builder, the reader will throw an exception. In such case, the method
	 * {@link #setEdgeBuilder(IdBuilder)} should be used for custom builder.
	 *
	 * @param  edgeType                 the type of the edges
	 * @throws IllegalArgumentException if the given type is not supported by the default builder. See
	 *                                      {@link IdBuilder#defaultBuilder(Class)} for supported types
	 */
	public void setEdgeBuilderDefault(Class&lt;E&gt; edgeType) {
<span class="fc" id="L268">		edgeBuilder = IdBuilder.defaultBuilder(edgeType);</span>
<span class="fc" id="L269">		this.edgeType = edgeType;</span>
<span class="fc" id="L270">	}</span>

	@Override
	GraphBuilder&lt;V, E&gt; readIntoBuilderImpl(Reader reader) throws IOException {
<span class="fc bfc" id="L274" title="All 2 branches covered.">		if (vertexParser == null)</span>
<span class="fc" id="L275">			throw new IllegalStateException(&quot;Vertex parser was not set&quot;);</span>
		try {
			Document document =
<span class="fc" id="L278">					DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(new InputSource(reader));</span>
<span class="fc" id="L279">			Element doc = document.getDocumentElement();</span>
<span class="fc" id="L280">			doc.normalize();</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">			if (!doc.getTagName().equals(&quot;gexf&quot;))</span>
<span class="fc" id="L282">				throw new IllegalArgumentException(&quot;root element is not 'gexf'&quot;);</span>
<span class="fc" id="L283">			Element graph = XmlUtils.requiredChild(doc, &quot;graph&quot;);</span>

<span class="fc" id="L285">			boolean directed = graph.getAttribute(&quot;defaultedgetype&quot;).equals(&quot;directed&quot;);</span>
			GraphFactory&lt;V, E&gt; factory;
<span class="fc bfc" id="L287" title="All 4 branches covered.">			if (vertexType == int.class &amp;&amp; edgeType == int.class) {</span>
				@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L289">				GraphFactory&lt;V, E&gt; factory0 = (GraphFactory&lt;V, E&gt;) IntGraphFactory.newInstance(directed);</span>
<span class="fc" id="L290">				factory = factory0;</span>
<span class="fc" id="L291">			} else {</span>
<span class="fc" id="L292">				factory = GraphFactory.newInstance(directed);</span>
			}
<span class="fc" id="L294">			GraphBuilder&lt;V, E&gt; g = factory.allowSelfEdges().allowParallelEdges().newBuilder();</span>

<span class="fc bfc" id="L296" title="All 2 branches covered.">			if (XmlUtils.optionalAttribute(graph, &quot;mode&quot;).orElse(&quot;static&quot;).equals(&quot;dynamic&quot;))</span>
<span class="fc" id="L297">				throw new IllegalArgumentException(&quot;dynamic graphs are not supported&quot;);</span>

<span class="fc" id="L299">			Map&lt;String, BiConsumer&lt;V, String&gt;&gt; vWeights = new HashMap&lt;&gt;();</span>
<span class="fc" id="L300">			Map&lt;String, BiConsumer&lt;E, String&gt;&gt; eWeights = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L302" title="All 2 branches covered.">			for (Element attributesElm : XmlUtils.children(graph, &quot;attributes&quot;)) {</span>
<span class="fc" id="L303">				String clazz = XmlUtils.requiredAttribute(attributesElm, &quot;class&quot;);</span>
				boolean isVertices;
<span class="fc bfc" id="L305" title="All 2 branches covered.">				if (clazz.equals(&quot;node&quot;)) {</span>
<span class="fc" id="L306">					isVertices = true;</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">				} else if (clazz.equals(&quot;edge&quot;)) {</span>
<span class="fc" id="L308">					isVertices = false;</span>
				} else {
<span class="fc" id="L310">					throw new IllegalArgumentException(&quot;unknown attributes class: &quot; + clazz);</span>
				}

<span class="fc bfc" id="L313" title="All 2 branches covered.">				for (Element attributeElm : XmlUtils.children(attributesElm, &quot;attribute&quot;)) {</span>
<span class="fc" id="L314">					String weightsId = XmlUtils.requiredAttribute(attributeElm, &quot;id&quot;);</span>
<span class="fc" id="L315">					String weightsName = XmlUtils.requiredAttribute(attributeElm, &quot;title&quot;);</span>
<span class="fc" id="L316">					String typeStr = XmlUtils.requiredAttribute(attributeElm, &quot;type&quot;);</span>
<span class="fc" id="L317">					String defValStr =</span>
<span class="fc" id="L318">							XmlUtils.optionalChild(attributeElm, &quot;default&quot;).map(Element::getTextContent).orElse(null);</span>
<span class="fc" id="L319">					String optionsStr =</span>
<span class="fc" id="L320">							XmlUtils.optionalChild(attributeElm, &quot;options&quot;).map(Element::getTextContent).orElse(null);</span>

					Class&lt;?&gt; type;
					Object defVal;
					Function&lt;Weights&lt;Object, Object&gt;, BiConsumer&lt;Object, String&gt;&gt; setterFactory;
<span class="fc bfc" id="L325" title="All 10 branches covered.">					switch (typeStr) {</span>
						case &quot;byte&quot;: {
<span class="fc" id="L327">							type = byte.class;</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">							ByteSet options = optionsStr == null ? null : ByteSet.of(parseListByte(optionsStr));</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">							ByteUnaryOperator checkOptions = options == null ? ByteUnaryOperator.identity() : b -&gt; {</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">								if (!options.contains(b))</span>
<span class="fc" id="L331">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + b + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L333">								return b;</span>
							};
<span class="fc bfc" id="L335" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L336">									: Byte.valueOf(checkOptions.apply(Byte.parseByte(defValStr)));</span>
<span class="fc" id="L337">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L339">								WeightsByte&lt;Object&gt; weights2 = (WeightsByte) weights;</span>
<span class="fc" id="L340">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Byte.parseByte(val)));</span>
							};
<span class="fc" id="L342">							break;</span>
						}
						case &quot;short&quot;: {
<span class="fc" id="L345">							type = short.class;</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">							ShortSet options = optionsStr == null ? null : ShortSet.of(parseListShort(optionsStr));</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">							ShortUnaryOperator checkOptions = options == null ? ShortUnaryOperator.identity() : s -&gt; {</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">								if (!options.contains(s))</span>
<span class="fc" id="L349">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + s + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L351">								return s;</span>
							};
<span class="fc bfc" id="L353" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L354">									: Short.valueOf(checkOptions.apply(Short.parseShort(defValStr)));</span>
<span class="fc" id="L355">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L357">								WeightsShort&lt;Object&gt; weights2 = (WeightsShort) weights;</span>
<span class="fc" id="L358">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Short.parseShort(val)));</span>
							};
<span class="fc" id="L360">							break;</span>
						}
						case &quot;integer&quot;: {
<span class="fc" id="L363">							type = int.class;</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">							IntSet options = optionsStr == null ? null : IntSet.of(parseListInt(optionsStr));</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">							IntUnaryOperator checkOptions = options == null ? IntUnaryOperator.identity() : i -&gt; {</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">								if (!options.contains(i))</span>
<span class="fc" id="L367">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + i + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L369">								return i;</span>
							};
<span class="fc bfc" id="L371" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L372">									: Integer.valueOf(checkOptions.apply(Integer.parseInt(defValStr)));</span>
<span class="fc" id="L373">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L375">								WeightsInt&lt;Object&gt; weights2 = (WeightsInt) weights;</span>
<span class="fc" id="L376">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Integer.parseInt(val)));</span>
							};
<span class="fc" id="L378">							break;</span>
						}
						case &quot;long&quot;: {
<span class="fc" id="L381">							type = long.class;</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">							LongSet options = optionsStr == null ? null : LongSet.of(parseListLong(optionsStr));</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">							LongUnaryOperator checkOptions = options == null ? LongUnaryOperator.identity() : l -&gt; {</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">								if (!options.contains(l))</span>
<span class="fc" id="L385">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + l + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L387">								return l;</span>
							};
<span class="fc bfc" id="L389" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L390">									: Long.valueOf(checkOptions.apply(Long.parseLong(defValStr)));</span>
<span class="fc" id="L391">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L393">								WeightsLong&lt;Object&gt; weights2 = (WeightsLong) weights;</span>
<span class="fc" id="L394">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Long.parseLong(val)));</span>
							};
<span class="fc" id="L396">							break;</span>
						}
						case &quot;float&quot;: {
<span class="fc" id="L399">							type = float.class;</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">							FloatSet options = optionsStr == null ? null : FloatSet.of(parseListFloat(optionsStr));</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">							FloatUnaryOperator checkOptions = options == null ? FloatUnaryOperator.identity() : f -&gt; {</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">								if (!options.contains(f))</span>
<span class="fc" id="L403">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + f + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L405">								return f;</span>
							};
<span class="fc bfc" id="L407" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L408">									: Float.valueOf(checkOptions.apply(Float.parseFloat(defValStr)));</span>
<span class="fc" id="L409">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L411">								WeightsFloat&lt;Object&gt; weights2 = (WeightsFloat) weights;</span>
<span class="fc" id="L412">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Float.parseFloat(val)));</span>
							};
<span class="fc" id="L414">							break;</span>
						}
						case &quot;double&quot;: {
<span class="fc" id="L417">							type = double.class;</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">							DoubleSet options = optionsStr == null ? null : DoubleSet.of(parseListDouble(optionsStr));</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">							DoubleUnaryOperator checkOptions = options == null ? DoubleUnaryOperator.identity() : d -&gt; {</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">								if (!options.contains(d))</span>
<span class="fc" id="L421">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + d + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L423">								return d;</span>
							};
<span class="fc bfc" id="L425" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L426">									: Double.valueOf(checkOptions.apply(Double.parseDouble(defValStr)));</span>
<span class="fc" id="L427">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L429">								WeightsDouble&lt;Object&gt; weights2 = (WeightsDouble) weights;</span>
<span class="fc" id="L430">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Double.parseDouble(val)));</span>
							};
<span class="fc" id="L432">							break;</span>
						}
						case &quot;boolean&quot;: {
<span class="fc" id="L435">							type = boolean.class;</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">							BooleanSet options = optionsStr == null ? null : BooleanSet.of(parseListBool(optionsStr));</span>
							BooleanUnaryOperator checkOptions =
<span class="fc bfc" id="L438" title="All 2 branches covered.">									options == null ? BooleanUnaryOperator.identity() : b -&gt; {</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">										if (!options.contains(b))</span>
<span class="fc" id="L440">											throw new IllegalArgumentException(</span>
													&quot;invalid value: &quot; + b + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L442">										return b;</span>
									};
<span class="fc bfc" id="L444" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L445">									: Boolean.valueOf(checkOptions.apply(Boolean.parseBoolean(defValStr)));</span>
<span class="fc" id="L446">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L448">								WeightsBool&lt;Object&gt; weights2 = (WeightsBool) weights;</span>
<span class="fc" id="L449">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Boolean.parseBoolean(val)));</span>
							};
<span class="fc" id="L451">							break;</span>
						}
						case &quot;char&quot;: {
<span class="fc" id="L454">							type = char.class;</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">							CharSet options = optionsStr == null ? null : CharSet.of(parseListChar(optionsStr));</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">							CharUnaryOperator checkOptions = options == null ? CharUnaryOperator.identity() : c -&gt; {</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">								if (!options.contains(c))</span>
<span class="fc" id="L458">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + c + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L460">								return c;</span>
							};
<span class="fc bfc" id="L462" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L463">									: Character.valueOf(checkOptions.apply(GraphIoUtils.parseChar(defValStr)));</span>
<span class="fc" id="L464">							setterFactory = weights -&gt; {</span>
<span class="fc" id="L465">								return (o, val) -&gt; {</span>
									@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L467">									WeightsChar&lt;Object&gt; weights2 = (WeightsChar) weights;</span>
<span class="fc" id="L468">									weights2.set(o, checkOptions.apply(GraphIoUtils.parseChar(val)));</span>
<span class="fc" id="L469">								};</span>
							};
<span class="fc" id="L471">							break;</span>
						}

						/* common for all Object weights */
						case &quot;string&quot;:
						case &quot;date&quot;:
						case &quot;anyURI&quot;:
						case &quot;bigdecimal&quot;:
						case &quot;biginteger&quot;:
						case &quot;listbyte&quot;:
						case &quot;listshort&quot;:
						case &quot;listinteger&quot;:
						case &quot;listlong&quot;:
						case &quot;listfloat&quot;:
						case &quot;listdouble&quot;:
						case &quot;listboolean&quot;:
						case &quot;listchar&quot;:
						case &quot;liststring&quot;:
						case &quot;listbigdecimal&quot;:
						case &quot;listbiginteger&quot;: {
							Function&lt;String, Object&gt; parser;
<span class="fc" id="L492">							Set&lt;Object&gt; objOptions = null;</span>

<span class="pc bpc" id="L494" title="1 of 17 branches missed.">							switch (typeStr) {</span>
								case &quot;string&quot;:
<span class="fc" id="L496">									type = String.class;</span>
									objOptions =
<span class="fc bfc" id="L498" title="All 2 branches covered.">											optionsStr == null ? null : new ObjectOpenHashSet&lt;&gt;(splitList(optionsStr));</span>
<span class="fc" id="L499">									parser = s -&gt; s;</span>
<span class="fc" id="L500">									break;</span>
								case &quot;date&quot;:
<span class="fc" id="L502">									type = Date.class;</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">									objOptions = optionsStr == null ? null</span>
<span class="fc" id="L504">											: new ObjectOpenHashSet&lt;&gt;(parseListDate(optionsStr));</span>
<span class="fc" id="L505">									parser = this::parseDate;</span>
<span class="fc" id="L506">									break;</span>
								case &quot;anyURI&quot;:
<span class="fc" id="L508">									type = URI.class;</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">									objOptions = optionsStr == null ? null</span>
<span class="fc" id="L510">											: new ObjectOpenHashSet&lt;&gt;(parseListURI(optionsStr));</span>
<span class="fc" id="L511">									parser = GexfGraphReader::parseURI;</span>
<span class="fc" id="L512">									break;</span>
								case &quot;bigdecimal&quot;:
<span class="fc" id="L514">									type = BigDecimal.class;</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">									objOptions = optionsStr == null ? null</span>
<span class="fc" id="L516">											: new ObjectOpenHashSet&lt;&gt;(parseListBigDecimal(optionsStr));</span>
<span class="fc" id="L517">									parser = BigDecimal::new;</span>
<span class="fc" id="L518">									break;</span>
								case &quot;biginteger&quot;:
<span class="fc" id="L520">									type = BigInteger.class;</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">									objOptions = optionsStr == null ? null</span>
<span class="fc" id="L522">											: new ObjectOpenHashSet&lt;&gt;(parseListBigInteger(optionsStr));</span>
<span class="fc" id="L523">									parser = BigInteger::new;</span>
<span class="fc" id="L524">									break;</span>
								case &quot;listbyte&quot;:
<span class="fc" id="L526">									type = byte[].class;</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L528">										parser = GexfGraphReader::parseListByte;</span>
									} else {
<span class="fc" id="L530">										ByteSet options = ByteSet.of(parseListByte(optionsStr));</span>
<span class="fc" id="L531">										parser = val -&gt; {</span>
<span class="fc" id="L532">											byte[] list = GexfGraphReader.parseListByte(val);</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">											for (byte i : list)</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L535">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L537">											return list;</span>
										};
									}
<span class="fc" id="L540">									break;</span>
								case &quot;listshort&quot;:
<span class="fc" id="L542">									type = short[].class;</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L544">										parser = GexfGraphReader::parseListShort;</span>
									} else {
<span class="fc" id="L546">										ShortSet options = ShortSet.of(parseListShort(optionsStr));</span>
<span class="fc" id="L547">										parser = val -&gt; {</span>
<span class="fc" id="L548">											short[] list = GexfGraphReader.parseListShort(val);</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">											for (short i : list)</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L551">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L553">											return list;</span>
										};
									}
<span class="fc" id="L556">									break;</span>
								case &quot;listinteger&quot;:
<span class="fc" id="L558">									type = int[].class;</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L560">										parser = GexfGraphReader::parseListInt;</span>
									} else {
<span class="fc" id="L562">										IntSet options = IntSet.of(parseListInt(optionsStr));</span>
<span class="fc" id="L563">										parser = val -&gt; {</span>
<span class="fc" id="L564">											int[] list = GexfGraphReader.parseListInt(val);</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">											for (int i : list)</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L567">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L569">											return list;</span>
										};
									}
<span class="fc" id="L572">									break;</span>
								case &quot;listlong&quot;:
<span class="fc" id="L574">									type = long[].class;</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L576">										parser = GexfGraphReader::parseListLong;</span>
									} else {
<span class="fc" id="L578">										LongSet options = LongSet.of(parseListLong(optionsStr));</span>
<span class="fc" id="L579">										parser = val -&gt; {</span>
<span class="fc" id="L580">											long[] list = GexfGraphReader.parseListLong(val);</span>
<span class="fc bfc" id="L581" title="All 2 branches covered.">											for (long i : list)</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L583">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L585">											return list;</span>
										};
									}
<span class="fc" id="L588">									break;</span>
								case &quot;listfloat&quot;:
<span class="fc" id="L590">									type = float[].class;</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L592">										parser = GexfGraphReader::parseListFloat;</span>
									} else {
<span class="fc" id="L594">										FloatSet options = FloatSet.of(parseListFloat(optionsStr));</span>
<span class="fc" id="L595">										parser = val -&gt; {</span>
<span class="fc" id="L596">											float[] list = GexfGraphReader.parseListFloat(val);</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">											for (float i : list)</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L599">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L601">											return list;</span>
										};
									}
<span class="fc" id="L604">									break;</span>
								case &quot;listdouble&quot;:
<span class="fc" id="L606">									type = double[].class;</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L608">										parser = GexfGraphReader::parseListDouble;</span>
									} else {
<span class="fc" id="L610">										DoubleSet options = DoubleSet.of(parseListDouble(optionsStr));</span>
<span class="fc" id="L611">										parser = val -&gt; {</span>
<span class="fc" id="L612">											double[] list = GexfGraphReader.parseListDouble(val);</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">											for (double i : list)</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L615">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L617">											return list;</span>
										};
									}
<span class="fc" id="L620">									break;</span>
								case &quot;listboolean&quot;:
<span class="fc" id="L622">									type = boolean[].class;</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L624">										parser = GexfGraphReader::parseListBool;</span>
									} else {
<span class="fc" id="L626">										BooleanSet options = BooleanSet.of(parseListBool(optionsStr));</span>
<span class="fc" id="L627">										parser = val -&gt; {</span>
<span class="fc" id="L628">											boolean[] list = GexfGraphReader.parseListBool(val);</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">											for (boolean i : list)</span>
<span class="fc bfc" id="L630" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L631">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L633">											return list;</span>
										};
									}
<span class="fc" id="L636">									break;</span>
								case &quot;listchar&quot;:
<span class="fc" id="L638">									type = char[].class;</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L640">										parser = GexfGraphReader::parseListChar;</span>
									} else {
<span class="fc" id="L642">										CharSet options = CharSet.of(parseListChar(optionsStr));</span>
<span class="fc" id="L643">										parser = val -&gt; {</span>
<span class="fc" id="L644">											char[] list = GexfGraphReader.parseListChar(val);</span>
<span class="fc bfc" id="L645" title="All 2 branches covered.">											for (char i : list)</span>
<span class="fc bfc" id="L646" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L647">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L649">											return list;</span>
										};
									}
<span class="fc" id="L652">									break;</span>
								case &quot;liststring&quot;:
<span class="fc" id="L654">									type = String[].class;</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L656">										parser = GexfGraphReader::splitList;</span>
									} else {
<span class="fc" id="L658">										Set&lt;String&gt; options = new ObjectOpenHashSet&lt;&gt;(splitList(optionsStr));</span>
<span class="fc" id="L659">										parser = val -&gt; {</span>
<span class="fc" id="L660">											String[] list = splitList(val);</span>
<span class="fc bfc" id="L661" title="All 2 branches covered.">											for (String i : list)</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L663">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L665">											return list;</span>
										};
									}
<span class="fc" id="L668">									break;</span>
								case &quot;listbigdecimal&quot;:
<span class="fc" id="L670">									type = BigDecimal[].class;</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L672">										parser = GexfGraphReader::parseListBigDecimal;</span>
									} else {
<span class="fc" id="L674">										Set&lt;BigDecimal&gt; options =</span>
<span class="fc" id="L675">												new ObjectOpenHashSet&lt;&gt;(parseListBigDecimal(optionsStr));</span>
<span class="fc" id="L676">										parser = val -&gt; {</span>
<span class="fc" id="L677">											BigDecimal[] list = parseListBigDecimal(val);</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">											for (BigDecimal i : list)</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L680">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L682">											return list;</span>
										};
									}
<span class="fc" id="L685">									break;</span>
								case &quot;listbiginteger&quot;:
<span class="fc" id="L687">									type = BigInteger[].class;</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L689">										parser = GexfGraphReader::parseListBigInteger;</span>
									} else {
<span class="fc" id="L691">										Set&lt;BigInteger&gt; options =</span>
<span class="fc" id="L692">												new ObjectOpenHashSet&lt;&gt;(parseListBigInteger(optionsStr));</span>
<span class="fc" id="L693">										parser = val -&gt; {</span>
<span class="fc" id="L694">											BigInteger[] list = parseListBigInteger(val);</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">											for (BigInteger i : list)</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L697">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L699">											return list;</span>
										};
									}
<span class="fc" id="L702">									break;</span>
								default:
									/* can't each here, already matched the first switch to one of the object types */
<span class="nc" id="L705">									throw new AssertionError();</span>
							}

<span class="fc bfc" id="L708" title="All 2 branches covered.">							if (objOptions != null) {</span>
<span class="fc" id="L709">								Function&lt;String, Object&gt; parser0 = parser;</span>
<span class="fc" id="L710">								Set&lt;Object&gt; objOptions0 = objOptions;</span>
<span class="fc" id="L711">								parser = val -&gt; {</span>
<span class="fc" id="L712">									Object weight = parser0.apply(val);</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">									if (!objOptions0.contains(weight))</span>
<span class="fc" id="L714">										throw new IllegalArgumentException(</span>
												&quot;invalid value: &quot; + weight + &quot; (not in options: &quot; + objOptions0 + &quot;)&quot;);
<span class="fc" id="L716">									return weight;</span>
								};
							}
<span class="fc bfc" id="L719" title="All 2 branches covered.">							defVal = defValStr == null ? null : parser.apply(defValStr);</span>
<span class="fc" id="L720">							Function&lt;String, Object&gt; parser0 = parser;</span>
<span class="fc" id="L721">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L723">								WeightsObj&lt;Object, Object&gt; weights2 = (WeightsObj) weights;</span>
<span class="fc" id="L724">								return (o, val) -&gt; weights2.set(o, parser0.apply(val));</span>
							};
<span class="fc" id="L726">							break;</span>
						}
						default:
<span class="fc" id="L729">							throw new IllegalArgumentException(&quot;unknown attribute type: &quot; + typeStr);</span>
					}
<span class="fc bfc" id="L731" title="All 2 branches covered.">					if (isVertices) {</span>
						@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L733">						Class&lt;Object&gt; attrType0 = (Class&lt;Object&gt;) type;</span>
<span class="fc" id="L734">						Weights&lt;V, Object&gt; weights = g.addVerticesWeights(weightsName, attrType0, defVal);</span>
						@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L736">						BiConsumer&lt;V, String&gt; setter =</span>
<span class="fc" id="L737">								(BiConsumer&lt;V, String&gt;) setterFactory.apply((Weights&lt;Object, Object&gt;) weights);</span>
<span class="fc" id="L738">						Object oldVal = vWeights.put(weightsId, setter);</span>
<span class="fc bfc" id="L739" title="All 2 branches covered.">						if (oldVal != null)</span>
<span class="fc" id="L740">							throw new IllegalArgumentException(&quot;duplicate node attribute id: &quot; + weightsId);</span>
<span class="fc" id="L741">					} else {</span>
						@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L743">						Class&lt;Object&gt; type0 = (Class&lt;Object&gt;) type;</span>
<span class="fc" id="L744">						Weights&lt;E, Object&gt; weights = g.addEdgesWeights(weightsName, type0, defVal);</span>
						@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L746">						BiConsumer&lt;E, String&gt; setter =</span>
<span class="fc" id="L747">								(BiConsumer&lt;E, String&gt;) setterFactory.apply((Weights&lt;Object, Object&gt;) weights);</span>
<span class="fc" id="L748">						Object oldVal = eWeights.put(weightsId, setter);</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">						if (oldVal != null)</span>
<span class="fc" id="L750">							throw new IllegalArgumentException(&quot;duplicate edge attribute id: &quot; + weightsId);</span>
					}
<span class="fc" id="L752">				}</span>
<span class="fc" id="L753">			}</span>

<span class="fc" id="L755">			WeightsObj&lt;V, String&gt; vLabels = null;</span>
<span class="fc" id="L756">			WeightsObj&lt;E, String&gt; eLabels = null;</span>
<span class="fc" id="L757">			WeightsDouble&lt;E&gt; eWeight = null;</span>

<span class="fc" id="L759">			Iterable&lt;Element&gt; nodes = XmlUtils</span>
<span class="fc" id="L760">					.optionalChild(graph, &quot;nodes&quot;)</span>
<span class="fc" id="L761">					.map(nodesElm -&gt; XmlUtils.children(nodesElm, &quot;node&quot;))</span>
<span class="fc" id="L762">					.orElse(Collections.emptyList());</span>
<span class="fc bfc" id="L763" title="All 2 branches covered.">			for (Element vElm : nodes) {</span>
<span class="fc" id="L764">				V v = vertexParser.apply(XmlUtils.requiredAttribute(vElm, &quot;id&quot;));</span>
<span class="fc" id="L765">				g.addVertex(v);</span>

<span class="fc" id="L767">				Optional&lt;String&gt; label = XmlUtils.optionalAttribute(vElm, &quot;label&quot;);</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">				if (label.isPresent()) {</span>
<span class="fc bfc" id="L769" title="All 2 branches covered.">					if (vLabels == null)</span>
<span class="fc" id="L770">						vLabels = g.addVerticesWeights(&quot;label&quot;, String.class);</span>
<span class="fc" id="L771">					vLabels.set(v, label.get());</span>
				}

<span class="fc" id="L774">				Optional&lt;Element&gt; attvaluesElm0 = XmlUtils.optionalChild(vElm, &quot;attvalues&quot;);</span>
<span class="fc bfc" id="L775" title="All 2 branches covered.">				if (attvaluesElm0.isPresent()) {</span>
<span class="fc" id="L776">					Element attvaluesElm = attvaluesElm0.get();</span>
<span class="fc bfc" id="L777" title="All 2 branches covered.">					for (Element attvalueElm : XmlUtils.children(attvaluesElm, &quot;attvalue&quot;)) {</span>
<span class="fc" id="L778">						String weightsId = XmlUtils.requiredAttribute(attvalueElm, &quot;for&quot;);</span>
<span class="fc" id="L779">						String value = XmlUtils.requiredAttribute(attvalueElm, &quot;value&quot;);</span>
<span class="fc" id="L780">						BiConsumer&lt;V, String&gt; setter = vWeights.get(weightsId);</span>
<span class="fc bfc" id="L781" title="All 2 branches covered.">						if (setter == null)</span>
<span class="fc" id="L782">							throw new IllegalArgumentException(&quot;unknown attribute id: &quot; + weightsId);</span>
<span class="fc" id="L783">						setter.accept(v, value);</span>
<span class="fc" id="L784">					}</span>
				}
<span class="fc" id="L786">			}</span>

<span class="fc" id="L788">			Iterable&lt;Element&gt; edges = XmlUtils</span>
<span class="fc" id="L789">					.optionalChild(graph, &quot;edges&quot;)</span>
<span class="fc" id="L790">					.map(edgesElm -&gt; XmlUtils.children(edgesElm, &quot;edge&quot;))</span>
<span class="fc" id="L791">					.orElse(Collections.emptyList());</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">			for (Element eElm : edges) {</span>
				E e;
<span class="fc" id="L794">				Optional&lt;String&gt; id = XmlUtils.optionalAttribute(eElm, &quot;id&quot;);</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">				if (id.isPresent()) {</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">					if (edgeParser == null)</span>
<span class="fc" id="L797">						throw new IllegalStateException(&quot;Edge parser was not set&quot;);</span>
<span class="fc" id="L798">					e = edgeParser.apply(id.get());</span>
				} else {
<span class="fc bfc" id="L800" title="All 2 branches covered.">					if (edgeBuilder == null)</span>
<span class="fc" id="L801">						throw new IllegalStateException(&quot;Edge builder was not set&quot;);</span>
<span class="fc" id="L802">					e = edgeBuilder.build(g.edges());</span>
				}
<span class="fc" id="L804">				V u = vertexParser.apply(XmlUtils.requiredAttribute(eElm, &quot;source&quot;));</span>
<span class="fc" id="L805">				V v = vertexParser.apply(XmlUtils.requiredAttribute(eElm, &quot;target&quot;));</span>
<span class="fc" id="L806">				g.addEdge(u, v, e);</span>

<span class="fc bfc" id="L808" title="All 2 branches covered.">				if (eElm.hasAttribute(&quot;type&quot;))</span>
<span class="fc" id="L809">					throw new IllegalArgumentException(&quot;directed attribute per-edge is not supported&quot;);</span>

<span class="fc" id="L811">				Optional&lt;String&gt; label = XmlUtils.optionalAttribute(eElm, &quot;label&quot;);</span>
<span class="fc bfc" id="L812" title="All 2 branches covered.">				if (label.isPresent()) {</span>
<span class="fc bfc" id="L813" title="All 2 branches covered.">					if (eLabels == null)</span>
<span class="fc" id="L814">						eLabels = g.addEdgesWeights(&quot;label&quot;, String.class);</span>
<span class="fc" id="L815">					eLabels.set(e, label.get());</span>
				}

<span class="fc" id="L818">				Optional&lt;String&gt; weight = XmlUtils.optionalAttribute(eElm, &quot;weight&quot;);</span>
<span class="fc bfc" id="L819" title="All 2 branches covered.">				if (weight.isPresent()) {</span>
<span class="fc bfc" id="L820" title="All 2 branches covered.">					if (eWeight == null)</span>
<span class="fc" id="L821">						eWeight = g.addEdgesWeights(&quot;weight&quot;, double.class, Double.valueOf(1.0));</span>
<span class="fc" id="L822">					eWeight.set(e, Double.parseDouble(weight.get()));</span>
				}

<span class="fc" id="L825">				Optional&lt;Element&gt; attvaluesElm0 = XmlUtils.optionalChild(eElm, &quot;attvalues&quot;);</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">				if (attvaluesElm0.isPresent()) {</span>
<span class="fc" id="L827">					Element attvaluesElm = attvaluesElm0.get();</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">					for (Element attvalueElm : XmlUtils.children(attvaluesElm, &quot;attvalue&quot;)) {</span>
<span class="fc" id="L829">						String weightsId = XmlUtils.requiredAttribute(attvalueElm, &quot;for&quot;);</span>
<span class="fc" id="L830">						String value = XmlUtils.requiredAttribute(attvalueElm, &quot;value&quot;);</span>
<span class="fc" id="L831">						BiConsumer&lt;E, String&gt; setter = eWeights.get(weightsId);</span>
<span class="fc bfc" id="L832" title="All 2 branches covered.">						if (setter == null)</span>
<span class="fc" id="L833">							throw new IllegalArgumentException(&quot;unknown attribute id: &quot; + weightsId);</span>
<span class="fc" id="L834">						setter.accept(e, value);</span>
<span class="fc" id="L835">					}</span>
				}
<span class="fc" id="L837">			}</span>

<span class="fc" id="L839">			return g;</span>
<span class="fc" id="L840">		} catch (SAXException | ParserConfigurationException e) {</span>
<span class="fc" id="L841">			throw new IllegalArgumentException(e);</span>
		}
	}

	private Date parseDate(String s) {
		try {
<span class="fc" id="L847">			return dateFormat.parse(s);</span>
<span class="fc" id="L848">		} catch (ParseException e) {</span>
<span class="fc" id="L849">			throw new IllegalArgumentException(e);</span>
		}
	}

	private static URI parseURI(String s) {
		try {
<span class="fc" id="L855">			return new URI(s);</span>
<span class="fc" id="L856">		} catch (URISyntaxException e) {</span>
<span class="fc" id="L857">			throw new IllegalArgumentException(e);</span>
		}
	}

	private static byte[] parseListByte(String val) {
<span class="fc" id="L862">		String[] words = splitList(val);</span>
<span class="fc" id="L863">		byte[] list = new byte[words.length];</span>
<span class="fc bfc" id="L864" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L865">			list[i] = Byte.parseByte(words[i]);</span>
<span class="fc" id="L866">		return list;</span>
	}

	private static short[] parseListShort(String val) {
<span class="fc" id="L870">		String[] words = splitList(val);</span>
<span class="fc" id="L871">		short[] list = new short[words.length];</span>
<span class="fc bfc" id="L872" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L873">			list[i] = Short.parseShort(words[i]);</span>
<span class="fc" id="L874">		return list;</span>
	}

	private static int[] parseListInt(String val) {
<span class="fc" id="L878">		String[] words = splitList(val);</span>
<span class="fc" id="L879">		int[] list = new int[words.length];</span>
<span class="fc bfc" id="L880" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L881">			list[i] = Integer.parseInt(words[i]);</span>
<span class="fc" id="L882">		return list;</span>
	}

	private static long[] parseListLong(String val) {
<span class="fc" id="L886">		String[] words = splitList(val);</span>
<span class="fc" id="L887">		long[] list = new long[words.length];</span>
<span class="fc bfc" id="L888" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L889">			list[i] = Long.parseLong(words[i]);</span>
<span class="fc" id="L890">		return list;</span>
	}

	private static float[] parseListFloat(String val) {
<span class="fc" id="L894">		String[] words = splitList(val);</span>
<span class="fc" id="L895">		float[] list = new float[words.length];</span>
<span class="fc bfc" id="L896" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L897">			list[i] = Float.parseFloat(words[i]);</span>
<span class="fc" id="L898">		return list;</span>
	}

	private static double[] parseListDouble(String val) {
<span class="fc" id="L902">		String[] words = splitList(val);</span>
<span class="fc" id="L903">		double[] list = new double[words.length];</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L905">			list[i] = Double.parseDouble(words[i]);</span>
<span class="fc" id="L906">		return list;</span>
	}

	private static boolean[] parseListBool(String val) {
<span class="fc" id="L910">		String[] words = splitList(val);</span>
<span class="fc" id="L911">		boolean[] list = new boolean[words.length];</span>
<span class="fc bfc" id="L912" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L913">			list[i] = Boolean.parseBoolean(words[i]);</span>
<span class="fc" id="L914">		return list;</span>
	}

	private static char[] parseListChar(String val) {
<span class="fc" id="L918">		String[] words = splitList(val);</span>
<span class="fc" id="L919">		char[] list = new char[words.length];</span>
<span class="fc bfc" id="L920" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L921">			list[i] = GraphIoUtils.parseChar(words[i]);</span>
<span class="fc" id="L922">		return list;</span>
	}

	private static BigDecimal[] parseListBigDecimal(String val) {
<span class="fc" id="L926">		String[] words = splitList(val);</span>
<span class="fc" id="L927">		BigDecimal[] list = new BigDecimal[words.length];</span>
<span class="fc bfc" id="L928" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L929">			list[i] = new BigDecimal(words[i]);</span>
<span class="fc" id="L930">		return list;</span>
	}

	private static BigInteger[] parseListBigInteger(String val) {
<span class="fc" id="L934">		String[] words = splitList(val);</span>
<span class="fc" id="L935">		BigInteger[] list = new BigInteger[words.length];</span>
<span class="fc bfc" id="L936" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L937">			list[i] = new BigInteger(words[i]);</span>
<span class="fc" id="L938">		return list;</span>
	}

	private static URI[] parseListURI(String val) {
<span class="fc" id="L942">		String[] words = splitList(val);</span>
<span class="fc" id="L943">		URI[] list = new URI[words.length];</span>
<span class="fc bfc" id="L944" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L945">			list[i] = parseURI(words[i]);</span>
<span class="fc" id="L946">		return list;</span>
	}

	private Date[] parseListDate(String val) {
<span class="fc" id="L950">		String[] words = splitList(val);</span>
<span class="fc" id="L951">		Date[] list = new Date[words.length];</span>
<span class="fc bfc" id="L952" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L953">			list[i] = parseDate(words[i]);</span>
<span class="fc" id="L954">		return list;</span>
	}

	private static String[] splitList(String s) {
<span class="fc bfc" id="L958" title="All 4 branches covered.">		if (!s.startsWith(&quot;[&quot;) || !s.endsWith(&quot;]&quot;))</span>
<span class="fc" id="L959">			throw new IllegalArgumentException(&quot;list attribute must be of the form [val1, val2,...]&quot;);</span>
<span class="fc" id="L960">		s = s.substring(1, s.length() - 1);</span>
<span class="fc" id="L961">		String[] words = s.split(&quot;,&quot;);</span>
<span class="fc bfc" id="L962" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L963">			words[i] = words[i].trim();</span>
<span class="fc" id="L964">		return words;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>