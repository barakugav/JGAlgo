<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GexfGraphReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - IO</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.io</a> &gt; <span class="el_source">GexfGraphReader.java</span></div><h1>GexfGraphReader.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.io;

import static com.jgalgo.internal.util.Range.range;
import java.io.IOException;
import java.io.Reader;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.URI;
import java.net.URISyntaxException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.Function;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import com.jgalgo.graph.Graph;
import com.jgalgo.graph.GraphBuilder;
import com.jgalgo.graph.GraphFactory;
import com.jgalgo.graph.IdBuilder;
import com.jgalgo.graph.IntGraphFactory;
import com.jgalgo.graph.Weights;
import com.jgalgo.graph.WeightsBool;
import com.jgalgo.graph.WeightsByte;
import com.jgalgo.graph.WeightsChar;
import com.jgalgo.graph.WeightsDouble;
import com.jgalgo.graph.WeightsFloat;
import com.jgalgo.graph.WeightsInt;
import com.jgalgo.graph.WeightsLong;
import com.jgalgo.graph.WeightsObj;
import com.jgalgo.graph.WeightsShort;
import it.unimi.dsi.fastutil.booleans.BooleanSet;
import it.unimi.dsi.fastutil.booleans.BooleanUnaryOperator;
import it.unimi.dsi.fastutil.bytes.ByteSet;
import it.unimi.dsi.fastutil.bytes.ByteUnaryOperator;
import it.unimi.dsi.fastutil.chars.CharSet;
import it.unimi.dsi.fastutil.chars.CharUnaryOperator;
import it.unimi.dsi.fastutil.doubles.DoubleSet;
import it.unimi.dsi.fastutil.doubles.DoubleUnaryOperator;
import it.unimi.dsi.fastutil.floats.FloatSet;
import it.unimi.dsi.fastutil.floats.FloatUnaryOperator;
import it.unimi.dsi.fastutil.ints.IntSet;
import it.unimi.dsi.fastutil.ints.IntUnaryOperator;
import it.unimi.dsi.fastutil.longs.LongSet;
import it.unimi.dsi.fastutil.longs.LongUnaryOperator;
import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
import it.unimi.dsi.fastutil.shorts.ShortSet;
import it.unimi.dsi.fastutil.shorts.ShortUnaryOperator;

/**
 * Read a graph in 'GEXF' format.
 *
 * &lt;p&gt;
 * GEXF is an XML-based format for graphs. Both directed and undirected graphs are supported, along with mixed graphs
 * (some edges are directed while others are undirected) although the {@link Graph} does not supported mixed graphs
 * (therefore the reader also doesn't support it). The format support graphs with vertices and edges of any type, as
 * long as they can be written as an XML attribute string. The format also support multiple weights for vertices and
 * edges, of any primitive Java type ({@code int}, {@code long}, {@code double}, {@code boolean}, ect.), {@link String},
 * {@link Date}, {@link URI}, {@link BigInteger}, {@link BigDecimal}, along with 'list' (arrays) of any of the above
 * except {@link Date} and {@link URI}.
 *
 * &lt;p&gt;
 * Identifiers of vertices are mandatory, and must be unique. Identifiers of edges are optional, if not specified the
 * reader will try generate them using a builder provided by the user, or a default builder for certain types (see
 * {@link #setEdgeBuilder(IdBuilder)} and {@link #setEdgeBuilderDefault(Class)}). Vertices identifiers (and edges
 * identifiers if specified) are parsed using a parser provided by the user, or a default parser for certain types (see
 * {@link #setVertexParserDefault(Class)} and {@link #setEdgeParserDefault(Class)}).
 *
 * &lt;p&gt;
 * When the reader reads a graph with weights, it will create a {@link Weights} object for each type of weights. For any
 * of the primitive types such as {@code int}, {@code long}, {@code double}, {@code boolean}, ect., the reader will
 * create a {@link Weights} object of the corresponding type, such as {@link WeightsInt}, {@link WeightsLong},
 * {@link WeightsDouble}, {@link WeightsBool}, ect. For {@link String}, {@link Date}, {@link URI}, {@link BigInteger},
 * {@link BigDecimal}, the reader will create a {@link Weights} object of type {@link WeightsObj}. For 'list' types,
 * which are supported for any primitive, {@link String}, {@link BigInteger} and {@link BigDecimal}, the reader will
 * create a {@link Weights} object of type {@link WeightsObj} and will populate it with arrays of the corresponding
 * type, such as {@code int[]}, {@code long[]}, {@code String[]}, {@code BigInteger[]}, ect. Default values are
 * supported for all types of weights, and will be available after reading via {@link Weights#defaultWeightAsObj()} or
 * any of the specific types weights such as {@link WeightsInt#defaultWeight()}. Note that the default value of 'list'
 * types is an array, which is shared between all vertices/edges that do not explicitly specify a value for the weight,
 * and should not be modified.
 *
 * &lt;p&gt;
 * The GEXF format support both self edges and parallel edges. The format documentation can be found
 * &lt;a href= &quot;https://gexf.net/&quot;&gt;here&lt;/a&gt;.
 *
 * @see        GexfGraphWriter
 * @param  &lt;V&gt; the vertices type
 * @param  &lt;E&gt; the edges type
 * @author     Barak Ugav
 */
public final class GexfGraphReader&lt;V, E&gt; extends GraphIoUtils.AbstractGraphReader&lt;V, E&gt; {

	private Class&lt;V&gt; vertexType;
	private Class&lt;E&gt; edgeType;
	private Function&lt;String, V&gt; vertexParser;
	private Function&lt;String, E&gt; edgeParser;
	private IdBuilder&lt;E&gt; edgeBuilder;
<span class="fc" id="L125">	private final SimpleDateFormat dateFormat = new SimpleDateFormat(Gexf.DateFormat);</span>

	/**
	 * Create a new reader.
	 *
	 * &lt;p&gt;
	 * The user should set the vertex/edge parsers and edge builder manually using {@link #setVertexParser(Function)},
	 * {@link #setEdgeParser(Function)} and {@link #setEdgeBuilder(IdBuilder)}. Setting the vertex parser is mandatory,
	 * while setting the edge parser is only required if edges identifiers are specified. Similarly, setting the edge
	 * builder is only required if edges identifiers are not specified.
	 */
<span class="fc" id="L136">	public GexfGraphReader() {}</span>

	/**
	 * Create a new reader with default parsers and builders for the given vertex and edge types.
	 *
	 * &lt;p&gt;
	 * During the reading process, the reader will use the parser to convert the vertex identifiers from string to the
	 * given type, and similarly for edges if edges identifiers are specified. If edges identifiers are not specified,
	 * the reader will use the builder to generate them. Default parsers exist for types {@code byte}, {@code short},
	 * {@code int}, {@code long}, {@code float}, {@code double} and {@code String}. Default edge builder is instantiated
	 * using {@link IdBuilder#defaultBuilder(Class)}, see it documentation for supported types. If the given types are
	 * not supported by the default parsers and builder, the reader will throw an exception. In such case, the
	 * constructor {@link #GexfGraphReader()} should be used, and the user should set the vertex/edge parsers and edge
	 * builder manually using {@link #setVertexParser(Function)}, {@link #setEdgeParser(Function)} and
	 * {@link #setEdgeBuilder(IdBuilder)}.
	 *
	 *
	 * @param  vertexType               the type of the vertices
	 * @param  edgeType                 the type of the edges
	 * @throws IllegalArgumentException if the given types are not supported by the default vertex/edge parsers and edge
	 *                                      builder. The supported types are {@code byte}, {@code short}, {@code int},
	 *                                      {@code long}, {@code float}, {@code double} and {@code String}.
	 * @see                             #setVertexParserDefault(Class)
	 * @see                             #setEdgeParserDefault(Class)
	 * @see                             #setEdgeBuilderDefault(Class)
	 */
<span class="fc" id="L162">	public GexfGraphReader(Class&lt;V&gt; vertexType, Class&lt;E&gt; edgeType) {</span>
<span class="fc" id="L163">		setVertexParserDefault(this.vertexType = vertexType);</span>
<span class="fc" id="L164">		setEdgeParserDefault(this.edgeType = edgeType);</span>
<span class="fc" id="L165">		setEdgeBuilderDefault(this.edgeType);</span>
<span class="fc" id="L166">	}</span>

	/**
	 * Set the parser for the vertices identifiers.
	 *
	 * &lt;p&gt;
	 * The parser is used to convert the vertex identifiers from string to the given vertex type. The parser is
	 * mandatory, and must be set before reading a graph. For default parsers for certain types, see
	 * {@link #setVertexParserDefault(Class)}.
	 *
	 * @param vertexParser a parser for the vertices identifiers
	 */
	public void setVertexParser(Function&lt;String, V&gt; vertexParser) {
<span class="fc" id="L179">		this.vertexParser = Objects.requireNonNull(vertexParser);</span>
<span class="fc" id="L180">	}</span>

	/**
	 * Set the parser for the vertices identifiers, using a default parser for the given vertex type.
	 *
	 * &lt;p&gt;
	 * The parser is used to convert the vertex identifiers from string to the given vertex type. The parser is
	 * mandatory, and must be set before reading a graph. The default parser exists for types {@code byte},
	 * {@code short}, {@code int}, {@code long}, {@code float}, {@code double} and {@code String}. If the given type is
	 * not supported by the default parser, the reader will throw an exception. In such case, the method
	 * {@link #setVertexParser(Function)} should be used for custom parsing.
	 *
	 * @param  vertexType               the type of the vertices
	 * @throws IllegalArgumentException if the given type is not supported by the default parser. The supported types
	 *                                      are {@code byte}, {@code short}, {@code int}, {@code long}, {@code float},
	 *                                      {@code double} and {@code String}.
	 */
	public void setVertexParserDefault(Class&lt;V&gt; vertexType) {
<span class="fc" id="L198">		this.vertexParser = GraphIoUtils.defaultParser(vertexType);</span>
<span class="fc" id="L199">		this.vertexType = vertexType;</span>
<span class="fc" id="L200">	}</span>

	/**
	 * Set the parser for the edges identifiers.
	 *
	 * &lt;p&gt;
	 * The parser is used to convert the edges identifiers from string to the given edge type. The parser is mandatory
	 * if edges identifiers are specified. In case edge identifiers are not specified, an edge builder must be set (see
	 * {@link #setEdgeBuilder(IdBuilder)}). For default parsers for certain types, see
	 * {@link #setEdgeParserDefault(Class)}.
	 *
	 * @param edgeParser a parser for the edges identifiers
	 */
	public void setEdgeParser(Function&lt;String, E&gt; edgeParser) {
<span class="fc" id="L214">		this.edgeParser = Objects.requireNonNull(edgeParser);</span>
<span class="fc" id="L215">	}</span>

	/**
	 * Set the parser for the edges identifiers, using a default parser for the given edge type.
	 *
	 * &lt;p&gt;
	 * The parser is used to convert the edges identifiers from string to the given edge type. The parser is mandatory
	 * if edges identifiers are specified. In case edge identifiers are not specified, an edge builder must be set (see
	 * {@link #setEdgeBuilder(IdBuilder)}). The default parser exists for types {@code byte}, {@code short},
	 * {@code int}, {@code long}, {@code float}, {@code double} and {@code String}. If the given type is not supported
	 * by the default parser, the reader will throw an exception. In such case, the method
	 * {@link #setEdgeParser(Function)} should be used for custom parsing.
	 *
	 * @param  edgeType                 the type of the edges
	 * @throws IllegalArgumentException if the given type is not supported by the default parser. The supported types
	 *                                      are {@code byte}, {@code short}, {@code int}, {@code long}, {@code float},
	 *                                      {@code double} and {@code String}.
	 */
	public void setEdgeParserDefault(Class&lt;E&gt; edgeType) {
<span class="fc" id="L234">		this.edgeParser = GraphIoUtils.defaultParser(edgeType);</span>
<span class="fc" id="L235">		this.edgeType = edgeType;</span>
<span class="fc" id="L236">	}</span>

	/**
	 * Set the builder for the edges identifiers.
	 *
	 * &lt;p&gt;
	 * The builder is used to generate edges identifiers if edges identifiers are not specified. The builder is
	 * mandatory if edges identifiers are not specified. In case edge identifiers are specified, an edge parser must be
	 * set (see {@link #setEdgeParser(Function)}). For default builders for certain types, see
	 * {@link #setEdgeBuilderDefault(Class)}.
	 *
	 * &lt;p&gt;
	 * The edge builder accepts a set of existing edges, and should return a new edge identifier that is not in the set.
	 *
	 * @param edgeBuilder a builder for the edges identifiers
	 */
	public void setEdgeBuilder(IdBuilder&lt;E&gt; edgeBuilder) {
<span class="fc" id="L253">		this.edgeBuilder = Objects.requireNonNull(edgeBuilder);</span>
<span class="fc" id="L254">	}</span>

	/**
	 * Set the builder for the edges identifiers, using a default builder for the given edge type.
	 *
	 * &lt;p&gt;
	 * The builder is used to generate edges identifiers if edges identifiers are not specified. The builder is
	 * mandatory if edges identifiers are not specified. In case edge identifiers are specified, an edge parser must be
	 * set (see {@link #setEdgeParser(Function)}). The default builder is instantiated using
	 * {@link IdBuilder#defaultBuilder(Class)}, see it documentation for supported types. If the given type is not
	 * supported by the default builder, the reader will throw an exception. In such case, the method
	 * {@link #setEdgeBuilder(IdBuilder)} should be used for custom builder.
	 *
	 * @param  edgeType                 the type of the edges
	 * @throws IllegalArgumentException if the given type is not supported by the default builder. See
	 *                                      {@link IdBuilder#defaultBuilder(Class)} for supported types
	 */
	public void setEdgeBuilderDefault(Class&lt;E&gt; edgeType) {
<span class="fc" id="L272">		edgeBuilder = IdBuilder.defaultBuilder(edgeType);</span>
<span class="fc" id="L273">		this.edgeType = edgeType;</span>
<span class="fc" id="L274">	}</span>

	@Override
	GraphBuilder&lt;V, E&gt; readIntoBuilderImpl(Reader reader) throws IOException {
<span class="fc bfc" id="L278" title="All 2 branches covered.">		if (vertexParser == null)</span>
<span class="fc" id="L279">			throw new IllegalStateException(&quot;Vertex parser was not set&quot;);</span>
		try {
			Document document =
<span class="fc" id="L282">					DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(new InputSource(reader));</span>
<span class="fc" id="L283">			Element doc = document.getDocumentElement();</span>
<span class="fc" id="L284">			doc.normalize();</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">			if (!doc.getTagName().equals(&quot;gexf&quot;))</span>
<span class="fc" id="L286">				throw new IllegalArgumentException(&quot;root element is not 'gexf'&quot;);</span>
<span class="fc" id="L287">			Element graph = XmlUtils.requiredChild(doc, &quot;graph&quot;);</span>

<span class="fc" id="L289">			boolean directed = graph.getAttribute(&quot;defaultedgetype&quot;).equals(&quot;directed&quot;);</span>
			GraphFactory&lt;V, E&gt; factory;
<span class="fc bfc" id="L291" title="All 4 branches covered.">			if (vertexType == int.class &amp;&amp; edgeType == int.class) {</span>
				@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L293">				GraphFactory&lt;V, E&gt; factory0 = (GraphFactory&lt;V, E&gt;) IntGraphFactory.newInstance(directed);</span>
<span class="fc" id="L294">				factory = factory0;</span>
<span class="fc" id="L295">			} else {</span>
<span class="fc" id="L296">				factory = GraphFactory.newInstance(directed);</span>
			}
<span class="fc" id="L298">			GraphBuilder&lt;V, E&gt; g = factory.allowSelfEdges().allowParallelEdges().newBuilder();</span>

<span class="fc bfc" id="L300" title="All 2 branches covered.">			if (XmlUtils.optionalAttribute(graph, &quot;mode&quot;).orElse(&quot;static&quot;).equals(&quot;dynamic&quot;))</span>
<span class="fc" id="L301">				throw new IllegalArgumentException(&quot;dynamic graphs are not supported&quot;);</span>

<span class="fc" id="L303">			Map&lt;String, BiConsumer&lt;V, String&gt;&gt; vWeights = new HashMap&lt;&gt;();</span>
<span class="fc" id="L304">			Map&lt;String, BiConsumer&lt;E, String&gt;&gt; eWeights = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L306" title="All 2 branches covered.">			for (Element attributesElm : XmlUtils.children(graph, &quot;attributes&quot;)) {</span>
<span class="fc" id="L307">				String clazz = XmlUtils.requiredAttribute(attributesElm, &quot;class&quot;);</span>
				boolean isVertices;
<span class="fc bfc" id="L309" title="All 2 branches covered.">				if (clazz.equals(&quot;node&quot;)) {</span>
<span class="fc" id="L310">					isVertices = true;</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">				} else if (clazz.equals(&quot;edge&quot;)) {</span>
<span class="fc" id="L312">					isVertices = false;</span>
				} else {
<span class="fc" id="L314">					throw new IllegalArgumentException(&quot;unknown attributes class: &quot; + clazz);</span>
				}

<span class="fc bfc" id="L317" title="All 2 branches covered.">				for (Element attributeElm : XmlUtils.children(attributesElm, &quot;attribute&quot;)) {</span>
<span class="fc" id="L318">					String weightsId = XmlUtils.requiredAttribute(attributeElm, &quot;id&quot;);</span>
<span class="fc" id="L319">					String weightsName = XmlUtils.requiredAttribute(attributeElm, &quot;title&quot;);</span>
<span class="fc" id="L320">					String typeStr = XmlUtils.requiredAttribute(attributeElm, &quot;type&quot;);</span>
<span class="fc" id="L321">					String defValStr =</span>
<span class="fc" id="L322">							XmlUtils.optionalChild(attributeElm, &quot;default&quot;).map(Element::getTextContent).orElse(null);</span>
<span class="fc" id="L323">					String optionsStr =</span>
<span class="fc" id="L324">							XmlUtils.optionalChild(attributeElm, &quot;options&quot;).map(Element::getTextContent).orElse(null);</span>

					Class&lt;?&gt; type;
					Object defVal;
					Function&lt;Weights&lt;Object, Object&gt;, BiConsumer&lt;Object, String&gt;&gt; setterFactory;
<span class="fc bfc" id="L329" title="All 10 branches covered.">					switch (typeStr) {</span>
						case &quot;byte&quot;: {
<span class="fc" id="L331">							type = byte.class;</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">							ByteSet options = optionsStr == null ? null : ByteSet.of(parseListByte(optionsStr));</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">							ByteUnaryOperator checkOptions = options == null ? ByteUnaryOperator.identity() : b -&gt; {</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">								if (!options.contains(b))</span>
<span class="fc" id="L335">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + b + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L337">								return b;</span>
							};
<span class="fc bfc" id="L339" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L340">									: Byte.valueOf(checkOptions.apply(Byte.parseByte(defValStr)));</span>
<span class="fc" id="L341">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L343">								WeightsByte&lt;Object&gt; weights2 = (WeightsByte) weights;</span>
<span class="fc" id="L344">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Byte.parseByte(val)));</span>
							};
<span class="fc" id="L346">							break;</span>
						}
						case &quot;short&quot;: {
<span class="fc" id="L349">							type = short.class;</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">							ShortSet options = optionsStr == null ? null : ShortSet.of(parseListShort(optionsStr));</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">							ShortUnaryOperator checkOptions = options == null ? ShortUnaryOperator.identity() : s -&gt; {</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">								if (!options.contains(s))</span>
<span class="fc" id="L353">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + s + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L355">								return s;</span>
							};
<span class="fc bfc" id="L357" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L358">									: Short.valueOf(checkOptions.apply(Short.parseShort(defValStr)));</span>
<span class="fc" id="L359">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L361">								WeightsShort&lt;Object&gt; weights2 = (WeightsShort) weights;</span>
<span class="fc" id="L362">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Short.parseShort(val)));</span>
							};
<span class="fc" id="L364">							break;</span>
						}
						case &quot;integer&quot;: {
<span class="fc" id="L367">							type = int.class;</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">							IntSet options = optionsStr == null ? null : IntSet.of(parseListInt(optionsStr));</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">							IntUnaryOperator checkOptions = options == null ? IntUnaryOperator.identity() : i -&gt; {</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">								if (!options.contains(i))</span>
<span class="fc" id="L371">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + i + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L373">								return i;</span>
							};
<span class="fc bfc" id="L375" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L376">									: Integer.valueOf(checkOptions.apply(Integer.parseInt(defValStr)));</span>
<span class="fc" id="L377">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L379">								WeightsInt&lt;Object&gt; weights2 = (WeightsInt) weights;</span>
<span class="fc" id="L380">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Integer.parseInt(val)));</span>
							};
<span class="fc" id="L382">							break;</span>
						}
						case &quot;long&quot;: {
<span class="fc" id="L385">							type = long.class;</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">							LongSet options = optionsStr == null ? null : LongSet.of(parseListLong(optionsStr));</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">							LongUnaryOperator checkOptions = options == null ? LongUnaryOperator.identity() : l -&gt; {</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">								if (!options.contains(l))</span>
<span class="fc" id="L389">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + l + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L391">								return l;</span>
							};
<span class="fc bfc" id="L393" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L394">									: Long.valueOf(checkOptions.apply(Long.parseLong(defValStr)));</span>
<span class="fc" id="L395">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L397">								WeightsLong&lt;Object&gt; weights2 = (WeightsLong) weights;</span>
<span class="fc" id="L398">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Long.parseLong(val)));</span>
							};
<span class="fc" id="L400">							break;</span>
						}
						case &quot;float&quot;: {
<span class="fc" id="L403">							type = float.class;</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">							FloatSet options = optionsStr == null ? null : FloatSet.of(parseListFloat(optionsStr));</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">							FloatUnaryOperator checkOptions = options == null ? FloatUnaryOperator.identity() : f -&gt; {</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">								if (!options.contains(f))</span>
<span class="fc" id="L407">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + f + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L409">								return f;</span>
							};
<span class="fc bfc" id="L411" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L412">									: Float.valueOf(checkOptions.apply(Float.parseFloat(defValStr)));</span>
<span class="fc" id="L413">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L415">								WeightsFloat&lt;Object&gt; weights2 = (WeightsFloat) weights;</span>
<span class="fc" id="L416">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Float.parseFloat(val)));</span>
							};
<span class="fc" id="L418">							break;</span>
						}
						case &quot;double&quot;: {
<span class="fc" id="L421">							type = double.class;</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">							DoubleSet options = optionsStr == null ? null : DoubleSet.of(parseListDouble(optionsStr));</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">							DoubleUnaryOperator checkOptions = options == null ? DoubleUnaryOperator.identity() : d -&gt; {</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">								if (!options.contains(d))</span>
<span class="fc" id="L425">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + d + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L427">								return d;</span>
							};
<span class="fc bfc" id="L429" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L430">									: Double.valueOf(checkOptions.apply(Double.parseDouble(defValStr)));</span>
<span class="fc" id="L431">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L433">								WeightsDouble&lt;Object&gt; weights2 = (WeightsDouble) weights;</span>
<span class="fc" id="L434">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Double.parseDouble(val)));</span>
							};
<span class="fc" id="L436">							break;</span>
						}
						case &quot;boolean&quot;: {
<span class="fc" id="L439">							type = boolean.class;</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">							BooleanSet options = optionsStr == null ? null : BooleanSet.of(parseListBool(optionsStr));</span>
							BooleanUnaryOperator checkOptions =
<span class="fc bfc" id="L442" title="All 2 branches covered.">									options == null ? BooleanUnaryOperator.identity() : b -&gt; {</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">										if (!options.contains(b))</span>
<span class="fc" id="L444">											throw new IllegalArgumentException(</span>
													&quot;invalid value: &quot; + b + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L446">										return b;</span>
									};
<span class="fc bfc" id="L448" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L449">									: Boolean.valueOf(checkOptions.apply(Boolean.parseBoolean(defValStr)));</span>
<span class="fc" id="L450">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L452">								WeightsBool&lt;Object&gt; weights2 = (WeightsBool) weights;</span>
<span class="fc" id="L453">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Boolean.parseBoolean(val)));</span>
							};
<span class="fc" id="L455">							break;</span>
						}
						case &quot;char&quot;: {
<span class="fc" id="L458">							type = char.class;</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">							CharSet options = optionsStr == null ? null : CharSet.of(parseListChar(optionsStr));</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">							CharUnaryOperator checkOptions = options == null ? CharUnaryOperator.identity() : c -&gt; {</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">								if (!options.contains(c))</span>
<span class="fc" id="L462">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + c + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L464">								return c;</span>
							};
<span class="fc bfc" id="L466" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L467">									: Character.valueOf(checkOptions.apply(GraphIoUtils.parseChar(defValStr)));</span>
<span class="fc" id="L468">							setterFactory = weights -&gt; {</span>
<span class="fc" id="L469">								return (o, val) -&gt; {</span>
									@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L471">									WeightsChar&lt;Object&gt; weights2 = (WeightsChar) weights;</span>
<span class="fc" id="L472">									weights2.set(o, checkOptions.apply(GraphIoUtils.parseChar(val)));</span>
<span class="fc" id="L473">								};</span>
							};
<span class="fc" id="L475">							break;</span>
						}

						/* common for all Object weights */
						case &quot;string&quot;:
						case &quot;date&quot;:
						case &quot;anyURI&quot;:
						case &quot;bigdecimal&quot;:
						case &quot;biginteger&quot;:
						case &quot;listbyte&quot;:
						case &quot;listshort&quot;:
						case &quot;listinteger&quot;:
						case &quot;listlong&quot;:
						case &quot;listfloat&quot;:
						case &quot;listdouble&quot;:
						case &quot;listboolean&quot;:
						case &quot;listchar&quot;:
						case &quot;liststring&quot;:
						case &quot;listbigdecimal&quot;:
						case &quot;listbiginteger&quot;: {
							Function&lt;String, Object&gt; parser;
<span class="fc" id="L496">							Set&lt;Object&gt; objOptions = null;</span>

<span class="pc bpc" id="L498" title="1 of 17 branches missed.">							switch (typeStr) {</span>
								case &quot;string&quot;:
<span class="fc" id="L500">									type = String.class;</span>
									objOptions =
<span class="fc bfc" id="L502" title="All 2 branches covered.">											optionsStr == null ? null : new ObjectOpenHashSet&lt;&gt;(splitList(optionsStr));</span>
<span class="fc" id="L503">									parser = s -&gt; s;</span>
<span class="fc" id="L504">									break;</span>
								case &quot;date&quot;:
<span class="fc" id="L506">									type = Date.class;</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">									objOptions = optionsStr == null ? null</span>
<span class="fc" id="L508">											: new ObjectOpenHashSet&lt;&gt;(parseListDate(optionsStr));</span>
<span class="fc" id="L509">									parser = this::parseDate;</span>
<span class="fc" id="L510">									break;</span>
								case &quot;anyURI&quot;:
<span class="fc" id="L512">									type = URI.class;</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">									objOptions = optionsStr == null ? null</span>
<span class="fc" id="L514">											: new ObjectOpenHashSet&lt;&gt;(parseListURI(optionsStr));</span>
<span class="fc" id="L515">									parser = GexfGraphReader::parseURI;</span>
<span class="fc" id="L516">									break;</span>
								case &quot;bigdecimal&quot;:
<span class="fc" id="L518">									type = BigDecimal.class;</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">									objOptions = optionsStr == null ? null</span>
<span class="fc" id="L520">											: new ObjectOpenHashSet&lt;&gt;(parseListBigDecimal(optionsStr));</span>
<span class="fc" id="L521">									parser = BigDecimal::new;</span>
<span class="fc" id="L522">									break;</span>
								case &quot;biginteger&quot;:
<span class="fc" id="L524">									type = BigInteger.class;</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">									objOptions = optionsStr == null ? null</span>
<span class="fc" id="L526">											: new ObjectOpenHashSet&lt;&gt;(parseListBigInteger(optionsStr));</span>
<span class="fc" id="L527">									parser = BigInteger::new;</span>
<span class="fc" id="L528">									break;</span>
								case &quot;listbyte&quot;:
<span class="fc" id="L530">									type = byte[].class;</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L532">										parser = GexfGraphReader::parseListByte;</span>
									} else {
<span class="fc" id="L534">										ByteSet options = ByteSet.of(parseListByte(optionsStr));</span>
<span class="fc" id="L535">										parser = val -&gt; {</span>
<span class="fc" id="L536">											byte[] list = GexfGraphReader.parseListByte(val);</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">											for (byte i : list)</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L539">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L541">											return list;</span>
										};
									}
<span class="fc" id="L544">									break;</span>
								case &quot;listshort&quot;:
<span class="fc" id="L546">									type = short[].class;</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L548">										parser = GexfGraphReader::parseListShort;</span>
									} else {
<span class="fc" id="L550">										ShortSet options = ShortSet.of(parseListShort(optionsStr));</span>
<span class="fc" id="L551">										parser = val -&gt; {</span>
<span class="fc" id="L552">											short[] list = GexfGraphReader.parseListShort(val);</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">											for (short i : list)</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L555">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L557">											return list;</span>
										};
									}
<span class="fc" id="L560">									break;</span>
								case &quot;listinteger&quot;:
<span class="fc" id="L562">									type = int[].class;</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L564">										parser = GexfGraphReader::parseListInt;</span>
									} else {
<span class="fc" id="L566">										IntSet options = IntSet.of(parseListInt(optionsStr));</span>
<span class="fc" id="L567">										parser = val -&gt; {</span>
<span class="fc" id="L568">											int[] list = GexfGraphReader.parseListInt(val);</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">											for (int i : list)</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L571">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L573">											return list;</span>
										};
									}
<span class="fc" id="L576">									break;</span>
								case &quot;listlong&quot;:
<span class="fc" id="L578">									type = long[].class;</span>
<span class="fc bfc" id="L579" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L580">										parser = GexfGraphReader::parseListLong;</span>
									} else {
<span class="fc" id="L582">										LongSet options = LongSet.of(parseListLong(optionsStr));</span>
<span class="fc" id="L583">										parser = val -&gt; {</span>
<span class="fc" id="L584">											long[] list = GexfGraphReader.parseListLong(val);</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">											for (long i : list)</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L587">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L589">											return list;</span>
										};
									}
<span class="fc" id="L592">									break;</span>
								case &quot;listfloat&quot;:
<span class="fc" id="L594">									type = float[].class;</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L596">										parser = GexfGraphReader::parseListFloat;</span>
									} else {
<span class="fc" id="L598">										FloatSet options = FloatSet.of(parseListFloat(optionsStr));</span>
<span class="fc" id="L599">										parser = val -&gt; {</span>
<span class="fc" id="L600">											float[] list = GexfGraphReader.parseListFloat(val);</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">											for (float i : list)</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L603">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L605">											return list;</span>
										};
									}
<span class="fc" id="L608">									break;</span>
								case &quot;listdouble&quot;:
<span class="fc" id="L610">									type = double[].class;</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L612">										parser = GexfGraphReader::parseListDouble;</span>
									} else {
<span class="fc" id="L614">										DoubleSet options = DoubleSet.of(parseListDouble(optionsStr));</span>
<span class="fc" id="L615">										parser = val -&gt; {</span>
<span class="fc" id="L616">											double[] list = GexfGraphReader.parseListDouble(val);</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">											for (double i : list)</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L619">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L621">											return list;</span>
										};
									}
<span class="fc" id="L624">									break;</span>
								case &quot;listboolean&quot;:
<span class="fc" id="L626">									type = boolean[].class;</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L628">										parser = GexfGraphReader::parseListBool;</span>
									} else {
<span class="fc" id="L630">										BooleanSet options = BooleanSet.of(parseListBool(optionsStr));</span>
<span class="fc" id="L631">										parser = val -&gt; {</span>
<span class="fc" id="L632">											boolean[] list = GexfGraphReader.parseListBool(val);</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">											for (boolean i : list)</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L635">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L637">											return list;</span>
										};
									}
<span class="fc" id="L640">									break;</span>
								case &quot;listchar&quot;:
<span class="fc" id="L642">									type = char[].class;</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L644">										parser = GexfGraphReader::parseListChar;</span>
									} else {
<span class="fc" id="L646">										CharSet options = CharSet.of(parseListChar(optionsStr));</span>
<span class="fc" id="L647">										parser = val -&gt; {</span>
<span class="fc" id="L648">											char[] list = GexfGraphReader.parseListChar(val);</span>
<span class="fc bfc" id="L649" title="All 2 branches covered.">											for (char i : list)</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L651">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L653">											return list;</span>
										};
									}
<span class="fc" id="L656">									break;</span>
								case &quot;liststring&quot;:
<span class="fc" id="L658">									type = String[].class;</span>
<span class="fc bfc" id="L659" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L660">										parser = GexfGraphReader::splitList;</span>
									} else {
<span class="fc" id="L662">										Set&lt;String&gt; options = new ObjectOpenHashSet&lt;&gt;(splitList(optionsStr));</span>
<span class="fc" id="L663">										parser = val -&gt; {</span>
<span class="fc" id="L664">											String[] list = splitList(val);</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">											for (String i : list)</span>
<span class="fc bfc" id="L666" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L667">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L669">											return list;</span>
										};
									}
<span class="fc" id="L672">									break;</span>
								case &quot;listbigdecimal&quot;:
<span class="fc" id="L674">									type = BigDecimal[].class;</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L676">										parser = GexfGraphReader::parseListBigDecimal;</span>
									} else {
<span class="fc" id="L678">										Set&lt;BigDecimal&gt; options =</span>
<span class="fc" id="L679">												new ObjectOpenHashSet&lt;&gt;(parseListBigDecimal(optionsStr));</span>
<span class="fc" id="L680">										parser = val -&gt; {</span>
<span class="fc" id="L681">											BigDecimal[] list = parseListBigDecimal(val);</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">											for (BigDecimal i : list)</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L684">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L686">											return list;</span>
										};
									}
<span class="fc" id="L689">									break;</span>
								case &quot;listbiginteger&quot;:
<span class="fc" id="L691">									type = BigInteger[].class;</span>
<span class="fc bfc" id="L692" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L693">										parser = GexfGraphReader::parseListBigInteger;</span>
									} else {
<span class="fc" id="L695">										Set&lt;BigInteger&gt; options =</span>
<span class="fc" id="L696">												new ObjectOpenHashSet&lt;&gt;(parseListBigInteger(optionsStr));</span>
<span class="fc" id="L697">										parser = val -&gt; {</span>
<span class="fc" id="L698">											BigInteger[] list = parseListBigInteger(val);</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">											for (BigInteger i : list)</span>
<span class="fc bfc" id="L700" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L701">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L703">											return list;</span>
										};
									}
<span class="fc" id="L706">									break;</span>
								default:
									/* can't each here, already matched the first switch to one of the object types */
<span class="nc" id="L709">									throw new AssertionError();</span>
							}

<span class="fc bfc" id="L712" title="All 2 branches covered.">							if (objOptions != null) {</span>
<span class="fc" id="L713">								Function&lt;String, Object&gt; parser0 = parser;</span>
<span class="fc" id="L714">								Set&lt;Object&gt; objOptions0 = objOptions;</span>
<span class="fc" id="L715">								parser = val -&gt; {</span>
<span class="fc" id="L716">									Object weight = parser0.apply(val);</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">									if (!objOptions0.contains(weight))</span>
<span class="fc" id="L718">										throw new IllegalArgumentException(</span>
												&quot;invalid value: &quot; + weight + &quot; (not in options: &quot; + objOptions0 + &quot;)&quot;);
<span class="fc" id="L720">									return weight;</span>
								};
							}
<span class="fc bfc" id="L723" title="All 2 branches covered.">							defVal = defValStr == null ? null : parser.apply(defValStr);</span>
<span class="fc" id="L724">							Function&lt;String, Object&gt; parser0 = parser;</span>
<span class="fc" id="L725">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L727">								WeightsObj&lt;Object, Object&gt; weights2 = (WeightsObj) weights;</span>
<span class="fc" id="L728">								return (o, val) -&gt; weights2.set(o, parser0.apply(val));</span>
							};
<span class="fc" id="L730">							break;</span>
						}
						default:
<span class="fc" id="L733">							throw new IllegalArgumentException(&quot;unknown attribute type: &quot; + typeStr);</span>
					}
<span class="fc bfc" id="L735" title="All 2 branches covered.">					if (isVertices) {</span>
						@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L737">						Class&lt;Object&gt; attrType0 = (Class&lt;Object&gt;) type;</span>
<span class="fc" id="L738">						Weights&lt;V, Object&gt; weights = g.addVerticesWeights(weightsName, attrType0, defVal);</span>
						@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L740">						BiConsumer&lt;V, String&gt; setter =</span>
<span class="fc" id="L741">								(BiConsumer&lt;V, String&gt;) setterFactory.apply((Weights&lt;Object, Object&gt;) weights);</span>
<span class="fc" id="L742">						Object oldVal = vWeights.put(weightsId, setter);</span>
<span class="fc bfc" id="L743" title="All 2 branches covered.">						if (oldVal != null)</span>
<span class="fc" id="L744">							throw new IllegalArgumentException(&quot;duplicate node attribute id: &quot; + weightsId);</span>
<span class="fc" id="L745">					} else {</span>
						@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L747">						Class&lt;Object&gt; type0 = (Class&lt;Object&gt;) type;</span>
<span class="fc" id="L748">						Weights&lt;E, Object&gt; weights = g.addEdgesWeights(weightsName, type0, defVal);</span>
						@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L750">						BiConsumer&lt;E, String&gt; setter =</span>
<span class="fc" id="L751">								(BiConsumer&lt;E, String&gt;) setterFactory.apply((Weights&lt;Object, Object&gt;) weights);</span>
<span class="fc" id="L752">						Object oldVal = eWeights.put(weightsId, setter);</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">						if (oldVal != null)</span>
<span class="fc" id="L754">							throw new IllegalArgumentException(&quot;duplicate edge attribute id: &quot; + weightsId);</span>
					}
<span class="fc" id="L756">				}</span>
<span class="fc" id="L757">			}</span>

<span class="fc" id="L759">			WeightsObj&lt;V, String&gt; vLabels = null;</span>
<span class="fc" id="L760">			WeightsObj&lt;E, String&gt; eLabels = null;</span>
<span class="fc" id="L761">			WeightsDouble&lt;E&gt; eWeight = null;</span>

<span class="fc" id="L763">			Iterable&lt;Element&gt; nodes = XmlUtils</span>
<span class="fc" id="L764">					.optionalChild(graph, &quot;nodes&quot;)</span>
<span class="fc" id="L765">					.map(nodesElm -&gt; XmlUtils.children(nodesElm, &quot;node&quot;))</span>
<span class="fc" id="L766">					.orElse(Collections.emptyList());</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">			for (Element vElm : nodes) {</span>
<span class="fc" id="L768">				V v = vertexParser.apply(XmlUtils.requiredAttribute(vElm, &quot;id&quot;));</span>
<span class="fc" id="L769">				g.addVertex(v);</span>

<span class="fc" id="L771">				Optional&lt;String&gt; label = XmlUtils.optionalAttribute(vElm, &quot;label&quot;);</span>
<span class="fc bfc" id="L772" title="All 2 branches covered.">				if (label.isPresent()) {</span>
<span class="fc bfc" id="L773" title="All 2 branches covered.">					if (vLabels == null)</span>
<span class="fc" id="L774">						vLabels = g.addVerticesWeights(&quot;label&quot;, String.class);</span>
<span class="fc" id="L775">					vLabels.set(v, label.get());</span>
				}

<span class="fc" id="L778">				Optional&lt;Element&gt; attvaluesElm0 = XmlUtils.optionalChild(vElm, &quot;attvalues&quot;);</span>
<span class="fc bfc" id="L779" title="All 2 branches covered.">				if (attvaluesElm0.isPresent()) {</span>
<span class="fc" id="L780">					Element attvaluesElm = attvaluesElm0.get();</span>
<span class="fc bfc" id="L781" title="All 2 branches covered.">					for (Element attvalueElm : XmlUtils.children(attvaluesElm, &quot;attvalue&quot;)) {</span>
<span class="fc" id="L782">						String weightsId = XmlUtils.requiredAttribute(attvalueElm, &quot;for&quot;);</span>
<span class="fc" id="L783">						String value = XmlUtils.requiredAttribute(attvalueElm, &quot;value&quot;);</span>
<span class="fc" id="L784">						BiConsumer&lt;V, String&gt; setter = vWeights.get(weightsId);</span>
<span class="fc bfc" id="L785" title="All 2 branches covered.">						if (setter == null)</span>
<span class="fc" id="L786">							throw new IllegalArgumentException(&quot;unknown attribute id: &quot; + weightsId);</span>
<span class="fc" id="L787">						setter.accept(v, value);</span>
<span class="fc" id="L788">					}</span>
				}
<span class="fc" id="L790">			}</span>

<span class="fc" id="L792">			Iterable&lt;Element&gt; edges = XmlUtils</span>
<span class="fc" id="L793">					.optionalChild(graph, &quot;edges&quot;)</span>
<span class="fc" id="L794">					.map(edgesElm -&gt; XmlUtils.children(edgesElm, &quot;edge&quot;))</span>
<span class="fc" id="L795">					.orElse(Collections.emptyList());</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">			for (Element eElm : edges) {</span>
				E e;
<span class="fc" id="L798">				Optional&lt;String&gt; id = XmlUtils.optionalAttribute(eElm, &quot;id&quot;);</span>
<span class="fc bfc" id="L799" title="All 2 branches covered.">				if (id.isPresent()) {</span>
<span class="fc bfc" id="L800" title="All 2 branches covered.">					if (edgeParser == null)</span>
<span class="fc" id="L801">						throw new IllegalStateException(&quot;Edge parser was not set&quot;);</span>
<span class="fc" id="L802">					e = edgeParser.apply(id.get());</span>
				} else {
<span class="fc bfc" id="L804" title="All 2 branches covered.">					if (edgeBuilder == null)</span>
<span class="fc" id="L805">						throw new IllegalStateException(&quot;Edge builder was not set&quot;);</span>
<span class="fc" id="L806">					e = edgeBuilder.build(g.edges());</span>
				}
<span class="fc" id="L808">				V u = vertexParser.apply(XmlUtils.requiredAttribute(eElm, &quot;source&quot;));</span>
<span class="fc" id="L809">				V v = vertexParser.apply(XmlUtils.requiredAttribute(eElm, &quot;target&quot;));</span>
<span class="fc" id="L810">				g.addEdge(u, v, e);</span>

<span class="fc bfc" id="L812" title="All 2 branches covered.">				if (eElm.hasAttribute(&quot;type&quot;))</span>
<span class="fc" id="L813">					throw new IllegalArgumentException(&quot;directed attribute per-edge is not supported&quot;);</span>

<span class="fc" id="L815">				Optional&lt;String&gt; label = XmlUtils.optionalAttribute(eElm, &quot;label&quot;);</span>
<span class="fc bfc" id="L816" title="All 2 branches covered.">				if (label.isPresent()) {</span>
<span class="fc bfc" id="L817" title="All 2 branches covered.">					if (eLabels == null)</span>
<span class="fc" id="L818">						eLabels = g.addEdgesWeights(&quot;label&quot;, String.class);</span>
<span class="fc" id="L819">					eLabels.set(e, label.get());</span>
				}

<span class="fc" id="L822">				Optional&lt;String&gt; weight = XmlUtils.optionalAttribute(eElm, &quot;weight&quot;);</span>
<span class="fc bfc" id="L823" title="All 2 branches covered.">				if (weight.isPresent()) {</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">					if (eWeight == null)</span>
<span class="fc" id="L825">						eWeight = g.addEdgesWeights(&quot;weight&quot;, double.class, Double.valueOf(1.0));</span>
<span class="fc" id="L826">					eWeight.set(e, Double.parseDouble(weight.get()));</span>
				}

<span class="fc" id="L829">				Optional&lt;Element&gt; attvaluesElm0 = XmlUtils.optionalChild(eElm, &quot;attvalues&quot;);</span>
<span class="fc bfc" id="L830" title="All 2 branches covered.">				if (attvaluesElm0.isPresent()) {</span>
<span class="fc" id="L831">					Element attvaluesElm = attvaluesElm0.get();</span>
<span class="fc bfc" id="L832" title="All 2 branches covered.">					for (Element attvalueElm : XmlUtils.children(attvaluesElm, &quot;attvalue&quot;)) {</span>
<span class="fc" id="L833">						String weightsId = XmlUtils.requiredAttribute(attvalueElm, &quot;for&quot;);</span>
<span class="fc" id="L834">						String value = XmlUtils.requiredAttribute(attvalueElm, &quot;value&quot;);</span>
<span class="fc" id="L835">						BiConsumer&lt;E, String&gt; setter = eWeights.get(weightsId);</span>
<span class="fc bfc" id="L836" title="All 2 branches covered.">						if (setter == null)</span>
<span class="fc" id="L837">							throw new IllegalArgumentException(&quot;unknown attribute id: &quot; + weightsId);</span>
<span class="fc" id="L838">						setter.accept(e, value);</span>
<span class="fc" id="L839">					}</span>
				}
<span class="fc" id="L841">			}</span>

<span class="fc" id="L843">			return g;</span>
<span class="fc" id="L844">		} catch (SAXException | ParserConfigurationException e) {</span>
<span class="fc" id="L845">			throw new IllegalArgumentException(e);</span>
		}
	}

	private Date parseDate(String s) {
		try {
<span class="fc" id="L851">			return dateFormat.parse(s);</span>
<span class="fc" id="L852">		} catch (ParseException e) {</span>
<span class="fc" id="L853">			throw new IllegalArgumentException(e);</span>
		}
	}

	private static URI parseURI(String s) {
		try {
<span class="fc" id="L859">			return new URI(s);</span>
<span class="fc" id="L860">		} catch (URISyntaxException e) {</span>
<span class="fc" id="L861">			throw new IllegalArgumentException(e);</span>
		}
	}

	private static byte[] parseListByte(String val) {
<span class="fc" id="L866">		String[] words = splitList(val);</span>
<span class="fc" id="L867">		byte[] list = new byte[words.length];</span>
<span class="fc bfc" id="L868" title="All 2 branches covered.">		for (int i : range(words.length))</span>
<span class="fc" id="L869">			list[i] = Byte.parseByte(words[i]);</span>
<span class="fc" id="L870">		return list;</span>
	}

	private static short[] parseListShort(String val) {
<span class="fc" id="L874">		String[] words = splitList(val);</span>
<span class="fc" id="L875">		short[] list = new short[words.length];</span>
<span class="fc bfc" id="L876" title="All 2 branches covered.">		for (int i : range(words.length))</span>
<span class="fc" id="L877">			list[i] = Short.parseShort(words[i]);</span>
<span class="fc" id="L878">		return list;</span>
	}

	private static int[] parseListInt(String val) {
<span class="fc" id="L882">		String[] words = splitList(val);</span>
<span class="fc" id="L883">		int[] list = new int[words.length];</span>
<span class="fc bfc" id="L884" title="All 2 branches covered.">		for (int i : range(words.length))</span>
<span class="fc" id="L885">			list[i] = Integer.parseInt(words[i]);</span>
<span class="fc" id="L886">		return list;</span>
	}

	private static long[] parseListLong(String val) {
<span class="fc" id="L890">		String[] words = splitList(val);</span>
<span class="fc" id="L891">		long[] list = new long[words.length];</span>
<span class="fc bfc" id="L892" title="All 2 branches covered.">		for (int i : range(words.length))</span>
<span class="fc" id="L893">			list[i] = Long.parseLong(words[i]);</span>
<span class="fc" id="L894">		return list;</span>
	}

	private static float[] parseListFloat(String val) {
<span class="fc" id="L898">		String[] words = splitList(val);</span>
<span class="fc" id="L899">		float[] list = new float[words.length];</span>
<span class="fc bfc" id="L900" title="All 2 branches covered.">		for (int i : range(words.length))</span>
<span class="fc" id="L901">			list[i] = Float.parseFloat(words[i]);</span>
<span class="fc" id="L902">		return list;</span>
	}

	private static double[] parseListDouble(String val) {
<span class="fc" id="L906">		String[] words = splitList(val);</span>
<span class="fc" id="L907">		double[] list = new double[words.length];</span>
<span class="fc bfc" id="L908" title="All 2 branches covered.">		for (int i : range(words.length))</span>
<span class="fc" id="L909">			list[i] = Double.parseDouble(words[i]);</span>
<span class="fc" id="L910">		return list;</span>
	}

	private static boolean[] parseListBool(String val) {
<span class="fc" id="L914">		String[] words = splitList(val);</span>
<span class="fc" id="L915">		boolean[] list = new boolean[words.length];</span>
<span class="fc bfc" id="L916" title="All 2 branches covered.">		for (int i : range(words.length))</span>
<span class="fc" id="L917">			list[i] = Boolean.parseBoolean(words[i]);</span>
<span class="fc" id="L918">		return list;</span>
	}

	private static char[] parseListChar(String val) {
<span class="fc" id="L922">		String[] words = splitList(val);</span>
<span class="fc" id="L923">		char[] list = new char[words.length];</span>
<span class="fc bfc" id="L924" title="All 2 branches covered.">		for (int i : range(words.length))</span>
<span class="fc" id="L925">			list[i] = GraphIoUtils.parseChar(words[i]);</span>
<span class="fc" id="L926">		return list;</span>
	}

	private static BigDecimal[] parseListBigDecimal(String val) {
<span class="fc" id="L930">		return Arrays.stream(splitList(val)).map(BigDecimal::new).toArray(BigDecimal[]::new);</span>
	}

	private static BigInteger[] parseListBigInteger(String val) {
<span class="fc" id="L934">		return Arrays.stream(splitList(val)).map(BigInteger::new).toArray(BigInteger[]::new);</span>
	}

	private static URI[] parseListURI(String val) {
<span class="fc" id="L938">		return Arrays.stream(splitList(val)).map(GexfGraphReader::parseURI).toArray(URI[]::new);</span>
	}

	private Date[] parseListDate(String val) {
<span class="fc" id="L942">		return Arrays.stream(splitList(val)).map(this::parseDate).toArray(Date[]::new);</span>
	}

	private static String[] splitList(String s) {
<span class="fc bfc" id="L946" title="All 4 branches covered.">		if (!s.startsWith(&quot;[&quot;) || !s.endsWith(&quot;]&quot;))</span>
<span class="fc" id="L947">			throw new IllegalArgumentException(&quot;list attribute must be of the form [val1, val2,...]&quot;);</span>
<span class="fc" id="L948">		s = s.substring(1, s.length() - 1);</span>
<span class="fc" id="L949">		String[] words = s.split(&quot;,&quot;);</span>
<span class="fc bfc" id="L950" title="All 2 branches covered.">		for (int i : range(words.length))</span>
<span class="fc" id="L951">			words[i] = words[i].trim();</span>
<span class="fc" id="L952">		return words;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>