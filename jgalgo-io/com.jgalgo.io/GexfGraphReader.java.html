<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GexfGraphReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - IO</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.io</a> &gt; <span class="el_source">GexfGraphReader.java</span></div><h1>GexfGraphReader.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.io;

import java.io.IOException;
import java.io.Reader;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.URI;
import java.net.URISyntaxException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.Function;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import com.jgalgo.graph.Graph;
import com.jgalgo.graph.GraphBuilder;
import com.jgalgo.graph.GraphFactory;
import com.jgalgo.graph.IntGraphFactory;
import com.jgalgo.graph.Weights;
import com.jgalgo.graph.WeightsBool;
import com.jgalgo.graph.WeightsByte;
import com.jgalgo.graph.WeightsChar;
import com.jgalgo.graph.WeightsDouble;
import com.jgalgo.graph.WeightsFloat;
import com.jgalgo.graph.WeightsInt;
import com.jgalgo.graph.WeightsLong;
import com.jgalgo.graph.WeightsObj;
import com.jgalgo.graph.WeightsShort;
import it.unimi.dsi.fastutil.booleans.BooleanSet;
import it.unimi.dsi.fastutil.booleans.BooleanUnaryOperator;
import it.unimi.dsi.fastutil.bytes.ByteSet;
import it.unimi.dsi.fastutil.bytes.ByteUnaryOperator;
import it.unimi.dsi.fastutil.chars.CharSet;
import it.unimi.dsi.fastutil.chars.CharUnaryOperator;
import it.unimi.dsi.fastutil.doubles.DoubleSet;
import it.unimi.dsi.fastutil.doubles.DoubleUnaryOperator;
import it.unimi.dsi.fastutil.floats.FloatSet;
import it.unimi.dsi.fastutil.floats.FloatUnaryOperator;
import it.unimi.dsi.fastutil.ints.IntSet;
import it.unimi.dsi.fastutil.ints.IntUnaryOperator;
import it.unimi.dsi.fastutil.longs.LongSet;
import it.unimi.dsi.fastutil.longs.LongUnaryOperator;
import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
import it.unimi.dsi.fastutil.shorts.ShortSet;
import it.unimi.dsi.fastutil.shorts.ShortUnaryOperator;

/**
 * Read a graph in 'GEXF' format.
 *
 * &lt;p&gt;
 * GEXF is an XML-based format for graphs. Both directed and undirected graphs are supported, along with mixed graphs
 * (some edges are directed while others are undirected) although the {@link Graph} does not supported mixed graphs
 * (therefore the reader also doesn't support it). The format support graphs with vertices and edges of any type, as
 * long as they can be written as an XML attribute string. The format also support multiple weights for vertices and
 * edges, of any primitive Java type ({@code int}, {@code long}, {@code double}, {@code boolean}, ect.), {@link String},
 * {@link Date}, {@link URI}, {@link BigInteger}, {@link BigDecimal}, along with 'list' (arrays) of any of the above
 * except {@link Date} and {@link URI}.
 *
 * &lt;p&gt;
 * Identifiers of vertices are mandatory, and must be unique. Identifiers of edges are optional, if not specified the
 * reader will try generate them using a supplier provided by the user, or a default supplier for certain types (see
 * {@link #setEdgeSupplier(Function)} and {@link #setEdgeSupplierDefault(Class)}). Vertices identifiers (and edges
 * identifiers if specified) are parsed using a parser provided by the user, or a default parser for certain types (see
 * {@link #setVertexParserDefault(Class)} and {@link #setEdgeParserDefault(Class)}).
 *
 * &lt;p&gt;
 * When the reader reads a graph with weights, it will create a {@link Weights} object for each type of weights. For any
 * of the primitive types such as {@code int}, {@code long}, {@code double}, {@code boolean}, ect., the reader will
 * create a {@link Weights} object of the corresponding type, such as {@link WeightsInt}, {@link WeightsLong},
 * {@link WeightsDouble}, {@link WeightsBool}, ect. For {@link String}, {@link Date}, {@link URI}, {@link BigInteger},
 * {@link BigDecimal}, the reader will create a {@link Weights} object of type {@link WeightsObj}. For 'list' types,
 * which are supported for any primitive, {@link String}, {@link BigInteger} and {@link BigDecimal}, the reader will
 * create a {@link Weights} object of type {@link WeightsObj} and will populate it with arrays of the corresponding
 * type, such as {@code int[]}, {@code long[]}, {@code String[]}, {@code BigInteger[]}, ect. Default values are
 * supported for all types of weights, and will be available after reading via {@link Weights#defaultWeightAsObj()} or
 * any of the specific types weights such as {@link WeightsInt#defaultWeight()}. Note that the default value of 'list'
 * types is an array, which is shared between all vertices/edges that do not explicitly specify a value for the weight,
 * and should not be modified.
 *
 * &lt;p&gt;
 * The GEXF format support both self edges and parallel edges. The format documentation can be found
 * &lt;a href= &quot;https://gexf.net/&quot;&gt;here&lt;/a&gt;.
 *
 * @see    GexfGraphWriter
 * @author Barak Ugav
 */
public class GexfGraphReader&lt;V, E&gt; extends GraphIoUtils.AbstractGraphReader&lt;V, E&gt; {

	private Class&lt;V&gt; vertexType;
	private Class&lt;E&gt; edgeType;
	private Function&lt;String, V&gt; vertexParser;
	private Function&lt;String, E&gt; edgeParser;
	private Function&lt;Set&lt;E&gt;, E&gt; edgeSupplier;
<span class="fc" id="L120">	private final SimpleDateFormat dateFormat = new SimpleDateFormat(Gexf.DateFormat);</span>

	/**
	 * Create a new reader.
	 *
	 * &lt;p&gt;
	 * The user should set the vertex/edge parsers and edge supplier manually using {@link #setVertexParser(Function)},
	 * {@link #setEdgeParser(Function)} and {@link #setEdgeSupplier(Function)}. Setting the vertex parser is mandatory,
	 * while setting the edge parser is only required if edges identifiers are specified. Similarly, setting the edge
	 * supplier is only required if edges identifiers are not specified.
	 */
<span class="fc" id="L131">	public GexfGraphReader() {}</span>

	/**
	 * Create a new reader with default parsers and suppliers for the given vertex and edge types.
	 *
	 * &lt;p&gt;
	 * During the reading process, the reader will use the parser to convert the vertex identifiers from string to the
	 * given type, and similarly for edges if edges identifiers are specified. If edges identifiers are not specified,
	 * the reader will use the supplier to generate them. Default parsers and edge supplier exists for types
	 * {@code byte}, {@code short}, {@code int}, {@code long}, {@code float}, {@code double} and {@code String}, which
	 * will be used by the reader for the given types. If the given types are not supported by the default parsers and
	 * supplier, the reader will throw an exception. In such case, the constructor {@link #GexfGraphReader()} should be
	 * used, and the user should set the vertex/edge parsers and edge supplier manually using
	 * {@link #setVertexParser(Function)}, {@link #setEdgeParser(Function)} and {@link #setEdgeSupplier(Function)}.
	 *
	 *
	 * @param  vertexType               the type of the vertices
	 * @param  edgeType                 the type of the edges
	 * @throws IllegalArgumentException if the given types are not supported by the default vertex/edge parsers and edge
	 *                                      supplier. The supported types are {@code byte}, {@code short}, {@code int},
	 *                                      {@code long}, {@code float}, {@code double} and {@code String}.
	 * @see                             #setVertexParserDefault(Class)
	 * @see                             #setEdgeParserDefault(Class)
	 * @see                             #setEdgeSupplierDefault(Class)
	 */
<span class="fc" id="L156">	public GexfGraphReader(Class&lt;V&gt; vertexType, Class&lt;E&gt; edgeType) {</span>
<span class="fc" id="L157">		setVertexParserDefault(this.vertexType = vertexType);</span>
<span class="fc" id="L158">		setEdgeParserDefault(this.edgeType = edgeType);</span>
<span class="fc" id="L159">		setEdgeSupplierDefault(this.edgeType);</span>
<span class="fc" id="L160">	}</span>

	/**
	 * Set the parser for the vertices identifiers.
	 *
	 * &lt;p&gt;
	 * The parser is used to convert the vertex identifiers from string to the given vertex type. The parser is
	 * mandatory, and must be set before reading a graph. For default parsers for certain types, see
	 * {@link #setVertexParserDefault(Class)}.
	 *
	 * @param vertexParser a parser for the vertices identifiers
	 */
	public void setVertexParser(Function&lt;String, V&gt; vertexParser) {
<span class="fc" id="L173">		this.vertexParser = Objects.requireNonNull(vertexParser);</span>
<span class="fc" id="L174">	}</span>

	/**
	 * Set the parser for the vertices identifiers, using a default parser for the given vertex type.
	 *
	 * &lt;p&gt;
	 * The parser is used to convert the vertex identifiers from string to the given vertex type. The parser is
	 * mandatory, and must be set before reading a graph. The default parser exists for types {@code byte},
	 * {@code short}, {@code int}, {@code long}, {@code float}, {@code double} and {@code String}. If the given type is
	 * not supported by the default parser, the reader will throw an exception. In such case, the method
	 * {@link #setVertexParser(Function)} should be used for custom parsing.
	 *
	 * @param  vertexType               the type of the vertices
	 * @throws IllegalArgumentException if the given type is not supported by the default parser. The supported types
	 *                                      are {@code byte}, {@code short}, {@code int}, {@code long}, {@code float},
	 *                                      {@code double} and {@code String}.
	 */
	public void setVertexParserDefault(Class&lt;V&gt; vertexType) {
<span class="fc" id="L192">		this.vertexParser = GraphIoUtils.defaultParser(vertexType);</span>
<span class="fc" id="L193">		this.vertexType = vertexType;</span>
<span class="fc" id="L194">	}</span>

	/**
	 * Set the parser for the edges identifiers.
	 *
	 * &lt;p&gt;
	 * The parser is used to convert the edges identifiers from string to the given edge type. The parser is mandatory
	 * if edges identifiers are specified. In case edge identifiers are not specified, an edge supplier must be set (see
	 * {@link #setEdgeSupplier(Function)}). For default parsers for certain types, see
	 * {@link #setEdgeParserDefault(Class)}.
	 *
	 * @param edgeParser a parser for the edges identifiers
	 */
	public void setEdgeParser(Function&lt;String, E&gt; edgeParser) {
<span class="fc" id="L208">		this.edgeParser = Objects.requireNonNull(edgeParser);</span>
<span class="fc" id="L209">	}</span>

	/**
	 * Set the parser for the edges identifiers, using a default parser for the given edge type.
	 *
	 * &lt;p&gt;
	 * The parser is used to convert the edges identifiers from string to the given edge type. The parser is mandatory
	 * if edges identifiers are specified. In case edge identifiers are not specified, an edge supplier must be set (see
	 * {@link #setEdgeSupplier(Function)}). The default parser exists for types {@code byte}, {@code short},
	 * {@code int}, {@code long}, {@code float}, {@code double} and {@code String}. If the given type is not supported
	 * by the default parser, the reader will throw an exception. In such case, the method
	 * {@link #setEdgeParser(Function)} should be used for custom parsing.
	 *
	 * @param  edgeType                 the type of the edges
	 * @throws IllegalArgumentException if the given type is not supported by the default parser. The supported types
	 *                                      are {@code byte}, {@code short}, {@code int}, {@code long}, {@code float},
	 *                                      {@code double} and {@code String}.
	 */
	public void setEdgeParserDefault(Class&lt;E&gt; edgeType) {
<span class="fc" id="L228">		this.edgeParser = GraphIoUtils.defaultParser(edgeType);</span>
<span class="fc" id="L229">		this.edgeType = edgeType;</span>
<span class="fc" id="L230">	}</span>

	/**
	 * Set the supplier for the edges identifiers.
	 *
	 * &lt;p&gt;
	 * The supplier is used to generate edges identifiers if edges identifiers are not specified. The supplier is
	 * mandatory if edges identifiers are not specified. In case edge identifiers are specified, an edge parser must be
	 * set (see {@link #setEdgeParser(Function)}). For default suppliers for certain types, see
	 * {@link #setEdgeSupplierDefault(Class)}.
	 *
	 * &lt;p&gt;
	 * The edge supplier accepts a set of existing edges, and should return a new edge identifier that is not in the
	 * set.
	 *
	 * @param edgeSupplier a supplier for the edges identifiers
	 */
	public void setEdgeSupplier(Function&lt;Set&lt;E&gt;, E&gt; edgeSupplier) {
<span class="fc" id="L248">		this.edgeSupplier = Objects.requireNonNull(edgeSupplier);</span>
<span class="fc" id="L249">	}</span>

	/**
	 * Set the supplier for the edges identifiers, using a default supplier for the given edge type.
	 *
	 * &lt;p&gt;
	 * The supplier is used to generate edges identifiers if edges identifiers are not specified. The supplier is
	 * mandatory if edges identifiers are not specified. In case edge identifiers are specified, an edge parser must be
	 * set (see {@link #setEdgeParser(Function)}). The default supplier exists for types {@code byte}, {@code short},
	 * {@code int}, {@code long}, {@code float}, {@code double} and {@code String}. If the given type is not supported
	 * by the default supplier, the reader will throw an exception. In such case, the method
	 * {@link #setEdgeSupplier(Function)} should be used for custom supplier.
	 *
	 * @param  edgeType                 the type of the edges
	 * @throws IllegalArgumentException if the given type is not supported by the default supplier. The supported types
	 *                                      are {@code byte}, {@code short}, {@code int}, {@code long}, {@code float},
	 *                                      {@code double} and {@code String}.
	 */
	public void setEdgeSupplierDefault(Class&lt;E&gt; edgeType) {
<span class="fc" id="L268">		edgeSupplier = GraphIoUtils.defaultEdgeSupplier(edgeType);</span>
<span class="fc" id="L269">		this.edgeType = edgeType;</span>
<span class="fc" id="L270">	}</span>

	@Override
	GraphBuilder&lt;V, E&gt; readIntoBuilderImpl(Reader reader) throws IOException {
<span class="fc bfc" id="L274" title="All 2 branches covered.">		if (vertexParser == null)</span>
<span class="fc" id="L275">			throw new IllegalStateException(&quot;Vertex parser was not set&quot;);</span>
		try {
			Document document =
<span class="fc" id="L278">					DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(new InputSource(reader));</span>
<span class="fc" id="L279">			Element doc = document.getDocumentElement();</span>
<span class="fc" id="L280">			doc.normalize();</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">			if (!doc.getTagName().equals(&quot;gexf&quot;))</span>
<span class="fc" id="L282">				throw new IllegalArgumentException(&quot;root element is not 'gexf'&quot;);</span>
<span class="fc" id="L283">			Element graph = XmlUtils.requiredChild(doc, &quot;graph&quot;);</span>

<span class="fc" id="L285">			boolean directed = graph.getAttribute(&quot;defaultedgetype&quot;).equals(&quot;directed&quot;);</span>
			GraphFactory&lt;V, E&gt; factory;
<span class="fc bfc" id="L287" title="All 4 branches covered.">			if (vertexType == int.class &amp;&amp; edgeType == int.class) {</span>
				@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc bfc" id="L289" title="All 2 branches covered.">				GraphFactory&lt;V, E&gt; factory0 = (GraphFactory&lt;V, E&gt;) (directed ? IntGraphFactory.newDirected()</span>
<span class="fc" id="L290">						: IntGraphFactory.newUndirected());</span>
<span class="fc" id="L291">				factory = factory0;</span>
<span class="fc" id="L292">			} else {</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">				factory = directed ? GraphFactory.newDirected() : GraphFactory.newUndirected();</span>
			}
<span class="fc" id="L295">			GraphBuilder&lt;V, E&gt; g = factory.allowSelfEdges().allowParallelEdges().newBuilder();</span>

<span class="fc bfc" id="L297" title="All 2 branches covered.">			if (XmlUtils.optionalAttribute(graph, &quot;mode&quot;).orElse(&quot;static&quot;).equals(&quot;dynamic&quot;))</span>
<span class="fc" id="L298">				throw new IllegalArgumentException(&quot;dynamic graphs are not supported&quot;);</span>

<span class="fc" id="L300">			Map&lt;String, BiConsumer&lt;V, String&gt;&gt; vWeights = new HashMap&lt;&gt;();</span>
<span class="fc" id="L301">			Map&lt;String, BiConsumer&lt;E, String&gt;&gt; eWeights = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L303" title="All 2 branches covered.">			for (Element attributesElm : XmlUtils.children(graph, &quot;attributes&quot;)) {</span>
<span class="fc" id="L304">				String clazz = XmlUtils.requiredAttribute(attributesElm, &quot;class&quot;);</span>
				boolean isVertices;
<span class="fc bfc" id="L306" title="All 2 branches covered.">				if (clazz.equals(&quot;node&quot;)) {</span>
<span class="fc" id="L307">					isVertices = true;</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">				} else if (clazz.equals(&quot;edge&quot;)) {</span>
<span class="fc" id="L309">					isVertices = false;</span>
				} else {
<span class="fc" id="L311">					throw new IllegalArgumentException(&quot;unknown attributes class: &quot; + clazz);</span>
				}

<span class="fc bfc" id="L314" title="All 2 branches covered.">				for (Element attributeElm : XmlUtils.children(attributesElm, &quot;attribute&quot;)) {</span>
<span class="fc" id="L315">					String weightsId = XmlUtils.requiredAttribute(attributeElm, &quot;id&quot;);</span>
<span class="fc" id="L316">					String weightsName = XmlUtils.requiredAttribute(attributeElm, &quot;title&quot;);</span>
<span class="fc" id="L317">					String typeStr = XmlUtils.requiredAttribute(attributeElm, &quot;type&quot;);</span>
<span class="fc" id="L318">					String defValStr =</span>
<span class="fc" id="L319">							XmlUtils.optionalChild(attributeElm, &quot;default&quot;).map(Element::getTextContent).orElse(null);</span>
<span class="fc" id="L320">					String optionsStr =</span>
<span class="fc" id="L321">							XmlUtils.optionalChild(attributeElm, &quot;options&quot;).map(Element::getTextContent).orElse(null);</span>

					Class&lt;?&gt; type;
					Object defVal;
					Function&lt;Weights&lt;Object, Object&gt;, BiConsumer&lt;Object, String&gt;&gt; setterFactory;
<span class="fc bfc" id="L326" title="All 10 branches covered.">					switch (typeStr) {</span>
						case &quot;byte&quot;: {
<span class="fc" id="L328">							type = byte.class;</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">							ByteSet options = optionsStr == null ? null : ByteSet.of(parseListByte(optionsStr));</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">							ByteUnaryOperator checkOptions = options == null ? ByteUnaryOperator.identity() : b -&gt; {</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">								if (!options.contains(b))</span>
<span class="fc" id="L332">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + b + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L334">								return b;</span>
							};
<span class="fc bfc" id="L336" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L337">									: Byte.valueOf(checkOptions.apply(Byte.parseByte(defValStr)));</span>
<span class="fc" id="L338">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L340">								WeightsByte&lt;Object&gt; weights2 = (WeightsByte) weights;</span>
<span class="fc" id="L341">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Byte.parseByte(val)));</span>
							};
<span class="fc" id="L343">							break;</span>
						}
						case &quot;short&quot;: {
<span class="fc" id="L346">							type = short.class;</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">							ShortSet options = optionsStr == null ? null : ShortSet.of(parseListShort(optionsStr));</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">							ShortUnaryOperator checkOptions = options == null ? ShortUnaryOperator.identity() : s -&gt; {</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">								if (!options.contains(s))</span>
<span class="fc" id="L350">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + s + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L352">								return s;</span>
							};
<span class="fc bfc" id="L354" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L355">									: Short.valueOf(checkOptions.apply(Short.parseShort(defValStr)));</span>
<span class="fc" id="L356">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L358">								WeightsShort&lt;Object&gt; weights2 = (WeightsShort) weights;</span>
<span class="fc" id="L359">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Short.parseShort(val)));</span>
							};
<span class="fc" id="L361">							break;</span>
						}
						case &quot;integer&quot;: {
<span class="fc" id="L364">							type = int.class;</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">							IntSet options = optionsStr == null ? null : IntSet.of(parseListInt(optionsStr));</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">							IntUnaryOperator checkOptions = options == null ? IntUnaryOperator.identity() : i -&gt; {</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">								if (!options.contains(i))</span>
<span class="fc" id="L368">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + i + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L370">								return i;</span>
							};
<span class="fc bfc" id="L372" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L373">									: Integer.valueOf(checkOptions.apply(Integer.parseInt(defValStr)));</span>
<span class="fc" id="L374">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L376">								WeightsInt&lt;Object&gt; weights2 = (WeightsInt) weights;</span>
<span class="fc" id="L377">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Integer.parseInt(val)));</span>
							};
<span class="fc" id="L379">							break;</span>
						}
						case &quot;long&quot;: {
<span class="fc" id="L382">							type = long.class;</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">							LongSet options = optionsStr == null ? null : LongSet.of(parseListLong(optionsStr));</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">							LongUnaryOperator checkOptions = options == null ? LongUnaryOperator.identity() : l -&gt; {</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">								if (!options.contains(l))</span>
<span class="fc" id="L386">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + l + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L388">								return l;</span>
							};
<span class="fc bfc" id="L390" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L391">									: Long.valueOf(checkOptions.apply(Long.parseLong(defValStr)));</span>
<span class="fc" id="L392">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L394">								WeightsLong&lt;Object&gt; weights2 = (WeightsLong) weights;</span>
<span class="fc" id="L395">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Long.parseLong(val)));</span>
							};
<span class="fc" id="L397">							break;</span>
						}
						case &quot;float&quot;: {
<span class="fc" id="L400">							type = float.class;</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">							FloatSet options = optionsStr == null ? null : FloatSet.of(parseListFloat(optionsStr));</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">							FloatUnaryOperator checkOptions = options == null ? FloatUnaryOperator.identity() : f -&gt; {</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">								if (!options.contains(f))</span>
<span class="fc" id="L404">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + f + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L406">								return f;</span>
							};
<span class="fc bfc" id="L408" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L409">									: Float.valueOf(checkOptions.apply(Float.parseFloat(defValStr)));</span>
<span class="fc" id="L410">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L412">								WeightsFloat&lt;Object&gt; weights2 = (WeightsFloat) weights;</span>
<span class="fc" id="L413">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Float.parseFloat(val)));</span>
							};
<span class="fc" id="L415">							break;</span>
						}
						case &quot;double&quot;: {
<span class="fc" id="L418">							type = double.class;</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">							DoubleSet options = optionsStr == null ? null : DoubleSet.of(parseListDouble(optionsStr));</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">							DoubleUnaryOperator checkOptions = options == null ? DoubleUnaryOperator.identity() : d -&gt; {</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">								if (!options.contains(d))</span>
<span class="fc" id="L422">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + d + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L424">								return d;</span>
							};
<span class="fc bfc" id="L426" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L427">									: Double.valueOf(checkOptions.apply(Double.parseDouble(defValStr)));</span>
<span class="fc" id="L428">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L430">								WeightsDouble&lt;Object&gt; weights2 = (WeightsDouble) weights;</span>
<span class="fc" id="L431">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Double.parseDouble(val)));</span>
							};
<span class="fc" id="L433">							break;</span>
						}
						case &quot;boolean&quot;: {
<span class="fc" id="L436">							type = boolean.class;</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">							BooleanSet options = optionsStr == null ? null : BooleanSet.of(parseListBool(optionsStr));</span>
							BooleanUnaryOperator checkOptions =
<span class="fc bfc" id="L439" title="All 2 branches covered.">									options == null ? BooleanUnaryOperator.identity() : b -&gt; {</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">										if (!options.contains(b))</span>
<span class="fc" id="L441">											throw new IllegalArgumentException(</span>
													&quot;invalid value: &quot; + b + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L443">										return b;</span>
									};
<span class="fc bfc" id="L445" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L446">									: Boolean.valueOf(checkOptions.apply(Boolean.parseBoolean(defValStr)));</span>
<span class="fc" id="L447">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L449">								WeightsBool&lt;Object&gt; weights2 = (WeightsBool) weights;</span>
<span class="fc" id="L450">								return (o, val) -&gt; weights2.set(o, checkOptions.apply(Boolean.parseBoolean(val)));</span>
							};
<span class="fc" id="L452">							break;</span>
						}
						case &quot;char&quot;: {
<span class="fc" id="L455">							type = char.class;</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">							CharSet options = optionsStr == null ? null : CharSet.of(parseListChar(optionsStr));</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">							CharUnaryOperator checkOptions = options == null ? CharUnaryOperator.identity() : c -&gt; {</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">								if (!options.contains(c))</span>
<span class="fc" id="L459">									throw new IllegalArgumentException(</span>
											&quot;invalid value: &quot; + c + &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L461">								return c;</span>
							};
<span class="fc bfc" id="L463" title="All 2 branches covered.">							defVal = defValStr == null ? null</span>
<span class="fc" id="L464">									: Character.valueOf(checkOptions.apply(GraphIoUtils.parseChar(defValStr)));</span>
<span class="fc" id="L465">							setterFactory = weights -&gt; {</span>
<span class="fc" id="L466">								return (o, val) -&gt; {</span>
									@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L468">									WeightsChar&lt;Object&gt; weights2 = (WeightsChar) weights;</span>
<span class="fc" id="L469">									weights2.set(o, checkOptions.apply(GraphIoUtils.parseChar(val)));</span>
<span class="fc" id="L470">								};</span>
							};
<span class="fc" id="L472">							break;</span>
						}

						/* common for all Object weights */
						case &quot;string&quot;:
						case &quot;date&quot;:
						case &quot;anyURI&quot;:
						case &quot;bigdecimal&quot;:
						case &quot;biginteger&quot;:
						case &quot;listbyte&quot;:
						case &quot;listshort&quot;:
						case &quot;listinteger&quot;:
						case &quot;listlong&quot;:
						case &quot;listfloat&quot;:
						case &quot;listdouble&quot;:
						case &quot;listboolean&quot;:
						case &quot;listchar&quot;:
						case &quot;liststring&quot;:
						case &quot;listbigdecimal&quot;:
						case &quot;listbiginteger&quot;: {
							Function&lt;String, Object&gt; parser;
<span class="fc" id="L493">							Set&lt;Object&gt; objOptions = null;</span>

<span class="pc bpc" id="L495" title="1 of 17 branches missed.">							switch (typeStr) {</span>
								case &quot;string&quot;:
<span class="fc" id="L497">									type = String.class;</span>
									objOptions =
<span class="fc bfc" id="L499" title="All 2 branches covered.">											optionsStr == null ? null : new ObjectOpenHashSet&lt;&gt;(splitList(optionsStr));</span>
<span class="fc" id="L500">									parser = s -&gt; s;</span>
<span class="fc" id="L501">									break;</span>
								case &quot;date&quot;:
<span class="fc" id="L503">									type = Date.class;</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">									objOptions = optionsStr == null ? null</span>
<span class="fc" id="L505">											: new ObjectOpenHashSet&lt;&gt;(parseListDate(optionsStr));</span>
<span class="fc" id="L506">									parser = this::parseDate;</span>
<span class="fc" id="L507">									break;</span>
								case &quot;anyURI&quot;:
<span class="fc" id="L509">									type = URI.class;</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">									objOptions = optionsStr == null ? null</span>
<span class="fc" id="L511">											: new ObjectOpenHashSet&lt;&gt;(parseListURI(optionsStr));</span>
<span class="fc" id="L512">									parser = GexfGraphReader::parseURI;</span>
<span class="fc" id="L513">									break;</span>
								case &quot;bigdecimal&quot;:
<span class="fc" id="L515">									type = BigDecimal.class;</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">									objOptions = optionsStr == null ? null</span>
<span class="fc" id="L517">											: new ObjectOpenHashSet&lt;&gt;(parseListBigDecimal(optionsStr));</span>
<span class="fc" id="L518">									parser = BigDecimal::new;</span>
<span class="fc" id="L519">									break;</span>
								case &quot;biginteger&quot;:
<span class="fc" id="L521">									type = BigInteger.class;</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">									objOptions = optionsStr == null ? null</span>
<span class="fc" id="L523">											: new ObjectOpenHashSet&lt;&gt;(parseListBigInteger(optionsStr));</span>
<span class="fc" id="L524">									parser = BigInteger::new;</span>
<span class="fc" id="L525">									break;</span>
								case &quot;listbyte&quot;:
<span class="fc" id="L527">									type = byte[].class;</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L529">										parser = GexfGraphReader::parseListByte;</span>
									} else {
<span class="fc" id="L531">										ByteSet options = ByteSet.of(parseListByte(optionsStr));</span>
<span class="fc" id="L532">										parser = val -&gt; {</span>
<span class="fc" id="L533">											byte[] list = GexfGraphReader.parseListByte(val);</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">											for (byte i : list)</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L536">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L538">											return list;</span>
										};
									}
<span class="fc" id="L541">									break;</span>
								case &quot;listshort&quot;:
<span class="fc" id="L543">									type = short[].class;</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L545">										parser = GexfGraphReader::parseListShort;</span>
									} else {
<span class="fc" id="L547">										ShortSet options = ShortSet.of(parseListShort(optionsStr));</span>
<span class="fc" id="L548">										parser = val -&gt; {</span>
<span class="fc" id="L549">											short[] list = GexfGraphReader.parseListShort(val);</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">											for (short i : list)</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L552">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L554">											return list;</span>
										};
									}
<span class="fc" id="L557">									break;</span>
								case &quot;listinteger&quot;:
<span class="fc" id="L559">									type = int[].class;</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L561">										parser = GexfGraphReader::parseListInt;</span>
									} else {
<span class="fc" id="L563">										IntSet options = IntSet.of(parseListInt(optionsStr));</span>
<span class="fc" id="L564">										parser = val -&gt; {</span>
<span class="fc" id="L565">											int[] list = GexfGraphReader.parseListInt(val);</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">											for (int i : list)</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L568">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L570">											return list;</span>
										};
									}
<span class="fc" id="L573">									break;</span>
								case &quot;listlong&quot;:
<span class="fc" id="L575">									type = long[].class;</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L577">										parser = GexfGraphReader::parseListLong;</span>
									} else {
<span class="fc" id="L579">										LongSet options = LongSet.of(parseListLong(optionsStr));</span>
<span class="fc" id="L580">										parser = val -&gt; {</span>
<span class="fc" id="L581">											long[] list = GexfGraphReader.parseListLong(val);</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">											for (long i : list)</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L584">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L586">											return list;</span>
										};
									}
<span class="fc" id="L589">									break;</span>
								case &quot;listfloat&quot;:
<span class="fc" id="L591">									type = float[].class;</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L593">										parser = GexfGraphReader::parseListFloat;</span>
									} else {
<span class="fc" id="L595">										FloatSet options = FloatSet.of(parseListFloat(optionsStr));</span>
<span class="fc" id="L596">										parser = val -&gt; {</span>
<span class="fc" id="L597">											float[] list = GexfGraphReader.parseListFloat(val);</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">											for (float i : list)</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L600">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L602">											return list;</span>
										};
									}
<span class="fc" id="L605">									break;</span>
								case &quot;listdouble&quot;:
<span class="fc" id="L607">									type = double[].class;</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L609">										parser = GexfGraphReader::parseListDouble;</span>
									} else {
<span class="fc" id="L611">										DoubleSet options = DoubleSet.of(parseListDouble(optionsStr));</span>
<span class="fc" id="L612">										parser = val -&gt; {</span>
<span class="fc" id="L613">											double[] list = GexfGraphReader.parseListDouble(val);</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">											for (double i : list)</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L616">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L618">											return list;</span>
										};
									}
<span class="fc" id="L621">									break;</span>
								case &quot;listboolean&quot;:
<span class="fc" id="L623">									type = boolean[].class;</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L625">										parser = GexfGraphReader::parseListBool;</span>
									} else {
<span class="fc" id="L627">										BooleanSet options = BooleanSet.of(parseListBool(optionsStr));</span>
<span class="fc" id="L628">										parser = val -&gt; {</span>
<span class="fc" id="L629">											boolean[] list = GexfGraphReader.parseListBool(val);</span>
<span class="fc bfc" id="L630" title="All 2 branches covered.">											for (boolean i : list)</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L632">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L634">											return list;</span>
										};
									}
<span class="fc" id="L637">									break;</span>
								case &quot;listchar&quot;:
<span class="fc" id="L639">									type = char[].class;</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L641">										parser = GexfGraphReader::parseListChar;</span>
									} else {
<span class="fc" id="L643">										CharSet options = CharSet.of(parseListChar(optionsStr));</span>
<span class="fc" id="L644">										parser = val -&gt; {</span>
<span class="fc" id="L645">											char[] list = GexfGraphReader.parseListChar(val);</span>
<span class="fc bfc" id="L646" title="All 2 branches covered.">											for (char i : list)</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L648">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L650">											return list;</span>
										};
									}
<span class="fc" id="L653">									break;</span>
								case &quot;liststring&quot;:
<span class="fc" id="L655">									type = String[].class;</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L657">										parser = GexfGraphReader::splitList;</span>
									} else {
<span class="fc" id="L659">										Set&lt;String&gt; options = new ObjectOpenHashSet&lt;&gt;(splitList(optionsStr));</span>
<span class="fc" id="L660">										parser = val -&gt; {</span>
<span class="fc" id="L661">											String[] list = splitList(val);</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">											for (String i : list)</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L664">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L666">											return list;</span>
										};
									}
<span class="fc" id="L669">									break;</span>
								case &quot;listbigdecimal&quot;:
<span class="fc" id="L671">									type = BigDecimal[].class;</span>
<span class="fc bfc" id="L672" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L673">										parser = GexfGraphReader::parseListBigDecimal;</span>
									} else {
<span class="fc" id="L675">										Set&lt;BigDecimal&gt; options =</span>
<span class="fc" id="L676">												new ObjectOpenHashSet&lt;&gt;(parseListBigDecimal(optionsStr));</span>
<span class="fc" id="L677">										parser = val -&gt; {</span>
<span class="fc" id="L678">											BigDecimal[] list = parseListBigDecimal(val);</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">											for (BigDecimal i : list)</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L681">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L683">											return list;</span>
										};
									}
<span class="fc" id="L686">									break;</span>
								case &quot;listbiginteger&quot;:
<span class="fc" id="L688">									type = BigInteger[].class;</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">									if (optionsStr == null) {</span>
<span class="fc" id="L690">										parser = GexfGraphReader::parseListBigInteger;</span>
									} else {
<span class="fc" id="L692">										Set&lt;BigInteger&gt; options =</span>
<span class="fc" id="L693">												new ObjectOpenHashSet&lt;&gt;(parseListBigInteger(optionsStr));</span>
<span class="fc" id="L694">										parser = val -&gt; {</span>
<span class="fc" id="L695">											BigInteger[] list = parseListBigInteger(val);</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">											for (BigInteger i : list)</span>
<span class="fc bfc" id="L697" title="All 2 branches covered.">												if (!options.contains(i))</span>
<span class="fc" id="L698">													throw new IllegalArgumentException(&quot;invalid value: &quot; + i</span>
															+ &quot; (not in options: &quot; + options + &quot;)&quot;);
<span class="fc" id="L700">											return list;</span>
										};
									}
<span class="fc" id="L703">									break;</span>
								default:
									/* can't each here, already matched the first switch to one of the object types */
<span class="nc" id="L706">									throw new AssertionError();</span>
							}

<span class="fc bfc" id="L709" title="All 2 branches covered.">							if (objOptions != null) {</span>
<span class="fc" id="L710">								Function&lt;String, Object&gt; parser0 = parser;</span>
<span class="fc" id="L711">								Set&lt;Object&gt; objOptions0 = objOptions;</span>
<span class="fc" id="L712">								parser = val -&gt; {</span>
<span class="fc" id="L713">									Object weight = parser0.apply(val);</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">									if (!objOptions0.contains(weight))</span>
<span class="fc" id="L715">										throw new IllegalArgumentException(</span>
												&quot;invalid value: &quot; + weight + &quot; (not in options: &quot; + objOptions0 + &quot;)&quot;);
<span class="fc" id="L717">									return weight;</span>
								};
							}
<span class="fc bfc" id="L720" title="All 2 branches covered.">							defVal = defValStr == null ? null : parser.apply(defValStr);</span>
<span class="fc" id="L721">							Function&lt;String, Object&gt; parser0 = parser;</span>
<span class="fc" id="L722">							setterFactory = weights -&gt; {</span>
								@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
<span class="fc" id="L724">								WeightsObj&lt;Object, Object&gt; weights2 = (WeightsObj) weights;</span>
<span class="fc" id="L725">								return (o, val) -&gt; weights2.set(o, parser0.apply(val));</span>
							};
<span class="fc" id="L727">							break;</span>
						}
						default:
<span class="fc" id="L730">							throw new IllegalArgumentException(&quot;unknown attribute type: &quot; + typeStr);</span>
					}
<span class="fc bfc" id="L732" title="All 2 branches covered.">					if (isVertices) {</span>
						@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L734">						Class&lt;Object&gt; attrType0 = (Class&lt;Object&gt;) type;</span>
<span class="fc" id="L735">						Weights&lt;V, Object&gt; weights = g.addVerticesWeights(weightsName, attrType0, defVal);</span>
						@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L737">						BiConsumer&lt;V, String&gt; setter =</span>
<span class="fc" id="L738">								(BiConsumer&lt;V, String&gt;) setterFactory.apply((Weights&lt;Object, Object&gt;) weights);</span>
<span class="fc" id="L739">						Object oldVal = vWeights.put(weightsId, setter);</span>
<span class="fc bfc" id="L740" title="All 2 branches covered.">						if (oldVal != null)</span>
<span class="fc" id="L741">							throw new IllegalArgumentException(&quot;duplicate node attribute id: &quot; + weightsId);</span>
<span class="fc" id="L742">					} else {</span>
						@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L744">						Class&lt;Object&gt; type0 = (Class&lt;Object&gt;) type;</span>
<span class="fc" id="L745">						Weights&lt;E, Object&gt; weights = g.addEdgesWeights(weightsName, type0, defVal);</span>
						@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L747">						BiConsumer&lt;E, String&gt; setter =</span>
<span class="fc" id="L748">								(BiConsumer&lt;E, String&gt;) setterFactory.apply((Weights&lt;Object, Object&gt;) weights);</span>
<span class="fc" id="L749">						Object oldVal = eWeights.put(weightsId, setter);</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">						if (oldVal != null)</span>
<span class="fc" id="L751">							throw new IllegalArgumentException(&quot;duplicate edge attribute id: &quot; + weightsId);</span>
					}
<span class="fc" id="L753">				}</span>
<span class="fc" id="L754">			}</span>

<span class="fc" id="L756">			WeightsObj&lt;V, String&gt; vLabels = null;</span>
<span class="fc" id="L757">			WeightsObj&lt;E, String&gt; eLabels = null;</span>
<span class="fc" id="L758">			WeightsDouble&lt;E&gt; eWeight = null;</span>

<span class="fc" id="L760">			Iterable&lt;Element&gt; nodes = XmlUtils.optionalChild(graph, &quot;nodes&quot;)</span>
<span class="fc" id="L761">					.map(nodesElm -&gt; XmlUtils.children(nodesElm, &quot;node&quot;)).orElse(Collections.emptyList());</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">			for (Element vElm : nodes) {</span>
<span class="fc" id="L763">				V v = vertexParser.apply(XmlUtils.requiredAttribute(vElm, &quot;id&quot;));</span>
<span class="fc" id="L764">				g.addVertex(v);</span>

<span class="fc" id="L766">				Optional&lt;String&gt; label = XmlUtils.optionalAttribute(vElm, &quot;label&quot;);</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">				if (label.isPresent()) {</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">					if (vLabels == null)</span>
<span class="fc" id="L769">						vLabels = g.addVerticesWeights(&quot;label&quot;, String.class);</span>
<span class="fc" id="L770">					vLabels.set(v, label.get());</span>
				}

<span class="fc" id="L773">				Optional&lt;Element&gt; attvaluesElm0 = XmlUtils.optionalChild(vElm, &quot;attvalues&quot;);</span>
<span class="fc bfc" id="L774" title="All 2 branches covered.">				if (attvaluesElm0.isPresent()) {</span>
<span class="fc" id="L775">					Element attvaluesElm = attvaluesElm0.get();</span>
<span class="fc bfc" id="L776" title="All 2 branches covered.">					for (Element attvalueElm : XmlUtils.children(attvaluesElm, &quot;attvalue&quot;)) {</span>
<span class="fc" id="L777">						String weightsId = XmlUtils.requiredAttribute(attvalueElm, &quot;for&quot;);</span>
<span class="fc" id="L778">						String value = XmlUtils.requiredAttribute(attvalueElm, &quot;value&quot;);</span>
<span class="fc" id="L779">						BiConsumer&lt;V, String&gt; setter = vWeights.get(weightsId);</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">						if (setter == null)</span>
<span class="fc" id="L781">							throw new IllegalArgumentException(&quot;unknown attribute id: &quot; + weightsId);</span>
<span class="fc" id="L782">						setter.accept(v, value);</span>
<span class="fc" id="L783">					}</span>
				}
<span class="fc" id="L785">			}</span>

<span class="fc" id="L787">			Iterable&lt;Element&gt; edges = XmlUtils.optionalChild(graph, &quot;edges&quot;)</span>
<span class="fc" id="L788">					.map(edgesElm -&gt; XmlUtils.children(edgesElm, &quot;edge&quot;)).orElse(Collections.emptyList());</span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">			for (Element eElm : edges) {</span>
				E e;
<span class="fc" id="L791">				Optional&lt;String&gt; id = XmlUtils.optionalAttribute(eElm, &quot;id&quot;);</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">				if (id.isPresent()) {</span>
<span class="fc bfc" id="L793" title="All 2 branches covered.">					if (edgeParser == null)</span>
<span class="fc" id="L794">						throw new IllegalStateException(&quot;Edge parser was not set&quot;);</span>
<span class="fc" id="L795">					e = edgeParser.apply(id.get());</span>
				} else {
<span class="fc bfc" id="L797" title="All 2 branches covered.">					if (edgeSupplier == null)</span>
<span class="fc" id="L798">						throw new IllegalStateException(&quot;Edge supplier was not set&quot;);</span>
<span class="fc" id="L799">					e = edgeSupplier.apply(g.edges());</span>
				}
<span class="fc" id="L801">				V u = vertexParser.apply(XmlUtils.requiredAttribute(eElm, &quot;source&quot;));</span>
<span class="fc" id="L802">				V v = vertexParser.apply(XmlUtils.requiredAttribute(eElm, &quot;target&quot;));</span>
<span class="fc" id="L803">				g.addEdge(u, v, e);</span>

<span class="fc bfc" id="L805" title="All 2 branches covered.">				if (eElm.hasAttribute(&quot;type&quot;))</span>
<span class="fc" id="L806">					throw new IllegalArgumentException(&quot;directed attribute per-edge is not supported&quot;);</span>

<span class="fc" id="L808">				Optional&lt;String&gt; label = XmlUtils.optionalAttribute(eElm, &quot;label&quot;);</span>
<span class="fc bfc" id="L809" title="All 2 branches covered.">				if (label.isPresent()) {</span>
<span class="fc bfc" id="L810" title="All 2 branches covered.">					if (eLabels == null)</span>
<span class="fc" id="L811">						eLabels = g.addEdgesWeights(&quot;label&quot;, String.class);</span>
<span class="fc" id="L812">					eLabels.set(e, label.get());</span>
				}

<span class="fc" id="L815">				Optional&lt;String&gt; weight = XmlUtils.optionalAttribute(eElm, &quot;weight&quot;);</span>
<span class="fc bfc" id="L816" title="All 2 branches covered.">				if (weight.isPresent()) {</span>
<span class="fc bfc" id="L817" title="All 2 branches covered.">					if (eWeight == null)</span>
<span class="fc" id="L818">						eWeight = g.addEdgesWeights(&quot;weight&quot;, double.class, Double.valueOf(1.0));</span>
<span class="fc" id="L819">					eWeight.set(e, Double.parseDouble(weight.get()));</span>
				}

<span class="fc" id="L822">				Optional&lt;Element&gt; attvaluesElm0 = XmlUtils.optionalChild(eElm, &quot;attvalues&quot;);</span>
<span class="fc bfc" id="L823" title="All 2 branches covered.">				if (attvaluesElm0.isPresent()) {</span>
<span class="fc" id="L824">					Element attvaluesElm = attvaluesElm0.get();</span>
<span class="fc bfc" id="L825" title="All 2 branches covered.">					for (Element attvalueElm : XmlUtils.children(attvaluesElm, &quot;attvalue&quot;)) {</span>
<span class="fc" id="L826">						String weightsId = XmlUtils.requiredAttribute(attvalueElm, &quot;for&quot;);</span>
<span class="fc" id="L827">						String value = XmlUtils.requiredAttribute(attvalueElm, &quot;value&quot;);</span>
<span class="fc" id="L828">						BiConsumer&lt;E, String&gt; setter = eWeights.get(weightsId);</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">						if (setter == null)</span>
<span class="fc" id="L830">							throw new IllegalArgumentException(&quot;unknown attribute id: &quot; + weightsId);</span>
<span class="fc" id="L831">						setter.accept(e, value);</span>
<span class="fc" id="L832">					}</span>
				}
<span class="fc" id="L834">			}</span>

<span class="fc" id="L836">			return g;</span>
<span class="fc" id="L837">		} catch (SAXException | ParserConfigurationException e) {</span>
<span class="fc" id="L838">			throw new IllegalArgumentException(e);</span>
		}
	}

	private Date parseDate(String s) {
		try {
<span class="fc" id="L844">			return dateFormat.parse(s);</span>
<span class="fc" id="L845">		} catch (ParseException e) {</span>
<span class="fc" id="L846">			throw new IllegalArgumentException(e);</span>
		}
	}

	private static URI parseURI(String s) {
		try {
<span class="fc" id="L852">			return new URI(s);</span>
<span class="fc" id="L853">		} catch (URISyntaxException e) {</span>
<span class="fc" id="L854">			throw new IllegalArgumentException(e);</span>
		}
	}

	private static byte[] parseListByte(String val) {
<span class="fc" id="L859">		String[] words = splitList(val);</span>
<span class="fc" id="L860">		byte[] list = new byte[words.length];</span>
<span class="fc bfc" id="L861" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L862">			list[i] = Byte.parseByte(words[i]);</span>
<span class="fc" id="L863">		return list;</span>
	}

	private static short[] parseListShort(String val) {
<span class="fc" id="L867">		String[] words = splitList(val);</span>
<span class="fc" id="L868">		short[] list = new short[words.length];</span>
<span class="fc bfc" id="L869" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L870">			list[i] = Short.parseShort(words[i]);</span>
<span class="fc" id="L871">		return list;</span>
	}

	private static int[] parseListInt(String val) {
<span class="fc" id="L875">		String[] words = splitList(val);</span>
<span class="fc" id="L876">		int[] list = new int[words.length];</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L878">			list[i] = Integer.parseInt(words[i]);</span>
<span class="fc" id="L879">		return list;</span>
	}

	private static long[] parseListLong(String val) {
<span class="fc" id="L883">		String[] words = splitList(val);</span>
<span class="fc" id="L884">		long[] list = new long[words.length];</span>
<span class="fc bfc" id="L885" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L886">			list[i] = Long.parseLong(words[i]);</span>
<span class="fc" id="L887">		return list;</span>
	}

	private static float[] parseListFloat(String val) {
<span class="fc" id="L891">		String[] words = splitList(val);</span>
<span class="fc" id="L892">		float[] list = new float[words.length];</span>
<span class="fc bfc" id="L893" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L894">			list[i] = Float.parseFloat(words[i]);</span>
<span class="fc" id="L895">		return list;</span>
	}

	private static double[] parseListDouble(String val) {
<span class="fc" id="L899">		String[] words = splitList(val);</span>
<span class="fc" id="L900">		double[] list = new double[words.length];</span>
<span class="fc bfc" id="L901" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L902">			list[i] = Double.parseDouble(words[i]);</span>
<span class="fc" id="L903">		return list;</span>
	}

	private static boolean[] parseListBool(String val) {
<span class="fc" id="L907">		String[] words = splitList(val);</span>
<span class="fc" id="L908">		boolean[] list = new boolean[words.length];</span>
<span class="fc bfc" id="L909" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L910">			list[i] = Boolean.parseBoolean(words[i]);</span>
<span class="fc" id="L911">		return list;</span>
	}

	private static char[] parseListChar(String val) {
<span class="fc" id="L915">		String[] words = splitList(val);</span>
<span class="fc" id="L916">		char[] list = new char[words.length];</span>
<span class="fc bfc" id="L917" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L918">			list[i] = GraphIoUtils.parseChar(words[i]);</span>
<span class="fc" id="L919">		return list;</span>
	}

	private static BigDecimal[] parseListBigDecimal(String val) {
<span class="fc" id="L923">		String[] words = splitList(val);</span>
<span class="fc" id="L924">		BigDecimal[] list = new BigDecimal[words.length];</span>
<span class="fc bfc" id="L925" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L926">			list[i] = new BigDecimal(words[i]);</span>
<span class="fc" id="L927">		return list;</span>
	}

	private static BigInteger[] parseListBigInteger(String val) {
<span class="fc" id="L931">		String[] words = splitList(val);</span>
<span class="fc" id="L932">		BigInteger[] list = new BigInteger[words.length];</span>
<span class="fc bfc" id="L933" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L934">			list[i] = new BigInteger(words[i]);</span>
<span class="fc" id="L935">		return list;</span>
	}

	private static URI[] parseListURI(String val) {
<span class="fc" id="L939">		String[] words = splitList(val);</span>
<span class="fc" id="L940">		URI[] list = new URI[words.length];</span>
<span class="fc bfc" id="L941" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L942">			list[i] = parseURI(words[i]);</span>
<span class="fc" id="L943">		return list;</span>
	}

	private Date[] parseListDate(String val) {
<span class="fc" id="L947">		String[] words = splitList(val);</span>
<span class="fc" id="L948">		Date[] list = new Date[words.length];</span>
<span class="fc bfc" id="L949" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L950">			list[i] = parseDate(words[i]);</span>
<span class="fc" id="L951">		return list;</span>
	}

	private static String[] splitList(String s) {
<span class="fc bfc" id="L955" title="All 4 branches covered.">		if (!s.startsWith(&quot;[&quot;) || !s.endsWith(&quot;]&quot;))</span>
<span class="fc" id="L956">			throw new IllegalArgumentException(&quot;list attribute must be of the form [val1, val2,...]&quot;);</span>
<span class="fc" id="L957">		s = s.substring(1, s.length() - 1);</span>
<span class="fc" id="L958">		String[] words = s.split(&quot;,&quot;);</span>
<span class="fc bfc" id="L959" title="All 2 branches covered.">		for (int i = 0; i &lt; words.length; i++)</span>
<span class="fc" id="L960">			words[i] = words[i].trim();</span>
<span class="fc" id="L961">		return words;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>