<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FormatDIMACS.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - IO</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.io</a> &gt; <span class="el_source">FormatDIMACS.java</span></div><h1>FormatDIMACS.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.io;

import static com.jgalgo.internal.util.Range.range;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.io.UncheckedIOException;
import java.io.Writer;
import java.util.List;
import com.jgalgo.graph.IWeightsInt;
import com.jgalgo.graph.IntGraph;
import com.jgalgo.graph.IntGraphBuilder;
import com.jgalgo.graph.IntGraphFactory;

class FormatDIMACS implements GraphFormat {

	private FormatDIMACS() {}

<span class="fc" id="L34">	static final FormatDIMACS Instance = new FormatDIMACS();</span>

	@Override
	public GraphWriter newWriter() {
<span class="fc" id="L38">		return new WriterImpl();</span>
	}

	@Override
	public GraphReader newReader() {
<span class="fc" id="L43">		return new ReaderImpl();</span>
	}

<span class="fc" id="L46">	private static final List&lt;String&gt; FILE_EXTENSIONS = List.of(&quot;col&quot;, &quot;gr&quot;);</span>

	@Override
	public List&lt;String&gt; getFileExtensions() {
<span class="nc" id="L50">		return FILE_EXTENSIONS;</span>
	}

	private static class WriterImpl implements GraphWriter {

		@Override
		public void writeGraph(IntGraph graph, Writer writer) {
<span class="fc bfc" id="L57" title="All 2 branches covered.">			if (graph.isDirected())</span>
<span class="fc" id="L58">				throw new IllegalArgumentException(&quot;the DIMACS format support undirected graphs only&quot;);</span>
<span class="fc" id="L59">			final int numVertices = graph.vertices().size();</span>
<span class="fc" id="L60">			final int numEdges = graph.edges().size();</span>
<span class="pc bpc" id="L61" title="1 of 2 branches missed.">			if (!range(1, numVertices + 1).equals(graph.vertices()))</span>
<span class="nc" id="L62">				throw new IllegalArgumentException(&quot;the DIMACS format support graphs with vertices 1..n only&quot;);</span>
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">			if (!range(1, numEdges + 1).equals(graph.edges()))</span>
<span class="nc" id="L64">				throw new IllegalArgumentException(&quot;the DIMACS format support graphs with edges 1..m only&quot;);</span>

			try {
<span class="fc" id="L67">				writer.append(&quot;c DIMACS written graph by JGAlgo&quot;).append(System.lineSeparator());</span>
<span class="fc" id="L68">				final IWeightsInt w = graph.getEdgesWeights(&quot;weightsEdges&quot;);</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">				final boolean hasWeights = w != null;</span>

<span class="fc bfc" id="L71" title="All 2 branches covered.">				if (hasWeights) {</span>
<span class="fc" id="L72">					writer.append(&quot;p sp &quot; + numVertices + &quot; &quot; + numEdges).append(System.lineSeparator());</span>
				} else {
<span class="fc" id="L74">					writer.append(&quot;p edge &quot; + numVertices + &quot; &quot; + numEdges).append(System.lineSeparator());</span>
				}

				// writes all edges, optional with weights
<span class="fc bfc" id="L78" title="All 2 branches covered.">				for (int e = 1; e &lt;= numEdges; e++) {</span>
					/* e {source} {target} */
<span class="fc" id="L80">					writer.append(&quot;e &quot;).append(Integer.toString(graph.edgeSource(e))).append(' ')</span>
<span class="fc" id="L81">							.append(Integer.toString(graph.edgeTarget(e)));</span>
					/* e {source} {target} {weight} */
<span class="fc bfc" id="L83" title="All 2 branches covered.">					if (hasWeights)</span>
<span class="fc" id="L84">						writer.append(' ').append(Integer.toString(w.get(e)));</span>
<span class="fc" id="L85">					writer.append(System.lineSeparator());</span>
				}
<span class="nc" id="L87">			} catch (IOException e) {</span>
<span class="nc" id="L88">				throw new UncheckedIOException(e);</span>
<span class="fc" id="L89">			}</span>
<span class="fc" id="L90">		}</span>

	}

	private static class ReaderImpl implements GraphReader {

		/**
		 * Support 2 DIMACS formats:&lt;br&gt;
		 * The &quot;DIMACS edge format&quot; and &quot;DIMACS sp format&quot;&lt;br&gt;
		 * &lt;br&gt;
		 * 1. Basic DIMACS format: &lt;br&gt;
		 * see https://github.com/akinanop/mvl-solver/wiki/DIMACS-Graph-Format
		 *
		 * &lt;pre&gt;
		 * p edge &amp;lt;NumVertices&amp;gt; &amp;lt;NumEdges&amp;gt;
		 * e &amp;lt;VertexName1&amp;gt; &amp;lt;VertexName2&amp;gt;
		 * Example:
		 * c this is the graph with vertices {1,2,3,4,5} and edges {(1,2),(2,3),(2,4),(3,4),(4,5)}
		 * p edge 5 5
		 * e 1 2
		 * e 2 3
		 * e 2 4
		 * e 3 4
		 * e 4 5
		 * &lt;/pre&gt;
		 *
		 * &lt;p&gt;
		 * 2. Shortest path format (with weights)&lt;br&gt;
		 * Two assumptions:&lt;br&gt;
		 * (1) Undirected graph.&lt;br&gt;
		 * (2) Weights are integers.&lt;br&gt;
		 * &lt;br&gt;
		 * The .gr files:&lt;br&gt;
		 * see http://www.diag.uniroma1.it/challenge9/format.shtml#graph
		 *
		 * &lt;pre&gt;
		 * c
		 * p sp n nm
		 * a u v w
		 * &lt;/pre&gt;
		 */
		@Override
		public IntGraphBuilder readIntoBuilder(Reader reader) {
			try (BufferedReader br =
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">					reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader)) {</span>
<span class="fc" id="L135">				IntGraphBuilder gb = IntGraphFactory.newUndirected().allowSelfEdges().newBuilder();</span>
<span class="fc" id="L136">				IWeightsInt w = null;</span>
<span class="fc" id="L137">				int verticesNum = -1;</span>
<span class="fc" id="L138">				int edgesNum = -1;</span>
<span class="fc" id="L139">				boolean hasWeights = false;</span>
<span class="fc" id="L140">				boolean problemLineSeen = false;</span>

<span class="fc bfc" id="L142" title="All 2 branches covered.">				for (String line; (line = br.readLine()) != null;) {</span>
<span class="fc" id="L143">					line = line.trim();</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">					if (line.isEmpty())</span>
<span class="nc" id="L145">						continue;</span>

					// replace multiple spaces with just one space
<span class="fc" id="L148">					line = line.replaceAll(&quot;\\s+&quot;, &quot; &quot;);</span>

<span class="fc" id="L150">					char firstChar = line.charAt(0);</span>
<span class="pc bpc" id="L151" title="1 of 4 branches missed.">					switch (firstChar) {</span>
						case 'c': /* comment line */
<span class="fc" id="L153">							continue;</span>

						case 'p': /* problem line */ {
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">							if (problemLineSeen)</span>
<span class="nc" id="L157">								throw new IllegalArgumentException(&quot;more than one problem line ('p' prefix) in file&quot;);</span>
<span class="fc" id="L158">							problemLineSeen = true;</span>

<span class="fc" id="L160">							String[] arr = line.split(&quot; &quot;);</span>
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">							if (arr.length != 4)</span>
<span class="nc" id="L162">								throw new IllegalArgumentException(</span>
										&quot;p lines must have 4 parameters: p edge &lt;NumVertices&gt; &lt;NumEdges&gt;&quot;
												+ &quot; or p sp &lt;NumVertices&gt; &lt;NumEdges&gt;&quot;);
<span class="fc" id="L165">							String graphFormat = arr[1].toLowerCase();</span>
<span class="pc bpc" id="L166" title="1 of 3 branches missed.">							switch (graphFormat) {</span>
								case &quot;edge&quot;:
<span class="fc" id="L168">									hasWeights = false;</span>
<span class="fc" id="L169">									break;</span>
								case &quot;sp&quot;:
<span class="fc" id="L171">									hasWeights = true;</span>
<span class="fc" id="L172">									break;</span>
								default:
<span class="nc" id="L174">									throw new IllegalArgumentException(&quot;support only: p edge &lt;NumVertices&gt; &lt;NumEdges&gt;&quot;</span>
											+ &quot; or p sp &lt;NumVertices&gt; &lt;NumEdges&gt;&quot;);
							}

							try {
<span class="fc" id="L179">								verticesNum = Integer.parseInt(arr[2]);</span>
<span class="fc" id="L180">								edgesNum = Integer.parseInt(arr[3]);</span>
<span class="nc" id="L181">							} catch (Exception e) {</span>
<span class="nc" id="L182">								throw new IllegalArgumentException(&quot;expect numbers: p edge &lt;NumVertices&gt; &lt;NumEdges&gt;&quot;</span>
										+ &quot; or p sp &lt;NumVertices&gt; &lt;NumEdges&gt;&quot;, e);
<span class="fc" id="L184">							}</span>

<span class="pc bpc" id="L186" title="2 of 4 branches missed.">							if (verticesNum &lt; 0 || edgesNum &lt; 0)</span>
<span class="nc" id="L187">								throw new IllegalArgumentException(</span>
										&quot;negative vertices/edges num: &quot; + verticesNum + &quot; &quot; + edgesNum);
<span class="fc" id="L189">							gb.expectedVerticesNum(verticesNum);</span>
<span class="fc" id="L190">							gb.expectedEdgesNum(edgesNum);</span>

<span class="fc bfc" id="L192" title="All 2 branches covered.">							if (graphFormat.equals(&quot;sp&quot;))</span>
<span class="fc" id="L193">								w = gb.addEdgesWeights(&quot;weightsEdges&quot;, int.class);</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">							for (int v = 1; v &lt;= verticesNum; v++)</span>
<span class="fc" id="L195">								gb.addVertex(v); // vertices are labeled as 1,2,3,4...</span>
<span class="fc" id="L196">							break;</span>
						}

						case 'e': /* edge line */ {
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">							if (!problemLineSeen)</span>
<span class="nc" id="L201">								throw new IllegalArgumentException(&quot;problem line ('p' prefix) was not seen yet&quot;);</span>

<span class="fc" id="L203">							String[] arr = line.split(&quot; &quot;);</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">							if (!hasWeights) {</span>
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">								if (arr.length != 3)</span>
<span class="nc" id="L206">									throw new IllegalArgumentException(</span>
											&quot;expect edge definition: e &lt;source_vertex&gt; &lt;destination_vertex&gt;&quot;);
							} else {
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">								if (arr.length != 4)</span>
<span class="nc" id="L210">									throw new IllegalArgumentException(</span>
											&quot;expect edge definition: e &lt;source_vertex&gt; &lt;destination_vertex&gt; &lt;weight&gt;&quot;);
							}

							/* parse edge source and target vertices */
<span class="fc" id="L215">							int vertexSource = -1;</span>
<span class="fc" id="L216">							int vertexTarget = -1;</span>
							try {
<span class="fc" id="L218">								vertexSource = Integer.parseInt(arr[1]);</span>
<span class="fc" id="L219">								vertexTarget = Integer.parseInt(arr[2]);</span>
<span class="nc" id="L220">							} catch (Exception e) {</span>
<span class="nc" id="L221">								throw new IllegalArgumentException(&quot;edge must have 2 vertices as numbers&quot;, e);</span>
<span class="fc" id="L222">							}</span>
<span class="pc bpc" id="L223" title="4 of 8 branches missed.">							if (vertexSource &lt; 1 || vertexSource &gt; verticesNum || vertexTarget &lt; 1</span>
									|| vertexTarget &gt; verticesNum)
<span class="nc" id="L225">								throw new IllegalArgumentException(&quot;vertex number must be between 1 and num_vertices&quot;);</span>
<span class="fc" id="L226">							final int e = gb.edges().size() + 1;</span>
<span class="fc" id="L227">							gb.addEdge(vertexSource, vertexTarget, e);</span>

							/* parse edge weight */
<span class="fc bfc" id="L230" title="All 2 branches covered.">							if (hasWeights) {</span>
<span class="fc" id="L231">								int edgeWeight = -1;</span>
								try {
<span class="fc" id="L233">									edgeWeight = Integer.parseInt(arr[3]);</span>
<span class="nc" id="L234">								} catch (Exception ex) {</span>
<span class="nc" id="L235">									throw new IllegalArgumentException(</span>
											&quot;edge must have 2 vertices as numbers and a weight&quot;, ex);
<span class="fc" id="L237">								}</span>
<span class="fc" id="L238">								w.set(e, edgeWeight);</span>
<span class="fc" id="L239">							}</span>
							break;
						}
						default:
<span class="nc" id="L243">							throw new IllegalArgumentException(&quot;unknown line: &quot; + line);</span>
					}
<span class="fc" id="L245">				}</span>
<span class="fc" id="L246">				return gb;</span>
<span class="nc" id="L247">			} catch (IOException e) {</span>
<span class="nc" id="L248">				throw new UncheckedIOException(e);</span>
			}
		}

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>