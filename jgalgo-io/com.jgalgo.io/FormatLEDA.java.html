<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FormatLEDA.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - IO</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.io</a> &gt; <span class="el_source">FormatLEDA.java</span></div><h1>FormatLEDA.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.io;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.io.UncheckedIOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import com.jgalgo.graph.Graph;
import com.jgalgo.graph.GraphBuilder;
import com.jgalgo.graph.Weights;
import com.jgalgo.graph.WeightsDouble;
import com.jgalgo.graph.WeightsFloat;
import com.jgalgo.graph.WeightsInt;
import com.jgalgo.graph.WeightsLong;
import com.jgalgo.graph.WeightsObj;
import com.jgalgo.graph.WeightsShort;

class FormatLEDA implements GraphFormat {

	private FormatLEDA() {}

<span class="fc" id="L43">	static final FormatLEDA Instance = new FormatLEDA();</span>

	@Override
	public GraphWriter newWriter() {
<span class="fc" id="L47">		return new WriterImpl();</span>
	}

	@Override
	public GraphReader newReader() {
<span class="fc" id="L52">		return new ReaderImpl();</span>
	}

<span class="fc" id="L55">	private static final List&lt;String&gt; FILE_EXTENSIONS = List.of(&quot;lgr&quot;);</span>

	@Override
	public List&lt;String&gt; getFileExtensions() {
<span class="nc" id="L59">		return FILE_EXTENSIONS;</span>
	}

	private static class WriterImpl implements GraphWriter {

		@Override
		public void writeGraph(Graph graph, Writer writer) {
<span class="fc" id="L66">			final int numVertices = graph.vertices().size();</span>
<span class="fc" id="L67">			final int numEdges = graph.edges().size();</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">			for (int v = 1; v &lt;= numVertices; v++)</span>
<span class="pc bpc" id="L69" title="1 of 2 branches missed.">				if (!graph.vertices().contains(v))</span>
<span class="nc" id="L70">					throw new IllegalArgumentException(&quot;the LEDA format support graphs with vertices 1..n only&quot;);</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">			for (int e = 1; e &lt;= numEdges; e++)</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">				if (!graph.edges().contains(e))</span>
<span class="nc" id="L73">					throw new IllegalArgumentException(&quot;the LEDA format support graphs with edges 1..m only&quot;);</span>

			try {
				String info_type_for_vertices; // can be void, string, int etc
				Weights&lt;?&gt; w_vertices; // weights for vertices
<span class="fc bfc" id="L78" title="All 2 branches covered.">				if (graph.getVerticesWeightsKeys().isEmpty()) {</span>
<span class="fc" id="L79">					info_type_for_vertices = &quot;void&quot;;</span>
<span class="fc" id="L80">					w_vertices = null;</span>
				} else {
					// for now, take the first weights collection
<span class="fc" id="L83">					String key = graph.getVerticesWeightsKeys().iterator().next();</span>
<span class="fc" id="L84">					w_vertices = graph.getVerticesWeights(key);</span>
<span class="pc bpc" id="L85" title="1 of 2 branches missed.">					if (w_vertices instanceof WeightsInt) {</span>
<span class="nc" id="L86">						info_type_for_vertices = &quot;int&quot;;</span>
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">					} else if (w_vertices instanceof WeightsShort) {</span>
<span class="nc" id="L88">						info_type_for_vertices = &quot;short&quot;;</span>
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">					} else if (w_vertices instanceof WeightsLong) {</span>
<span class="nc" id="L90">						info_type_for_vertices = &quot;long&quot;;</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">					} else if (w_vertices instanceof WeightsFloat) {</span>
<span class="nc" id="L92">						info_type_for_vertices = &quot;float&quot;;</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">					} else if (w_vertices instanceof WeightsDouble) {</span>
<span class="nc" id="L94">						info_type_for_vertices = &quot;double&quot;;</span>
					} else {
<span class="fc" id="L96">						info_type_for_vertices = &quot;string&quot;;</span>
					}
				}

				String info_type_for_edges; // can be void, string, int etc
				Weights&lt;?&gt; w_edges; // weights for edges
<span class="fc bfc" id="L102" title="All 2 branches covered.">				if (graph.getEdgesWeightsKeys().isEmpty()) {</span>
<span class="fc" id="L103">					info_type_for_edges = &quot;void&quot;;</span>
<span class="fc" id="L104">					w_edges = null;</span>
				} else {
					// for now, take the first weights collection
<span class="fc" id="L107">					String key = graph.getEdgesWeightsKeys().iterator().next();</span>
<span class="fc" id="L108">					w_edges = graph.getEdgesWeights(key);</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">					if (w_edges instanceof WeightsInt) {</span>
<span class="fc" id="L110">						info_type_for_edges = &quot;int&quot;;</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">					} else if (w_edges instanceof WeightsShort) {</span>
<span class="nc" id="L112">						info_type_for_edges = &quot;short&quot;;</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">					} else if (w_edges instanceof WeightsLong) {</span>
<span class="nc" id="L114">						info_type_for_edges = &quot;long&quot;;</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">					} else if (w_edges instanceof WeightsFloat) {</span>
<span class="nc" id="L116">						info_type_for_edges = &quot;float&quot;;</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">					} else if (w_edges instanceof WeightsDouble) {</span>
<span class="nc" id="L118">						info_type_for_edges = &quot;double&quot;;</span>
					} else {
<span class="nc" id="L120">						info_type_for_edges = &quot;string&quot;;</span>
					}
				}

<span class="fc" id="L124">				writer.append(&quot;LEDA.GRAPH&quot;).append(System.lineSeparator());</span>
<span class="fc" id="L125">				writer.append(info_type_for_vertices).append(System.lineSeparator()); // void/string/int etc</span>
<span class="fc" id="L126">				writer.append(info_type_for_edges).append(System.lineSeparator()); // void/string/int etc</span>
<span class="fc" id="L127">				final boolean is_directed = graph.isDirected();</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">				writer.append(is_directed ? &quot;-1&quot; : &quot;-2&quot;).append(System.lineSeparator());</span>

<span class="fc" id="L130">				writer.append(&quot;# section nodes/vertices&quot;).append(System.lineSeparator());</span>
<span class="fc" id="L131">				writer.append(Integer.toString(numVertices)).append(System.lineSeparator());</span>
				// write all vertices info
				// --&gt; LEDA expects 1..num_vertices
				// for (int ix = 1; ix &lt;= num_vertices; ix++)
				// but just in case, we are consistent with our labels etc
<span class="fc bfc" id="L136" title="All 2 branches covered.">				if (w_vertices == null) {</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">					for (int vertex = 1; vertex &lt;= numVertices; vertex++)</span>
<span class="fc" id="L138">						writer.append(&quot;|{}|&quot;).append(System.lineSeparator());</span>
				} else {
<span class="fc" id="L140">					WeightsStringer weightsStringer = WeightsStringer.newInstance(w_vertices);</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">					for (int vertex = 1; vertex &lt;= numVertices; vertex++) {</span>
<span class="fc" id="L142">						String weightStr = weightsStringer.getWeightAsString(vertex);</span>
<span class="fc" id="L143">						writer.append(&quot;|{&quot;).append(weightStr).append(&quot;}|&quot;).append(System.lineSeparator());</span>
					}
				}

<span class="fc" id="L147">				writer.append(&quot;# section edges&quot;).append(System.lineSeparator());</span>
<span class="fc" id="L148">				writer.append(Integer.toString(numEdges)).append(System.lineSeparator());</span>
				// write all edges info
<span class="fc bfc" id="L150" title="All 2 branches covered.">				WeightsStringer weightsStringer = w_edges != null ? WeightsStringer.newInstance(w_edges) : null;</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">				for (int edge = 1; edge &lt;= numEdges; edge++) {</span>
<span class="fc" id="L152">					int source_vertex = graph.edgeSource(edge);</span>
<span class="fc" id="L153">					int target_vertex = graph.edgeTarget(edge);</span>

<span class="fc" id="L155">					writer.append(Integer.toString(source_vertex)).append(' ');</span>
<span class="fc" id="L156">					writer.append(Integer.toString(target_vertex)).append(' ');</span>
<span class="fc" id="L157">					writer.append(/* twin edge */ '0').append(' ');</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">					if (weightsStringer == null) {</span>
<span class="fc" id="L159">						writer.append(&quot;|{}|&quot;).append(System.lineSeparator());</span>
					} else {
<span class="fc" id="L161">						String weightStr = weightsStringer.getWeightAsString(edge);</span>
<span class="fc" id="L162">						writer.append(&quot;|{&quot;).append(weightStr).append(&quot;}|&quot;).append(System.lineSeparator());</span>
					}
				}
<span class="nc" id="L165">			} catch (IOException e) {</span>
<span class="nc" id="L166">				throw new UncheckedIOException(e);</span>
<span class="fc" id="L167">			}</span>
<span class="fc" id="L168">		}</span>

	}

	private static class ReaderImpl implements GraphReader {

		@Override
		public GraphBuilder readIntoBuilder(Reader reader) {
<span class="fc" id="L176">			GraphBuilder builder = null;</span>

			// list_nodes keep the label/name of each node/vertex
			// we do not need it, but for future use
<span class="fc" id="L180">			ArrayList&lt;String&gt; list_nodes = new ArrayList&lt;&gt;();</span>

			// Pattern pattern_edge to regexp the edge line
			// Pattern.compile(&quot;^\\s*(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+\\{\\|(.*)\\|\\}\\s*$&quot;);
<span class="fc" id="L184">			Pattern pattern_edge = Pattern.compile(&quot;^\\s*(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\S\\S.*\\S\\S)\\s*$&quot;);</span>

			try (BufferedReader br =
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">					reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader)) {</span>
				// these are the oly weights format we support
<span class="fc" id="L189">				Set&lt;String&gt; hashSupportedTypes = new HashSet&lt;&gt;();</span>
<span class="fc" id="L190">				hashSupportedTypes.add(&quot;void&quot;);</span>
<span class="fc" id="L191">				hashSupportedTypes.add(&quot;int&quot;);</span>
<span class="fc" id="L192">				hashSupportedTypes.add(&quot;short&quot;);</span>
<span class="fc" id="L193">				hashSupportedTypes.add(&quot;long&quot;);</span>
<span class="fc" id="L194">				hashSupportedTypes.add(&quot;float&quot;);</span>
<span class="fc" id="L195">				hashSupportedTypes.add(&quot;double&quot;);</span>
<span class="fc" id="L196">				hashSupportedTypes.add(&quot;string&quot;);</span>
<span class="fc" id="L197">				int line_number = 0; // sequence of lines is important!</span>
<span class="fc" id="L198">				boolean in_section = false;</span>
<span class="fc" id="L199">				int num_secetion = 0; // 1 is nodes section, 2 is edges section</span>
<span class="fc" id="L200">				int section_num_elements = -1;</span>
				// section_ix_element will count from 1,2,3,4...,section_num_elements
<span class="fc" id="L202">				int section_ix_element = -1;</span>
<span class="fc" id="L203">				String info_type_for_vertices = null; // can be void,string, int etc</span>
<span class="fc" id="L204">				String info_type_for_edges = null; // can be void,string, int etc</span>
<span class="fc" id="L205">				Weights&lt;?&gt; w_info_type_for_vertices = null;</span>
<span class="fc" id="L206">				Weights&lt;?&gt; w_info_type_for_edges = null;</span>

				// read all lines from file
<span class="fc bfc" id="L209" title="All 2 branches covered.">				for (String line; (line = br.readLine()) != null;) {</span>
<span class="fc" id="L210">					line = line.trim();</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">					if (line.length() == 0)</span>
<span class="fc" id="L212">						continue; // skip empty lines</span>
					// # This is a comment line
<span class="fc bfc" id="L214" title="All 2 branches covered.">					if (line.toLowerCase().startsWith(&quot;#&quot;))</span>
<span class="fc" id="L215">						continue; // skip comment lines</span>
<span class="fc" id="L216">					line_number++;</span>

					// LEDA.GRAPH
<span class="fc bfc" id="L219" title="All 2 branches covered.">					if (line_number == 1) {</span>
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">						if (line.toUpperCase().startsWith(&quot;LEDA.GRAPH&quot;))</span>
<span class="fc" id="L221">							continue; // skip LEDA.GRAPH</span>
<span class="nc" id="L222">						throw new IllegalArgumentException(</span>
								&quot;Leda file format: first non-comment line must equals LEDA.GRAPH&quot;);
					}

<span class="fc bfc" id="L226" title="All 2 branches covered.">					if (line_number == 2) {</span>
<span class="fc" id="L227">						info_type_for_vertices = line.toLowerCase();</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">						if (!hashSupportedTypes.contains(info_type_for_vertices))</span>
<span class="nc" id="L229">							throw new IllegalArgumentException(</span>
									&quot;Leda file format: unsupported info/weight to vertices/nodes&quot;);
						continue; // skip 2nd - label string
					}

<span class="fc bfc" id="L234" title="All 2 branches covered.">					if (line_number == 3) {</span>
<span class="fc" id="L235">						info_type_for_edges = line.toLowerCase();</span>
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">						if (!hashSupportedTypes.contains(info_type_for_edges))</span>
<span class="nc" id="L237">							throw new IllegalArgumentException(&quot;Leda file format: unsupported info/weight to edges&quot;);</span>
						continue; // skip 3nd - label string
					}

<span class="fc bfc" id="L241" title="All 2 branches covered.">					if (line_number == 4) {</span>
						// The fourth line specifies if the graph is
						// either directed (-1)
						// or undirected (-2).
<span class="pc bpc" id="L245" title="1 of 3 branches missed.">						switch (line) {</span>
							case &quot;-1&quot;:
<span class="fc" id="L247">								builder = GraphBuilder.newDirected();</span>
<span class="fc" id="L248">								break;</span>
							case &quot;-2&quot;:
<span class="fc" id="L250">								builder = GraphBuilder.newUndirected();</span>
<span class="fc" id="L251">								break;</span>
							default:
<span class="nc" id="L253">								throw new IllegalArgumentException(</span>
										&quot;Leda file format: 4th non-comment line must equals -1 or -2. -1 is Directed graph. -2 is Undirected graph.&quot;);
						}

<span class="pc bpc" id="L257" title="5 of 7 branches missed.">						switch (info_type_for_vertices) {</span>
							case &quot;int&quot;:
<span class="nc" id="L259">								w_info_type_for_vertices = builder.addVerticesWeights(&quot;weightsKey&quot;, int.class);</span>
<span class="nc" id="L260">								break;</span>
							case &quot;short&quot;:
<span class="nc" id="L262">								w_info_type_for_vertices = builder.addVerticesWeights(&quot;weightsKey&quot;, short.class);</span>
<span class="nc" id="L263">								break;</span>
							case &quot;long&quot;:
<span class="nc" id="L265">								w_info_type_for_vertices = builder.addVerticesWeights(&quot;weightsKey&quot;, long.class);</span>
<span class="nc" id="L266">								break;</span>
							case &quot;float&quot;:
<span class="nc" id="L268">								w_info_type_for_vertices = builder.addVerticesWeights(&quot;weightsKey&quot;, float.class);</span>
<span class="nc" id="L269">								break;</span>
							case &quot;double&quot;:
<span class="nc" id="L271">								w_info_type_for_vertices = builder.addVerticesWeights(&quot;weightsKey&quot;, double.class);</span>
<span class="nc" id="L272">								break;</span>
							case &quot;void&quot;:
<span class="fc" id="L274">								break;</span>
							case &quot;string&quot;:
							default:
<span class="fc" id="L277">								w_info_type_for_vertices = builder.addVerticesWeights(&quot;weightsKey&quot;, String.class);</span>
								break;
						}

<span class="pc bpc" id="L281" title="5 of 7 branches missed.">						switch (info_type_for_edges) {</span>
							case &quot;int&quot;:
<span class="fc" id="L283">								w_info_type_for_edges = builder.addEdgesWeights(&quot;weightsKey&quot;, int.class);</span>
<span class="fc" id="L284">								break;</span>
							case &quot;short&quot;:
<span class="nc" id="L286">								w_info_type_for_edges = builder.addEdgesWeights(&quot;weightsKey&quot;, short.class);</span>
<span class="nc" id="L287">								break;</span>
							case &quot;long&quot;:
<span class="nc" id="L289">								w_info_type_for_edges = builder.addEdgesWeights(&quot;weightsKey&quot;, long.class);</span>
<span class="nc" id="L290">								break;</span>
							case &quot;float&quot;:
<span class="nc" id="L292">								w_info_type_for_edges = builder.addEdgesWeights(&quot;weightsKey&quot;, float.class);</span>
<span class="nc" id="L293">								break;</span>
							case &quot;double&quot;:
<span class="nc" id="L295">								w_info_type_for_edges = builder.addEdgesWeights(&quot;weightsKey&quot;, double.class);</span>
<span class="nc" id="L296">								break;</span>
							case &quot;void&quot;:
<span class="fc" id="L298">								break;</span>
							case &quot;string&quot;:
							default:
<span class="nc" id="L301">								w_info_type_for_edges = builder.addEdgesWeights(&quot;weightsKey&quot;, String.class);</span>
								break;
						}

<span class="fc" id="L305">						continue;</span>
					}

<span class="fc bfc" id="L308" title="All 2 branches covered.">					if (!in_section) {</span>
						// this line must be the number of elements in this section
<span class="fc" id="L310">						in_section = true;</span>
<span class="fc" id="L311">						num_secetion++; // 1=nodes/vertices, 2=edges</span>
<span class="fc" id="L312">						section_ix_element = 0;</span>
<span class="fc" id="L313">						section_num_elements = -1;</span>
						try {
<span class="fc" id="L315">							section_num_elements = Integer.parseInt(line);</span>
<span class="nc" id="L316">						} catch (Exception e) {</span>
<span class="nc" id="L317">							section_num_elements = -1;</span>
<span class="fc" id="L318">						}</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">						if (section_num_elements &lt; 0)</span>
<span class="nc" id="L320">							throw new IllegalArgumentException(</span>
									&quot;Leda file format: number of elements must be non-negative integers.&quot;);
						continue; // next
					}

					// we are inside a section
<span class="fc" id="L326">					section_ix_element++;</span>

					// is this the nodes section?
<span class="fc bfc" id="L329" title="All 2 branches covered.">					if (num_secetion == 1) {</span>
						// define node/vertex
						// |{v1}| --&gt; v1 is any label or name or identifier
						// |{}| --&gt; empty label or name or identifier
<span class="pc bpc" id="L333" title="2 of 4 branches missed.">						if (!line.startsWith(&quot;|{&quot;) || !line.endsWith(&quot;}|&quot;))</span>
<span class="nc" id="L334">							throw new IllegalArgumentException(</span>
									&quot;Leda file format: node/vertex error. must be |{any_name_label}| or |{}|.&quot;);
						// get the label
<span class="fc" id="L337">						String label = line.substring(2, line.length() - 2);</span>
						// debug
<span class="fc" id="L339">						list_nodes.add(label);</span>
<span class="fc" id="L340">						final int id = builder.vertices().size() + 1; // 1,2,3...</span>
<span class="fc" id="L341">						builder.addVertex(id);</span>

						// record label/weight
<span class="pc bpc" id="L344" title="5 of 7 branches missed.">						switch (info_type_for_vertices) {</span>
							case &quot;int&quot;:
								try {
<span class="nc" id="L347">									int val = Integer.parseInt(label);</span>
<span class="nc" id="L348">									((WeightsInt) w_info_type_for_vertices).set(id, val);</span>
<span class="nc" id="L349">								} catch (Exception e) {</span>
<span class="nc" id="L350">									throw new IllegalArgumentException(&quot;Leda file format: vertex must have int info.&quot;);</span>
<span class="nc" id="L351">								}</span>
								break;
							case &quot;short&quot;:
								try {
<span class="nc" id="L355">									short val = Short.parseShort(label);</span>
<span class="nc" id="L356">									((WeightsShort) w_info_type_for_vertices).set(id, val);</span>
<span class="nc" id="L357">								} catch (Exception e) {</span>
<span class="nc" id="L358">									throw new IllegalArgumentException(</span>
											&quot;Leda file format: vertex must have short info.&quot;);
<span class="nc" id="L360">								}</span>
								break;
							case &quot;long&quot;:
								try {
<span class="nc" id="L364">									long val = Long.parseLong(label);</span>
<span class="nc" id="L365">									((WeightsLong) w_info_type_for_vertices).set(id, val);</span>
<span class="nc" id="L366">								} catch (Exception e) {</span>
<span class="nc" id="L367">									throw new IllegalArgumentException(&quot;Leda file format: vertex must have long info.&quot;);</span>
<span class="nc" id="L368">								}</span>
								break;
							case &quot;float&quot;:
								try {
<span class="nc" id="L372">									float val = Float.parseFloat(label);</span>
<span class="nc" id="L373">									((WeightsFloat) w_info_type_for_vertices).set(id, val);</span>
<span class="nc" id="L374">								} catch (Exception e) {</span>
<span class="nc" id="L375">									throw new IllegalArgumentException(</span>
											&quot;Leda file format: vertex must have float info.&quot;);
<span class="nc" id="L377">								}</span>
								break;
							case &quot;double&quot;:
								try {
<span class="nc" id="L381">									double val = Double.parseDouble(label);</span>
<span class="nc" id="L382">									((WeightsDouble) w_info_type_for_vertices).set(id, val);</span>
<span class="nc" id="L383">								} catch (Exception e) {</span>
<span class="nc" id="L384">									throw new IllegalArgumentException(</span>
											&quot;Leda file format: vertex must have double info.&quot;);
<span class="nc" id="L386">								}</span>
								break;
							case &quot;void&quot;:
<span class="fc" id="L389">								break;</span>
							case &quot;string&quot;:
							default:
<span class="fc" id="L392">								((WeightsObj&lt;String&gt;) w_info_type_for_vertices).set(id, label);</span>
								break;
						}

<span class="fc bfc" id="L396" title="All 2 branches covered.">						if (section_ix_element == section_num_elements) {</span>
							// we ended the current section
<span class="fc" id="L398">							in_section = false;</span>
<span class="fc" id="L399">							section_ix_element = -1;</span>
<span class="fc" id="L400">							section_num_elements = -1;</span>
						}
						continue;
					}

<span class="pc bpc" id="L405" title="1 of 2 branches missed.">					if (num_secetion == 3)</span>
<span class="nc" id="L406">						throw new IllegalArgumentException(</span>
								&quot;Leda file format: too many parameers. 2nd section, the edges, is complete.&quot;);

					// if (num_secetion == 2)
					// define edges
					// edge definition consists of four space-separated parts:
					// ==&gt; the number of the source node
					// ==&gt; the number of the target node
					// ==&gt; the number of the reversal edge or 0, if no such edge is set
					// ==&gt; the information associated with the edge (cf. nodes section)

					// We use regexp to parse line
<span class="fc" id="L418">					final Matcher edge_matcher = pattern_edge.matcher(line);</span>
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">					if (!edge_matcher.find())</span>
<span class="nc" id="L420">						throw new IllegalArgumentException(&quot;Leda file format: invalid edge. must have 4 parts.&quot;);</span>

<span class="fc" id="L422">					int from_vertex = Integer.parseInt(edge_matcher.group(1));</span>
<span class="fc" id="L423">					int to_vertex = Integer.parseInt(edge_matcher.group(2));</span>
<span class="fc" id="L424">					int reversal_edge = Integer.parseInt(edge_matcher.group(3)); // not used right now</span>
<span class="fc" id="L425">					String label = edge_matcher.group(4);</span>

<span class="pc bpc" id="L427" title="2 of 4 branches missed.">					if (from_vertex &lt; 1 //</span>
							|| to_vertex &lt; 1 //
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">							|| from_vertex &gt; list_nodes.size() //</span>
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">							|| to_vertex &gt; list_nodes.size())</span>
<span class="nc" id="L431">						throw new IllegalArgumentException(</span>
								&quot;Leda file format: invalid edge. must be between 1 and num nodes/vertices.&quot;);

					// |{v1}| --&gt; v1 is any label or name or identifier
					// |{}| --&gt; empty label or name or identifier
<span class="pc bpc" id="L436" title="2 of 4 branches missed.">					if (!label.startsWith(&quot;|{&quot;) || !label.endsWith(&quot;}|&quot;))</span>
<span class="nc" id="L437">						throw new IllegalArgumentException(</span>
								&quot;Leda file format: invalid edge. inof/label must be starts with |{ and ends with }|.&quot;);
					// get the label
<span class="fc" id="L440">					label = label.substring(2, label.length() - 2);</span>

					// add the edge
<span class="fc" id="L443">					final int id = builder.edges().size() + 1; // 1,2,3...</span>
<span class="fc" id="L444">					builder.addEdge(from_vertex, to_vertex, id);</span>

					// record label/weight
<span class="pc bpc" id="L447" title="5 of 7 branches missed.">					switch (info_type_for_edges) {</span>
						case &quot;int&quot;:
							try {
<span class="fc" id="L450">								int val = Integer.parseInt(label);</span>
<span class="fc" id="L451">								((WeightsInt) w_info_type_for_edges).set(id, val);</span>
<span class="nc" id="L452">							} catch (Exception e) {</span>
<span class="nc" id="L453">								throw new IllegalArgumentException(&quot;Leda file format: edge must have int info.&quot;);</span>
<span class="fc" id="L454">							}</span>
							break;
						case &quot;short&quot;:
							try {
<span class="nc" id="L458">								short val = Short.parseShort(label);</span>
<span class="nc" id="L459">								((WeightsShort) w_info_type_for_edges).set(id, val);</span>
<span class="nc" id="L460">							} catch (Exception e) {</span>
<span class="nc" id="L461">								throw new IllegalArgumentException(&quot;Leda file format: edge must have short info.&quot;);</span>
<span class="nc" id="L462">							}</span>
							break;
						case &quot;long&quot;:
							try {
<span class="nc" id="L466">								long val = Long.parseLong(label);</span>
<span class="nc" id="L467">								((WeightsLong) w_info_type_for_edges).set(id, val);</span>
<span class="nc" id="L468">							} catch (Exception e) {</span>
<span class="nc" id="L469">								throw new IllegalArgumentException(&quot;Leda file format: edge must have long info.&quot;);</span>
<span class="nc" id="L470">							}</span>
							break;
						case &quot;float&quot;:
							try {
<span class="nc" id="L474">								float val = Float.parseFloat(label);</span>
<span class="nc" id="L475">								((WeightsFloat) w_info_type_for_edges).set(id, val);</span>
<span class="nc" id="L476">							} catch (Exception e) {</span>
<span class="nc" id="L477">								throw new IllegalArgumentException(&quot;Leda file format: edge must have float info.&quot;);</span>
<span class="nc" id="L478">							}</span>
							break;
						case &quot;double&quot;:
							try {
<span class="nc" id="L482">								double val = Double.parseDouble(label);</span>
<span class="nc" id="L483">								((WeightsDouble) w_info_type_for_edges).set(id, val);</span>
<span class="nc" id="L484">							} catch (Exception e) {</span>
<span class="nc" id="L485">								throw new IllegalArgumentException(&quot;Leda file format: edge must have double info.&quot;);</span>
<span class="nc" id="L486">							}</span>
							break;
						case &quot;void&quot;:
<span class="fc" id="L489">							break;</span>
						case &quot;string&quot;:
						default:
<span class="nc" id="L492">							((WeightsObj&lt;String&gt;) w_info_type_for_edges).set(id, label);</span>
							break;
					}

<span class="fc bfc" id="L496" title="All 2 branches covered.">					if (section_ix_element == section_num_elements) {</span>
						// we ended the current section
<span class="fc" id="L498">						in_section = false;</span>
<span class="fc" id="L499">						section_ix_element = -1;</span>
<span class="fc" id="L500">						section_num_elements = -1;</span>
					}
<span class="fc" id="L502">				}</span>
<span class="nc" id="L503">			} catch (IOException e) {</span>
<span class="nc" id="L504">				throw new UncheckedIOException(e);</span>
<span class="fc" id="L505">			}</span>

<span class="fc" id="L507">			return builder;</span>
		}

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>