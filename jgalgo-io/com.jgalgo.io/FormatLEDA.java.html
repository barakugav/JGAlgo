<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FormatLEDA.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - IO</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.io</a> &gt; <span class="el_source">FormatLEDA.java</span></div><h1>FormatLEDA.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.io;

import static com.jgalgo.internal.util.Range.range;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.io.UncheckedIOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import com.jgalgo.graph.IWeights;
import com.jgalgo.graph.IWeightsDouble;
import com.jgalgo.graph.IWeightsFloat;
import com.jgalgo.graph.IWeightsInt;
import com.jgalgo.graph.IWeightsLong;
import com.jgalgo.graph.IWeightsObj;
import com.jgalgo.graph.IWeightsShort;
import com.jgalgo.graph.IntGraph;
import com.jgalgo.graph.IntGraphBuilder;
import com.jgalgo.graph.IntGraphFactory;

class FormatLEDA implements GraphFormat {

	private FormatLEDA() {}

<span class="fc" id="L44">	static final FormatLEDA Instance = new FormatLEDA();</span>

	@Override
	public GraphWriter newWriter() {
<span class="fc" id="L48">		return new WriterImpl();</span>
	}

	@Override
	public GraphReader newReader() {
<span class="fc" id="L53">		return new ReaderImpl();</span>
	}

<span class="fc" id="L56">	private static final List&lt;String&gt; FILE_EXTENSIONS = List.of(&quot;lgr&quot;);</span>

	@Override
	public List&lt;String&gt; getFileExtensions() {
<span class="nc" id="L60">		return FILE_EXTENSIONS;</span>
	}

	private static class WriterImpl implements GraphWriter {

		@Override
		public void writeGraph(IntGraph graph, Writer writer) {
<span class="fc" id="L67">			final int numVertices = graph.vertices().size();</span>
<span class="fc" id="L68">			final int numEdges = graph.edges().size();</span>
<span class="pc bpc" id="L69" title="1 of 2 branches missed.">			if (!range(1, numVertices + 1).equals(graph.vertices()))</span>
<span class="nc" id="L70">				throw new IllegalArgumentException(&quot;the LEDA format support graphs with vertices 1..n only&quot;);</span>
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">			if (!range(1, numEdges + 1).equals(graph.edges()))</span>
<span class="nc" id="L72">				throw new IllegalArgumentException(&quot;the LEDA format support graphs with edges 1..m only&quot;);</span>

			try {
				String verticesWeightsType; // can be void, string, int etc
				IWeights&lt;?&gt; verticesWeights; // weights for vertices
<span class="fc bfc" id="L77" title="All 2 branches covered.">				if (graph.getVerticesWeightsKeys().isEmpty()) {</span>
<span class="fc" id="L78">					verticesWeightsType = &quot;void&quot;;</span>
<span class="fc" id="L79">					verticesWeights = null;</span>
				} else {
					// for now, take the first weights collection
<span class="fc" id="L82">					String key = graph.getVerticesWeightsKeys().iterator().next();</span>
<span class="fc" id="L83">					verticesWeights = graph.getVerticesIWeights(key);</span>
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">					if (verticesWeights instanceof IWeightsInt) {</span>
<span class="nc" id="L85">						verticesWeightsType = &quot;int&quot;;</span>
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">					} else if (verticesWeights instanceof IWeightsShort) {</span>
<span class="nc" id="L87">						verticesWeightsType = &quot;short&quot;;</span>
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">					} else if (verticesWeights instanceof IWeightsLong) {</span>
<span class="nc" id="L89">						verticesWeightsType = &quot;long&quot;;</span>
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">					} else if (verticesWeights instanceof IWeightsFloat) {</span>
<span class="nc" id="L91">						verticesWeightsType = &quot;float&quot;;</span>
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">					} else if (verticesWeights instanceof IWeightsDouble) {</span>
<span class="nc" id="L93">						verticesWeightsType = &quot;double&quot;;</span>
					} else {
<span class="fc" id="L95">						verticesWeightsType = &quot;string&quot;;</span>
					}
				}

				String edgesWeightsType; // can be void, string, int etc
				IWeights&lt;?&gt; edgesWeights; // weights for edges
<span class="fc bfc" id="L101" title="All 2 branches covered.">				if (graph.getEdgesWeightsKeys().isEmpty()) {</span>
<span class="fc" id="L102">					edgesWeightsType = &quot;void&quot;;</span>
<span class="fc" id="L103">					edgesWeights = null;</span>
				} else {
					// for now, take the first weights collection
<span class="fc" id="L106">					String key = graph.getEdgesWeightsKeys().iterator().next();</span>
<span class="fc" id="L107">					edgesWeights = graph.getEdgesIWeights(key);</span>
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">					if (edgesWeights instanceof IWeightsInt) {</span>
<span class="fc" id="L109">						edgesWeightsType = &quot;int&quot;;</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">					} else if (edgesWeights instanceof IWeightsShort) {</span>
<span class="nc" id="L111">						edgesWeightsType = &quot;short&quot;;</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">					} else if (edgesWeights instanceof IWeightsLong) {</span>
<span class="nc" id="L113">						edgesWeightsType = &quot;long&quot;;</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">					} else if (edgesWeights instanceof IWeightsFloat) {</span>
<span class="nc" id="L115">						edgesWeightsType = &quot;float&quot;;</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">					} else if (edgesWeights instanceof IWeightsDouble) {</span>
<span class="nc" id="L117">						edgesWeightsType = &quot;double&quot;;</span>
					} else {
<span class="nc" id="L119">						edgesWeightsType = &quot;string&quot;;</span>
					}
				}

<span class="fc" id="L123">				writer.append(&quot;LEDA.GRAPH&quot;).append(System.lineSeparator());</span>
<span class="fc" id="L124">				writer.append(verticesWeightsType).append(System.lineSeparator()); // void/string/int etc</span>
<span class="fc" id="L125">				writer.append(edgesWeightsType).append(System.lineSeparator()); // void/string/int etc</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">				writer.append(graph.isDirected() ? &quot;-1&quot; : &quot;-2&quot;).append(System.lineSeparator());</span>

<span class="fc" id="L128">				writer.append(&quot;# section nodes/vertices&quot;).append(System.lineSeparator());</span>
<span class="fc" id="L129">				writer.append(Integer.toString(numVertices)).append(System.lineSeparator());</span>
				// write all vertices info
				// --&gt; LEDA expects 1..numVertices
				// for (int ix = 1; ix &lt;= numVertices; ix++)
				// but just in case, we are consistent with our labels etc
<span class="fc bfc" id="L134" title="All 2 branches covered.">				if (verticesWeights == null) {</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">					for (int vertex = 1; vertex &lt;= numVertices; vertex++)</span>
<span class="fc" id="L136">						writer.append(&quot;|{}|&quot;).append(System.lineSeparator());</span>
				} else {
<span class="fc" id="L138">					WeightsStringifier weightsStringer = WeightsStringifier.newInstance(verticesWeights);</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">					for (int vertex = 1; vertex &lt;= numVertices; vertex++) {</span>
<span class="fc" id="L140">						String weightStr = weightsStringer.getWeightAsString(vertex);</span>
<span class="fc" id="L141">						writer.append(&quot;|{&quot;).append(weightStr).append(&quot;}|&quot;).append(System.lineSeparator());</span>
					}
				}

<span class="fc" id="L145">				writer.append(&quot;# section edges&quot;).append(System.lineSeparator());</span>
<span class="fc" id="L146">				writer.append(Integer.toString(numEdges)).append(System.lineSeparator());</span>
				// write all edges info
				WeightsStringifier weightsStringer =
<span class="fc bfc" id="L149" title="All 2 branches covered.">						edgesWeights != null ? WeightsStringifier.newInstance(edgesWeights) : null;</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">				for (int edge = 1; edge &lt;= numEdges; edge++) {</span>
<span class="fc" id="L151">					writer.append(Integer.toString(graph.edgeSource(edge))).append(' ');</span>
<span class="fc" id="L152">					writer.append(Integer.toString(graph.edgeTarget(edge))).append(' ');</span>
<span class="fc" id="L153">					writer.append(/* twin edge */ '0').append(' ');</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">					if (weightsStringer == null) {</span>
<span class="fc" id="L155">						writer.append(&quot;|{}|&quot;).append(System.lineSeparator());</span>
					} else {
<span class="fc" id="L157">						String weightStr = weightsStringer.getWeightAsString(edge);</span>
<span class="fc" id="L158">						writer.append(&quot;|{&quot;).append(weightStr).append(&quot;}|&quot;).append(System.lineSeparator());</span>
					}
				}
<span class="nc" id="L161">			} catch (IOException e) {</span>
<span class="nc" id="L162">				throw new UncheckedIOException(e);</span>
<span class="fc" id="L163">			}</span>
<span class="fc" id="L164">		}</span>

	}

	private static class ReaderImpl implements GraphReader {

		@Override
		public IntGraphBuilder readIntoBuilder(Reader reader) {
<span class="fc" id="L172">			IntGraphBuilder builder = null;</span>

			// nodes keep the label/name of each node/vertex
			// we do not need it, but for future use
<span class="fc" id="L176">			ArrayList&lt;String&gt; nodes = new ArrayList&lt;&gt;();</span>

			// Pattern edgePattern to regexp the edge line
			// Pattern.compile(&quot;^\\s*(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+\\{\\|(.*)\\|\\}\\s*$&quot;);
<span class="fc" id="L180">			Pattern edgePattern = Pattern.compile(&quot;^\\s*(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\S\\S.*\\S\\S)\\s*$&quot;);</span>

			try (BufferedReader br =
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">					reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader)) {</span>
				// these are the oly weights format we support
<span class="fc" id="L185">				Set&lt;String&gt; hashSupportedTypes = Set.of(&quot;void&quot;, &quot;int&quot;, &quot;short&quot;, &quot;long&quot;, &quot;float&quot;, &quot;double&quot;, &quot;string&quot;);</span>
<span class="fc" id="L186">				int lineNumber = 0; // sequence of lines is important!</span>
<span class="fc" id="L187">				boolean inSection = false;</span>
<span class="fc" id="L188">				int numberOfSections = 0; // 1 is nodes section, 2 is edges section</span>
<span class="fc" id="L189">				int sectionElementsNum = -1;</span>
				// elementIdxInSection will count from 1,2,3,4...,sectionElementsNum
<span class="fc" id="L191">				int elementIdxInSection = -1;</span>
<span class="fc" id="L192">				String verticesWeightsType = null; // can be void,string, int etc</span>
<span class="fc" id="L193">				String edgesWeightsType = null; // can be void,string, int etc</span>
<span class="fc" id="L194">				IWeights&lt;?&gt; verticesWeights = null;</span>
<span class="fc" id="L195">				IWeights&lt;?&gt; edgesWeights = null;</span>

				// read all lines from file
<span class="fc bfc" id="L198" title="All 2 branches covered.">				for (String line; (line = br.readLine()) != null;) {</span>
<span class="fc" id="L199">					line = line.trim();</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">					if (line.length() == 0)</span>
<span class="fc" id="L201">						continue; // skip empty lines</span>
					// # This is a comment line
<span class="fc bfc" id="L203" title="All 2 branches covered.">					if (line.toLowerCase().startsWith(&quot;#&quot;))</span>
<span class="fc" id="L204">						continue; // skip comment lines</span>
<span class="fc" id="L205">					lineNumber++;</span>

					// LEDA.GRAPH
<span class="fc bfc" id="L208" title="All 2 branches covered.">					if (lineNumber == 1) {</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">						if (line.toUpperCase().startsWith(&quot;LEDA.GRAPH&quot;))</span>
<span class="fc" id="L210">							continue; // skip LEDA.GRAPH</span>
<span class="nc" id="L211">						throw new IllegalArgumentException(</span>
								&quot;Leda file format: first non-comment line must equals LEDA.GRAPH&quot;);
					}

<span class="fc bfc" id="L215" title="All 2 branches covered.">					if (lineNumber == 2) {</span>
<span class="fc" id="L216">						verticesWeightsType = line.toLowerCase();</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">						if (!hashSupportedTypes.contains(verticesWeightsType))</span>
<span class="nc" id="L218">							throw new IllegalArgumentException(</span>
									&quot;Leda file format: unsupported info/weight to vertices/nodes&quot;);
						continue; // skip 2nd - label string
					}

<span class="fc bfc" id="L223" title="All 2 branches covered.">					if (lineNumber == 3) {</span>
<span class="fc" id="L224">						edgesWeightsType = line.toLowerCase();</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">						if (!hashSupportedTypes.contains(edgesWeightsType))</span>
<span class="nc" id="L226">							throw new IllegalArgumentException(&quot;Leda file format: unsupported info/weight to edges&quot;);</span>
						continue; // skip 3nd - label string
					}

<span class="fc bfc" id="L230" title="All 2 branches covered.">					if (lineNumber == 4) {</span>
						// The fourth line specifies if the graph is
						// either directed (-1)
						// or undirected (-2).
<span class="pc bpc" id="L234" title="1 of 3 branches missed.">						switch (line) {</span>
							case &quot;-1&quot;:
<span class="fc" id="L236">								builder = IntGraphFactory.newDirected().allowSelfEdges().newBuilder();</span>
<span class="fc" id="L237">								break;</span>
							case &quot;-2&quot;:
<span class="fc" id="L239">								builder = IntGraphFactory.newUndirected().allowSelfEdges().newBuilder();</span>
<span class="fc" id="L240">								break;</span>
							default:
<span class="nc" id="L242">								throw new IllegalArgumentException(</span>
										&quot;Leda file format: 4th non-comment line must equals -1 or -2. &quot;
												+ &quot;-1 is Directed graph. -2 is Undirected graph.&quot;);
						}

<span class="pc bpc" id="L247" title="5 of 7 branches missed.">						switch (verticesWeightsType) {</span>
							case &quot;int&quot;:
<span class="nc" id="L249">								verticesWeights = (IWeights&lt;?&gt;) builder.addVerticesWeights(&quot;weightsKey&quot;, int.class);</span>
<span class="nc" id="L250">								break;</span>
							case &quot;short&quot;:
<span class="nc" id="L252">								verticesWeights = (IWeights&lt;?&gt;) builder.addVerticesWeights(&quot;weightsKey&quot;, short.class);</span>
<span class="nc" id="L253">								break;</span>
							case &quot;long&quot;:
<span class="nc" id="L255">								verticesWeights = (IWeights&lt;?&gt;) builder.addVerticesWeights(&quot;weightsKey&quot;, long.class);</span>
<span class="nc" id="L256">								break;</span>
							case &quot;float&quot;:
<span class="nc" id="L258">								verticesWeights = (IWeights&lt;?&gt;) builder.addVerticesWeights(&quot;weightsKey&quot;, float.class);</span>
<span class="nc" id="L259">								break;</span>
							case &quot;double&quot;:
<span class="nc" id="L261">								verticesWeights = (IWeights&lt;?&gt;) builder.addVerticesWeights(&quot;weightsKey&quot;, double.class);</span>
<span class="nc" id="L262">								break;</span>
							case &quot;void&quot;:
<span class="fc" id="L264">								break;</span>
							case &quot;string&quot;:
							default:
<span class="fc" id="L267">								verticesWeights = (IWeights&lt;?&gt;) builder.addVerticesWeights(&quot;weightsKey&quot;, String.class);</span>
								break;
						}

<span class="pc bpc" id="L271" title="5 of 7 branches missed.">						switch (edgesWeightsType) {</span>
							case &quot;int&quot;:
<span class="fc" id="L273">								edgesWeights = (IWeights&lt;?&gt;) builder.addEdgesWeights(&quot;weightsKey&quot;, int.class);</span>
<span class="fc" id="L274">								break;</span>
							case &quot;short&quot;:
<span class="nc" id="L276">								edgesWeights = (IWeights&lt;?&gt;) builder.addEdgesWeights(&quot;weightsKey&quot;, short.class);</span>
<span class="nc" id="L277">								break;</span>
							case &quot;long&quot;:
<span class="nc" id="L279">								edgesWeights = (IWeights&lt;?&gt;) builder.addEdgesWeights(&quot;weightsKey&quot;, long.class);</span>
<span class="nc" id="L280">								break;</span>
							case &quot;float&quot;:
<span class="nc" id="L282">								edgesWeights = (IWeights&lt;?&gt;) builder.addEdgesWeights(&quot;weightsKey&quot;, float.class);</span>
<span class="nc" id="L283">								break;</span>
							case &quot;double&quot;:
<span class="nc" id="L285">								edgesWeights = (IWeights&lt;?&gt;) builder.addEdgesWeights(&quot;weightsKey&quot;, double.class);</span>
<span class="nc" id="L286">								break;</span>
							case &quot;void&quot;:
<span class="fc" id="L288">								break;</span>
							case &quot;string&quot;:
							default:
<span class="nc" id="L291">								edgesWeights = (IWeights&lt;?&gt;) builder.addEdgesWeights(&quot;weightsKey&quot;, String.class);</span>
								break;
						}

<span class="fc" id="L295">						continue;</span>
					}

<span class="fc bfc" id="L298" title="All 2 branches covered.">					if (!inSection) {</span>
						// this line must be the number of elements in this section
<span class="fc" id="L300">						inSection = true;</span>
<span class="fc" id="L301">						numberOfSections++; // 1=nodes/vertices, 2=edges</span>
<span class="fc" id="L302">						elementIdxInSection = 0;</span>
<span class="fc" id="L303">						sectionElementsNum = -1;</span>
						try {
<span class="fc" id="L305">							sectionElementsNum = Integer.parseInt(line);</span>
<span class="nc" id="L306">						} catch (Exception e) {</span>
<span class="nc" id="L307">							sectionElementsNum = -1;</span>
<span class="fc" id="L308">						}</span>
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">						if (sectionElementsNum &lt; 0)</span>
<span class="nc" id="L310">							throw new IllegalArgumentException(</span>
									&quot;Leda file format: number of elements must be non-negative integers.&quot;);
						continue; // next
					}

					// we are inside a section
<span class="fc" id="L316">					elementIdxInSection++;</span>

					// is this the nodes section?
<span class="fc bfc" id="L319" title="All 2 branches covered.">					if (numberOfSections == 1) {</span>
						// define node/vertex
						// |{v1}| --&gt; v1 is any label or name or identifier
						// |{}| --&gt; empty label or name or identifier
<span class="pc bpc" id="L323" title="2 of 4 branches missed.">						if (!line.startsWith(&quot;|{&quot;) || !line.endsWith(&quot;}|&quot;))</span>
<span class="nc" id="L324">							throw new IllegalArgumentException(</span>
									&quot;Leda file format: node/vertex error. must be |{any_name_label}| or |{}|.&quot;);
						// get the label
<span class="fc" id="L327">						String label = line.substring(2, line.length() - 2);</span>
						// debug
<span class="fc" id="L329">						nodes.add(label);</span>
<span class="fc" id="L330">						final int id = builder.vertices().size() + 1; // 1,2,3...</span>
<span class="fc" id="L331">						builder.addVertex(id);</span>

						// record label/weight
<span class="pc bpc" id="L334" title="5 of 7 branches missed.">						switch (verticesWeightsType) {</span>
							case &quot;int&quot;:
								try {
<span class="nc" id="L337">									int val = Integer.parseInt(label);</span>
<span class="nc" id="L338">									((IWeightsInt) verticesWeights).set(id, val);</span>
<span class="nc" id="L339">								} catch (Exception e) {</span>
<span class="nc" id="L340">									throw new IllegalArgumentException(&quot;Leda file format: vertex must have int info.&quot;);</span>
<span class="nc" id="L341">								}</span>
								break;
							case &quot;short&quot;:
								try {
<span class="nc" id="L345">									short val = Short.parseShort(label);</span>
<span class="nc" id="L346">									((IWeightsShort) verticesWeights).set(id, val);</span>
<span class="nc" id="L347">								} catch (Exception e) {</span>
<span class="nc" id="L348">									throw new IllegalArgumentException(</span>
											&quot;Leda file format: vertex must have short info.&quot;);
<span class="nc" id="L350">								}</span>
								break;
							case &quot;long&quot;:
								try {
<span class="nc" id="L354">									long val = Long.parseLong(label);</span>
<span class="nc" id="L355">									((IWeightsLong) verticesWeights).set(id, val);</span>
<span class="nc" id="L356">								} catch (Exception e) {</span>
<span class="nc" id="L357">									throw new IllegalArgumentException(&quot;Leda file format: vertex must have long info.&quot;);</span>
<span class="nc" id="L358">								}</span>
								break;
							case &quot;float&quot;:
								try {
<span class="nc" id="L362">									float val = Float.parseFloat(label);</span>
<span class="nc" id="L363">									((IWeightsFloat) verticesWeights).set(id, val);</span>
<span class="nc" id="L364">								} catch (Exception e) {</span>
<span class="nc" id="L365">									throw new IllegalArgumentException(</span>
											&quot;Leda file format: vertex must have float info.&quot;);
<span class="nc" id="L367">								}</span>
								break;
							case &quot;double&quot;:
								try {
<span class="nc" id="L371">									double val = Double.parseDouble(label);</span>
<span class="nc" id="L372">									((IWeightsDouble) verticesWeights).set(id, val);</span>
<span class="nc" id="L373">								} catch (Exception e) {</span>
<span class="nc" id="L374">									throw new IllegalArgumentException(</span>
											&quot;Leda file format: vertex must have double info.&quot;);
<span class="nc" id="L376">								}</span>
								break;
							case &quot;void&quot;:
<span class="fc" id="L379">								break;</span>
							case &quot;string&quot;:
							default:
								@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L383">								IWeightsObj&lt;String&gt; temp = (IWeightsObj&lt;String&gt;) verticesWeights;</span>
<span class="fc" id="L384">								temp.set(id, label);</span>
								break;
						}

<span class="fc bfc" id="L388" title="All 2 branches covered.">						if (elementIdxInSection == sectionElementsNum) {</span>
							// we ended the current section
<span class="fc" id="L390">							inSection = false;</span>
<span class="fc" id="L391">							elementIdxInSection = -1;</span>
<span class="fc" id="L392">							sectionElementsNum = -1;</span>
						}
						continue;
					}

<span class="pc bpc" id="L397" title="1 of 2 branches missed.">					if (numberOfSections == 3)</span>
<span class="nc" id="L398">						throw new IllegalArgumentException(</span>
								&quot;Leda file format: too many parameers. 2nd section, the edges, is complete.&quot;);

					// if (numberOfSections == 2)
					// define edges
					// edge definition consists of four space-separated parts:
					// ==&gt; the number of the source node
					// ==&gt; the number of the target node
					// ==&gt; the number of the reversal edge or 0, if no such edge is set
					// ==&gt; the information associated with the edge (cf. nodes section)

					// We use regexp to parse line
<span class="fc" id="L410">					final Matcher edgeMatcher = edgePattern.matcher(line);</span>
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">					if (!edgeMatcher.find())</span>
<span class="nc" id="L412">						throw new IllegalArgumentException(&quot;Leda file format: invalid edge. must have 4 parts.&quot;);</span>

<span class="fc" id="L414">					int fromVertex = Integer.parseInt(edgeMatcher.group(1));</span>
<span class="fc" id="L415">					int toVertex = Integer.parseInt(edgeMatcher.group(2));</span>
					// int reverseEdge = Integer.parseInt(edgeMatcher.group(3)); // not used right now
<span class="fc" id="L417">					String label = edgeMatcher.group(4);</span>

<span class="pc bpc" id="L419" title="2 of 4 branches missed.">					if (fromVertex &lt; 1 //</span>
							|| toVertex &lt; 1 //
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">							|| fromVertex &gt; nodes.size() //</span>
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">							|| toVertex &gt; nodes.size())</span>
<span class="nc" id="L423">						throw new IllegalArgumentException(</span>
								&quot;Leda file format: invalid edge. must be between 1 and num nodes/vertices.&quot;);

					// |{v1}| --&gt; v1 is any label or name or identifier
					// |{}| --&gt; empty label or name or identifier
<span class="pc bpc" id="L428" title="2 of 4 branches missed.">					if (!label.startsWith(&quot;|{&quot;) || !label.endsWith(&quot;}|&quot;))</span>
<span class="nc" id="L429">						throw new IllegalArgumentException(</span>
								&quot;Leda file format: invalid edge. inof/label must be starts with |{ and ends with }|.&quot;);
					// get the label
<span class="fc" id="L432">					label = label.substring(2, label.length() - 2);</span>

					// add the edge
<span class="fc" id="L435">					final int id = builder.edges().size() + 1; // 1,2,3...</span>
<span class="fc" id="L436">					builder.addEdge(fromVertex, toVertex, id);</span>

					// record label/weight
<span class="pc bpc" id="L439" title="5 of 7 branches missed.">					switch (edgesWeightsType) {</span>
						case &quot;int&quot;:
							try {
<span class="fc" id="L442">								int val = Integer.parseInt(label);</span>
<span class="fc" id="L443">								((IWeightsInt) edgesWeights).set(id, val);</span>
<span class="nc" id="L444">							} catch (Exception e) {</span>
<span class="nc" id="L445">								throw new IllegalArgumentException(&quot;Leda file format: edge must have int info.&quot;);</span>
<span class="fc" id="L446">							}</span>
							break;
						case &quot;short&quot;:
							try {
<span class="nc" id="L450">								short val = Short.parseShort(label);</span>
<span class="nc" id="L451">								((IWeightsShort) edgesWeights).set(id, val);</span>
<span class="nc" id="L452">							} catch (Exception e) {</span>
<span class="nc" id="L453">								throw new IllegalArgumentException(&quot;Leda file format: edge must have short info.&quot;);</span>
<span class="nc" id="L454">							}</span>
							break;
						case &quot;long&quot;:
							try {
<span class="nc" id="L458">								long val = Long.parseLong(label);</span>
<span class="nc" id="L459">								((IWeightsLong) edgesWeights).set(id, val);</span>
<span class="nc" id="L460">							} catch (Exception e) {</span>
<span class="nc" id="L461">								throw new IllegalArgumentException(&quot;Leda file format: edge must have long info.&quot;);</span>
<span class="nc" id="L462">							}</span>
							break;
						case &quot;float&quot;:
							try {
<span class="nc" id="L466">								float val = Float.parseFloat(label);</span>
<span class="nc" id="L467">								((IWeightsFloat) edgesWeights).set(id, val);</span>
<span class="nc" id="L468">							} catch (Exception e) {</span>
<span class="nc" id="L469">								throw new IllegalArgumentException(&quot;Leda file format: edge must have float info.&quot;);</span>
<span class="nc" id="L470">							}</span>
							break;
						case &quot;double&quot;:
							try {
<span class="nc" id="L474">								double val = Double.parseDouble(label);</span>
<span class="nc" id="L475">								((IWeightsDouble) edgesWeights).set(id, val);</span>
<span class="nc" id="L476">							} catch (Exception e) {</span>
<span class="nc" id="L477">								throw new IllegalArgumentException(&quot;Leda file format: edge must have double info.&quot;);</span>
<span class="nc" id="L478">							}</span>
							break;
						case &quot;void&quot;:
<span class="fc" id="L481">							break;</span>
						case &quot;string&quot;:
						default:
							@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L485">							IWeightsObj&lt;String&gt; temp = (IWeightsObj&lt;String&gt;) edgesWeights;</span>
<span class="nc" id="L486">							temp.set(id, label);</span>
							break;
					}

<span class="fc bfc" id="L490" title="All 2 branches covered.">					if (elementIdxInSection == sectionElementsNum) {</span>
						// we ended the current section
<span class="fc" id="L492">						inSection = false;</span>
<span class="fc" id="L493">						elementIdxInSection = -1;</span>
<span class="fc" id="L494">						sectionElementsNum = -1;</span>
					}
<span class="fc" id="L496">				}</span>
<span class="nc" id="L497">			} catch (IOException e) {</span>
<span class="nc" id="L498">				throw new UncheckedIOException(e);</span>
<span class="fc" id="L499">			}</span>

<span class="fc" id="L501">			return builder;</span>
		}

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>