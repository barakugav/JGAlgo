<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FormatLEDA.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - IO</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.io</a> &gt; <span class="el_source">FormatLEDA.java</span></div><h1>FormatLEDA.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.io;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.io.UncheckedIOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import com.jgalgo.graph.Graph;
import com.jgalgo.graph.GraphBuilder;
import com.jgalgo.graph.Weights;

class FormatLEDA implements GraphFormat {

	private FormatLEDA() {}

<span class="fc" id="L37">	static final FormatLEDA Instance = new FormatLEDA();</span>

	@Override
	public GraphWriter newWriter() {
<span class="fc" id="L41">		return new WriterImpl();</span>
	}

	@Override
	public GraphReader newReader() {
<span class="fc" id="L46">		return new ReaderImpl();</span>
	}

<span class="fc" id="L49">	private static final List&lt;String&gt; FILE_EXTENSIONS = List.of(&quot;lgr&quot;);</span>

	@Override
	public List&lt;String&gt; getFileExtensions() {
<span class="nc" id="L53">		return FILE_EXTENSIONS;</span>
	}

	private static class WriterImpl implements GraphWriter {

		@Override
		public void writeGraph(Graph graph, Writer writer) {
<span class="fc" id="L60">			final int numVertices = graph.vertices().size();</span>
<span class="fc" id="L61">			final int numEdges = graph.edges().size();</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">			for (int v = 1; v &lt;= numVertices; v++)</span>
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">				if (!graph.vertices().contains(v))</span>
<span class="nc" id="L64">					throw new IllegalArgumentException(&quot;the LEDA format support graphs with vertices 1..n only&quot;);</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">			for (int e = 1; e &lt;= numEdges; e++)</span>
<span class="pc bpc" id="L66" title="1 of 2 branches missed.">				if (!graph.edges().contains(e))</span>
<span class="nc" id="L67">					throw new IllegalArgumentException(&quot;the LEDA format support graphs with edges 1..m only&quot;);</span>

			try {
				String info_type_for_vertices; // can be void, string, int etc
				Weights&lt;?&gt; w_vertices; // weights for vertices
<span class="fc bfc" id="L72" title="All 2 branches covered.">				if (graph.getVerticesWeightsKeys().isEmpty()) {</span>
<span class="fc" id="L73">					info_type_for_vertices = &quot;void&quot;;</span>
<span class="fc" id="L74">					w_vertices = null;</span>
				} else {
					// for now, take the first weights collection
<span class="fc" id="L77">					Object key = graph.getVerticesWeightsKeys().iterator().next();</span>
<span class="fc" id="L78">					w_vertices = graph.getVerticesWeights(key);</span>
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">					if (w_vertices instanceof Weights.Int) {</span>
<span class="nc" id="L80">						info_type_for_vertices = &quot;int&quot;;</span>
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">					} else if (w_vertices instanceof Weights.Short) {</span>
<span class="nc" id="L82">						info_type_for_vertices = &quot;short&quot;;</span>
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">					} else if (w_vertices instanceof Weights.Long) {</span>
<span class="nc" id="L84">						info_type_for_vertices = &quot;long&quot;;</span>
<span class="pc bpc" id="L85" title="1 of 2 branches missed.">					} else if (w_vertices instanceof Weights.Float) {</span>
<span class="nc" id="L86">						info_type_for_vertices = &quot;float&quot;;</span>
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">					} else if (w_vertices instanceof Weights.Double) {</span>
<span class="nc" id="L88">						info_type_for_vertices = &quot;double&quot;;</span>
					} else {
<span class="fc" id="L90">						info_type_for_vertices = &quot;string&quot;;</span>
					}
				}

				String info_type_for_edges; // can be void, string, int etc
				Weights&lt;?&gt; w_edges; // weights for edges
<span class="fc bfc" id="L96" title="All 2 branches covered.">				if (graph.getEdgesWeightsKeys().isEmpty()) {</span>
<span class="fc" id="L97">					info_type_for_edges = &quot;void&quot;;</span>
<span class="fc" id="L98">					w_edges = null;</span>
				} else {
					// for now, take the first weights collection
<span class="fc" id="L101">					Object key = graph.getEdgesWeightsKeys().iterator().next();</span>
<span class="fc" id="L102">					w_edges = graph.getEdgesWeights(key);</span>
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">					if (w_edges instanceof Weights.Int) {</span>
<span class="fc" id="L104">						info_type_for_edges = &quot;int&quot;;</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">					} else if (w_edges instanceof Weights.Short) {</span>
<span class="nc" id="L106">						info_type_for_edges = &quot;short&quot;;</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">					} else if (w_edges instanceof Weights.Long) {</span>
<span class="nc" id="L108">						info_type_for_edges = &quot;long&quot;;</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">					} else if (w_edges instanceof Weights.Float) {</span>
<span class="nc" id="L110">						info_type_for_edges = &quot;float&quot;;</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">					} else if (w_edges instanceof Weights.Double) {</span>
<span class="nc" id="L112">						info_type_for_edges = &quot;double&quot;;</span>
					} else {
<span class="nc" id="L114">						info_type_for_edges = &quot;string&quot;;</span>
					}
				}

<span class="fc" id="L118">				writer.append(&quot;LEDA.GRAPH&quot;).append(System.lineSeparator());</span>
<span class="fc" id="L119">				writer.append(info_type_for_vertices).append(System.lineSeparator()); // void/string/int etc</span>
<span class="fc" id="L120">				writer.append(info_type_for_edges).append(System.lineSeparator()); // void/string/int etc</span>
<span class="fc" id="L121">				final boolean is_directed = graph.getCapabilities().directed();</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">				writer.append(is_directed ? &quot;-1&quot; : &quot;-2&quot;).append(System.lineSeparator());</span>

<span class="fc" id="L124">				writer.append(&quot;# section nodes/vertices&quot;).append(System.lineSeparator());</span>
<span class="fc" id="L125">				writer.append(Integer.toString(numVertices)).append(System.lineSeparator());</span>
				// write all vertices info
				// --&gt; LEDA expects 1..num_vertices
				// for (int ix = 1; ix &lt;= num_vertices; ix++)
				// but just in case, we are consistent with our labels etc
<span class="fc bfc" id="L130" title="All 2 branches covered.">				if (w_vertices == null) {</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">					for (int vertex = 1; vertex &lt;= numVertices; vertex++)</span>
<span class="fc" id="L132">						writer.append(&quot;|{}|&quot;).append(System.lineSeparator());</span>
				} else {
<span class="fc" id="L134">					WeightsStringer weightsStringer = WeightsStringer.newInstance(w_vertices);</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">					for (int vertex = 1; vertex &lt;= numVertices; vertex++) {</span>
<span class="fc" id="L136">						String weightStr = weightsStringer.getWeightAsString(vertex);</span>
<span class="fc" id="L137">						writer.append(&quot;|{&quot;).append(weightStr).append(&quot;}|&quot;).append(System.lineSeparator());</span>
					}
				}

<span class="fc" id="L141">				writer.append(&quot;# section edges&quot;).append(System.lineSeparator());</span>
<span class="fc" id="L142">				writer.append(Integer.toString(numEdges)).append(System.lineSeparator());</span>
				// write all edges info
<span class="fc bfc" id="L144" title="All 2 branches covered.">				WeightsStringer weightsStringer = w_edges != null ? WeightsStringer.newInstance(w_edges) : null;</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">				for (int edge = 1; edge &lt;= numEdges; edge++) {</span>
<span class="fc" id="L146">					int source_vertex = graph.edgeSource(edge);</span>
<span class="fc" id="L147">					int target_vertex = graph.edgeTarget(edge);</span>

<span class="fc" id="L149">					writer.append(Integer.toString(source_vertex)).append(' ');</span>
<span class="fc" id="L150">					writer.append(Integer.toString(target_vertex)).append(' ');</span>
<span class="fc" id="L151">					writer.append(/* twin edge */ '0').append(' ');</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">					if (weightsStringer == null) {</span>
<span class="fc" id="L153">						writer.append(&quot;|{}|&quot;).append(System.lineSeparator());</span>
					} else {
<span class="fc" id="L155">						String weightStr = weightsStringer.getWeightAsString(edge);</span>
<span class="fc" id="L156">						writer.append(&quot;|{&quot;).append(weightStr).append(&quot;}|&quot;).append(System.lineSeparator());</span>
					}
				}
<span class="nc" id="L159">			} catch (IOException e) {</span>
<span class="nc" id="L160">				throw new UncheckedIOException(e);</span>
<span class="fc" id="L161">			}</span>
<span class="fc" id="L162">		}</span>

	}

	private static class ReaderImpl implements GraphReader {

		@Override
		public GraphBuilder readIntoBuilder(Reader reader) {
<span class="fc" id="L170">			GraphBuilder builder = null;</span>

			// list_nodes keep the label/name of each node/vertex
			// we do not need it, but for future use
<span class="fc" id="L174">			ArrayList&lt;String&gt; list_nodes = new ArrayList&lt;&gt;();</span>

			// Pattern pattern_edge to regexp the edge line
			// Pattern.compile(&quot;^\\s*(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+\\{\\|(.*)\\|\\}\\s*$&quot;);
<span class="fc" id="L178">			Pattern pattern_edge = Pattern.compile(&quot;^\\s*(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\S\\S.*\\S\\S)\\s*$&quot;);</span>

			try (BufferedReader br =
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">					reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader)) {</span>
				// these are the oly weights format we support
<span class="fc" id="L183">				Set&lt;String&gt; hashSupportedTypes = new HashSet&lt;&gt;();</span>
<span class="fc" id="L184">				hashSupportedTypes.add(&quot;void&quot;);</span>
<span class="fc" id="L185">				hashSupportedTypes.add(&quot;int&quot;);</span>
<span class="fc" id="L186">				hashSupportedTypes.add(&quot;short&quot;);</span>
<span class="fc" id="L187">				hashSupportedTypes.add(&quot;long&quot;);</span>
<span class="fc" id="L188">				hashSupportedTypes.add(&quot;float&quot;);</span>
<span class="fc" id="L189">				hashSupportedTypes.add(&quot;double&quot;);</span>
<span class="fc" id="L190">				hashSupportedTypes.add(&quot;string&quot;);</span>
<span class="fc" id="L191">				int line_number = 0; // sequence of lines is important!</span>
<span class="fc" id="L192">				boolean in_section = false;</span>
<span class="fc" id="L193">				int num_secetion = 0; // 1 is nodes section, 2 is edges section</span>
<span class="fc" id="L194">				int section_num_elements = -1;</span>
				// section_ix_element will count from 1,2,3,4...,section_num_elements
<span class="fc" id="L196">				int section_ix_element = -1;</span>
<span class="fc" id="L197">				String info_type_for_vertices = null; // can be void,string, int etc</span>
<span class="fc" id="L198">				String info_type_for_edges = null; // can be void,string, int etc</span>
<span class="fc" id="L199">				Weights&lt;?&gt; w_info_type_for_vertices = null;</span>
<span class="fc" id="L200">				Weights&lt;?&gt; w_info_type_for_edges = null;</span>

				// read all lines from file
<span class="fc bfc" id="L203" title="All 2 branches covered.">				for (String line; (line = br.readLine()) != null;) {</span>
<span class="fc" id="L204">					line = line.trim();</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">					if (line.length() == 0)</span>
<span class="fc" id="L206">						continue; // skip empty lines</span>
					// # This is a comment line
<span class="fc bfc" id="L208" title="All 2 branches covered.">					if (line.toLowerCase().startsWith(&quot;#&quot;))</span>
<span class="fc" id="L209">						continue; // skip comment lines</span>
<span class="fc" id="L210">					line_number++;</span>

					// LEDA.GRAPH
<span class="fc bfc" id="L213" title="All 2 branches covered.">					if (line_number == 1) {</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">						if (line.toUpperCase().startsWith(&quot;LEDA.GRAPH&quot;))</span>
<span class="fc" id="L215">							continue; // skip LEDA.GRAPH</span>
<span class="nc" id="L216">						throw new IllegalArgumentException(</span>
								&quot;Leda file format: first non-comment line must equals LEDA.GRAPH&quot;);
					}

<span class="fc bfc" id="L220" title="All 2 branches covered.">					if (line_number == 2) {</span>
<span class="fc" id="L221">						info_type_for_vertices = line.toLowerCase();</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">						if (!hashSupportedTypes.contains(info_type_for_vertices))</span>
<span class="nc" id="L223">							throw new IllegalArgumentException(</span>
									&quot;Leda file format: unsupported info/weight to vertices/nodes&quot;);
						continue; // skip 2nd - label string
					}

<span class="fc bfc" id="L228" title="All 2 branches covered.">					if (line_number == 3) {</span>
<span class="fc" id="L229">						info_type_for_edges = line.toLowerCase();</span>
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">						if (!hashSupportedTypes.contains(info_type_for_edges))</span>
<span class="nc" id="L231">							throw new IllegalArgumentException(&quot;Leda file format: unsupported info/weight to edges&quot;);</span>
						continue; // skip 3nd - label string
					}

<span class="fc bfc" id="L235" title="All 2 branches covered.">					if (line_number == 4) {</span>
						// The fourth line specifies if the graph is
						// either directed (-1)
						// or undirected (-2).
<span class="pc bpc" id="L239" title="1 of 3 branches missed.">						switch (line) {</span>
							case &quot;-1&quot;:
<span class="fc" id="L241">								builder = GraphBuilder.newDirected();</span>
<span class="fc" id="L242">								break;</span>
							case &quot;-2&quot;:
<span class="fc" id="L244">								builder = GraphBuilder.newUndirected();</span>
<span class="fc" id="L245">								break;</span>
							default:
<span class="nc" id="L247">								throw new IllegalArgumentException(</span>
										&quot;Leda file format: 4th non-comment line must equals -1 or -2. -1 is Directed graph. -2 is Undirected graph.&quot;);
						}

<span class="pc bpc" id="L251" title="5 of 7 branches missed.">						switch (info_type_for_vertices) {</span>
							case &quot;int&quot;:
<span class="nc" id="L253">								w_info_type_for_vertices = builder.addVerticesWeights(&quot;weightsKey&quot;, int.class);</span>
<span class="nc" id="L254">								break;</span>
							case &quot;short&quot;:
<span class="nc" id="L256">								w_info_type_for_vertices = builder.addVerticesWeights(&quot;weightsKey&quot;, short.class);</span>
<span class="nc" id="L257">								break;</span>
							case &quot;long&quot;:
<span class="nc" id="L259">								w_info_type_for_vertices = builder.addVerticesWeights(&quot;weightsKey&quot;, long.class);</span>
<span class="nc" id="L260">								break;</span>
							case &quot;float&quot;:
<span class="nc" id="L262">								w_info_type_for_vertices = builder.addVerticesWeights(&quot;weightsKey&quot;, float.class);</span>
<span class="nc" id="L263">								break;</span>
							case &quot;double&quot;:
<span class="nc" id="L265">								w_info_type_for_vertices = builder.addVerticesWeights(&quot;weightsKey&quot;, double.class);</span>
<span class="nc" id="L266">								break;</span>
							case &quot;void&quot;:
<span class="fc" id="L268">								break;</span>
							case &quot;string&quot;:
							default:
<span class="fc" id="L271">								w_info_type_for_vertices = builder.addVerticesWeights(&quot;weightsKey&quot;, String.class);</span>
								break;
						}

<span class="pc bpc" id="L275" title="5 of 7 branches missed.">						switch (info_type_for_edges) {</span>
							case &quot;int&quot;:
<span class="fc" id="L277">								w_info_type_for_edges = builder.addEdgesWeights(&quot;weightsKey&quot;, int.class);</span>
<span class="fc" id="L278">								break;</span>
							case &quot;short&quot;:
<span class="nc" id="L280">								w_info_type_for_edges = builder.addEdgesWeights(&quot;weightsKey&quot;, short.class);</span>
<span class="nc" id="L281">								break;</span>
							case &quot;long&quot;:
<span class="nc" id="L283">								w_info_type_for_edges = builder.addEdgesWeights(&quot;weightsKey&quot;, long.class);</span>
<span class="nc" id="L284">								break;</span>
							case &quot;float&quot;:
<span class="nc" id="L286">								w_info_type_for_edges = builder.addEdgesWeights(&quot;weightsKey&quot;, float.class);</span>
<span class="nc" id="L287">								break;</span>
							case &quot;double&quot;:
<span class="nc" id="L289">								w_info_type_for_edges = builder.addEdgesWeights(&quot;weightsKey&quot;, double.class);</span>
<span class="nc" id="L290">								break;</span>
							case &quot;void&quot;:
<span class="fc" id="L292">								break;</span>
							case &quot;string&quot;:
							default:
<span class="nc" id="L295">								w_info_type_for_edges = builder.addEdgesWeights(&quot;weightsKey&quot;, String.class);</span>
								break;
						}

<span class="fc" id="L299">						continue;</span>
					}

<span class="fc bfc" id="L302" title="All 2 branches covered.">					if (!in_section) {</span>
						// this line must be the number of elements in this section
<span class="fc" id="L304">						in_section = true;</span>
<span class="fc" id="L305">						num_secetion++; // 1=nodes/vertices, 2=edges</span>
<span class="fc" id="L306">						section_ix_element = 0;</span>
<span class="fc" id="L307">						section_num_elements = -1;</span>
						try {
<span class="fc" id="L309">							section_num_elements = Integer.parseInt(line);</span>
<span class="nc" id="L310">						} catch (Exception e) {</span>
<span class="nc" id="L311">							section_num_elements = -1;</span>
<span class="fc" id="L312">						}</span>
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">						if (section_num_elements &lt; 0)</span>
<span class="nc" id="L314">							throw new IllegalArgumentException(</span>
									&quot;Leda file format: number of elements must be non-negative integers.&quot;);
						continue; // next
					}

					// we are inside a section
<span class="fc" id="L320">					section_ix_element++;</span>

					// is this the nodes section?
<span class="fc bfc" id="L323" title="All 2 branches covered.">					if (num_secetion == 1) {</span>
						// define node/vertex
						// |{v1}| --&gt; v1 is any label or name or identifier
						// |{}| --&gt; empty label or name or identifier
<span class="pc bpc" id="L327" title="2 of 4 branches missed.">						if (!line.startsWith(&quot;|{&quot;) || !line.endsWith(&quot;}|&quot;))</span>
<span class="nc" id="L328">							throw new IllegalArgumentException(</span>
									&quot;Leda file format: node/vertex error. must be |{any_name_label}| or |{}|.&quot;);
						// get the label
<span class="fc" id="L331">						String label = line.substring(2, line.length() - 2);</span>
						// debug
<span class="fc" id="L333">						list_nodes.add(label);</span>
<span class="fc" id="L334">						final int id = builder.vertices().size() + 1; // 1,2,3...</span>
<span class="fc" id="L335">						builder.addVertex(id);</span>

						// record label/weight
<span class="pc bpc" id="L338" title="5 of 7 branches missed.">						switch (info_type_for_vertices) {</span>
							case &quot;int&quot;:
								try {
<span class="nc" id="L341">									int val = Integer.parseInt(label);</span>
<span class="nc" id="L342">									((Weights.Int) w_info_type_for_vertices).set(id, val);</span>
<span class="nc" id="L343">								} catch (Exception e) {</span>
<span class="nc" id="L344">									throw new IllegalArgumentException(&quot;Leda file format: vertex must have int info.&quot;);</span>
<span class="nc" id="L345">								}</span>
								break;
							case &quot;short&quot;:
								try {
<span class="nc" id="L349">									short val = Short.parseShort(label);</span>
<span class="nc" id="L350">									((Weights.Short) w_info_type_for_vertices).set(id, val);</span>
<span class="nc" id="L351">								} catch (Exception e) {</span>
<span class="nc" id="L352">									throw new IllegalArgumentException(</span>
											&quot;Leda file format: vertex must have short info.&quot;);
<span class="nc" id="L354">								}</span>
								break;
							case &quot;long&quot;:
								try {
<span class="nc" id="L358">									long val = Long.parseLong(label);</span>
<span class="nc" id="L359">									((Weights.Long) w_info_type_for_vertices).set(id, val);</span>
<span class="nc" id="L360">								} catch (Exception e) {</span>
<span class="nc" id="L361">									throw new IllegalArgumentException(&quot;Leda file format: vertex must have long info.&quot;);</span>
<span class="nc" id="L362">								}</span>
								break;
							case &quot;float&quot;:
								try {
<span class="nc" id="L366">									float val = Float.parseFloat(label);</span>
<span class="nc" id="L367">									((Weights.Float) w_info_type_for_vertices).set(id, val);</span>
<span class="nc" id="L368">								} catch (Exception e) {</span>
<span class="nc" id="L369">									throw new IllegalArgumentException(</span>
											&quot;Leda file format: vertex must have float info.&quot;);
<span class="nc" id="L371">								}</span>
								break;
							case &quot;double&quot;:
								try {
<span class="nc" id="L375">									double val = Double.parseDouble(label);</span>
<span class="nc" id="L376">									((Weights.Double) w_info_type_for_vertices).set(id, val);</span>
<span class="nc" id="L377">								} catch (Exception e) {</span>
<span class="nc" id="L378">									throw new IllegalArgumentException(</span>
											&quot;Leda file format: vertex must have double info.&quot;);
<span class="nc" id="L380">								}</span>
								break;
							case &quot;void&quot;:
<span class="fc" id="L383">								break;</span>
							case &quot;string&quot;:
							default:
<span class="fc" id="L386">								((Weights&lt;String&gt;) w_info_type_for_vertices).set(id, label);</span>
								break;
						}

<span class="fc bfc" id="L390" title="All 2 branches covered.">						if (section_ix_element == section_num_elements) {</span>
							// we ended the current section
<span class="fc" id="L392">							in_section = false;</span>
<span class="fc" id="L393">							section_ix_element = -1;</span>
<span class="fc" id="L394">							section_num_elements = -1;</span>
						}
						continue;
					}

<span class="pc bpc" id="L399" title="1 of 2 branches missed.">					if (num_secetion == 3)</span>
<span class="nc" id="L400">						throw new IllegalArgumentException(</span>
								&quot;Leda file format: too many parameers. 2nd section, the edges, is complete.&quot;);

					// if (num_secetion == 2)
					// define edges
					// edge definition consists of four space-separated parts:
					// ==&gt; the number of the source node
					// ==&gt; the number of the target node
					// ==&gt; the number of the reversal edge or 0, if no such edge is set
					// ==&gt; the information associated with the edge (cf. nodes section)

					// We use regexp to parse line
<span class="fc" id="L412">					final Matcher edge_matcher = pattern_edge.matcher(line);</span>
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">					if (!edge_matcher.find())</span>
<span class="nc" id="L414">						throw new IllegalArgumentException(&quot;Leda file format: invalid edge. must have 4 parts.&quot;);</span>

<span class="fc" id="L416">					int from_vertex = Integer.parseInt(edge_matcher.group(1));</span>
<span class="fc" id="L417">					int to_vertex = Integer.parseInt(edge_matcher.group(2));</span>
<span class="fc" id="L418">					int reversal_edge = Integer.parseInt(edge_matcher.group(3)); // not used right now</span>
<span class="fc" id="L419">					String label = edge_matcher.group(4);</span>

<span class="pc bpc" id="L421" title="2 of 4 branches missed.">					if (from_vertex &lt; 1 //</span>
							|| to_vertex &lt; 1 //
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">							|| from_vertex &gt; list_nodes.size() //</span>
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">							|| to_vertex &gt; list_nodes.size())</span>
<span class="nc" id="L425">						throw new IllegalArgumentException(</span>
								&quot;Leda file format: invalid edge. must be between 1 and num nodes/vertices.&quot;);

					// |{v1}| --&gt; v1 is any label or name or identifier
					// |{}| --&gt; empty label or name or identifier
<span class="pc bpc" id="L430" title="2 of 4 branches missed.">					if (!label.startsWith(&quot;|{&quot;) || !label.endsWith(&quot;}|&quot;))</span>
<span class="nc" id="L431">						throw new IllegalArgumentException(</span>
								&quot;Leda file format: invalid edge. inof/label must be starts with |{ and ends with }|.&quot;);
					// get the label
<span class="fc" id="L434">					label = label.substring(2, label.length() - 2);</span>

					// add the edge
<span class="fc" id="L437">					final int id = builder.edges().size() + 1; // 1,2,3...</span>
<span class="fc" id="L438">					builder.addEdge(from_vertex, to_vertex, id);</span>

					// record label/weight
<span class="pc bpc" id="L441" title="5 of 7 branches missed.">					switch (info_type_for_edges) {</span>
						case &quot;int&quot;:
							try {
<span class="fc" id="L444">								int val = Integer.parseInt(label);</span>
<span class="fc" id="L445">								((Weights.Int) w_info_type_for_edges).set(id, val);</span>
<span class="nc" id="L446">							} catch (Exception e) {</span>
<span class="nc" id="L447">								throw new IllegalArgumentException(&quot;Leda file format: edge must have int info.&quot;);</span>
<span class="fc" id="L448">							}</span>
							break;
						case &quot;short&quot;:
							try {
<span class="nc" id="L452">								short val = Short.parseShort(label);</span>
<span class="nc" id="L453">								((Weights.Short) w_info_type_for_edges).set(id, val);</span>
<span class="nc" id="L454">							} catch (Exception e) {</span>
<span class="nc" id="L455">								throw new IllegalArgumentException(&quot;Leda file format: edge must have short info.&quot;);</span>
<span class="nc" id="L456">							}</span>
							break;
						case &quot;long&quot;:
							try {
<span class="nc" id="L460">								long val = Long.parseLong(label);</span>
<span class="nc" id="L461">								((Weights.Long) w_info_type_for_edges).set(id, val);</span>
<span class="nc" id="L462">							} catch (Exception e) {</span>
<span class="nc" id="L463">								throw new IllegalArgumentException(&quot;Leda file format: edge must have long info.&quot;);</span>
<span class="nc" id="L464">							}</span>
							break;
						case &quot;float&quot;:
							try {
<span class="nc" id="L468">								float val = Float.parseFloat(label);</span>
<span class="nc" id="L469">								((Weights.Float) w_info_type_for_edges).set(id, val);</span>
<span class="nc" id="L470">							} catch (Exception e) {</span>
<span class="nc" id="L471">								throw new IllegalArgumentException(&quot;Leda file format: edge must have float info.&quot;);</span>
<span class="nc" id="L472">							}</span>
							break;
						case &quot;double&quot;:
							try {
<span class="nc" id="L476">								double val = Double.parseDouble(label);</span>
<span class="nc" id="L477">								((Weights.Double) w_info_type_for_edges).set(id, val);</span>
<span class="nc" id="L478">							} catch (Exception e) {</span>
<span class="nc" id="L479">								throw new IllegalArgumentException(&quot;Leda file format: edge must have double info.&quot;);</span>
<span class="nc" id="L480">							}</span>
							break;
						case &quot;void&quot;:
<span class="fc" id="L483">							break;</span>
						case &quot;string&quot;:
						default:
<span class="nc" id="L486">							((Weights&lt;String&gt;) w_info_type_for_edges).set(id, label);</span>
							break;
					}

<span class="fc bfc" id="L490" title="All 2 branches covered.">					if (section_ix_element == section_num_elements) {</span>
						// we ended the current section
<span class="fc" id="L492">						in_section = false;</span>
<span class="fc" id="L493">						section_ix_element = -1;</span>
<span class="fc" id="L494">						section_num_elements = -1;</span>
					}
<span class="fc" id="L496">				}</span>
<span class="nc" id="L497">			} catch (IOException e) {</span>
<span class="nc" id="L498">				throw new UncheckedIOException(e);</span>
<span class="fc" id="L499">			}</span>

<span class="fc" id="L501">			return builder;</span>
		}

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>