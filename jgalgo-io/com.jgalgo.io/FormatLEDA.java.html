<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FormatLEDA.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - IO</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.io</a> &gt; <span class="el_source">FormatLEDA.java</span></div><h1>FormatLEDA.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.io;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.io.UncheckedIOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import com.jgalgo.graph.IWeights;
import com.jgalgo.graph.IWeightsDouble;
import com.jgalgo.graph.IWeightsFloat;
import com.jgalgo.graph.IWeightsInt;
import com.jgalgo.graph.IWeightsLong;
import com.jgalgo.graph.IWeightsObj;
import com.jgalgo.graph.IWeightsShort;
import com.jgalgo.graph.IntGraph;
import com.jgalgo.graph.IntGraphBuilder;
import com.jgalgo.internal.util.Range;

class FormatLEDA implements GraphFormat {

	private FormatLEDA() {}

<span class="fc" id="L43">	static final FormatLEDA Instance = new FormatLEDA();</span>

	@Override
	public GraphWriter newWriter() {
<span class="fc" id="L47">		return new WriterImpl();</span>
	}

	@Override
	public GraphReader newReader() {
<span class="fc" id="L52">		return new ReaderImpl();</span>
	}

<span class="fc" id="L55">	private static final List&lt;String&gt; FILE_EXTENSIONS = List.of(&quot;lgr&quot;);</span>

	@Override
	public List&lt;String&gt; getFileExtensions() {
<span class="nc" id="L59">		return FILE_EXTENSIONS;</span>
	}

	private static class WriterImpl implements GraphWriter {

		@Override
		public void writeGraph(IntGraph graph, Writer writer) {
<span class="fc" id="L66">			final int numVertices = graph.vertices().size();</span>
<span class="fc" id="L67">			final int numEdges = graph.edges().size();</span>
<span class="pc bpc" id="L68" title="1 of 2 branches missed.">			if (!Range.of(1, numVertices + 1).equals(graph.vertices()))</span>
<span class="nc" id="L69">				throw new IllegalArgumentException(&quot;the LEDA format support graphs with vertices 1..n only&quot;);</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">			if (!Range.of(1, numEdges + 1).equals(graph.edges()))</span>
<span class="nc" id="L71">				throw new IllegalArgumentException(&quot;the LEDA format support graphs with edges 1..m only&quot;);</span>

			try {
				String verticesWeightsType; // can be void, string, int etc
				IWeights&lt;?&gt; verticesWeights; // weights for vertices
<span class="fc bfc" id="L76" title="All 2 branches covered.">				if (graph.getVerticesWeightsKeys().isEmpty()) {</span>
<span class="fc" id="L77">					verticesWeightsType = &quot;void&quot;;</span>
<span class="fc" id="L78">					verticesWeights = null;</span>
				} else {
					// for now, take the first weights collection
<span class="fc" id="L81">					String key = graph.getVerticesWeightsKeys().iterator().next();</span>
<span class="fc" id="L82">					verticesWeights = graph.getVerticesIWeights(key);</span>
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">					if (verticesWeights instanceof IWeightsInt) {</span>
<span class="nc" id="L84">						verticesWeightsType = &quot;int&quot;;</span>
<span class="pc bpc" id="L85" title="1 of 2 branches missed.">					} else if (verticesWeights instanceof IWeightsShort) {</span>
<span class="nc" id="L86">						verticesWeightsType = &quot;short&quot;;</span>
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">					} else if (verticesWeights instanceof IWeightsLong) {</span>
<span class="nc" id="L88">						verticesWeightsType = &quot;long&quot;;</span>
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">					} else if (verticesWeights instanceof IWeightsFloat) {</span>
<span class="nc" id="L90">						verticesWeightsType = &quot;float&quot;;</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">					} else if (verticesWeights instanceof IWeightsDouble) {</span>
<span class="nc" id="L92">						verticesWeightsType = &quot;double&quot;;</span>
					} else {
<span class="fc" id="L94">						verticesWeightsType = &quot;string&quot;;</span>
					}
				}

				String edgesWeightsType; // can be void, string, int etc
				IWeights&lt;?&gt; edgesWeights; // weights for edges
<span class="fc bfc" id="L100" title="All 2 branches covered.">				if (graph.getEdgesWeightsKeys().isEmpty()) {</span>
<span class="fc" id="L101">					edgesWeightsType = &quot;void&quot;;</span>
<span class="fc" id="L102">					edgesWeights = null;</span>
				} else {
					// for now, take the first weights collection
<span class="fc" id="L105">					String key = graph.getEdgesWeightsKeys().iterator().next();</span>
<span class="fc" id="L106">					edgesWeights = graph.getEdgesIWeights(key);</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">					if (edgesWeights instanceof IWeightsInt) {</span>
<span class="fc" id="L108">						edgesWeightsType = &quot;int&quot;;</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">					} else if (edgesWeights instanceof IWeightsShort) {</span>
<span class="nc" id="L110">						edgesWeightsType = &quot;short&quot;;</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">					} else if (edgesWeights instanceof IWeightsLong) {</span>
<span class="nc" id="L112">						edgesWeightsType = &quot;long&quot;;</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">					} else if (edgesWeights instanceof IWeightsFloat) {</span>
<span class="nc" id="L114">						edgesWeightsType = &quot;float&quot;;</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">					} else if (edgesWeights instanceof IWeightsDouble) {</span>
<span class="nc" id="L116">						edgesWeightsType = &quot;double&quot;;</span>
					} else {
<span class="nc" id="L118">						edgesWeightsType = &quot;string&quot;;</span>
					}
				}

<span class="fc" id="L122">				writer.append(&quot;LEDA.GRAPH&quot;).append(System.lineSeparator());</span>
<span class="fc" id="L123">				writer.append(verticesWeightsType).append(System.lineSeparator()); // void/string/int etc</span>
<span class="fc" id="L124">				writer.append(edgesWeightsType).append(System.lineSeparator()); // void/string/int etc</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">				writer.append(graph.isDirected() ? &quot;-1&quot; : &quot;-2&quot;).append(System.lineSeparator());</span>

<span class="fc" id="L127">				writer.append(&quot;# section nodes/vertices&quot;).append(System.lineSeparator());</span>
<span class="fc" id="L128">				writer.append(Integer.toString(numVertices)).append(System.lineSeparator());</span>
				// write all vertices info
				// --&gt; LEDA expects 1..numVertices
				// for (int ix = 1; ix &lt;= numVertices; ix++)
				// but just in case, we are consistent with our labels etc
<span class="fc bfc" id="L133" title="All 2 branches covered.">				if (verticesWeights == null) {</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">					for (int vertex = 1; vertex &lt;= numVertices; vertex++)</span>
<span class="fc" id="L135">						writer.append(&quot;|{}|&quot;).append(System.lineSeparator());</span>
				} else {
<span class="fc" id="L137">					WeightsStringifier weightsStringer = WeightsStringifier.newInstance(verticesWeights);</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">					for (int vertex = 1; vertex &lt;= numVertices; vertex++) {</span>
<span class="fc" id="L139">						String weightStr = weightsStringer.getWeightAsString(vertex);</span>
<span class="fc" id="L140">						writer.append(&quot;|{&quot;).append(weightStr).append(&quot;}|&quot;).append(System.lineSeparator());</span>
					}
				}

<span class="fc" id="L144">				writer.append(&quot;# section edges&quot;).append(System.lineSeparator());</span>
<span class="fc" id="L145">				writer.append(Integer.toString(numEdges)).append(System.lineSeparator());</span>
				// write all edges info
				WeightsStringifier weightsStringer =
<span class="fc bfc" id="L148" title="All 2 branches covered.">						edgesWeights != null ? WeightsStringifier.newInstance(edgesWeights) : null;</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">				for (int edge = 1; edge &lt;= numEdges; edge++) {</span>
<span class="fc" id="L150">					writer.append(Integer.toString(graph.edgeSource(edge))).append(' ');</span>
<span class="fc" id="L151">					writer.append(Integer.toString(graph.edgeTarget(edge))).append(' ');</span>
<span class="fc" id="L152">					writer.append(/* twin edge */ '0').append(' ');</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">					if (weightsStringer == null) {</span>
<span class="fc" id="L154">						writer.append(&quot;|{}|&quot;).append(System.lineSeparator());</span>
					} else {
<span class="fc" id="L156">						String weightStr = weightsStringer.getWeightAsString(edge);</span>
<span class="fc" id="L157">						writer.append(&quot;|{&quot;).append(weightStr).append(&quot;}|&quot;).append(System.lineSeparator());</span>
					}
				}
<span class="nc" id="L160">			} catch (IOException e) {</span>
<span class="nc" id="L161">				throw new UncheckedIOException(e);</span>
<span class="fc" id="L162">			}</span>
<span class="fc" id="L163">		}</span>

	}

	private static class ReaderImpl implements GraphReader {

		@Override
		public IntGraphBuilder readIntoBuilder(Reader reader) {
<span class="fc" id="L171">			IntGraphBuilder builder = null;</span>

			// nodes keep the label/name of each node/vertex
			// we do not need it, but for future use
<span class="fc" id="L175">			ArrayList&lt;String&gt; nodes = new ArrayList&lt;&gt;();</span>

			// Pattern edgePattern to regexp the edge line
			// Pattern.compile(&quot;^\\s*(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+\\{\\|(.*)\\|\\}\\s*$&quot;);
<span class="fc" id="L179">			Pattern edgePattern = Pattern.compile(&quot;^\\s*(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\S\\S.*\\S\\S)\\s*$&quot;);</span>

			try (BufferedReader br =
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">					reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader)) {</span>
				// these are the oly weights format we support
<span class="fc" id="L184">				Set&lt;String&gt; hashSupportedTypes = Set.of(&quot;void&quot;, &quot;int&quot;, &quot;short&quot;, &quot;long&quot;, &quot;float&quot;, &quot;double&quot;, &quot;string&quot;);</span>
<span class="fc" id="L185">				int lineNumber = 0; // sequence of lines is important!</span>
<span class="fc" id="L186">				boolean inSection = false;</span>
<span class="fc" id="L187">				int numberOfSections = 0; // 1 is nodes section, 2 is edges section</span>
<span class="fc" id="L188">				int sectionElementsNum = -1;</span>
				// elementIdxInSection will count from 1,2,3,4...,sectionElementsNum
<span class="fc" id="L190">				int elementIdxInSection = -1;</span>
<span class="fc" id="L191">				String verticesWeightsType = null; // can be void,string, int etc</span>
<span class="fc" id="L192">				String edgesWeightsType = null; // can be void,string, int etc</span>
<span class="fc" id="L193">				IWeights&lt;?&gt; verticesWeights = null;</span>
<span class="fc" id="L194">				IWeights&lt;?&gt; edgesWeights = null;</span>

				// read all lines from file
<span class="fc bfc" id="L197" title="All 2 branches covered.">				for (String line; (line = br.readLine()) != null;) {</span>
<span class="fc" id="L198">					line = line.trim();</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">					if (line.length() == 0)</span>
<span class="fc" id="L200">						continue; // skip empty lines</span>
					// # This is a comment line
<span class="fc bfc" id="L202" title="All 2 branches covered.">					if (line.toLowerCase().startsWith(&quot;#&quot;))</span>
<span class="fc" id="L203">						continue; // skip comment lines</span>
<span class="fc" id="L204">					lineNumber++;</span>

					// LEDA.GRAPH
<span class="fc bfc" id="L207" title="All 2 branches covered.">					if (lineNumber == 1) {</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">						if (line.toUpperCase().startsWith(&quot;LEDA.GRAPH&quot;))</span>
<span class="fc" id="L209">							continue; // skip LEDA.GRAPH</span>
<span class="nc" id="L210">						throw new IllegalArgumentException(</span>
								&quot;Leda file format: first non-comment line must equals LEDA.GRAPH&quot;);
					}

<span class="fc bfc" id="L214" title="All 2 branches covered.">					if (lineNumber == 2) {</span>
<span class="fc" id="L215">						verticesWeightsType = line.toLowerCase();</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">						if (!hashSupportedTypes.contains(verticesWeightsType))</span>
<span class="nc" id="L217">							throw new IllegalArgumentException(</span>
									&quot;Leda file format: unsupported info/weight to vertices/nodes&quot;);
						continue; // skip 2nd - label string
					}

<span class="fc bfc" id="L222" title="All 2 branches covered.">					if (lineNumber == 3) {</span>
<span class="fc" id="L223">						edgesWeightsType = line.toLowerCase();</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">						if (!hashSupportedTypes.contains(edgesWeightsType))</span>
<span class="nc" id="L225">							throw new IllegalArgumentException(&quot;Leda file format: unsupported info/weight to edges&quot;);</span>
						continue; // skip 3nd - label string
					}

<span class="fc bfc" id="L229" title="All 2 branches covered.">					if (lineNumber == 4) {</span>
						// The fourth line specifies if the graph is
						// either directed (-1)
						// or undirected (-2).
<span class="pc bpc" id="L233" title="1 of 3 branches missed.">						switch (line) {</span>
							case &quot;-1&quot;:
<span class="fc" id="L235">								builder = IntGraphBuilder.newDirected();</span>
<span class="fc" id="L236">								break;</span>
							case &quot;-2&quot;:
<span class="fc" id="L238">								builder = IntGraphBuilder.newUndirected();</span>
<span class="fc" id="L239">								break;</span>
							default:
<span class="nc" id="L241">								throw new IllegalArgumentException(</span>
										&quot;Leda file format: 4th non-comment line must equals -1 or -2. &quot;
												+ &quot;-1 is Directed graph. -2 is Undirected graph.&quot;);
						}

<span class="pc bpc" id="L246" title="5 of 7 branches missed.">						switch (verticesWeightsType) {</span>
							case &quot;int&quot;:
<span class="nc" id="L248">								verticesWeights = (IWeights&lt;?&gt;) builder.addVerticesWeights(&quot;weightsKey&quot;, int.class);</span>
<span class="nc" id="L249">								break;</span>
							case &quot;short&quot;:
<span class="nc" id="L251">								verticesWeights = (IWeights&lt;?&gt;) builder.addVerticesWeights(&quot;weightsKey&quot;, short.class);</span>
<span class="nc" id="L252">								break;</span>
							case &quot;long&quot;:
<span class="nc" id="L254">								verticesWeights = (IWeights&lt;?&gt;) builder.addVerticesWeights(&quot;weightsKey&quot;, long.class);</span>
<span class="nc" id="L255">								break;</span>
							case &quot;float&quot;:
<span class="nc" id="L257">								verticesWeights = (IWeights&lt;?&gt;) builder.addVerticesWeights(&quot;weightsKey&quot;, float.class);</span>
<span class="nc" id="L258">								break;</span>
							case &quot;double&quot;:
<span class="nc" id="L260">								verticesWeights = (IWeights&lt;?&gt;) builder.addVerticesWeights(&quot;weightsKey&quot;, double.class);</span>
<span class="nc" id="L261">								break;</span>
							case &quot;void&quot;:
<span class="fc" id="L263">								break;</span>
							case &quot;string&quot;:
							default:
<span class="fc" id="L266">								verticesWeights = (IWeights&lt;?&gt;) builder.addVerticesWeights(&quot;weightsKey&quot;, String.class);</span>
								break;
						}

<span class="pc bpc" id="L270" title="5 of 7 branches missed.">						switch (edgesWeightsType) {</span>
							case &quot;int&quot;:
<span class="fc" id="L272">								edgesWeights = (IWeights&lt;?&gt;) builder.addEdgesWeights(&quot;weightsKey&quot;, int.class);</span>
<span class="fc" id="L273">								break;</span>
							case &quot;short&quot;:
<span class="nc" id="L275">								edgesWeights = (IWeights&lt;?&gt;) builder.addEdgesWeights(&quot;weightsKey&quot;, short.class);</span>
<span class="nc" id="L276">								break;</span>
							case &quot;long&quot;:
<span class="nc" id="L278">								edgesWeights = (IWeights&lt;?&gt;) builder.addEdgesWeights(&quot;weightsKey&quot;, long.class);</span>
<span class="nc" id="L279">								break;</span>
							case &quot;float&quot;:
<span class="nc" id="L281">								edgesWeights = (IWeights&lt;?&gt;) builder.addEdgesWeights(&quot;weightsKey&quot;, float.class);</span>
<span class="nc" id="L282">								break;</span>
							case &quot;double&quot;:
<span class="nc" id="L284">								edgesWeights = (IWeights&lt;?&gt;) builder.addEdgesWeights(&quot;weightsKey&quot;, double.class);</span>
<span class="nc" id="L285">								break;</span>
							case &quot;void&quot;:
<span class="fc" id="L287">								break;</span>
							case &quot;string&quot;:
							default:
<span class="nc" id="L290">								edgesWeights = (IWeights&lt;?&gt;) builder.addEdgesWeights(&quot;weightsKey&quot;, String.class);</span>
								break;
						}

<span class="fc" id="L294">						continue;</span>
					}

<span class="fc bfc" id="L297" title="All 2 branches covered.">					if (!inSection) {</span>
						// this line must be the number of elements in this section
<span class="fc" id="L299">						inSection = true;</span>
<span class="fc" id="L300">						numberOfSections++; // 1=nodes/vertices, 2=edges</span>
<span class="fc" id="L301">						elementIdxInSection = 0;</span>
<span class="fc" id="L302">						sectionElementsNum = -1;</span>
						try {
<span class="fc" id="L304">							sectionElementsNum = Integer.parseInt(line);</span>
<span class="nc" id="L305">						} catch (Exception e) {</span>
<span class="nc" id="L306">							sectionElementsNum = -1;</span>
<span class="fc" id="L307">						}</span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">						if (sectionElementsNum &lt; 0)</span>
<span class="nc" id="L309">							throw new IllegalArgumentException(</span>
									&quot;Leda file format: number of elements must be non-negative integers.&quot;);
						continue; // next
					}

					// we are inside a section
<span class="fc" id="L315">					elementIdxInSection++;</span>

					// is this the nodes section?
<span class="fc bfc" id="L318" title="All 2 branches covered.">					if (numberOfSections == 1) {</span>
						// define node/vertex
						// |{v1}| --&gt; v1 is any label or name or identifier
						// |{}| --&gt; empty label or name or identifier
<span class="pc bpc" id="L322" title="2 of 4 branches missed.">						if (!line.startsWith(&quot;|{&quot;) || !line.endsWith(&quot;}|&quot;))</span>
<span class="nc" id="L323">							throw new IllegalArgumentException(</span>
									&quot;Leda file format: node/vertex error. must be |{any_name_label}| or |{}|.&quot;);
						// get the label
<span class="fc" id="L326">						String label = line.substring(2, line.length() - 2);</span>
						// debug
<span class="fc" id="L328">						nodes.add(label);</span>
<span class="fc" id="L329">						final int id = builder.vertices().size() + 1; // 1,2,3...</span>
<span class="fc" id="L330">						builder.addVertex(id);</span>

						// record label/weight
<span class="pc bpc" id="L333" title="5 of 7 branches missed.">						switch (verticesWeightsType) {</span>
							case &quot;int&quot;:
								try {
<span class="nc" id="L336">									int val = Integer.parseInt(label);</span>
<span class="nc" id="L337">									((IWeightsInt) verticesWeights).set(id, val);</span>
<span class="nc" id="L338">								} catch (Exception e) {</span>
<span class="nc" id="L339">									throw new IllegalArgumentException(&quot;Leda file format: vertex must have int info.&quot;);</span>
<span class="nc" id="L340">								}</span>
								break;
							case &quot;short&quot;:
								try {
<span class="nc" id="L344">									short val = Short.parseShort(label);</span>
<span class="nc" id="L345">									((IWeightsShort) verticesWeights).set(id, val);</span>
<span class="nc" id="L346">								} catch (Exception e) {</span>
<span class="nc" id="L347">									throw new IllegalArgumentException(</span>
											&quot;Leda file format: vertex must have short info.&quot;);
<span class="nc" id="L349">								}</span>
								break;
							case &quot;long&quot;:
								try {
<span class="nc" id="L353">									long val = Long.parseLong(label);</span>
<span class="nc" id="L354">									((IWeightsLong) verticesWeights).set(id, val);</span>
<span class="nc" id="L355">								} catch (Exception e) {</span>
<span class="nc" id="L356">									throw new IllegalArgumentException(&quot;Leda file format: vertex must have long info.&quot;);</span>
<span class="nc" id="L357">								}</span>
								break;
							case &quot;float&quot;:
								try {
<span class="nc" id="L361">									float val = Float.parseFloat(label);</span>
<span class="nc" id="L362">									((IWeightsFloat) verticesWeights).set(id, val);</span>
<span class="nc" id="L363">								} catch (Exception e) {</span>
<span class="nc" id="L364">									throw new IllegalArgumentException(</span>
											&quot;Leda file format: vertex must have float info.&quot;);
<span class="nc" id="L366">								}</span>
								break;
							case &quot;double&quot;:
								try {
<span class="nc" id="L370">									double val = Double.parseDouble(label);</span>
<span class="nc" id="L371">									((IWeightsDouble) verticesWeights).set(id, val);</span>
<span class="nc" id="L372">								} catch (Exception e) {</span>
<span class="nc" id="L373">									throw new IllegalArgumentException(</span>
											&quot;Leda file format: vertex must have double info.&quot;);
<span class="nc" id="L375">								}</span>
								break;
							case &quot;void&quot;:
<span class="fc" id="L378">								break;</span>
							case &quot;string&quot;:
							default:
								@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L382">								IWeightsObj&lt;String&gt; temp = (IWeightsObj&lt;String&gt;) verticesWeights;</span>
<span class="fc" id="L383">								temp.set(id, label);</span>
								break;
						}

<span class="fc bfc" id="L387" title="All 2 branches covered.">						if (elementIdxInSection == sectionElementsNum) {</span>
							// we ended the current section
<span class="fc" id="L389">							inSection = false;</span>
<span class="fc" id="L390">							elementIdxInSection = -1;</span>
<span class="fc" id="L391">							sectionElementsNum = -1;</span>
						}
						continue;
					}

<span class="pc bpc" id="L396" title="1 of 2 branches missed.">					if (numberOfSections == 3)</span>
<span class="nc" id="L397">						throw new IllegalArgumentException(</span>
								&quot;Leda file format: too many parameers. 2nd section, the edges, is complete.&quot;);

					// if (numberOfSections == 2)
					// define edges
					// edge definition consists of four space-separated parts:
					// ==&gt; the number of the source node
					// ==&gt; the number of the target node
					// ==&gt; the number of the reversal edge or 0, if no such edge is set
					// ==&gt; the information associated with the edge (cf. nodes section)

					// We use regexp to parse line
<span class="fc" id="L409">					final Matcher edgeMatcher = edgePattern.matcher(line);</span>
<span class="pc bpc" id="L410" title="1 of 2 branches missed.">					if (!edgeMatcher.find())</span>
<span class="nc" id="L411">						throw new IllegalArgumentException(&quot;Leda file format: invalid edge. must have 4 parts.&quot;);</span>

<span class="fc" id="L413">					int fromVertex = Integer.parseInt(edgeMatcher.group(1));</span>
<span class="fc" id="L414">					int toVertex = Integer.parseInt(edgeMatcher.group(2));</span>
					// int reverseEdge = Integer.parseInt(edgeMatcher.group(3)); // not used right now
<span class="fc" id="L416">					String label = edgeMatcher.group(4);</span>

<span class="pc bpc" id="L418" title="2 of 4 branches missed.">					if (fromVertex &lt; 1 //</span>
							|| toVertex &lt; 1 //
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">							|| fromVertex &gt; nodes.size() //</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">							|| toVertex &gt; nodes.size())</span>
<span class="nc" id="L422">						throw new IllegalArgumentException(</span>
								&quot;Leda file format: invalid edge. must be between 1 and num nodes/vertices.&quot;);

					// |{v1}| --&gt; v1 is any label or name or identifier
					// |{}| --&gt; empty label or name or identifier
<span class="pc bpc" id="L427" title="2 of 4 branches missed.">					if (!label.startsWith(&quot;|{&quot;) || !label.endsWith(&quot;}|&quot;))</span>
<span class="nc" id="L428">						throw new IllegalArgumentException(</span>
								&quot;Leda file format: invalid edge. inof/label must be starts with |{ and ends with }|.&quot;);
					// get the label
<span class="fc" id="L431">					label = label.substring(2, label.length() - 2);</span>

					// add the edge
<span class="fc" id="L434">					final int id = builder.edges().size() + 1; // 1,2,3...</span>
<span class="fc" id="L435">					builder.addEdge(fromVertex, toVertex, id);</span>

					// record label/weight
<span class="pc bpc" id="L438" title="5 of 7 branches missed.">					switch (edgesWeightsType) {</span>
						case &quot;int&quot;:
							try {
<span class="fc" id="L441">								int val = Integer.parseInt(label);</span>
<span class="fc" id="L442">								((IWeightsInt) edgesWeights).set(id, val);</span>
<span class="nc" id="L443">							} catch (Exception e) {</span>
<span class="nc" id="L444">								throw new IllegalArgumentException(&quot;Leda file format: edge must have int info.&quot;);</span>
<span class="fc" id="L445">							}</span>
							break;
						case &quot;short&quot;:
							try {
<span class="nc" id="L449">								short val = Short.parseShort(label);</span>
<span class="nc" id="L450">								((IWeightsShort) edgesWeights).set(id, val);</span>
<span class="nc" id="L451">							} catch (Exception e) {</span>
<span class="nc" id="L452">								throw new IllegalArgumentException(&quot;Leda file format: edge must have short info.&quot;);</span>
<span class="nc" id="L453">							}</span>
							break;
						case &quot;long&quot;:
							try {
<span class="nc" id="L457">								long val = Long.parseLong(label);</span>
<span class="nc" id="L458">								((IWeightsLong) edgesWeights).set(id, val);</span>
<span class="nc" id="L459">							} catch (Exception e) {</span>
<span class="nc" id="L460">								throw new IllegalArgumentException(&quot;Leda file format: edge must have long info.&quot;);</span>
<span class="nc" id="L461">							}</span>
							break;
						case &quot;float&quot;:
							try {
<span class="nc" id="L465">								float val = Float.parseFloat(label);</span>
<span class="nc" id="L466">								((IWeightsFloat) edgesWeights).set(id, val);</span>
<span class="nc" id="L467">							} catch (Exception e) {</span>
<span class="nc" id="L468">								throw new IllegalArgumentException(&quot;Leda file format: edge must have float info.&quot;);</span>
<span class="nc" id="L469">							}</span>
							break;
						case &quot;double&quot;:
							try {
<span class="nc" id="L473">								double val = Double.parseDouble(label);</span>
<span class="nc" id="L474">								((IWeightsDouble) edgesWeights).set(id, val);</span>
<span class="nc" id="L475">							} catch (Exception e) {</span>
<span class="nc" id="L476">								throw new IllegalArgumentException(&quot;Leda file format: edge must have double info.&quot;);</span>
<span class="nc" id="L477">							}</span>
							break;
						case &quot;void&quot;:
<span class="fc" id="L480">							break;</span>
						case &quot;string&quot;:
						default:
							@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L484">							IWeightsObj&lt;String&gt; temp = (IWeightsObj&lt;String&gt;) edgesWeights;</span>
<span class="nc" id="L485">							temp.set(id, label);</span>
							break;
					}

<span class="fc bfc" id="L489" title="All 2 branches covered.">					if (elementIdxInSection == sectionElementsNum) {</span>
						// we ended the current section
<span class="fc" id="L491">						inSection = false;</span>
<span class="fc" id="L492">						elementIdxInSection = -1;</span>
<span class="fc" id="L493">						sectionElementsNum = -1;</span>
					}
<span class="fc" id="L495">				}</span>
<span class="nc" id="L496">			} catch (IOException e) {</span>
<span class="nc" id="L497">				throw new UncheckedIOException(e);</span>
<span class="fc" id="L498">			}</span>

<span class="fc" id="L500">			return builder;</span>
		}

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>