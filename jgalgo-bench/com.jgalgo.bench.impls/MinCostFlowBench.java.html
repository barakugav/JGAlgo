<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MinCostFlowBench.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Benchmarks</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.bench.impls</a> &gt; <span class="el_source">MinCostFlowBench.java</span></div><h1>MinCostFlowBench.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.bench.impls;

import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Fork;
import org.openjdk.jmh.annotations.Level;
import org.openjdk.jmh.annotations.Measurement;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Param;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.annotations.Warmup;
import org.openjdk.jmh.infra.Blackhole;
import com.jgalgo.alg.IFlowNetworkInt;
import com.jgalgo.alg.MinimumCostFlow;
import com.jgalgo.bench.util.BenchUtils;
import com.jgalgo.bench.util.GraphsTestUtils;
import com.jgalgo.bench.util.TestUtils.SeedGenerator;
import com.jgalgo.graph.IntGraph;
import com.jgalgo.graph.IWeightFunctionInt;
import com.jgalgo.graph.IWeights;
import com.jgalgo.graph.IWeightsInt;
import com.jgalgo.internal.util.Assertions;
import it.unimi.dsi.fastutil.Pair;
import it.unimi.dsi.fastutil.ints.Int2IntMap;
import it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap;
import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
import it.unimi.dsi.fastutil.ints.IntArrayList;
import it.unimi.dsi.fastutil.ints.IntArrays;
import it.unimi.dsi.fastutil.ints.IntCollection;
import it.unimi.dsi.fastutil.ints.IntList;
import it.unimi.dsi.fastutil.ints.IntLists;
import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
import it.unimi.dsi.fastutil.ints.IntSet;
import it.unimi.dsi.fastutil.objects.ObjectArrayList;

<span class="fc" id="L60">public class MinCostFlowBench {</span>

<span class="fc" id="L62">	final int graphsNum = 31;</span>
<span class="fc" id="L63">	final AtomicInteger graphIdx = new AtomicInteger();</span>

<span class="fc" id="L65">	public static class Supply extends MinCostFlowBench {</span>

		List&lt;Supply.Task&gt; graphs;

<span class="fc" id="L69">		static class Task {</span>
			IntGraph g;
			IFlowNetworkInt net;
			IWeightFunctionInt cost;
			IWeightFunctionInt lowerBound;
			IWeightFunctionInt supply;

			static Task newRand(IntGraph g, Random rand) {
<span class="fc" id="L77">				IFlowNetworkInt net = randNetwork(g, rand);</span>
<span class="fc" id="L78">				IWeightFunctionInt supply = randSupply(g, net, rand);</span>

				/*
				 * build a 'random' lower bound by solving min-cost flow with a different cost function and use the
				 * flows
				 */
<span class="fc" id="L84">				IWeightFunctionInt cost1 = randCost(g, rand);</span>
<span class="fc" id="L85">				MinimumCostFlow.newInstance().computeMinCostFlow(g, net, cost1, supply);</span>
<span class="fc" id="L86">				IWeightsInt lowerBound = IWeights.createExternalEdgesWeights(g, int.class);</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">				for (int e : g.edges()) {</span>
<span class="fc" id="L88">					lowerBound.set(e, (int) (net.getFlowInt(e) * 0.4 * rand.nextDouble()));</span>
<span class="fc" id="L89">					net.setFlow(e, 0);</span>
<span class="fc" id="L90">				}</span>

<span class="fc" id="L92">				IWeightFunctionInt cost = randCost(g, rand);</span>

<span class="fc" id="L94">				Task t = new Task();</span>
<span class="fc" id="L95">				t.g = g;</span>
<span class="fc" id="L96">				t.net = net;</span>
<span class="fc" id="L97">				t.cost = cost;</span>
<span class="fc" id="L98">				t.lowerBound = lowerBound;</span>
<span class="fc" id="L99">				t.supply = supply;</span>
<span class="fc" id="L100">				return t;</span>
			}
		}

		public void resetFlow() {
<span class="fc bfc" id="L105" title="All 2 branches covered.">			for (Task task : graphs)</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">				for (int e : task.g.edges())</span>
<span class="fc" id="L107">					task.net.setFlow(e, 0);</span>
<span class="fc" id="L108">		}</span>

		void benchMinCostFlow(MinimumCostFlow.Builder builder, Blackhole blackhole) {
<span class="fc" id="L111">			Task t = graphs.get(graphIdx.getAndUpdate(i -&gt; (i + 1) % graphsNum));</span>
<span class="fc" id="L112">			MinimumCostFlow algo = builder.build();</span>
<span class="fc" id="L113">			algo.computeMinCostFlow(t.g, t.net, t.cost, t.lowerBound, t.supply);</span>
<span class="fc" id="L114">			blackhole.consume(t.net);</span>
<span class="fc" id="L115">		}</span>

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.MILLISECONDS)
		@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.SECONDS)
		@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L123">		public static class Gnp extends MinCostFlowBench.Supply {</span>

			// @Param({ &quot;|V|=1000&quot;, &quot;|V|=2000&quot;, &quot;|V|=2500&quot; })
			@Param({ &quot;|V|=100&quot; })
			public String args;

<span class="fc" id="L129">			public String directed = &quot;directed&quot;;</span>

			@Override
			@Setup(Level.Invocation)
			public void resetFlow() {
<span class="fc" id="L134">				super.resetFlow();</span>
<span class="fc" id="L135">			}</span>

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L139">				Map&lt;String, String&gt; argsMap = BenchUtils.parseArgsStr(args);</span>
<span class="fc" id="L140">				int n = Integer.parseInt(argsMap.get(&quot;|V|&quot;));</span>
<span class="fc" id="L141">				boolean directed = this.directed.equals(&quot;directed&quot;);</span>

<span class="fc" id="L143">				final SeedGenerator seedGen = new SeedGenerator(0x94fc6ec413f60392L);</span>
<span class="fc" id="L144">				Random rand = new Random(seedGen.nextSeed());</span>
<span class="fc" id="L145">				graphs = new ObjectArrayList&lt;&gt;(graphsNum);</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">				for (int gIdx = 0; gIdx &lt; graphsNum; gIdx++) {</span>
<span class="fc" id="L147">					IntGraph g = GraphsTestUtils.randomGraphGnp(n, directed, seedGen.nextSeed());</span>
<span class="fc" id="L148">					graphs.add(Task.newRand(g, rand));</span>
				}
<span class="fc" id="L150">			}</span>

			@Benchmark
			public void CycleCanceling(Blackhole blackhole) {
<span class="fc" id="L154">				benchMinCostFlow(MinimumCostFlow.newBuilder().setOption(&quot;impl&quot;, &quot;cycle-canceling&quot;), blackhole);</span>
<span class="fc" id="L155">			}</span>

			@Benchmark
			public void CostScaling(Blackhole blackhole) {
<span class="fc" id="L159">				benchMinCostFlow(MinimumCostFlow.newBuilder().setOption(&quot;impl&quot;, &quot;cost-scaling&quot;), blackhole);</span>
<span class="fc" id="L160">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.MILLISECONDS)
		@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.SECONDS)
		@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L169">		public static class BarabasiAlbert extends MinCostFlowBench.Supply {</span>

			// @Param({ &quot;|V|=3000&quot;, &quot;|V|=4500&quot;, &quot;|V|=6000&quot; })
			@Param({ &quot;|V|=100&quot; })
			public String args;

<span class="fc" id="L175">			public String directed = &quot;directed&quot;;</span>

			@Override
			@Setup(Level.Invocation)
			public void resetFlow() {
<span class="fc" id="L180">				super.resetFlow();</span>
<span class="fc" id="L181">			}</span>

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L185">				Map&lt;String, String&gt; argsMap = BenchUtils.parseArgsStr(args);</span>
<span class="fc" id="L186">				int n = Integer.parseInt(argsMap.get(&quot;|V|&quot;));</span>
<span class="fc" id="L187">				boolean directed = this.directed.equals(&quot;directed&quot;);</span>

<span class="fc" id="L189">				final SeedGenerator seedGen = new SeedGenerator(0xdc6c4cf7f4d3843cL);</span>
<span class="fc" id="L190">				Random rand = new Random(seedGen.nextSeed());</span>
<span class="fc" id="L191">				graphs = new ObjectArrayList&lt;&gt;(graphsNum);</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">				for (int gIdx = 0; gIdx &lt; graphsNum; gIdx++) {</span>
<span class="fc" id="L193">					IntGraph g = GraphsTestUtils.randomGraphBarabasiAlbert(n, directed, seedGen.nextSeed());</span>
<span class="fc" id="L194">					graphs.add(Task.newRand(g, rand));</span>
				}
<span class="fc" id="L196">			}</span>

			@Benchmark
			public void CycleCanceling(Blackhole blackhole) {
<span class="fc" id="L200">				benchMinCostFlow(MinimumCostFlow.newBuilder().setOption(&quot;impl&quot;, &quot;cycle-canceling&quot;), blackhole);</span>
<span class="fc" id="L201">			}</span>

			@Benchmark
			public void CostScaling(Blackhole blackhole) {
<span class="fc" id="L205">				benchMinCostFlow(MinimumCostFlow.newBuilder().setOption(&quot;impl&quot;, &quot;cost-scaling&quot;), blackhole);</span>
<span class="fc" id="L206">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.MILLISECONDS)
		@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.SECONDS)
		@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L215">		public static class RecursiveMatrix extends MinCostFlowBench.Supply {</span>

			// @Param({ &quot;|V|=1500 |E|=5000&quot;, &quot;|V|=2500 |E|=8000&quot;, &quot;|V|=4000 |E|=16000&quot; })
			// @Param({ &quot;|V|=15 |E|=50&quot; })
			@Param({ &quot;|V|=3 |E|=3&quot; })
			public String args;

<span class="fc" id="L222">			public String directed = &quot;directed&quot;;</span>

			@Override
			@Setup(Level.Invocation)
			public void resetFlow() {
<span class="fc" id="L227">				super.resetFlow();</span>
<span class="fc" id="L228">			}</span>

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L232">				Map&lt;String, String&gt; argsMap = BenchUtils.parseArgsStr(args);</span>
<span class="fc" id="L233">				int n = Integer.parseInt(argsMap.get(&quot;|V|&quot;));</span>
<span class="fc" id="L234">				int m = Integer.parseInt(argsMap.get(&quot;|E|&quot;));</span>
<span class="fc" id="L235">				boolean directed = this.directed.equals(&quot;directed&quot;);</span>

<span class="fc" id="L237">				final SeedGenerator seedGen = new SeedGenerator(0x9716aede5cfa6eabL);</span>
<span class="fc" id="L238">				Random rand = new Random(seedGen.nextSeed());</span>
<span class="fc" id="L239">				graphs = new ObjectArrayList&lt;&gt;(graphsNum);</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">				for (int gIdx = 0; gIdx &lt; graphsNum; gIdx++) {</span>
<span class="fc" id="L241">					IntGraph g = GraphsTestUtils.randomGraphRecursiveMatrix(n, m, directed, seedGen.nextSeed());</span>
<span class="fc" id="L242">					graphs.add(Task.newRand(g, rand));</span>
				}
<span class="fc" id="L244">			}</span>

			@Benchmark
			public void CycleCanceling(Blackhole blackhole) {
<span class="fc" id="L248">				benchMinCostFlow(MinimumCostFlow.newBuilder().setOption(&quot;impl&quot;, &quot;cycle-canceling&quot;), blackhole);</span>
<span class="fc" id="L249">			}</span>

			@Benchmark
			public void CostScaling(Blackhole blackhole) {
<span class="fc" id="L253">				benchMinCostFlow(MinimumCostFlow.newBuilder().setOption(&quot;impl&quot;, &quot;cost-scaling&quot;), blackhole);</span>
<span class="fc" id="L254">			}</span>
		}
	}

<span class="fc" id="L258">	public static class MaxFlow extends MinCostFlowBench {</span>

		List&lt;MaxFlow.Task&gt; graphs;

<span class="fc" id="L262">		static class Task {</span>
			IntGraph g;
			IFlowNetworkInt net;
			IWeightFunctionInt cost;
			IWeightFunctionInt lowerBound;
			IntCollection sources;
			IntCollection sinks;

			static Task newRand(IntGraph g, Random rand) {
<span class="fc" id="L271">				IFlowNetworkInt net = randNetwork(g, rand);</span>
<span class="fc" id="L272">				Pair&lt;IntCollection, IntCollection&gt; sourcesSinks = MaximumFlowBench.chooseMultiSourceMultiSink(g, rand);</span>
<span class="fc" id="L273">				IntCollection sources = sourcesSinks.first();</span>
<span class="fc" id="L274">				IntCollection sinks = sourcesSinks.second();</span>
<span class="fc" id="L275">				IWeightFunctionInt cost = randCost(g, rand);</span>
<span class="fc" id="L276">				IWeightFunctionInt lowerBound = randLowerBound(g, net, sources, sinks, rand);</span>

<span class="fc" id="L278">				Task t = new Task();</span>
<span class="fc" id="L279">				t.g = g;</span>
<span class="fc" id="L280">				t.net = net;</span>
<span class="fc" id="L281">				t.cost = cost;</span>
<span class="fc" id="L282">				t.lowerBound = lowerBound;</span>
<span class="fc" id="L283">				t.sources = sources;</span>
<span class="fc" id="L284">				t.sinks = sinks;</span>
<span class="fc" id="L285">				return t;</span>
			}
		}

		public void resetFlow() {
<span class="fc bfc" id="L290" title="All 2 branches covered.">			for (Task task : graphs)</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">				for (int e : task.g.edges())</span>
<span class="fc" id="L292">					task.net.setFlow(e, 0);</span>
<span class="fc" id="L293">		}</span>

		void benchMinCostFlow(MinimumCostFlow.Builder builder, Blackhole blackhole) {
<span class="fc" id="L296">			Task t = graphs.get(graphIdx.getAndUpdate(i -&gt; (i + 1) % graphsNum));</span>
<span class="fc" id="L297">			MinimumCostFlow algo = builder.build();</span>
<span class="fc" id="L298">			algo.computeMinCostMaxFlow(t.g, t.net, t.cost, t.lowerBound, t.sources, t.sinks);</span>
<span class="fc" id="L299">			blackhole.consume(t.net);</span>
<span class="fc" id="L300">		}</span>

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.MILLISECONDS)
		@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.SECONDS)
		@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L308">		public static class Gnp extends MinCostFlowBench.MaxFlow {</span>

			// @Param({ &quot;|V|=1000&quot;, &quot;|V|=2000&quot;, &quot;|V|=2500&quot; })
			@Param({ &quot;|V|=100&quot; })
			public String args;

<span class="fc" id="L314">			public String directed = &quot;directed&quot;;</span>

			@Override
			@Setup(Level.Invocation)
			public void resetFlow() {
<span class="fc" id="L319">				super.resetFlow();</span>
<span class="fc" id="L320">			}</span>

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L324">				Map&lt;String, String&gt; argsMap = BenchUtils.parseArgsStr(args);</span>
<span class="fc" id="L325">				int n = Integer.parseInt(argsMap.get(&quot;|V|&quot;));</span>
<span class="fc" id="L326">				boolean directed = this.directed.equals(&quot;directed&quot;);</span>

<span class="fc" id="L328">				final SeedGenerator seedGen = new SeedGenerator(0x94fc6ec413f60392L);</span>
<span class="fc" id="L329">				Random rand = new Random(seedGen.nextSeed());</span>
<span class="fc" id="L330">				graphs = new ObjectArrayList&lt;&gt;(graphsNum);</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">				for (int gIdx = 0; gIdx &lt; graphsNum; gIdx++) {</span>
<span class="fc" id="L332">					IntGraph g = GraphsTestUtils.randomGraphGnp(n, directed, seedGen.nextSeed());</span>
<span class="fc" id="L333">					graphs.add(Task.newRand(g, rand));</span>
				}
<span class="fc" id="L335">			}</span>

			@Benchmark
			public void CycleCanceling(Blackhole blackhole) {
<span class="fc" id="L339">				benchMinCostFlow(MinimumCostFlow.newBuilder().setOption(&quot;impl&quot;, &quot;cycle-canceling&quot;), blackhole);</span>
<span class="fc" id="L340">			}</span>

			@Benchmark
			public void CostScaling(Blackhole blackhole) {
<span class="fc" id="L344">				benchMinCostFlow(MinimumCostFlow.newBuilder().setOption(&quot;impl&quot;, &quot;cost-scaling&quot;), blackhole);</span>
<span class="fc" id="L345">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.MILLISECONDS)
		@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.SECONDS)
		@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L354">		public static class BarabasiAlbert extends MinCostFlowBench.MaxFlow {</span>

			// @Param({ &quot;|V|=3000&quot;, &quot;|V|=4500&quot;, &quot;|V|=6000&quot; })
			@Param({ &quot;|V|=100&quot; })
			public String args;

<span class="fc" id="L360">			public String directed = &quot;directed&quot;;</span>

			@Override
			@Setup(Level.Invocation)
			public void resetFlow() {
<span class="fc" id="L365">				super.resetFlow();</span>
<span class="fc" id="L366">			}</span>

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L370">				Map&lt;String, String&gt; argsMap = BenchUtils.parseArgsStr(args);</span>
<span class="fc" id="L371">				int n = Integer.parseInt(argsMap.get(&quot;|V|&quot;));</span>
<span class="fc" id="L372">				boolean directed = this.directed.equals(&quot;directed&quot;);</span>

<span class="fc" id="L374">				final SeedGenerator seedGen = new SeedGenerator(0xdc6c4cf7f4d3843cL);</span>
<span class="fc" id="L375">				Random rand = new Random(seedGen.nextSeed());</span>
<span class="fc" id="L376">				graphs = new ObjectArrayList&lt;&gt;(graphsNum);</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">				for (int gIdx = 0; gIdx &lt; graphsNum; gIdx++) {</span>
<span class="fc" id="L378">					IntGraph g = GraphsTestUtils.randomGraphBarabasiAlbert(n, directed, seedGen.nextSeed());</span>
<span class="fc" id="L379">					graphs.add(Task.newRand(g, rand));</span>
				}
<span class="fc" id="L381">			}</span>

			@Benchmark
			public void CycleCanceling(Blackhole blackhole) {
<span class="fc" id="L385">				benchMinCostFlow(MinimumCostFlow.newBuilder().setOption(&quot;impl&quot;, &quot;cycle-canceling&quot;), blackhole);</span>
<span class="fc" id="L386">			}</span>

			@Benchmark
			public void CostScaling(Blackhole blackhole) {
<span class="fc" id="L390">				benchMinCostFlow(MinimumCostFlow.newBuilder().setOption(&quot;impl&quot;, &quot;cost-scaling&quot;), blackhole);</span>
<span class="fc" id="L391">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.MILLISECONDS)
		@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.SECONDS)
		@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L400">		public static class RecursiveMatrix extends MinCostFlowBench.MaxFlow {</span>

			// @Param({ &quot;|V|=1500 |E|=5000&quot;, &quot;|V|=2500 |E|=8000&quot;, &quot;|V|=4000 |E|=16000&quot; })
			@Param({ &quot;|V|=15 |E|=50&quot; })
			public String args;

<span class="fc" id="L406">			public String directed = &quot;directed&quot;;</span>

			@Override
			@Setup(Level.Invocation)
			public void resetFlow() {
<span class="fc" id="L411">				super.resetFlow();</span>
<span class="fc" id="L412">			}</span>

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L416">				Map&lt;String, String&gt; argsMap = BenchUtils.parseArgsStr(args);</span>
<span class="fc" id="L417">				int n = Integer.parseInt(argsMap.get(&quot;|V|&quot;));</span>
<span class="fc" id="L418">				int m = Integer.parseInt(argsMap.get(&quot;|E|&quot;));</span>
<span class="fc" id="L419">				boolean directed = this.directed.equals(&quot;directed&quot;);</span>

<span class="fc" id="L421">				final SeedGenerator seedGen = new SeedGenerator(0x9716aede5cfa6eabL);</span>
<span class="fc" id="L422">				Random rand = new Random(seedGen.nextSeed());</span>
<span class="fc" id="L423">				graphs = new ObjectArrayList&lt;&gt;(graphsNum);</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">				for (int gIdx = 0; gIdx &lt; graphsNum; gIdx++) {</span>
<span class="fc" id="L425">					IntGraph g = GraphsTestUtils.randomGraphRecursiveMatrix(n, m, directed, seedGen.nextSeed());</span>
<span class="fc" id="L426">					graphs.add(Task.newRand(g, rand));</span>
				}
<span class="fc" id="L428">			}</span>

			@Benchmark
			public void CycleCanceling(Blackhole blackhole) {
<span class="fc" id="L432">				benchMinCostFlow(MinimumCostFlow.newBuilder().setOption(&quot;impl&quot;, &quot;cycle-canceling&quot;), blackhole);</span>
<span class="fc" id="L433">			}</span>

			@Benchmark
			public void CostScaling(Blackhole blackhole) {
<span class="fc" id="L437">				benchMinCostFlow(MinimumCostFlow.newBuilder().setOption(&quot;impl&quot;, &quot;cost-scaling&quot;), blackhole);</span>
<span class="fc" id="L438">			}</span>
		}
	}

	private static IFlowNetworkInt randNetwork(IntGraph g, Random rand) {
<span class="fc" id="L443">		IWeightsInt capacities = IWeights.createExternalEdgesWeights(g, int.class);</span>
<span class="fc" id="L444">		IWeightsInt flows = IWeights.createExternalEdgesWeights(g, int.class);</span>
<span class="fc" id="L445">		IFlowNetworkInt net = IFlowNetworkInt.createFromEdgeWeights(capacities, flows);</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">		for (int e : g.edges())</span>
<span class="fc" id="L447">			net.setCapacity(e, 400 + rand.nextInt(1024));</span>
<span class="fc" id="L448">		return net;</span>
	}

	private static IWeightFunctionInt randCost(IntGraph g, Random rand) {
<span class="fc" id="L452">		IWeightsInt cost = IWeights.createExternalEdgesWeights(g, int.class);</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">		for (int e : g.edges())</span>
<span class="fc" id="L454">			cost.set(e, rand.nextInt(2424) - 600);</span>
<span class="fc" id="L455">		return cost;</span>
	}

	private static IWeightFunctionInt randLowerBound(IntGraph g, IFlowNetworkInt net, IntCollection sources,
			IntCollection sinks, Random rand) {
<span class="fc" id="L460">		Assertions.Graphs.onlyDirected(g);</span>

<span class="fc" id="L462">		Int2IntMap capacity = new Int2IntOpenHashMap();</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">		for (int e : g.edges())</span>
<span class="fc" id="L464">			capacity.put(e, net.getCapacityInt(e));</span>

<span class="fc" id="L466">		IntSet sinksSet = new IntOpenHashSet(sinks);</span>
<span class="fc" id="L467">		IntList sourcesList = new IntArrayList(sources);</span>

<span class="fc" id="L469">		IWeightsInt lowerBound = IWeights.createExternalEdgesWeights(g, int.class);</span>
<span class="fc" id="L470">		IntArrayList path = new IntArrayList();</span>
<span class="fc" id="L471">		IntSet visited = new IntOpenHashSet();</span>

<span class="fc" id="L473">		int lowerBoundCount = 0;</span>
		sourcesLoop: for (;;) {
<span class="fc bfc" id="L475" title="All 4 branches covered.">			if (sourcesList.isEmpty() || lowerBoundCount &gt;= g.vertices().size() / 2)</span>
<span class="fc" id="L476">				return lowerBound;</span>

<span class="fc" id="L478">			class EdgeIterator {</span>
				int[] es;
				int idx;
			}

<span class="fc" id="L483">			path.clear();</span>
<span class="fc" id="L484">			visited.clear();</span>
<span class="fc" id="L485">			Int2ObjectMap&lt;EdgeIterator&gt; edgeIters = new Int2ObjectOpenHashMap&lt;&gt;(g.vertices().size());</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">			for (int u : g.vertices()) {</span>
<span class="fc" id="L487">				int[] es = g.outEdges(u).toIntArray();</span>
<span class="fc" id="L488">				IntArrays.shuffle(es, rand);</span>
<span class="fc" id="L489">				EdgeIterator iter = new EdgeIterator();</span>
<span class="fc" id="L490">				iter.es = es;</span>
<span class="fc" id="L491">				iter.idx = 0;</span>
<span class="fc" id="L492">				edgeIters.put(u, iter);</span>
<span class="fc" id="L493">			}</span>

<span class="fc" id="L495">			int sourceIdx = rand.nextInt(sourcesList.size());</span>
<span class="fc" id="L496">			int source = sourcesList.getInt(sourceIdx);</span>
<span class="fc" id="L497">			visited.add(source);</span>
<span class="fc" id="L498">			dfs: for (int u = source;;) {</span>

				/* Find a random edge to deepen the DFS */
<span class="fc bfc" id="L501" title="All 2 branches covered.">				for (EdgeIterator edgeIter = edgeIters.get(u); edgeIter.idx &lt; edgeIter.es.length; edgeIter.idx++) {</span>
<span class="fc" id="L502">					int e = edgeIter.es[edgeIter.idx];</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">					if (capacity.get(e) == 0)</span>
<span class="fc" id="L504">						continue;</span>
<span class="pc bnc" id="L505" title="All 2 branches missed.">					assert u == g.edgeSource(e);</span>
<span class="fc" id="L506">					int v = g.edgeTarget(e);</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">					if (visited.contains(v))</span>
<span class="fc" id="L508">						continue;</span>
<span class="fc" id="L509">					path.add(e);</span>

<span class="fc bfc" id="L511" title="All 2 branches covered.">					if (sinksSet.contains(v))</span>
						/* found an residual path from source to sink */
<span class="fc" id="L513">						break dfs;</span>

					/* Continue down in the DFS */
<span class="fc" id="L516">					visited.add(v);</span>
<span class="fc" id="L517">					u = v;</span>
<span class="fc" id="L518">					continue dfs;</span>
				}

				/* No more edges to explore */
<span class="fc bfc" id="L522" title="All 2 branches covered.">				if (path.isEmpty()) {</span>
					/* No more residual paths from source to any sink, remove source from sources list */
<span class="fc" id="L524">					sourcesList.set(sourceIdx, sourcesList.getInt(sourcesList.size() - 1));</span>
<span class="fc" id="L525">					sourcesList.removeInt(sourcesList.size() - 1);</span>
<span class="fc" id="L526">					continue sourcesLoop;</span>
				}

				/* Back up in the DFS path one vertex */
<span class="fc" id="L530">				int lastEdge = path.popInt();</span>
<span class="pc bnc" id="L531" title="All 2 branches missed.">				assert u == g.edgeTarget(lastEdge);</span>
<span class="fc" id="L532">				u = g.edgeSource(lastEdge);</span>
<span class="fc" id="L533">			}</span>

			/* Found a residual path from source to sink */
<span class="fc" id="L536">			int delta = path.intStream().map(capacity::get).min().getAsInt();</span>
<span class="pc bnc" id="L537" title="All 2 branches missed.">			assert delta &gt; 0;</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">			for (int e : path)</span>
<span class="fc" id="L539">				capacity.put(e, capacity.get(e) - delta);</span>

			/* Add lower bounds to some of the edges */
<span class="fc" id="L542">			IntList lowerBoundEdges = new IntArrayList(path);</span>
<span class="fc" id="L543">			IntLists.shuffle(lowerBoundEdges, rand);</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">			if (lowerBoundEdges.size() &gt; 1)</span>
<span class="fc" id="L545">				lowerBoundEdges.removeElements(Math.max(1, lowerBoundEdges.size() / 3), lowerBoundEdges.size());</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">			for (int e : lowerBoundEdges) {</span>
<span class="fc" id="L547">				int boundDelta = delta / 2 + rand.nextInt((delta + 1) / 2);</span>
<span class="fc" id="L548">				lowerBound.set(e, lowerBound.weightInt(e) + boundDelta);</span>
<span class="fc" id="L549">				lowerBoundCount++;</span>
<span class="fc" id="L550">			}</span>
<span class="fc" id="L551">		}</span>
	}

	private static IWeightFunctionInt randSupply(IntGraph g, IFlowNetworkInt net, Random rand) {
<span class="fc" id="L555">		Assertions.Graphs.onlyDirected(g);</span>

<span class="fc" id="L557">		IntList suppliers = new IntArrayList();</span>
<span class="fc" id="L558">		IntList demanders = new IntArrayList();</span>
<span class="fc" id="L559">		int[] vertices = g.vertices().toIntArray();</span>
<span class="fc" id="L560">		IntArrays.shuffle(vertices, rand);</span>
<span class="pc bnc" id="L561" title="All 2 branches missed.">		assert vertices.length &gt;= 2;</span>
<span class="fc" id="L562">		suppliers.add(vertices[0]);</span>
<span class="fc" id="L563">		demanders.add(vertices[1]);</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">		for (int i = 2; i &lt; vertices.length; i++) {</span>
<span class="fc" id="L565">			int r = rand.nextInt(3);</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">			if (r == 0) {</span>
<span class="fc" id="L567">				suppliers.add(vertices[i]);</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">			} else if (r == 1) {</span>
<span class="fc" id="L569">				demanders.add(vertices[i]);</span>
			} else {
				/* do nothing */
			}
		}

<span class="fc" id="L575">		Int2IntMap capacity = new Int2IntOpenHashMap();</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">		for (int e : g.edges())</span>
<span class="fc" id="L577">			capacity.put(e, net.getCapacityInt(e));</span>

<span class="fc" id="L579">		IntSet demandersSet = new IntOpenHashSet(demanders);</span>
<span class="fc" id="L580">		IntList suppliersList = new IntArrayList(suppliers);</span>

<span class="fc" id="L582">		IWeightsInt supply = IWeights.createExternalVerticesWeights(g, int.class);</span>
<span class="fc" id="L583">		IntArrayList path = new IntArrayList();</span>
<span class="fc" id="L584">		IntSet visited = new IntOpenHashSet();</span>
		suppliersLoop: for (;;) {
<span class="fc bfc" id="L586" title="All 2 branches covered.">			if (suppliersList.isEmpty()) {</span>
<span class="pc bnc" id="L587" title="All 2 branches missed.">				assert g.vertices().intStream().map(supply::weightInt).sum() == 0;</span>
<span class="fc" id="L588">				return supply;</span>
			}

<span class="fc" id="L591">			path.clear();</span>
<span class="fc" id="L592">			visited.clear();</span>

<span class="fc" id="L594">			int supplierIdx = rand.nextInt(suppliersList.size());</span>
<span class="fc" id="L595">			int supplier = suppliersList.getInt(supplierIdx);</span>
<span class="fc" id="L596">			visited.add(supplier);</span>
<span class="fc" id="L597">			dfs: for (int u = supplier;;) {</span>

				/* Find a random edge to deepen the DFS */
<span class="fc" id="L600">				int[] es = g.outEdges(u).toIntArray();</span>
<span class="fc" id="L601">				IntArrays.shuffle(es, rand);</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">				for (int e : es) {</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">					if (capacity.get(e) == 0)</span>
<span class="fc" id="L604">						continue;</span>
<span class="pc bnc" id="L605" title="All 2 branches missed.">					assert u == g.edgeSource(e);</span>
<span class="fc" id="L606">					int v = g.edgeTarget(e);</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">					if (visited.contains(v))</span>
<span class="fc" id="L608">						continue;</span>
<span class="fc" id="L609">					path.add(e);</span>

<span class="fc bfc" id="L611" title="All 2 branches covered.">					if (demandersSet.contains(v))</span>
						/* found an residual path from a supplier to a demander */
<span class="fc" id="L613">						break dfs;</span>

					/* Continue down in the DFS */
<span class="fc" id="L616">					visited.add(v);</span>
<span class="fc" id="L617">					u = v;</span>
<span class="fc" id="L618">					continue dfs;</span>
				}

				/* No more edges to explore */
<span class="fc bfc" id="L622" title="All 2 branches covered.">				if (path.isEmpty()) {</span>
					/* No more residual paths from supplier to any demander, remove supplier from suppliers list */
<span class="fc" id="L624">					suppliersList.set(supplierIdx, suppliersList.getInt(suppliersList.size() - 1));</span>
<span class="fc" id="L625">					suppliersList.removeInt(suppliersList.size() - 1);</span>
<span class="fc" id="L626">					continue suppliersLoop;</span>
				}

				/* Back up in the DFS path one vertex */
<span class="fc" id="L630">				int lastEdge = path.popInt();</span>
<span class="pc bnc" id="L631" title="All 2 branches missed.">				assert u == g.edgeTarget(lastEdge);</span>
<span class="fc" id="L632">				u = g.edgeSource(lastEdge);</span>
<span class="fc" id="L633">			}</span>

			/* Found a residual path from a supplier to a demander */
<span class="fc" id="L636">			int delta = path.intStream().map(capacity::get).min().getAsInt();</span>
<span class="pc bnc" id="L637" title="All 2 branches missed.">			assert delta &gt; 0;</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">			for (int e : path)</span>
<span class="fc" id="L639">				capacity.put(e, capacity.get(e) - delta);</span>

			/* Add lower bounds to some of the edges */
<span class="fc" id="L642">			int source = g.edgeSource(path.getInt(0));</span>
<span class="fc" id="L643">			int sink = g.edgeTarget(path.getInt(path.size() - 1));</span>
<span class="fc bfc" id="L644" title="All 2 branches covered.">			if (rand.nextBoolean()) {</span>
<span class="fc" id="L645">				int s = rand.nextInt((delta + 1) / 2);</span>
<span class="fc" id="L646">				supply.set(source, supply.weightInt(source) + s);</span>
<span class="fc" id="L647">				supply.set(sink, supply.weightInt(sink) - s);</span>
			}
<span class="fc" id="L649">		}</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>