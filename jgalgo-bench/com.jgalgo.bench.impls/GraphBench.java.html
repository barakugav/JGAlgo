<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GraphBench.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Benchmarks</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.bench.impls</a> &gt; <span class="el_source">GraphBench.java</span></div><h1>GraphBench.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.bench.impls;

import java.util.Map;
import java.util.Random;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import java.util.function.Supplier;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Fork;
import org.openjdk.jmh.annotations.Level;
import org.openjdk.jmh.annotations.Measurement;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OperationsPerInvocation;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Param;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.annotations.Warmup;
import org.openjdk.jmh.infra.Blackhole;
import com.jgalgo.bench.util.BenchUtils;
import com.jgalgo.bench.util.TestUtils;
import com.jgalgo.graph.Graphs;
import com.jgalgo.graph.IEdgeIter;
import com.jgalgo.graph.IEdgeSet;
import com.jgalgo.graph.IndexGraph;
import com.jgalgo.graph.IndexGraphBuilder;
import com.jgalgo.graph.IndexGraphFactory;
import com.jgalgo.internal.util.JGAlgoUtils;
import it.unimi.dsi.fastutil.ints.IntImmutableList;
import it.unimi.dsi.fastutil.ints.IntIterable;
import it.unimi.dsi.fastutil.ints.IntIterator;
import it.unimi.dsi.fastutil.longs.LongImmutableList;
import it.unimi.dsi.fastutil.longs.LongIterable;
import it.unimi.dsi.fastutil.longs.LongIterator;
import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
import it.unimi.dsi.fastutil.longs.LongSet;

<span class="nc" id="L55">public class GraphBench {</span>

<span class="fc" id="L57">	public static class EdgesRead {</span>

		private IndexGraph g;
		private IntIterator queryVIter;
		private LongIterator queryUVIter;

		void setup(String args, Function&lt;IndexGraph, IndexGraph&gt; graphImplementation, boolean directed,
				boolean allowParallelEdges, boolean allowSelfEdges) {
<span class="fc" id="L65">			final long seed = 0x8c91b913bfe81bb7L;</span>
<span class="fc" id="L66">			final Random rand = new Random(seed);</span>
<span class="fc" id="L67">			Map&lt;String, String&gt; argsMap = BenchUtils.parseArgsStr(args);</span>
<span class="fc" id="L68">			final int n = Integer.parseInt(argsMap.get(&quot;|V|&quot;));</span>
<span class="fc" id="L69">			final int m = Integer.parseInt(argsMap.get(&quot;|E|&quot;));</span>

<span class="fc bfc" id="L71" title="All 2 branches covered.">			IndexGraphFactory factory = directed ? IndexGraphFactory.newDirected() : IndexGraphFactory.newUndirected();</span>
<span class="fc" id="L72">			g = factory.allowSelfEdges().newGraph();</span>
<span class="fc bfc" id="L73" title="All 2 branches covered.">			for (int v = 0; v &lt; n; v++)</span>
<span class="fc" id="L74">				g.addVertex();</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">			LongSet existingEdges = allowParallelEdges ? null : new LongOpenHashSet();</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">			for (int e = 0; e &lt; m;) {</span>
<span class="fc" id="L77">				int u = Graphs.randVertex(g, rand), v = Graphs.randVertex(g, rand);</span>
<span class="fc bfc" id="L78" title="All 4 branches covered.">				if (!allowSelfEdges &amp;&amp; u == v)</span>
<span class="fc" id="L79">					continue;</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">				if (!allowParallelEdges) {</span>
<span class="fc" id="L81">					int u1 = u, v1 = v;</span>
<span class="fc bfc" id="L82" title="All 4 branches covered.">					if (!directed &amp;&amp; u1 &lt; v1) {</span>
<span class="fc" id="L83">						int tmp = u1;</span>
<span class="fc" id="L84">						u1 = v1;</span>
<span class="fc" id="L85">						v1 = tmp;</span>
					}
<span class="fc" id="L87">					long key = JGAlgoUtils.longPack(u1, v1);</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">					if (!existingEdges.add(key))</span>
<span class="fc" id="L89">						continue;</span>
				}
<span class="fc" id="L91">				g.addEdge(u, v);</span>
<span class="fc" id="L92">				e++;</span>
<span class="fc" id="L93">			}</span>
<span class="fc" id="L94">			g = graphImplementation.apply(g);</span>

<span class="fc" id="L96">			int[] queryVertices = TestUtils.randArray(n * 16, 0, n, seed);</span>
<span class="fc" id="L97">			queryVIter = circularIterator(IntImmutableList.of(queryVertices));</span>

<span class="fc" id="L99">			int[] queryUVertices = TestUtils.randArray(n * 32, 0, n, seed);</span>
<span class="fc" id="L100">			long[] queryUVertices0 = new long[queryUVertices.length / 2];</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">			for (int q = 0; q &lt; queryUVertices0.length; q++) {</span>
				int u, v;
<span class="fc bfc" id="L103" title="All 2 branches covered.">				if (rand.nextBoolean()) {</span>
<span class="fc" id="L104">					u = queryUVertices[q * 2 + 0];</span>
<span class="fc" id="L105">					v = queryUVertices[q * 2 + 1];</span>
				} else {
<span class="fc" id="L107">					int e = Graphs.randEdge(g, rand);</span>
<span class="fc" id="L108">					u = g.edgeSource(e);</span>
<span class="fc" id="L109">					v = g.edgeTarget(e);</span>
<span class="fc bfc" id="L110" title="All 4 branches covered.">					if (!directed &amp;&amp; rand.nextBoolean()) {</span>
<span class="fc" id="L111">						int tmp = u;</span>
<span class="fc" id="L112">						u = v;</span>
<span class="fc" id="L113">						v = tmp;</span>
					}
				}
<span class="fc" id="L116">				queryUVertices0[q] = JGAlgoUtils.longPack(u, v);</span>
			}
<span class="fc" id="L118">			queryUVIter = circularIterator(LongImmutableList.of(queryUVertices0));</span>
<span class="fc" id="L119">		}</span>

		void setup(String args, Supplier&lt;IndexGraph&gt; graphImplementation, boolean directed, boolean allowParallelEdges,
				boolean allowSelfEdges) {
<span class="fc" id="L123">			setup(args, g -&gt; {</span>
<span class="pc bnc" id="L124" title="All 2 branches missed.">				assert g.isDirected() == directed;</span>
<span class="fc" id="L125">				IndexGraph g1 = graphImplementation.get();</span>
<span class="pc bnc" id="L126" title="All 2 branches missed.">				assert g1.isDirected() == directed;</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">				for (int n = g.vertices().size(), v = 0; v &lt; n; v++)</span>
<span class="fc" id="L128">					g1.addVertex();</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">				for (int m = g.edges().size(), e = 0; e &lt; m; e++)</span>
<span class="fc" id="L130">					g1.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L131">				return g1;</span>
			}, directed, allowParallelEdges, allowSelfEdges);
<span class="fc" id="L133">		}</span>

		private void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L136">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L137">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc" id="L138">			blackhole.consume(edgeSet);</span>
<span class="fc" id="L139">		}</span>

		private void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L142">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L143">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc" id="L144">			blackhole.consume(edgeSet.size());</span>
<span class="fc" id="L145">		}</span>

		private void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L148">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L149">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();)</span>
<span class="fc" id="L151">				blackhole.consume(eit.nextInt());</span>
<span class="fc" id="L152">		}</span>

		private void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L155">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L156">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();) {</span>
<span class="fc" id="L158">				eit.nextInt();</span>
<span class="fc" id="L159">				blackhole.consume(eit.sourceInt());</span>
			}
<span class="fc" id="L161">		}</span>

		private void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L164">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L165">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();) {</span>
<span class="fc" id="L167">				eit.nextInt();</span>
<span class="fc" id="L168">				blackhole.consume(eit.targetInt());</span>
			}
<span class="fc" id="L170">		}</span>

		private void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L173">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L174">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc" id="L175">			blackhole.consume(edgeSet);</span>
<span class="fc" id="L176">		}</span>

		private void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L179">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L180">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc" id="L181">			blackhole.consume(edgeSet.size());</span>
<span class="fc" id="L182">		}</span>

		private void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L185">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L186">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();)</span>
<span class="fc" id="L188">				blackhole.consume(eit.nextInt());</span>
<span class="fc" id="L189">		}</span>

		private void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L192">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L193">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();) {</span>
<span class="fc" id="L195">				eit.nextInt();</span>
<span class="fc" id="L196">				blackhole.consume(eit.sourceInt());</span>
			}
<span class="fc" id="L198">		}</span>

		private void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L201">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L202">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();) {</span>
<span class="fc" id="L204">				eit.nextInt();</span>
<span class="fc" id="L205">				blackhole.consume(eit.targetInt());</span>
			}
<span class="fc" id="L207">		}</span>

		private void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L210">			long l = queryUVIter.nextLong();</span>
<span class="fc" id="L211">			int u = JGAlgoUtils.long2low(l);</span>
<span class="fc" id="L212">			int v = JGAlgoUtils.long2high(l);</span>
<span class="fc" id="L213">			blackhole.consume(g.getEdge(u, v));</span>
<span class="fc" id="L214">		}</span>

		private void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L217">			long l = queryUVIter.nextLong();</span>
<span class="fc" id="L218">			int u = JGAlgoUtils.long2low(l);</span>
<span class="fc" id="L219">			int v = JGAlgoUtils.long2high(l);</span>
<span class="fc" id="L220">			blackhole.consume(g.getEdges(u, v));</span>
<span class="fc" id="L221">		}</span>

		private void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L224">			long l = queryUVIter.nextLong();</span>
<span class="fc" id="L225">			int u = JGAlgoUtils.long2low(l);</span>
<span class="fc" id="L226">			int v = JGAlgoUtils.long2high(l);</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">			for (IEdgeIter eit = g.getEdges(u, v).iterator(); eit.hasNext();)</span>
<span class="fc" id="L228">				blackhole.consume(eit.nextInt());</span>
<span class="fc" id="L229">		}</span>

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L237">		public static class ArrayDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L244">				setup(args, IndexGraphFactory.newDirected().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, true, true, false);</span>
<span class="fc" id="L245">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L249">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L250">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L254">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L255">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L259">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L260">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L264">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L265">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L269">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L270">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L274">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L275">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L279">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L280">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L284">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L285">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L289">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L290">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L294">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L295">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L299">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L300">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L304">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L305">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L309">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L310">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L319">		public static class ArrayUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L326">				setup(args, IndexGraphFactory.newUndirected().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, false, true, false);</span>
<span class="fc" id="L327">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L331">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L332">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L336">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L337">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L341">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L342">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L346">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L347">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L351">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L352">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L356">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L357">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L361">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L362">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L366">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L367">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L371">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L372">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L376">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L377">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L381">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L382">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L386">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L387">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L391">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L392">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L401">		public static class LinkedDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L408">				setup(args, IndexGraphFactory.newDirected().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, true, true,</span>
						false);
<span class="fc" id="L410">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L414">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L415">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L419">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L420">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L424">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L425">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L429">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L430">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L434">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L435">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L439">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L440">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L444">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L445">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L449">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L450">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L454">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L455">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L459">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L460">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L464">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L465">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L469">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L470">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L474">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L475">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L484">		public static class LinkedUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L491">				setup(args, IndexGraphFactory.newUndirected().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, false, true,</span>
						false);
<span class="fc" id="L493">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L497">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L498">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L502">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L503">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L507">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L508">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L512">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L513">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L517">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L518">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L522">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L523">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L527">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L528">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L532">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L533">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L537">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L538">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L542">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L543">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L547">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L548">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L552">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L553">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L557">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L558">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L567">		public static class LinkedPtrDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L574">				setup(args, IndexGraphFactory.newDirected().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, true, true,</span>
						false);
<span class="fc" id="L576">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L580">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L581">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L585">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L586">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L590">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L591">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L595">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L596">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L600">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L601">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L605">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L606">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L610">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L611">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L615">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L616">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L620">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L621">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L625">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L626">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L630">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L631">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L635">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L636">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L640">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L641">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L650">		public static class LinkedPtrUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L657">				setup(args, IndexGraphFactory.newUndirected().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, false,</span>
						true, false);
<span class="fc" id="L659">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L663">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L664">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L668">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L669">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L673">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L674">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L678">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L679">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L683">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L684">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L688">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L689">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L693">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L694">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L698">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L699">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L703">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L704">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L708">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L709">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L713">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L714">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L718">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L719">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L723">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L724">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L733">		public static class HashtableDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L740">				setup(args, IndexGraphFactory.newDirected().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, true, false,</span>
						false);
<span class="fc" id="L742">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L746">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L747">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L751">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L752">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L756">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L757">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L761">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L762">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L766">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L767">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L771">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L772">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L776">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L777">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L781">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L782">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L786">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L787">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L791">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L792">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L796">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L797">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L801">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L802">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L806">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L807">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L816">		public static class HashtableUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L823">				setup(args, IndexGraphFactory.newUndirected().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, false, false,</span>
						false);
<span class="fc" id="L825">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L829">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L830">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L834">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L835">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L839">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L840">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L844">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L845">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L849">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L850">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L854">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L855">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L859">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L860">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L864">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L865">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L869">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L870">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L874">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L875">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L879">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L880">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L884">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L885">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L889">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L890">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L899">		public static class MatrixDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L906">				setup(args, IndexGraphFactory.newDirected().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, true, false, false);</span>
<span class="fc" id="L907">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L911">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L912">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L916">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L917">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L921">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L922">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L926">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L927">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L931">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L932">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L936">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L937">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L941">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L942">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L946">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L947">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L951">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L952">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L956">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L957">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L961">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L962">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L966">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L967">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L971">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L972">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L981">		public static class MatrixUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L988">				setup(args, IndexGraphFactory.newUndirected().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, false, false,</span>
						false);
<span class="fc" id="L990">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L994">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L995">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L999">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L1000">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1004">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L1005">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1009">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L1010">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1014">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L1015">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L1019">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L1020">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1024">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L1025">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1029">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L1030">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1034">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L1035">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1039">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L1040">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L1044">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L1045">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L1049">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L1050">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1054">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L1055">			}</span>
		}

<span class="fc" id="L1058">		@BenchmarkMode(Mode.AverageTime)</span>
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L1064">		public static class CsrDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L1071">				final boolean directed = true;</span>
<span class="fc" id="L1072">				final boolean allowParallelEdges = true;</span>
<span class="fc" id="L1073">				final boolean allowSelfEdges = true;</span>
<span class="fc" id="L1074">				setup(args, g -&gt; {</span>
<span class="pc bnc" id="L1075" title="All 2 branches missed.">					assert g.isDirected() == directed;</span>
<span class="fc" id="L1076">					IndexGraphBuilder g1 = IndexGraphBuilder.newDirected();</span>
<span class="fc bfc" id="L1077" title="All 2 branches covered.">					for (int n = g.vertices().size(), v = 0; v &lt; n; v++)</span>
<span class="fc" id="L1078">						g1.addVertex();</span>
<span class="fc bfc" id="L1079" title="All 2 branches covered.">					for (int m = g.edges().size(), e = 0; e &lt; m; e++)</span>
<span class="fc" id="L1080">						g1.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L1081">					IndexGraph g1Graph = g1.build();</span>
<span class="pc bnc" id="L1082" title="All 2 branches missed.">					assert g1Graph.isDirected() == directed;</span>
<span class="fc" id="L1083">					return g1Graph;</span>
				}, directed, allowParallelEdges, allowSelfEdges);
<span class="fc" id="L1085">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L1089">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L1090">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1094">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L1095">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1099">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L1100">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1104">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L1105">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1109">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L1110">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L1114">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L1115">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1119">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L1120">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1124">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L1125">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1129">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L1130">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1134">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L1135">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L1139">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L1140">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L1144">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L1145">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1149">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L1150">			}</span>
		}

<span class="fc" id="L1153">		@BenchmarkMode(Mode.AverageTime)</span>
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L1159">		public static class CsrUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L1166">				final boolean directed = false;</span>
<span class="fc" id="L1167">				final boolean allowParallelEdges = true;</span>
<span class="fc" id="L1168">				final boolean allowSelfEdges = true;</span>
<span class="fc" id="L1169">				setup(args, g -&gt; {</span>
<span class="pc bnc" id="L1170" title="All 2 branches missed.">					assert g.isDirected() == directed;</span>
<span class="fc" id="L1171">					IndexGraphBuilder g1 = IndexGraphBuilder.newUndirected();</span>
<span class="fc bfc" id="L1172" title="All 2 branches covered.">					for (int n = g.vertices().size(), v = 0; v &lt; n; v++)</span>
<span class="fc" id="L1173">						g1.addVertex();</span>
<span class="fc bfc" id="L1174" title="All 2 branches covered.">					for (int m = g.edges().size(), e = 0; e &lt; m; e++)</span>
<span class="fc" id="L1175">						g1.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L1176">					IndexGraph g1Graph = g1.build();</span>
<span class="pc bnc" id="L1177" title="All 2 branches missed.">					assert g1Graph.isDirected() == directed;</span>
<span class="fc" id="L1178">					return g1Graph;</span>
				}, directed, allowParallelEdges, allowSelfEdges);
<span class="fc" id="L1180">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L1184">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L1185">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1189">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L1190">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1194">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L1195">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1199">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L1200">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1204">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L1205">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L1209">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L1210">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1214">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L1215">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1219">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L1220">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1224">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L1225">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1229">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L1230">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L1234">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L1235">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L1239">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L1240">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1244">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L1245">			}</span>
		}

<span class="fc" id="L1248">		@BenchmarkMode(Mode.AverageTime)</span>
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L1254">		public static class CsrDirectedReindexed extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L1261">				final boolean directed = true;</span>
<span class="fc" id="L1262">				final boolean allowParallelEdges = true;</span>
<span class="fc" id="L1263">				final boolean allowSelfEdges = true;</span>
<span class="fc" id="L1264">				setup(args, g -&gt; {</span>
<span class="pc bnc" id="L1265" title="All 2 branches missed.">					assert g.isDirected() == directed;</span>
<span class="fc" id="L1266">					IndexGraphBuilder g1 = IndexGraphBuilder.newDirected();</span>
<span class="fc bfc" id="L1267" title="All 2 branches covered.">					for (int n = g.vertices().size(), v = 0; v &lt; n; v++)</span>
<span class="fc" id="L1268">						g1.addVertex();</span>
<span class="fc bfc" id="L1269" title="All 2 branches covered.">					for (int m = g.edges().size(), e = 0; e &lt; m; e++)</span>
<span class="fc" id="L1270">						g1.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L1271">					IndexGraph g1Graph = g1.reIndexAndBuild(true, true).graph();</span>
<span class="pc bnc" id="L1272" title="All 2 branches missed.">					assert g1Graph.isDirected() == directed;</span>
<span class="fc" id="L1273">					return g1Graph;</span>
				}, directed, allowParallelEdges, allowSelfEdges);
<span class="fc" id="L1275">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L1279">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L1280">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1284">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L1285">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1289">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L1290">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1294">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L1295">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1299">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L1300">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L1304">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L1305">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1309">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L1310">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1314">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L1315">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1319">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L1320">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1324">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L1325">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L1329">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L1330">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L1334">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L1335">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1339">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L1340">			}</span>
		}

	}

<span class="fc" id="L1345">	public static class Remove {</span>

		IndexGraph g;
		int n, m;
		Random rand;

		void setup(String args, Function&lt;IndexGraph, IndexGraph&gt; graphImplementation, boolean directed,
				boolean allowParallelEdges, boolean allowSelfEdges) {
<span class="fc" id="L1353">			final long seed = 0x850a14ff3dad400cL;</span>
<span class="fc" id="L1354">			rand = new Random(seed);</span>
<span class="fc" id="L1355">			Map&lt;String, String&gt; argsMap = BenchUtils.parseArgsStr(args);</span>
<span class="fc" id="L1356">			n = Integer.parseInt(argsMap.get(&quot;|V|&quot;));</span>
<span class="fc" id="L1357">			m = Integer.parseInt(argsMap.get(&quot;|E|&quot;));</span>

<span class="fc bfc" id="L1359" title="All 2 branches covered.">			IndexGraphFactory factory = directed ? IndexGraphFactory.newDirected() : IndexGraphFactory.newUndirected();</span>
<span class="fc" id="L1360">			g = factory.allowSelfEdges(allowSelfEdges).allowParallelEdges(allowParallelEdges).newGraph();</span>
<span class="fc bfc" id="L1361" title="All 2 branches covered.">			for (int v = 0; v &lt; n; v++)</span>
<span class="fc" id="L1362">				g.addVertex();</span>
<span class="fc bfc" id="L1363" title="All 2 branches covered.">			LongSet existingEdges = allowParallelEdges ? null : new LongOpenHashSet();</span>
<span class="fc bfc" id="L1364" title="All 2 branches covered.">			for (int e = 0; e &lt; m;) {</span>
<span class="fc" id="L1365">				int u = Graphs.randVertex(g, rand), v = Graphs.randVertex(g, rand);</span>
<span class="pc bpc" id="L1366" title="1 of 4 branches missed.">				if (!allowSelfEdges &amp;&amp; u == v)</span>
<span class="fc" id="L1367">					continue;</span>
<span class="fc bfc" id="L1368" title="All 2 branches covered.">				if (!allowParallelEdges) {</span>
<span class="fc" id="L1369">					int u1 = u, v1 = v;</span>
<span class="fc bfc" id="L1370" title="All 4 branches covered.">					if (!directed &amp;&amp; u1 &lt; v1) {</span>
<span class="fc" id="L1371">						int tmp = u1;</span>
<span class="fc" id="L1372">						u1 = v1;</span>
<span class="fc" id="L1373">						v1 = tmp;</span>
					}
<span class="fc" id="L1375">					long key = JGAlgoUtils.longPack(u1, v1);</span>
<span class="fc bfc" id="L1376" title="All 2 branches covered.">					if (!existingEdges.add(key))</span>
<span class="fc" id="L1377">						continue;</span>
				}
<span class="fc" id="L1379">				g.addEdge(u, v);</span>
<span class="fc" id="L1380">				e++;</span>
<span class="fc" id="L1381">			}</span>
<span class="fc" id="L1382">			g = graphImplementation.apply(g);</span>
<span class="fc" id="L1383">		}</span>

		void setup(String args, Supplier&lt;IndexGraph&gt; graphImplementation, boolean directed, boolean allowParallelEdges,
				boolean allowSelfEdges) {
<span class="fc" id="L1387">			setup(args, g -&gt; {</span>
<span class="pc bnc" id="L1388" title="All 2 branches missed.">				assert g.isDirected() == directed;</span>
<span class="fc" id="L1389">				IndexGraph g1 = graphImplementation.get();</span>
<span class="pc bnc" id="L1390" title="All 2 branches missed.">				assert g1.isDirected() == directed;</span>
<span class="fc bfc" id="L1391" title="All 2 branches covered.">				for (int n = g.vertices().size(), v = 0; v &lt; n; v++)</span>
<span class="fc" id="L1392">					g1.addVertex();</span>
<span class="fc bfc" id="L1393" title="All 2 branches covered.">				for (int e = 0; e &lt; m; e++)</span>
<span class="fc" id="L1394">					g1.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L1395">				return g1;</span>
			}, directed, allowParallelEdges, allowSelfEdges);
<span class="fc" id="L1397">		}</span>

		void restoreGraph() {
<span class="fc" id="L1400">			final boolean allowSelfEdges = g.isAllowSelfEdges();</span>
<span class="fc" id="L1401">			final boolean allowParallelEdges = g.isAllowParallelEdges();</span>
<span class="pc bpc" id="L1402" title="1 of 2 branches missed.">			while (g.vertices().size() &lt; n)</span>
<span class="nc" id="L1403">				g.addVertex();</span>
<span class="pc bpc" id="L1404" title="1 of 2 branches missed.">			while (g.edges().size() &lt; m) {</span>
<span class="nc" id="L1405">				int u = Graphs.randVertex(g, rand), v = Graphs.randVertex(g, rand);</span>
<span class="nc bnc" id="L1406" title="All 4 branches missed.">				if (!allowSelfEdges &amp;&amp; u == v)</span>
<span class="nc" id="L1407">					continue;</span>
<span class="nc bnc" id="L1408" title="All 4 branches missed.">				if (!allowParallelEdges &amp;&amp; g.getEdge(u, v) != -1)</span>
<span class="nc" id="L1409">					continue;</span>
<span class="nc" id="L1410">				g.addEdge(u, v);</span>
<span class="nc" id="L1411">			}</span>
<span class="fc" id="L1412">		}</span>

<span class="fc" id="L1414">		public static class Edge extends Remove {</span>

			private IntIterator removeEIter;

			private static final int OperationsPerInvocation = 100;

			@Override
			void setup(String args, Function&lt;IndexGraph, IndexGraph&gt; graphImplementation, boolean directed,
					boolean allowParallelEdges, boolean allowSelfEdges) {
<span class="fc" id="L1423">				super.setup(args, graphImplementation, directed, allowParallelEdges, allowSelfEdges);</span>

<span class="pc bnc" id="L1425" title="All 2 branches missed.">				assert m &gt; OperationsPerInvocation;</span>
<span class="fc" id="L1426">				int[] removeEdges = TestUtils.randArray(m * 16, 0, m - OperationsPerInvocation, rand.nextLong());</span>
<span class="fc" id="L1427">				removeEIter = circularIterator(IntImmutableList.of(removeEdges));</span>
<span class="fc" id="L1428">			}</span>

			private void bench(Blackhole blackhole) {
<span class="fc bfc" id="L1431" title="All 2 branches covered.">				for (int o = 0; o &lt; OperationsPerInvocation; o++) {</span>
<span class="fc" id="L1432">					int e = removeEIter.nextInt();</span>
<span class="fc" id="L1433">					g.removeEdge(e);</span>
<span class="fc" id="L1434">					blackhole.consume(e);</span>
<span class="fc" id="L1435">					blackhole.consume(g);</span>
				}
<span class="fc" id="L1437">			}</span>

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1445">			public static class ArrayDirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1452">					setup(args, IndexGraphFactory.newDirected().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, true, true,</span>
							false);
<span class="fc" id="L1454">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1459">					super.restoreGraph();</span>
<span class="fc" id="L1460">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1465">					super.bench(blackhole);</span>
<span class="fc" id="L1466">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1475">			public static class ArrayUndirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1482">					setup(args, IndexGraphFactory.newUndirected().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, false, true,</span>
							false);
<span class="fc" id="L1484">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1489">					super.restoreGraph();</span>
<span class="fc" id="L1490">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1495">					super.bench(blackhole);</span>
<span class="fc" id="L1496">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1505">			public static class LinkedDirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1512">					setup(args, IndexGraphFactory.newDirected().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, true, true,</span>
							false);
<span class="fc" id="L1514">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1519">					super.restoreGraph();</span>
<span class="fc" id="L1520">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1525">					super.bench(blackhole);</span>
<span class="fc" id="L1526">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1535">			public static class LinkedUndirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1542">					setup(args, IndexGraphFactory.newUndirected().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, false,</span>
							true, false);
<span class="fc" id="L1544">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1549">					super.restoreGraph();</span>
<span class="fc" id="L1550">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1555">					super.bench(blackhole);</span>
<span class="fc" id="L1556">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1565">			public static class LinkedPtrDirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1572">					setup(args, IndexGraphFactory.newDirected().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, true,</span>
							true, false);
<span class="fc" id="L1574">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1579">					super.restoreGraph();</span>
<span class="fc" id="L1580">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1585">					super.bench(blackhole);</span>
<span class="fc" id="L1586">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1595">			public static class LinkedPtrUndirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1602">					setup(args, IndexGraphFactory.newUndirected().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, false,</span>
							true, false);
<span class="fc" id="L1604">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1609">					super.restoreGraph();</span>
<span class="fc" id="L1610">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1615">					super.bench(blackhole);</span>
<span class="fc" id="L1616">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1625">			public static class HashtableDirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1632">					setup(args, IndexGraphFactory.newDirected().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, true, false,</span>
							false);
<span class="fc" id="L1634">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1639">					super.restoreGraph();</span>
<span class="fc" id="L1640">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1645">					super.bench(blackhole);</span>
<span class="fc" id="L1646">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1655">			public static class HashtableUndirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1662">					setup(args, IndexGraphFactory.newUndirected().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, false,</span>
							false, false);
<span class="fc" id="L1664">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1669">					super.restoreGraph();</span>
<span class="fc" id="L1670">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1675">					super.bench(blackhole);</span>
<span class="fc" id="L1676">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1685">			public static class MatrixDirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1692">					setup(args, IndexGraphFactory.newDirected().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, true, false,</span>
							false);
<span class="fc" id="L1694">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1699">					super.restoreGraph();</span>
<span class="fc" id="L1700">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1705">					super.bench(blackhole);</span>
<span class="fc" id="L1706">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1715">			public static class MatrixUndirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1722">					setup(args, IndexGraphFactory.newUndirected().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, false, false,</span>
							false);
<span class="fc" id="L1724">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1729">					super.restoreGraph();</span>
<span class="fc" id="L1730">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1735">					super.bench(blackhole);</span>
<span class="fc" id="L1736">				}</span>
			}

		}

<span class="fc" id="L1741">		public static class Vertex extends Remove {</span>

			private IntIterator removeVIter;

			private static final int OperationsPerInvocation = 50;

			@Override
			void setup(String args, Function&lt;IndexGraph, IndexGraph&gt; graphImplementation, boolean directed,
					boolean allowParallelEdges, boolean allowSelfEdges) {
<span class="fc" id="L1750">				super.setup(args, graphImplementation, directed, allowParallelEdges, allowSelfEdges);</span>

<span class="pc bnc" id="L1752" title="All 2 branches missed.">				assert n &gt; OperationsPerInvocation;</span>
<span class="fc" id="L1753">				int[] removeVertices = TestUtils.randArray(n * 16, 0, n - OperationsPerInvocation, rand.nextLong());</span>
<span class="fc" id="L1754">				removeVIter = circularIterator(IntImmutableList.of(removeVertices));</span>
<span class="fc" id="L1755">			}</span>

			private void bench(Blackhole blackhole) {
<span class="fc bfc" id="L1758" title="All 2 branches covered.">				for (int o = 0; o &lt; OperationsPerInvocation; o++) {</span>
<span class="fc" id="L1759">					int v = removeVIter.nextInt();</span>
<span class="fc" id="L1760">					g.removeEdge(v);</span>
<span class="fc" id="L1761">					blackhole.consume(v);</span>
<span class="fc" id="L1762">					blackhole.consume(g);</span>
				}
<span class="fc" id="L1764">			}</span>

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1772">			public static class ArrayDirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1779">					setup(args, IndexGraphFactory.newDirected().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, true, true,</span>
							false);
<span class="fc" id="L1781">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1786">					super.restoreGraph();</span>
<span class="fc" id="L1787">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1792">					super.bench(blackhole);</span>
<span class="fc" id="L1793">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1802">			public static class ArrayUndirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1809">					setup(args, IndexGraphFactory.newUndirected().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, false, true,</span>
							false);
<span class="fc" id="L1811">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1816">					super.restoreGraph();</span>

<span class="fc" id="L1818">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1823">					super.bench(blackhole);</span>
<span class="fc" id="L1824">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1833">			public static class LinkedDirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1840">					setup(args, IndexGraphFactory.newDirected().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, true, true,</span>
							false);
<span class="fc" id="L1842">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1847">					super.restoreGraph();</span>

<span class="fc" id="L1849">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1854">					super.bench(blackhole);</span>
<span class="fc" id="L1855">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1864">			public static class LinkedUndirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1871">					setup(args, IndexGraphFactory.newUndirected().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, false,</span>
							true, false);
<span class="fc" id="L1873">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1878">					super.restoreGraph();</span>

<span class="fc" id="L1880">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1885">					super.bench(blackhole);</span>
<span class="fc" id="L1886">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1895">			public static class LinkedPtrDirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1902">					setup(args, IndexGraphFactory.newDirected().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, true,</span>
							true, false);
<span class="fc" id="L1904">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1909">					super.restoreGraph();</span>

<span class="fc" id="L1911">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1916">					super.bench(blackhole);</span>
<span class="fc" id="L1917">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1926">			public static class LinkedPtrUndirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1933">					setup(args, IndexGraphFactory.newUndirected().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, false,</span>
							true, false);
<span class="fc" id="L1935">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1940">					super.restoreGraph();</span>

<span class="fc" id="L1942">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1947">					super.bench(blackhole);</span>
<span class="fc" id="L1948">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1957">			public static class HashtableDirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1964">					setup(args, IndexGraphFactory.newDirected().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, true, false,</span>
							false);
<span class="fc" id="L1966">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1971">					super.restoreGraph();</span>

<span class="fc" id="L1973">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1978">					super.bench(blackhole);</span>
<span class="fc" id="L1979">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1988">			public static class HashtableUndirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1995">					setup(args, IndexGraphFactory.newUndirected().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, false,</span>
							false, false);
<span class="fc" id="L1997">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2002">					super.restoreGraph();</span>

<span class="fc" id="L2004">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2009">					super.bench(blackhole);</span>
<span class="fc" id="L2010">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2019">			public static class MatrixDirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2026">					setup(args, IndexGraphFactory.newDirected().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, true, false,</span>
							false);
<span class="fc" id="L2028">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2033">					super.restoreGraph();</span>

<span class="fc" id="L2035">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2040">					super.bench(blackhole);</span>
<span class="fc" id="L2041">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2050">			public static class MatrixUndirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2057">					setup(args, IndexGraphFactory.newUndirected().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, false, false,</span>
							false);
<span class="fc" id="L2059">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2064">					super.restoreGraph();</span>

<span class="fc" id="L2066">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2071">					super.bench(blackhole);</span>
<span class="fc" id="L2072">				}</span>
			}

		}
	}

	static IntIterator circularIterator(IntIterable iterable) {
<span class="fc" id="L2079">		return new IntIterator() {</span>
<span class="fc" id="L2080">			IntIterator it = iterable.iterator();</span>

			@Override
			public boolean hasNext() {
<span class="nc" id="L2084">				return true;</span>
			}

			@Override
			public int nextInt() {
<span class="fc" id="L2089">				int res = it.nextInt();</span>
<span class="pc bpc" id="L2090" title="1 of 2 branches missed.">				if (!it.hasNext())</span>
<span class="nc" id="L2091">					it = iterable.iterator();</span>
<span class="fc" id="L2092">				return res;</span>
			}
		};
	}

	static LongIterator circularIterator(LongIterable iterable) {
<span class="fc" id="L2098">		return new LongIterator() {</span>
<span class="fc" id="L2099">			LongIterator it = iterable.iterator();</span>

			@Override
			public boolean hasNext() {
<span class="nc" id="L2103">				return true;</span>
			}

			@Override
			public long nextLong() {
<span class="fc" id="L2108">				long res = it.nextLong();</span>
<span class="pc bpc" id="L2109" title="1 of 2 branches missed.">				if (!it.hasNext())</span>
<span class="nc" id="L2110">					it = iterable.iterator();</span>
<span class="fc" id="L2111">				return res;</span>
			}
		};
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>