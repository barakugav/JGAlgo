<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GraphBench.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Benchmarks</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.bench.impls</a> &gt; <span class="el_source">GraphBench.java</span></div><h1>GraphBench.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.bench.impls;

import java.util.Map;
import java.util.Random;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import java.util.function.Supplier;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Fork;
import org.openjdk.jmh.annotations.Level;
import org.openjdk.jmh.annotations.Measurement;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OperationsPerInvocation;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Param;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.annotations.Warmup;
import org.openjdk.jmh.infra.Blackhole;
import com.jgalgo.bench.util.BenchUtils;
import com.jgalgo.bench.util.TestUtils;
import com.jgalgo.graph.Graphs;
import com.jgalgo.graph.IEdgeIter;
import com.jgalgo.graph.IEdgeSet;
import com.jgalgo.graph.IndexGraph;
import com.jgalgo.graph.IndexGraphBuilder;
import com.jgalgo.graph.IndexGraphFactory;
import com.jgalgo.internal.util.JGAlgoUtils;
import it.unimi.dsi.fastutil.ints.IntImmutableList;
import it.unimi.dsi.fastutil.ints.IntIterable;
import it.unimi.dsi.fastutil.ints.IntIterator;
import it.unimi.dsi.fastutil.longs.LongImmutableList;
import it.unimi.dsi.fastutil.longs.LongIterable;
import it.unimi.dsi.fastutil.longs.LongIterator;
import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
import it.unimi.dsi.fastutil.longs.LongSet;

<span class="nc" id="L55">public class GraphBench {</span>

<span class="fc" id="L57">	public static class EdgesRead {</span>

		private IndexGraph g;
		private IntIterator queryVIter;
		private LongIterator queryUVIter;

		void setup(String args, Function&lt;IndexGraph, IndexGraph&gt; graphImplementation, boolean directed,
				boolean allowParallelEdges, boolean allowSelfEdges) {
<span class="fc" id="L65">			final long seed = 0x8c91b913bfe81bb7L;</span>
<span class="fc" id="L66">			final Random rand = new Random(seed);</span>
<span class="fc" id="L67">			Map&lt;String, String&gt; argsMap = BenchUtils.parseArgsStr(args);</span>
<span class="fc" id="L68">			final int n = Integer.parseInt(argsMap.get(&quot;|V|&quot;));</span>
<span class="fc" id="L69">			final int m = Integer.parseInt(argsMap.get(&quot;|E|&quot;));</span>

<span class="fc" id="L71">			g = IndexGraphFactory.newInstance(directed).allowSelfEdges().newGraph();</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">			for (int v = 0; v &lt; n; v++)</span>
<span class="fc" id="L73">				g.addVertex();</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">			LongSet existingEdges = allowParallelEdges ? null : new LongOpenHashSet();</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">			for (int e = 0; e &lt; m;) {</span>
<span class="fc" id="L76">				int u = Graphs.randVertex(g, rand), v = Graphs.randVertex(g, rand);</span>
<span class="fc bfc" id="L77" title="All 4 branches covered.">				if (!allowSelfEdges &amp;&amp; u == v)</span>
<span class="fc" id="L78">					continue;</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">				if (!allowParallelEdges) {</span>
<span class="fc" id="L80">					int u1 = u, v1 = v;</span>
<span class="fc bfc" id="L81" title="All 4 branches covered.">					if (!directed &amp;&amp; u1 &lt; v1) {</span>
<span class="fc" id="L82">						int tmp = u1;</span>
<span class="fc" id="L83">						u1 = v1;</span>
<span class="fc" id="L84">						v1 = tmp;</span>
					}
<span class="fc" id="L86">					long key = JGAlgoUtils.longPack(u1, v1);</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">					if (!existingEdges.add(key))</span>
<span class="fc" id="L88">						continue;</span>
				}
<span class="fc" id="L90">				g.addEdge(u, v);</span>
<span class="fc" id="L91">				e++;</span>
<span class="fc" id="L92">			}</span>
<span class="fc" id="L93">			g = graphImplementation.apply(g);</span>

<span class="fc" id="L95">			int[] queryVertices = TestUtils.randArray(n * 16, 0, n, seed);</span>
<span class="fc" id="L96">			queryVIter = circularIterator(IntImmutableList.of(queryVertices));</span>

<span class="fc" id="L98">			int[] queryUVertices = TestUtils.randArray(n * 32, 0, n, seed);</span>
<span class="fc" id="L99">			long[] queryUVertices0 = new long[queryUVertices.length / 2];</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">			for (int q = 0; q &lt; queryUVertices0.length; q++) {</span>
				int u, v;
<span class="fc bfc" id="L102" title="All 2 branches covered.">				if (rand.nextBoolean()) {</span>
<span class="fc" id="L103">					u = queryUVertices[q * 2 + 0];</span>
<span class="fc" id="L104">					v = queryUVertices[q * 2 + 1];</span>
				} else {
<span class="fc" id="L106">					int e = Graphs.randEdge(g, rand);</span>
<span class="fc" id="L107">					u = g.edgeSource(e);</span>
<span class="fc" id="L108">					v = g.edgeTarget(e);</span>
<span class="fc bfc" id="L109" title="All 4 branches covered.">					if (!directed &amp;&amp; rand.nextBoolean()) {</span>
<span class="fc" id="L110">						int tmp = u;</span>
<span class="fc" id="L111">						u = v;</span>
<span class="fc" id="L112">						v = tmp;</span>
					}
				}
<span class="fc" id="L115">				queryUVertices0[q] = JGAlgoUtils.longPack(u, v);</span>
			}
<span class="fc" id="L117">			queryUVIter = circularIterator(LongImmutableList.of(queryUVertices0));</span>
<span class="fc" id="L118">		}</span>

		void setup(String args, Supplier&lt;IndexGraph&gt; graphImplementation, boolean directed, boolean allowParallelEdges,
				boolean allowSelfEdges) {
<span class="fc" id="L122">			setup(args, g -&gt; {</span>
<span class="pc bnc" id="L123" title="All 2 branches missed.">				assert g.isDirected() == directed;</span>
<span class="fc" id="L124">				IndexGraph g1 = graphImplementation.get();</span>
<span class="pc bnc" id="L125" title="All 2 branches missed.">				assert g1.isDirected() == directed;</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">				for (int n = g.vertices().size(), v = 0; v &lt; n; v++)</span>
<span class="fc" id="L127">					g1.addVertex();</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">				for (int m = g.edges().size(), e = 0; e &lt; m; e++)</span>
<span class="fc" id="L129">					g1.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L130">				return g1;</span>
			}, directed, allowParallelEdges, allowSelfEdges);
<span class="fc" id="L132">		}</span>

		private void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L135">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L136">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc" id="L137">			blackhole.consume(edgeSet);</span>
<span class="fc" id="L138">		}</span>

		private void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L141">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L142">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc" id="L143">			blackhole.consume(edgeSet.size());</span>
<span class="fc" id="L144">		}</span>

		private void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L147">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L148">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();)</span>
<span class="fc" id="L150">				blackhole.consume(eit.nextInt());</span>
<span class="fc" id="L151">		}</span>

		private void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L154">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L155">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();) {</span>
<span class="fc" id="L157">				eit.nextInt();</span>
<span class="fc" id="L158">				blackhole.consume(eit.sourceInt());</span>
			}
<span class="fc" id="L160">		}</span>

		private void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L163">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L164">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();) {</span>
<span class="fc" id="L166">				eit.nextInt();</span>
<span class="fc" id="L167">				blackhole.consume(eit.targetInt());</span>
			}
<span class="fc" id="L169">		}</span>

		private void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L172">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L173">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc" id="L174">			blackhole.consume(edgeSet);</span>
<span class="fc" id="L175">		}</span>

		private void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L178">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L179">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc" id="L180">			blackhole.consume(edgeSet.size());</span>
<span class="fc" id="L181">		}</span>

		private void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L184">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L185">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();)</span>
<span class="fc" id="L187">				blackhole.consume(eit.nextInt());</span>
<span class="fc" id="L188">		}</span>

		private void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L191">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L192">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();) {</span>
<span class="fc" id="L194">				eit.nextInt();</span>
<span class="fc" id="L195">				blackhole.consume(eit.sourceInt());</span>
			}
<span class="fc" id="L197">		}</span>

		private void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L200">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L201">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();) {</span>
<span class="fc" id="L203">				eit.nextInt();</span>
<span class="fc" id="L204">				blackhole.consume(eit.targetInt());</span>
			}
<span class="fc" id="L206">		}</span>

		private void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L209">			long l = queryUVIter.nextLong();</span>
<span class="fc" id="L210">			int u = JGAlgoUtils.long2low(l);</span>
<span class="fc" id="L211">			int v = JGAlgoUtils.long2high(l);</span>
<span class="fc" id="L212">			blackhole.consume(g.getEdge(u, v));</span>
<span class="fc" id="L213">		}</span>

		private void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L216">			long l = queryUVIter.nextLong();</span>
<span class="fc" id="L217">			int u = JGAlgoUtils.long2low(l);</span>
<span class="fc" id="L218">			int v = JGAlgoUtils.long2high(l);</span>
<span class="fc" id="L219">			blackhole.consume(g.getEdges(u, v));</span>
<span class="fc" id="L220">		}</span>

		private void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L223">			long l = queryUVIter.nextLong();</span>
<span class="fc" id="L224">			int u = JGAlgoUtils.long2low(l);</span>
<span class="fc" id="L225">			int v = JGAlgoUtils.long2high(l);</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">			for (IEdgeIter eit = g.getEdges(u, v).iterator(); eit.hasNext();)</span>
<span class="fc" id="L227">				blackhole.consume(eit.nextInt());</span>
<span class="fc" id="L228">		}</span>

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L236">		public static class ArrayDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L243">				setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, true, true, false);</span>
<span class="fc" id="L244">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L248">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L249">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L253">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L254">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L258">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L259">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L263">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L264">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L268">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L269">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L273">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L274">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L278">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L279">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L283">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L284">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L288">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L289">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L293">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L294">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L298">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L299">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L303">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L304">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L308">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L309">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L318">		public static class ArrayUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L325">				setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, false, true, false);</span>
<span class="fc" id="L326">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L330">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L331">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L335">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L336">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L340">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L341">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L345">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L346">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L350">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L351">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L355">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L356">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L360">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L361">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L365">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L366">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L370">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L371">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L375">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L376">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L380">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L381">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L385">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L386">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L390">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L391">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L400">		public static class LinkedDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L407">				setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, true, true, false);</span>
<span class="fc" id="L408">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L412">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L413">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L417">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L418">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L422">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L423">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L427">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L428">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L432">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L433">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L437">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L438">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L442">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L443">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L447">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L448">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L452">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L453">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L457">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L458">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L462">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L463">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L467">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L468">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L472">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L473">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L482">		public static class LinkedUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L489">				setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, false, true,</span>
						false);
<span class="fc" id="L491">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L495">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L496">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L500">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L501">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L505">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L506">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L510">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L511">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L515">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L516">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L520">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L521">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L525">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L526">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L530">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L531">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L535">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L536">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L540">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L541">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L545">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L546">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L550">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L551">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L555">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L556">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L565">		public static class LinkedPtrDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L572">				setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, true, true,</span>
						false);
<span class="fc" id="L574">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L578">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L579">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L583">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L584">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L588">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L589">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L593">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L594">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L598">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L599">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L603">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L604">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L608">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L609">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L613">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L614">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L618">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L619">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L623">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L624">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L628">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L629">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L633">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L634">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L638">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L639">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L648">		public static class LinkedPtrUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L655">				setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, false, true,</span>
						false);
<span class="fc" id="L657">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L661">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L662">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L666">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L667">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L671">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L672">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L676">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L677">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L681">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L682">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L686">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L687">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L691">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L692">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L696">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L697">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L701">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L702">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L706">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L707">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L711">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L712">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L716">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L717">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L721">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L722">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L731">		public static class HashtableDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L738">				setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, true, false, false);</span>
<span class="fc" id="L739">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L743">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L744">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L748">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L749">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L753">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L754">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L758">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L759">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L763">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L764">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L768">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L769">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L773">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L774">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L778">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L779">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L783">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L784">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L788">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L789">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L793">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L794">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L798">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L799">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L803">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L804">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L813">		public static class HashtableUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L820">				setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, false, false,</span>
						false);
<span class="fc" id="L822">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L826">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L827">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L831">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L832">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L836">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L837">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L841">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L842">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L846">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L847">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L851">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L852">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L856">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L857">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L861">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L862">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L866">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L867">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L871">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L872">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L876">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L877">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L881">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L882">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L886">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L887">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L896">		public static class MatrixDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L903">				setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, true, false, false);</span>
<span class="fc" id="L904">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L908">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L909">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L913">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L914">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L918">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L919">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L923">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L924">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L928">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L929">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L933">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L934">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L938">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L939">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L943">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L944">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L948">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L949">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L953">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L954">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L958">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L959">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L963">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L964">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L968">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L969">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L978">		public static class MatrixUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L985">				setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, false, false, false);</span>
<span class="fc" id="L986">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L990">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L991">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L995">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L996">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1000">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L1001">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1005">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L1006">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1010">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L1011">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L1015">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L1016">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1020">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L1021">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1025">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L1026">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1030">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L1031">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1035">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L1036">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L1040">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L1041">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L1045">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L1046">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1050">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L1051">			}</span>
		}

<span class="fc" id="L1054">		@BenchmarkMode(Mode.AverageTime)</span>
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L1060">		public static class CsrDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L1067">				final boolean directed = true;</span>
<span class="fc" id="L1068">				final boolean allowParallelEdges = true;</span>
<span class="fc" id="L1069">				final boolean allowSelfEdges = true;</span>
<span class="fc" id="L1070">				setup(args, g -&gt; {</span>
<span class="pc bnc" id="L1071" title="All 2 branches missed.">					assert g.isDirected() == directed;</span>
<span class="fc" id="L1072">					IndexGraphBuilder g1 = IndexGraphBuilder.directed();</span>
<span class="fc bfc" id="L1073" title="All 2 branches covered.">					for (int n = g.vertices().size(), v = 0; v &lt; n; v++)</span>
<span class="fc" id="L1074">						g1.addVertex();</span>
<span class="fc bfc" id="L1075" title="All 2 branches covered.">					for (int m = g.edges().size(), e = 0; e &lt; m; e++)</span>
<span class="fc" id="L1076">						g1.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L1077">					IndexGraph g1Graph = g1.build();</span>
<span class="pc bnc" id="L1078" title="All 2 branches missed.">					assert g1Graph.isDirected() == directed;</span>
<span class="fc" id="L1079">					return g1Graph;</span>
				}, directed, allowParallelEdges, allowSelfEdges);
<span class="fc" id="L1081">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L1085">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L1086">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1090">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L1091">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1095">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L1096">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1100">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L1101">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1105">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L1106">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L1110">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L1111">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1115">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L1116">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1120">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L1121">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1125">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L1126">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1130">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L1131">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L1135">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L1136">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L1140">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L1141">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1145">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L1146">			}</span>
		}

<span class="fc" id="L1149">		@BenchmarkMode(Mode.AverageTime)</span>
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L1155">		public static class CsrUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L1162">				final boolean directed = false;</span>
<span class="fc" id="L1163">				final boolean allowParallelEdges = true;</span>
<span class="fc" id="L1164">				final boolean allowSelfEdges = true;</span>
<span class="fc" id="L1165">				setup(args, g -&gt; {</span>
<span class="pc bnc" id="L1166" title="All 2 branches missed.">					assert g.isDirected() == directed;</span>
<span class="fc" id="L1167">					IndexGraphBuilder g1 = IndexGraphBuilder.undirected();</span>
<span class="fc bfc" id="L1168" title="All 2 branches covered.">					for (int n = g.vertices().size(), v = 0; v &lt; n; v++)</span>
<span class="fc" id="L1169">						g1.addVertex();</span>
<span class="fc bfc" id="L1170" title="All 2 branches covered.">					for (int m = g.edges().size(), e = 0; e &lt; m; e++)</span>
<span class="fc" id="L1171">						g1.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L1172">					IndexGraph g1Graph = g1.build();</span>
<span class="pc bnc" id="L1173" title="All 2 branches missed.">					assert g1Graph.isDirected() == directed;</span>
<span class="fc" id="L1174">					return g1Graph;</span>
				}, directed, allowParallelEdges, allowSelfEdges);
<span class="fc" id="L1176">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L1180">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L1181">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1185">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L1186">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1190">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L1191">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1195">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L1196">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1200">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L1201">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L1205">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L1206">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1210">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L1211">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1215">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L1216">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1220">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L1221">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1225">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L1226">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L1230">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L1231">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L1235">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L1236">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1240">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L1241">			}</span>
		}

<span class="fc" id="L1244">		@BenchmarkMode(Mode.AverageTime)</span>
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L1250">		public static class CsrDirectedReindexed extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L1257">				final boolean directed = true;</span>
<span class="fc" id="L1258">				final boolean allowParallelEdges = true;</span>
<span class="fc" id="L1259">				final boolean allowSelfEdges = true;</span>
<span class="fc" id="L1260">				setup(args, g -&gt; {</span>
<span class="pc bnc" id="L1261" title="All 2 branches missed.">					assert g.isDirected() == directed;</span>
<span class="fc" id="L1262">					IndexGraphBuilder g1 = IndexGraphBuilder.directed();</span>
<span class="fc bfc" id="L1263" title="All 2 branches covered.">					for (int n = g.vertices().size(), v = 0; v &lt; n; v++)</span>
<span class="fc" id="L1264">						g1.addVertex();</span>
<span class="fc bfc" id="L1265" title="All 2 branches covered.">					for (int m = g.edges().size(), e = 0; e &lt; m; e++)</span>
<span class="fc" id="L1266">						g1.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L1267">					IndexGraph g1Graph = g1.reIndexAndBuild(true, true).graph();</span>
<span class="pc bnc" id="L1268" title="All 2 branches missed.">					assert g1Graph.isDirected() == directed;</span>
<span class="fc" id="L1269">					return g1Graph;</span>
				}, directed, allowParallelEdges, allowSelfEdges);
<span class="fc" id="L1271">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L1275">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L1276">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1280">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L1281">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1285">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L1286">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1290">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L1291">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1295">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L1296">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L1300">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L1301">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1305">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L1306">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1310">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L1311">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1315">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L1316">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1320">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L1321">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L1325">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L1326">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L1330">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L1331">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1335">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L1336">			}</span>
		}

	}

<span class="fc" id="L1341">	public static class Remove {</span>

		IndexGraph g;
		int n, m;
		Random rand;

		void setup(String args, Function&lt;IndexGraph, IndexGraph&gt; graphImplementation, boolean directed,
				boolean allowParallelEdges, boolean allowSelfEdges) {
<span class="fc" id="L1349">			final long seed = 0x850a14ff3dad400cL;</span>
<span class="fc" id="L1350">			rand = new Random(seed);</span>
<span class="fc" id="L1351">			Map&lt;String, String&gt; argsMap = BenchUtils.parseArgsStr(args);</span>
<span class="fc" id="L1352">			n = Integer.parseInt(argsMap.get(&quot;|V|&quot;));</span>
<span class="fc" id="L1353">			m = Integer.parseInt(argsMap.get(&quot;|E|&quot;));</span>

<span class="fc" id="L1355">			g = IndexGraphFactory.newInstance(directed).allowSelfEdges(allowSelfEdges)</span>
<span class="fc" id="L1356">					.allowParallelEdges(allowParallelEdges).newGraph();</span>
<span class="fc bfc" id="L1357" title="All 2 branches covered.">			for (int v = 0; v &lt; n; v++)</span>
<span class="fc" id="L1358">				g.addVertex();</span>
<span class="fc bfc" id="L1359" title="All 2 branches covered.">			LongSet existingEdges = allowParallelEdges ? null : new LongOpenHashSet();</span>
<span class="fc bfc" id="L1360" title="All 2 branches covered.">			for (int e = 0; e &lt; m;) {</span>
<span class="fc" id="L1361">				int u = Graphs.randVertex(g, rand), v = Graphs.randVertex(g, rand);</span>
<span class="pc bpc" id="L1362" title="1 of 4 branches missed.">				if (!allowSelfEdges &amp;&amp; u == v)</span>
<span class="fc" id="L1363">					continue;</span>
<span class="fc bfc" id="L1364" title="All 2 branches covered.">				if (!allowParallelEdges) {</span>
<span class="fc" id="L1365">					int u1 = u, v1 = v;</span>
<span class="fc bfc" id="L1366" title="All 4 branches covered.">					if (!directed &amp;&amp; u1 &lt; v1) {</span>
<span class="fc" id="L1367">						int tmp = u1;</span>
<span class="fc" id="L1368">						u1 = v1;</span>
<span class="fc" id="L1369">						v1 = tmp;</span>
					}
<span class="fc" id="L1371">					long key = JGAlgoUtils.longPack(u1, v1);</span>
<span class="fc bfc" id="L1372" title="All 2 branches covered.">					if (!existingEdges.add(key))</span>
<span class="fc" id="L1373">						continue;</span>
				}
<span class="fc" id="L1375">				g.addEdge(u, v);</span>
<span class="fc" id="L1376">				e++;</span>
<span class="fc" id="L1377">			}</span>
<span class="fc" id="L1378">			g = graphImplementation.apply(g);</span>
<span class="fc" id="L1379">		}</span>

		void setup(String args, Supplier&lt;IndexGraph&gt; graphImplementation, boolean directed, boolean allowParallelEdges,
				boolean allowSelfEdges) {
<span class="fc" id="L1383">			setup(args, g -&gt; {</span>
<span class="pc bnc" id="L1384" title="All 2 branches missed.">				assert g.isDirected() == directed;</span>
<span class="fc" id="L1385">				IndexGraph g1 = graphImplementation.get();</span>
<span class="pc bnc" id="L1386" title="All 2 branches missed.">				assert g1.isDirected() == directed;</span>
<span class="fc bfc" id="L1387" title="All 2 branches covered.">				for (int n = g.vertices().size(), v = 0; v &lt; n; v++)</span>
<span class="fc" id="L1388">					g1.addVertex();</span>
<span class="fc bfc" id="L1389" title="All 2 branches covered.">				for (int e = 0; e &lt; m; e++)</span>
<span class="fc" id="L1390">					g1.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L1391">				return g1;</span>
			}, directed, allowParallelEdges, allowSelfEdges);
<span class="fc" id="L1393">		}</span>

		void restoreGraph() {
<span class="fc" id="L1396">			final boolean allowSelfEdges = g.isAllowSelfEdges();</span>
<span class="fc" id="L1397">			final boolean allowParallelEdges = g.isAllowParallelEdges();</span>
<span class="pc bpc" id="L1398" title="1 of 2 branches missed.">			while (g.vertices().size() &lt; n)</span>
<span class="nc" id="L1399">				g.addVertex();</span>
<span class="pc bpc" id="L1400" title="1 of 2 branches missed.">			while (g.edges().size() &lt; m) {</span>
<span class="nc" id="L1401">				int u = Graphs.randVertex(g, rand), v = Graphs.randVertex(g, rand);</span>
<span class="nc bnc" id="L1402" title="All 4 branches missed.">				if (!allowSelfEdges &amp;&amp; u == v)</span>
<span class="nc" id="L1403">					continue;</span>
<span class="nc bnc" id="L1404" title="All 4 branches missed.">				if (!allowParallelEdges &amp;&amp; g.getEdge(u, v) != -1)</span>
<span class="nc" id="L1405">					continue;</span>
<span class="nc" id="L1406">				g.addEdge(u, v);</span>
<span class="nc" id="L1407">			}</span>
<span class="fc" id="L1408">		}</span>

<span class="fc" id="L1410">		public static class Edge extends Remove {</span>

			private IntIterator removeEIter;

			private static final int OperationsPerInvocation = 100;

			@Override
			void setup(String args, Function&lt;IndexGraph, IndexGraph&gt; graphImplementation, boolean directed,
					boolean allowParallelEdges, boolean allowSelfEdges) {
<span class="fc" id="L1419">				super.setup(args, graphImplementation, directed, allowParallelEdges, allowSelfEdges);</span>

<span class="pc bnc" id="L1421" title="All 2 branches missed.">				assert m &gt; OperationsPerInvocation;</span>
<span class="fc" id="L1422">				int[] removeEdges = TestUtils.randArray(m * 16, 0, m - OperationsPerInvocation, rand.nextLong());</span>
<span class="fc" id="L1423">				removeEIter = circularIterator(IntImmutableList.of(removeEdges));</span>
<span class="fc" id="L1424">			}</span>

			private void bench(Blackhole blackhole) {
<span class="fc bfc" id="L1427" title="All 2 branches covered.">				for (int o = 0; o &lt; OperationsPerInvocation; o++) {</span>
<span class="fc" id="L1428">					int e = removeEIter.nextInt();</span>
<span class="fc" id="L1429">					g.removeEdge(e);</span>
<span class="fc" id="L1430">					blackhole.consume(e);</span>
<span class="fc" id="L1431">					blackhole.consume(g);</span>
				}
<span class="fc" id="L1433">			}</span>

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1441">			public static class ArrayDirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1448">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, true, true, false);</span>
<span class="fc" id="L1449">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1454">					super.restoreGraph();</span>
<span class="fc" id="L1455">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1460">					super.bench(blackhole);</span>
<span class="fc" id="L1461">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1470">			public static class ArrayUndirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1477">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, false, true,</span>
							false);
<span class="fc" id="L1479">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1484">					super.restoreGraph();</span>
<span class="fc" id="L1485">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1490">					super.bench(blackhole);</span>
<span class="fc" id="L1491">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1500">			public static class LinkedDirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1507">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, true, true,</span>
							false);
<span class="fc" id="L1509">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1514">					super.restoreGraph();</span>
<span class="fc" id="L1515">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1520">					super.bench(blackhole);</span>
<span class="fc" id="L1521">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1530">			public static class LinkedUndirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1537">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, false, true,</span>
							false);
<span class="fc" id="L1539">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1544">					super.restoreGraph();</span>
<span class="fc" id="L1545">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1550">					super.bench(blackhole);</span>
<span class="fc" id="L1551">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1560">			public static class LinkedPtrDirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1567">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, true, true,</span>
							false);
<span class="fc" id="L1569">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1574">					super.restoreGraph();</span>
<span class="fc" id="L1575">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1580">					super.bench(blackhole);</span>
<span class="fc" id="L1581">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1590">			public static class LinkedPtrUndirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1597">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, false,</span>
							true, false);
<span class="fc" id="L1599">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1604">					super.restoreGraph();</span>
<span class="fc" id="L1605">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1610">					super.bench(blackhole);</span>
<span class="fc" id="L1611">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1620">			public static class HashtableDirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1627">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, true, false,</span>
							false);
<span class="fc" id="L1629">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1634">					super.restoreGraph();</span>
<span class="fc" id="L1635">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1640">					super.bench(blackhole);</span>
<span class="fc" id="L1641">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1650">			public static class HashtableUndirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1657">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, false, false,</span>
							false);
<span class="fc" id="L1659">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1664">					super.restoreGraph();</span>
<span class="fc" id="L1665">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1670">					super.bench(blackhole);</span>
<span class="fc" id="L1671">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1680">			public static class MatrixDirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1687">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, true, false, false);</span>
<span class="fc" id="L1688">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1693">					super.restoreGraph();</span>
<span class="fc" id="L1694">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1699">					super.bench(blackhole);</span>
<span class="fc" id="L1700">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1709">			public static class MatrixUndirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1716">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, false, false,</span>
							false);
<span class="fc" id="L1718">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1723">					super.restoreGraph();</span>
<span class="fc" id="L1724">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1729">					super.bench(blackhole);</span>
<span class="fc" id="L1730">				}</span>
			}

		}

<span class="fc" id="L1735">		public static class Vertex extends Remove {</span>

			private IntIterator removeVIter;

			private static final int OperationsPerInvocation = 50;

			@Override
			void setup(String args, Function&lt;IndexGraph, IndexGraph&gt; graphImplementation, boolean directed,
					boolean allowParallelEdges, boolean allowSelfEdges) {
<span class="fc" id="L1744">				super.setup(args, graphImplementation, directed, allowParallelEdges, allowSelfEdges);</span>

<span class="pc bnc" id="L1746" title="All 2 branches missed.">				assert n &gt; OperationsPerInvocation;</span>
<span class="fc" id="L1747">				int[] removeVertices = TestUtils.randArray(n * 16, 0, n - OperationsPerInvocation, rand.nextLong());</span>
<span class="fc" id="L1748">				removeVIter = circularIterator(IntImmutableList.of(removeVertices));</span>
<span class="fc" id="L1749">			}</span>

			private void bench(Blackhole blackhole) {
<span class="fc bfc" id="L1752" title="All 2 branches covered.">				for (int o = 0; o &lt; OperationsPerInvocation; o++) {</span>
<span class="fc" id="L1753">					int v = removeVIter.nextInt();</span>
<span class="fc" id="L1754">					g.removeEdge(v);</span>
<span class="fc" id="L1755">					blackhole.consume(v);</span>
<span class="fc" id="L1756">					blackhole.consume(g);</span>
				}
<span class="fc" id="L1758">			}</span>

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1766">			public static class ArrayDirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1773">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, true, true, false);</span>
<span class="fc" id="L1774">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1779">					super.restoreGraph();</span>
<span class="fc" id="L1780">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1785">					super.bench(blackhole);</span>
<span class="fc" id="L1786">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1795">			public static class ArrayUndirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1802">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, false, true,</span>
							false);
<span class="fc" id="L1804">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1809">					super.restoreGraph();</span>

<span class="fc" id="L1811">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1816">					super.bench(blackhole);</span>
<span class="fc" id="L1817">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1826">			public static class LinkedDirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1833">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, true, true,</span>
							false);
<span class="fc" id="L1835">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1840">					super.restoreGraph();</span>

<span class="fc" id="L1842">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1847">					super.bench(blackhole);</span>
<span class="fc" id="L1848">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1857">			public static class LinkedUndirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1864">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, false, true,</span>
							false);
<span class="fc" id="L1866">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1871">					super.restoreGraph();</span>

<span class="fc" id="L1873">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1878">					super.bench(blackhole);</span>
<span class="fc" id="L1879">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1888">			public static class LinkedPtrDirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1895">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, true, true,</span>
							false);
<span class="fc" id="L1897">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1902">					super.restoreGraph();</span>

<span class="fc" id="L1904">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1909">					super.bench(blackhole);</span>
<span class="fc" id="L1910">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1919">			public static class LinkedPtrUndirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1926">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, false,</span>
							true, false);
<span class="fc" id="L1928">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1933">					super.restoreGraph();</span>

<span class="fc" id="L1935">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1940">					super.bench(blackhole);</span>
<span class="fc" id="L1941">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1950">			public static class HashtableDirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1957">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, true, false,</span>
							false);
<span class="fc" id="L1959">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1964">					super.restoreGraph();</span>

<span class="fc" id="L1966">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1971">					super.bench(blackhole);</span>
<span class="fc" id="L1972">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1981">			public static class HashtableUndirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1988">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, false, false,</span>
							false);
<span class="fc" id="L1990">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1995">					super.restoreGraph();</span>

<span class="fc" id="L1997">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2002">					super.bench(blackhole);</span>
<span class="fc" id="L2003">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2012">			public static class MatrixDirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2019">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, true, false, false);</span>
<span class="fc" id="L2020">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2025">					super.restoreGraph();</span>

<span class="fc" id="L2027">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2032">					super.bench(blackhole);</span>
<span class="fc" id="L2033">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2042">			public static class MatrixUndirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2049">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, false, false,</span>
							false);
<span class="fc" id="L2051">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2056">					super.restoreGraph();</span>

<span class="fc" id="L2058">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2063">					super.bench(blackhole);</span>
<span class="fc" id="L2064">				}</span>
			}

		}
	}

	static IntIterator circularIterator(IntIterable iterable) {
<span class="fc" id="L2071">		return new IntIterator() {</span>
<span class="fc" id="L2072">			IntIterator it = iterable.iterator();</span>

			@Override
			public boolean hasNext() {
<span class="nc" id="L2076">				return true;</span>
			}

			@Override
			public int nextInt() {
<span class="fc" id="L2081">				int res = it.nextInt();</span>
<span class="pc bpc" id="L2082" title="1 of 2 branches missed.">				if (!it.hasNext())</span>
<span class="nc" id="L2083">					it = iterable.iterator();</span>
<span class="fc" id="L2084">				return res;</span>
			}
		};
	}

	static LongIterator circularIterator(LongIterable iterable) {
<span class="fc" id="L2090">		return new LongIterator() {</span>
<span class="fc" id="L2091">			LongIterator it = iterable.iterator();</span>

			@Override
			public boolean hasNext() {
<span class="nc" id="L2095">				return true;</span>
			}

			@Override
			public long nextLong() {
<span class="fc" id="L2100">				long res = it.nextLong();</span>
<span class="pc bpc" id="L2101" title="1 of 2 branches missed.">				if (!it.hasNext())</span>
<span class="nc" id="L2102">					it = iterable.iterator();</span>
<span class="fc" id="L2103">				return res;</span>
			}
		};
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>