<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GraphBench.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Benchmarks</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.bench.impls</a> &gt; <span class="el_source">GraphBench.java</span></div><h1>GraphBench.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.bench.impls;

import static com.jgalgo.internal.util.Range.range;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import java.util.function.Supplier;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Fork;
import org.openjdk.jmh.annotations.Level;
import org.openjdk.jmh.annotations.Measurement;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OperationsPerInvocation;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Param;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.annotations.Warmup;
import org.openjdk.jmh.infra.Blackhole;
import com.jgalgo.bench.util.BenchUtils;
import com.jgalgo.bench.util.TestUtils;
import com.jgalgo.graph.Graphs;
import com.jgalgo.graph.IEdgeIter;
import com.jgalgo.graph.IEdgeSet;
import com.jgalgo.graph.IndexGraph;
import com.jgalgo.graph.IndexGraphBuilder;
import com.jgalgo.graph.IndexGraphFactory;
import com.jgalgo.internal.util.JGAlgoUtils;
import it.unimi.dsi.fastutil.ints.IntImmutableList;
import it.unimi.dsi.fastutil.ints.IntIterable;
import it.unimi.dsi.fastutil.ints.IntIterator;
import it.unimi.dsi.fastutil.longs.LongImmutableList;
import it.unimi.dsi.fastutil.longs.LongIterable;
import it.unimi.dsi.fastutil.longs.LongIterator;
import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
import it.unimi.dsi.fastutil.longs.LongSet;

<span class="nc" id="L56">public class GraphBench {</span>

<span class="fc" id="L58">	public static class EdgesRead {</span>

		private IndexGraph g;
		private IntIterator queryVIter;
		private LongIterator queryUVIter;

		void setup(String args, Function&lt;IndexGraph, IndexGraph&gt; graphImplementation, boolean directed,
				boolean allowParallelEdges, boolean allowSelfEdges) {
<span class="fc" id="L66">			final long seed = 0x8c91b913bfe81bb7L;</span>
<span class="fc" id="L67">			final Random rand = new Random(seed);</span>
<span class="fc" id="L68">			Map&lt;String, String&gt; argsMap = BenchUtils.parseArgsStr(args);</span>
<span class="fc" id="L69">			final int n = Integer.parseInt(argsMap.get(&quot;|V|&quot;));</span>
<span class="fc" id="L70">			final int m = Integer.parseInt(argsMap.get(&quot;|E|&quot;));</span>

<span class="fc" id="L72">			g = IndexGraphFactory.newInstance(directed).allowSelfEdges().newGraph();</span>
<span class="fc" id="L73">			g.addVertices(range(n));</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">			LongSet existingEdges = allowParallelEdges ? null : new LongOpenHashSet();</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">			for (int e = 0; e &lt; m;) {</span>
<span class="fc" id="L76">				int u = Graphs.randVertex(g, rand), v = Graphs.randVertex(g, rand);</span>
<span class="fc bfc" id="L77" title="All 4 branches covered.">				if (!allowSelfEdges &amp;&amp; u == v)</span>
<span class="fc" id="L78">					continue;</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">				if (!allowParallelEdges) {</span>
<span class="fc" id="L80">					int u1 = u, v1 = v;</span>
<span class="fc bfc" id="L81" title="All 4 branches covered.">					if (!directed &amp;&amp; u1 &lt; v1) {</span>
<span class="fc" id="L82">						int tmp = u1;</span>
<span class="fc" id="L83">						u1 = v1;</span>
<span class="fc" id="L84">						v1 = tmp;</span>
					}
<span class="fc" id="L86">					long key = JGAlgoUtils.longPack(u1, v1);</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">					if (!existingEdges.add(key))</span>
<span class="fc" id="L88">						continue;</span>
				}
<span class="fc" id="L90">				g.addEdge(u, v);</span>
<span class="fc" id="L91">				e++;</span>
<span class="fc" id="L92">			}</span>
<span class="fc" id="L93">			g = graphImplementation.apply(g);</span>

<span class="fc" id="L95">			int[] queryVertices = TestUtils.randArray(n * 16, 0, n, seed);</span>
<span class="fc" id="L96">			queryVIter = circularIterator(IntImmutableList.of(queryVertices));</span>

<span class="fc" id="L98">			int[] queryUVertices = TestUtils.randArray(n * 32, 0, n, seed);</span>
<span class="fc" id="L99">			long[] queryUVertices0 = new long[queryUVertices.length / 2];</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">			for (int q = 0; q &lt; queryUVertices0.length; q++) {</span>
				int u, v;
<span class="fc bfc" id="L102" title="All 2 branches covered.">				if (rand.nextBoolean()) {</span>
<span class="fc" id="L103">					u = queryUVertices[q * 2 + 0];</span>
<span class="fc" id="L104">					v = queryUVertices[q * 2 + 1];</span>
				} else {
<span class="fc" id="L106">					int e = Graphs.randEdge(g, rand);</span>
<span class="fc" id="L107">					u = g.edgeSource(e);</span>
<span class="fc" id="L108">					v = g.edgeTarget(e);</span>
<span class="fc bfc" id="L109" title="All 4 branches covered.">					if (!directed &amp;&amp; rand.nextBoolean()) {</span>
<span class="fc" id="L110">						int tmp = u;</span>
<span class="fc" id="L111">						u = v;</span>
<span class="fc" id="L112">						v = tmp;</span>
					}
				}
<span class="fc" id="L115">				queryUVertices0[q] = JGAlgoUtils.longPack(u, v);</span>
			}
<span class="fc" id="L117">			queryUVIter = circularIterator(LongImmutableList.of(queryUVertices0));</span>
<span class="fc" id="L118">		}</span>

		void setup(String args, Supplier&lt;IndexGraph&gt; graphImplementation, boolean directed, boolean allowParallelEdges,
				boolean allowSelfEdges) {
<span class="fc" id="L122">			setup(args, g -&gt; {</span>
<span class="pc bnc" id="L123" title="All 2 branches missed.">				assert g.isDirected() == directed;</span>
<span class="fc" id="L124">				IndexGraph g1 = graphImplementation.get();</span>
<span class="pc bnc" id="L125" title="All 2 branches missed.">				assert g1.isDirected() == directed;</span>
<span class="fc" id="L126">				g1.addVertices(g.vertices());</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">				for (int m = g.edges().size(), e = 0; e &lt; m; e++)</span>
<span class="fc" id="L128">					g1.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L129">				return g1;</span>
			}, directed, allowParallelEdges, allowSelfEdges);
<span class="fc" id="L131">		}</span>

		private void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L134">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L135">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc" id="L136">			blackhole.consume(edgeSet);</span>
<span class="fc" id="L137">		}</span>

		private void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L140">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L141">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc" id="L142">			blackhole.consume(edgeSet.size());</span>
<span class="fc" id="L143">		}</span>

		private void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L146">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L147">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();)</span>
<span class="fc" id="L149">				blackhole.consume(eit.nextInt());</span>
<span class="fc" id="L150">		}</span>

		private void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L153">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L154">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();) {</span>
<span class="fc" id="L156">				eit.nextInt();</span>
<span class="fc" id="L157">				blackhole.consume(eit.sourceInt());</span>
			}
<span class="fc" id="L159">		}</span>

		private void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L162">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L163">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();) {</span>
<span class="fc" id="L165">				eit.nextInt();</span>
<span class="fc" id="L166">				blackhole.consume(eit.targetInt());</span>
			}
<span class="fc" id="L168">		}</span>

		private void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L171">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L172">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc" id="L173">			blackhole.consume(edgeSet);</span>
<span class="fc" id="L174">		}</span>

		private void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L177">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L178">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc" id="L179">			blackhole.consume(edgeSet.size());</span>
<span class="fc" id="L180">		}</span>

		private void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L183">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L184">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();)</span>
<span class="fc" id="L186">				blackhole.consume(eit.nextInt());</span>
<span class="fc" id="L187">		}</span>

		private void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L190">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L191">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();) {</span>
<span class="fc" id="L193">				eit.nextInt();</span>
<span class="fc" id="L194">				blackhole.consume(eit.sourceInt());</span>
			}
<span class="fc" id="L196">		}</span>

		private void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L199">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L200">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();) {</span>
<span class="fc" id="L202">				eit.nextInt();</span>
<span class="fc" id="L203">				blackhole.consume(eit.targetInt());</span>
			}
<span class="fc" id="L205">		}</span>

		private void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L208">			long l = queryUVIter.nextLong();</span>
<span class="fc" id="L209">			int u = JGAlgoUtils.long2low(l);</span>
<span class="fc" id="L210">			int v = JGAlgoUtils.long2high(l);</span>
<span class="fc" id="L211">			blackhole.consume(g.getEdge(u, v));</span>
<span class="fc" id="L212">		}</span>

		private void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L215">			long l = queryUVIter.nextLong();</span>
<span class="fc" id="L216">			int u = JGAlgoUtils.long2low(l);</span>
<span class="fc" id="L217">			int v = JGAlgoUtils.long2high(l);</span>
<span class="fc" id="L218">			blackhole.consume(g.getEdges(u, v));</span>
<span class="fc" id="L219">		}</span>

		private void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L222">			long l = queryUVIter.nextLong();</span>
<span class="fc" id="L223">			int u = JGAlgoUtils.long2low(l);</span>
<span class="fc" id="L224">			int v = JGAlgoUtils.long2high(l);</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">			for (IEdgeIter eit = g.getEdges(u, v).iterator(); eit.hasNext();)</span>
<span class="fc" id="L226">				blackhole.consume(eit.nextInt());</span>
<span class="fc" id="L227">		}</span>

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L235">		public static class ArrayDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L242">				setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, true, true, false);</span>
<span class="fc" id="L243">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L247">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L248">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L252">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L253">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L257">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L258">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L262">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L263">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L267">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L268">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L272">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L273">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L277">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L278">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L282">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L283">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L287">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L288">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L292">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L293">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L297">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L298">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L302">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L303">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L307">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L308">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L317">		public static class ArrayUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L324">				setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, false, true, false);</span>
<span class="fc" id="L325">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L329">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L330">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L334">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L335">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L339">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L340">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L344">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L345">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L349">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L350">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L354">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L355">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L359">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L360">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L364">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L365">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L369">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L370">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L374">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L375">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L379">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L380">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L384">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L385">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L389">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L390">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L399">		public static class LinkedDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L406">				setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, true, true, false);</span>
<span class="fc" id="L407">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L411">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L412">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L416">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L417">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L421">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L422">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L426">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L427">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L431">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L432">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L436">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L437">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L441">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L442">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L446">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L447">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L451">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L452">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L456">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L457">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L461">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L462">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L466">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L467">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L471">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L472">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L481">		public static class LinkedUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L488">				setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, false, true,</span>
						false);
<span class="fc" id="L490">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L494">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L495">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L499">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L500">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L504">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L505">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L509">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L510">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L514">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L515">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L519">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L520">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L524">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L525">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L529">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L530">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L534">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L535">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L539">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L540">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L544">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L545">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L549">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L550">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L554">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L555">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L564">		public static class LinkedPtrDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L571">				setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, true, true,</span>
						false);
<span class="fc" id="L573">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L577">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L578">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L582">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L583">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L587">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L588">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L592">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L593">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L597">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L598">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L602">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L603">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L607">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L608">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L612">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L613">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L617">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L618">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L622">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L623">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L627">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L628">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L632">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L633">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L637">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L638">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L647">		public static class LinkedPtrUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L654">				setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, false, true,</span>
						false);
<span class="fc" id="L656">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L660">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L661">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L665">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L666">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L670">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L671">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L675">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L676">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L680">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L681">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L685">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L686">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L690">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L691">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L695">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L696">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L700">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L701">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L705">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L706">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L710">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L711">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L715">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L716">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L720">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L721">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L730">		public static class HashtableMultiDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L737">				setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;hashtable-multi&quot;)::newGraph, true, false,</span>
						false);
<span class="fc" id="L739">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L743">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L744">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L748">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L749">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L753">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L754">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L758">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L759">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L763">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L764">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L768">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L769">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L773">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L774">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L778">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L779">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L783">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L784">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L788">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L789">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L793">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L794">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L798">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L799">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L803">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L804">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L813">		public static class HashtableMultiUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L820">				setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;hashtable-multi&quot;)::newGraph, false, false,</span>
						false);
<span class="fc" id="L822">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L826">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L827">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L831">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L832">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L836">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L837">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L841">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L842">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L846">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L847">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L851">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L852">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L856">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L857">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L861">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L862">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L866">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L867">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L871">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L872">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L876">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L877">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L881">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L882">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L886">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L887">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L896">		public static class HashtableDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L903">				setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, true, false, false);</span>
<span class="fc" id="L904">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L908">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L909">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L913">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L914">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L918">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L919">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L923">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L924">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L928">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L929">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L933">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L934">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L938">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L939">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L943">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L944">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L948">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L949">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L953">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L954">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L958">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L959">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L963">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L964">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L968">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L969">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L978">		public static class HashtableUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L985">				setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, false, false,</span>
						false);
<span class="fc" id="L987">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L991">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L992">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L996">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L997">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1001">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L1002">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1006">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L1007">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1011">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L1012">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L1016">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L1017">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1021">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L1022">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1026">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L1027">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1031">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L1032">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1036">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L1037">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L1041">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L1042">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L1046">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L1047">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1051">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L1052">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L1061">		public static class MatrixDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L1068">				setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, true, false, false);</span>
<span class="fc" id="L1069">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L1073">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L1074">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1078">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L1079">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1083">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L1084">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1088">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L1089">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1093">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L1094">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L1098">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L1099">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1103">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L1104">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1108">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L1109">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1113">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L1114">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1118">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L1119">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L1123">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L1124">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L1128">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L1129">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1133">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L1134">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L1143">		public static class MatrixUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L1150">				setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, false, false, false);</span>
<span class="fc" id="L1151">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L1155">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L1156">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1160">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L1161">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1165">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L1166">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1170">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L1171">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1175">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L1176">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L1180">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L1181">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1185">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L1186">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1190">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L1191">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1195">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L1196">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1200">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L1201">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L1205">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L1206">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L1210">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L1211">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1215">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L1216">			}</span>
		}

<span class="fc" id="L1219">		@BenchmarkMode(Mode.AverageTime)</span>
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L1225">		public static class CsrDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L1232">				final boolean directed = true;</span>
<span class="fc" id="L1233">				final boolean allowParallelEdges = true;</span>
<span class="fc" id="L1234">				final boolean allowSelfEdges = true;</span>
<span class="fc" id="L1235">				setup(args, g -&gt; {</span>
<span class="pc bnc" id="L1236" title="All 2 branches missed.">					assert g.isDirected() == directed;</span>
<span class="fc" id="L1237">					IndexGraphBuilder g1 = IndexGraphBuilder.directed();</span>
<span class="fc" id="L1238">					g1.addVertices(g.vertices());</span>
<span class="fc bfc" id="L1239" title="All 2 branches covered.">					for (int m = g.edges().size(), e = 0; e &lt; m; e++)</span>
<span class="fc" id="L1240">						g1.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L1241">					IndexGraph g1Graph = g1.build();</span>
<span class="pc bnc" id="L1242" title="All 2 branches missed.">					assert g1Graph.isDirected() == directed;</span>
<span class="fc" id="L1243">					return g1Graph;</span>
				}, directed, allowParallelEdges, allowSelfEdges);
<span class="fc" id="L1245">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L1249">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L1250">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1254">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L1255">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1259">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L1260">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1264">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L1265">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1269">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L1270">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L1274">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L1275">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1279">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L1280">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1284">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L1285">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1289">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L1290">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1294">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L1295">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L1299">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L1300">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L1304">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L1305">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1309">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L1310">			}</span>
		}

<span class="fc" id="L1313">		@BenchmarkMode(Mode.AverageTime)</span>
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L1319">		public static class CsrUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L1326">				final boolean directed = false;</span>
<span class="fc" id="L1327">				final boolean allowParallelEdges = true;</span>
<span class="fc" id="L1328">				final boolean allowSelfEdges = true;</span>
<span class="fc" id="L1329">				setup(args, g -&gt; {</span>
<span class="pc bnc" id="L1330" title="All 2 branches missed.">					assert g.isDirected() == directed;</span>
<span class="fc" id="L1331">					IndexGraphBuilder g1 = IndexGraphBuilder.undirected();</span>
<span class="fc" id="L1332">					g1.addVertices(g.vertices());</span>
<span class="fc bfc" id="L1333" title="All 2 branches covered.">					for (int m = g.edges().size(), e = 0; e &lt; m; e++)</span>
<span class="fc" id="L1334">						g1.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L1335">					IndexGraph g1Graph = g1.build();</span>
<span class="pc bnc" id="L1336" title="All 2 branches missed.">					assert g1Graph.isDirected() == directed;</span>
<span class="fc" id="L1337">					return g1Graph;</span>
				}, directed, allowParallelEdges, allowSelfEdges);
<span class="fc" id="L1339">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L1343">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L1344">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1348">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L1349">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1353">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L1354">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1358">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L1359">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1363">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L1364">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L1368">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L1369">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1373">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L1374">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1378">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L1379">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1383">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L1384">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1388">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L1389">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L1393">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L1394">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L1398">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L1399">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1403">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L1404">			}</span>
		}

<span class="fc" id="L1407">		@BenchmarkMode(Mode.AverageTime)</span>
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L1413">		public static class CsrDirectedReindexed extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L1420">				final boolean directed = true;</span>
<span class="fc" id="L1421">				final boolean allowParallelEdges = true;</span>
<span class="fc" id="L1422">				final boolean allowSelfEdges = true;</span>
<span class="fc" id="L1423">				setup(args, g -&gt; {</span>
<span class="pc bnc" id="L1424" title="All 2 branches missed.">					assert g.isDirected() == directed;</span>
<span class="fc" id="L1425">					IndexGraphBuilder g1 = IndexGraphBuilder.directed();</span>
<span class="fc" id="L1426">					g1.addVertices(g.vertices());</span>
<span class="fc bfc" id="L1427" title="All 2 branches covered.">					for (int m = g.edges().size(), e = 0; e &lt; m; e++)</span>
<span class="fc" id="L1428">						g1.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L1429">					IndexGraph g1Graph = g1.reIndexAndBuild(true, true).graph();</span>
<span class="pc bnc" id="L1430" title="All 2 branches missed.">					assert g1Graph.isDirected() == directed;</span>
<span class="fc" id="L1431">					return g1Graph;</span>
				}, directed, allowParallelEdges, allowSelfEdges);
<span class="fc" id="L1433">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L1437">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L1438">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1442">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L1443">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1447">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L1448">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1452">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L1453">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1457">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L1458">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L1462">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L1463">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1467">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L1468">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1472">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L1473">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1477">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L1478">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1482">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L1483">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L1487">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L1488">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L1492">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L1493">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1497">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L1498">			}</span>
		}

	}

<span class="fc" id="L1503">	public static class Remove {</span>

		IndexGraph g;
		int n, m;
		Random rand;

		void setup(String args, Function&lt;IndexGraph, IndexGraph&gt; graphImplementation, boolean directed,
				boolean allowParallelEdges, boolean allowSelfEdges) {
<span class="fc" id="L1511">			final long seed = 0x850a14ff3dad400cL;</span>
<span class="fc" id="L1512">			rand = new Random(seed);</span>
<span class="fc" id="L1513">			Map&lt;String, String&gt; argsMap = BenchUtils.parseArgsStr(args);</span>
<span class="fc" id="L1514">			n = Integer.parseInt(argsMap.get(&quot;|V|&quot;));</span>
<span class="fc" id="L1515">			m = Integer.parseInt(argsMap.get(&quot;|E|&quot;));</span>

<span class="fc" id="L1517">			g = IndexGraphFactory.newInstance(directed).allowSelfEdges(allowSelfEdges)</span>
<span class="fc" id="L1518">					.allowParallelEdges(allowParallelEdges).newGraph();</span>
<span class="fc" id="L1519">			g.addVertices(range(n));</span>
<span class="fc bfc" id="L1520" title="All 2 branches covered.">			LongSet existingEdges = allowParallelEdges ? null : new LongOpenHashSet();</span>
<span class="fc bfc" id="L1521" title="All 2 branches covered.">			for (int e = 0; e &lt; m;) {</span>
<span class="fc" id="L1522">				int u = Graphs.randVertex(g, rand), v = Graphs.randVertex(g, rand);</span>
<span class="pc bpc" id="L1523" title="1 of 4 branches missed.">				if (!allowSelfEdges &amp;&amp; u == v)</span>
<span class="fc" id="L1524">					continue;</span>
<span class="fc bfc" id="L1525" title="All 2 branches covered.">				if (!allowParallelEdges) {</span>
<span class="fc" id="L1526">					int u1 = u, v1 = v;</span>
<span class="fc bfc" id="L1527" title="All 4 branches covered.">					if (!directed &amp;&amp; u1 &lt; v1) {</span>
<span class="fc" id="L1528">						int tmp = u1;</span>
<span class="fc" id="L1529">						u1 = v1;</span>
<span class="fc" id="L1530">						v1 = tmp;</span>
					}
<span class="fc" id="L1532">					long key = JGAlgoUtils.longPack(u1, v1);</span>
<span class="fc bfc" id="L1533" title="All 2 branches covered.">					if (!existingEdges.add(key))</span>
<span class="fc" id="L1534">						continue;</span>
				}
<span class="fc" id="L1536">				g.addEdge(u, v);</span>
<span class="fc" id="L1537">				e++;</span>
<span class="fc" id="L1538">			}</span>
<span class="fc" id="L1539">			g = graphImplementation.apply(g);</span>
<span class="fc" id="L1540">		}</span>

		void setup(String args, Supplier&lt;IndexGraph&gt; graphImplementation, boolean directed, boolean allowParallelEdges,
				boolean allowSelfEdges) {
<span class="fc" id="L1544">			setup(args, g -&gt; {</span>
<span class="pc bnc" id="L1545" title="All 2 branches missed.">				assert g.isDirected() == directed;</span>
<span class="fc" id="L1546">				IndexGraph g1 = graphImplementation.get();</span>
<span class="pc bnc" id="L1547" title="All 2 branches missed.">				assert g1.isDirected() == directed;</span>
<span class="fc" id="L1548">				g1.addVertices(g.vertices());</span>
<span class="fc bfc" id="L1549" title="All 2 branches covered.">				for (int e = 0; e &lt; m; e++)</span>
<span class="fc" id="L1550">					g1.addEdge(g.edgeSource(e), g.edgeTarget(e));</span>
<span class="fc" id="L1551">				return g1;</span>
			}, directed, allowParallelEdges, allowSelfEdges);
<span class="fc" id="L1553">		}</span>

		void restoreGraph() {
<span class="fc" id="L1556">			final boolean allowSelfEdges = g.isAllowSelfEdges();</span>
<span class="fc" id="L1557">			final boolean allowParallelEdges = g.isAllowParallelEdges();</span>
<span class="pc bpc" id="L1558" title="1 of 2 branches missed.">			while (g.vertices().size() &lt; n)</span>
<span class="nc" id="L1559">				g.addVertex();</span>
<span class="pc bpc" id="L1560" title="1 of 2 branches missed.">			while (g.edges().size() &lt; m) {</span>
<span class="nc" id="L1561">				int u = Graphs.randVertex(g, rand), v = Graphs.randVertex(g, rand);</span>
<span class="nc bnc" id="L1562" title="All 4 branches missed.">				if (!allowSelfEdges &amp;&amp; u == v)</span>
<span class="nc" id="L1563">					continue;</span>
<span class="nc bnc" id="L1564" title="All 4 branches missed.">				if (!allowParallelEdges &amp;&amp; g.getEdge(u, v) != -1)</span>
<span class="nc" id="L1565">					continue;</span>
<span class="nc" id="L1566">				g.addEdge(u, v);</span>
<span class="nc" id="L1567">			}</span>
<span class="fc" id="L1568">		}</span>

<span class="fc" id="L1570">		public static class Edge extends Remove {</span>

			private IntIterator removeEIter;

			private static final int OperationsPerInvocation = 100;

			@Override
			void setup(String args, Function&lt;IndexGraph, IndexGraph&gt; graphImplementation, boolean directed,
					boolean allowParallelEdges, boolean allowSelfEdges) {
<span class="fc" id="L1579">				super.setup(args, graphImplementation, directed, allowParallelEdges, allowSelfEdges);</span>

<span class="pc bnc" id="L1581" title="All 2 branches missed.">				assert m &gt; OperationsPerInvocation;</span>
<span class="fc" id="L1582">				int[] removeEdges = TestUtils.randArray(m * 16, 0, m - OperationsPerInvocation, rand.nextLong());</span>
<span class="fc" id="L1583">				removeEIter = circularIterator(IntImmutableList.of(removeEdges));</span>
<span class="fc" id="L1584">			}</span>

			private void bench(Blackhole blackhole) {
<span class="fc bfc" id="L1587" title="All 2 branches covered.">				for (int o = 0; o &lt; OperationsPerInvocation; o++) {</span>
<span class="fc" id="L1588">					int e = removeEIter.nextInt();</span>
<span class="fc" id="L1589">					g.removeEdge(e);</span>
<span class="fc" id="L1590">					blackhole.consume(e);</span>
<span class="fc" id="L1591">					blackhole.consume(g);</span>
				}
<span class="fc" id="L1593">			}</span>

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1601">			public static class ArrayDirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1608">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, true, true, false);</span>
<span class="fc" id="L1609">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1614">					super.restoreGraph();</span>
<span class="fc" id="L1615">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1620">					super.bench(blackhole);</span>
<span class="fc" id="L1621">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1630">			public static class ArrayUndirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1637">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, false, true,</span>
							false);
<span class="fc" id="L1639">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1644">					super.restoreGraph();</span>
<span class="fc" id="L1645">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1650">					super.bench(blackhole);</span>
<span class="fc" id="L1651">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1660">			public static class LinkedDirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1667">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, true, true,</span>
							false);
<span class="fc" id="L1669">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1674">					super.restoreGraph();</span>
<span class="fc" id="L1675">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1680">					super.bench(blackhole);</span>
<span class="fc" id="L1681">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1690">			public static class LinkedUndirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1697">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, false, true,</span>
							false);
<span class="fc" id="L1699">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1704">					super.restoreGraph();</span>
<span class="fc" id="L1705">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1710">					super.bench(blackhole);</span>
<span class="fc" id="L1711">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1720">			public static class LinkedPtrDirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1727">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, true, true,</span>
							false);
<span class="fc" id="L1729">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1734">					super.restoreGraph();</span>
<span class="fc" id="L1735">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1740">					super.bench(blackhole);</span>
<span class="fc" id="L1741">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1750">			public static class LinkedPtrUndirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1757">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, false,</span>
							true, false);
<span class="fc" id="L1759">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1764">					super.restoreGraph();</span>
<span class="fc" id="L1765">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1770">					super.bench(blackhole);</span>
<span class="fc" id="L1771">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1780">			public static class HashtableDirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1787">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, true, false,</span>
							false);
<span class="fc" id="L1789">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1794">					super.restoreGraph();</span>
<span class="fc" id="L1795">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1800">					super.bench(blackhole);</span>
<span class="fc" id="L1801">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1810">			public static class HashtableUndirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1817">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, false, false,</span>
							false);
<span class="fc" id="L1819">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1824">					super.restoreGraph();</span>
<span class="fc" id="L1825">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1830">					super.bench(blackhole);</span>
<span class="fc" id="L1831">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1840">			public static class HashtableMultiDirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1847">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;hashtable-multi&quot;)::newGraph, true,</span>
							false, false);
<span class="fc" id="L1849">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1854">					super.restoreGraph();</span>
<span class="fc" id="L1855">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1860">					super.bench(blackhole);</span>
<span class="fc" id="L1861">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1870">			public static class HashtableMultiUndirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1877">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;hashtable-multi&quot;)::newGraph, false,</span>
							false, false);
<span class="fc" id="L1879">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1884">					super.restoreGraph();</span>
<span class="fc" id="L1885">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1890">					super.bench(blackhole);</span>
<span class="fc" id="L1891">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1900">			public static class MatrixDirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1907">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, true, false, false);</span>
<span class="fc" id="L1908">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1913">					super.restoreGraph();</span>
<span class="fc" id="L1914">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1919">					super.bench(blackhole);</span>
<span class="fc" id="L1920">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1929">			public static class MatrixUndirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1936">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, false, false,</span>
							false);
<span class="fc" id="L1938">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1943">					super.restoreGraph();</span>
<span class="fc" id="L1944">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1949">					super.bench(blackhole);</span>
<span class="fc" id="L1950">				}</span>
			}

		}

<span class="fc" id="L1955">		public static class Vertex extends Remove {</span>

			private IntIterator removeVIter;

			private static final int OperationsPerInvocation = 50;

			@Override
			void setup(String args, Function&lt;IndexGraph, IndexGraph&gt; graphImplementation, boolean directed,
					boolean allowParallelEdges, boolean allowSelfEdges) {
<span class="fc" id="L1964">				super.setup(args, graphImplementation, directed, allowParallelEdges, allowSelfEdges);</span>

<span class="pc bnc" id="L1966" title="All 2 branches missed.">				assert n &gt; OperationsPerInvocation;</span>
<span class="fc" id="L1967">				int[] removeVertices = TestUtils.randArray(n * 16, 0, n - OperationsPerInvocation, rand.nextLong());</span>
<span class="fc" id="L1968">				removeVIter = circularIterator(IntImmutableList.of(removeVertices));</span>
<span class="fc" id="L1969">			}</span>

			private void bench(Blackhole blackhole) {
<span class="fc bfc" id="L1972" title="All 2 branches covered.">				for (int o = 0; o &lt; OperationsPerInvocation; o++) {</span>
<span class="fc" id="L1973">					int v = removeVIter.nextInt();</span>
<span class="fc" id="L1974">					g.removeEdge(v);</span>
<span class="fc" id="L1975">					blackhole.consume(v);</span>
<span class="fc" id="L1976">					blackhole.consume(g);</span>
				}
<span class="fc" id="L1978">			}</span>

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1986">			public static class ArrayDirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1993">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, true, true, false);</span>
<span class="fc" id="L1994">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1999">					super.restoreGraph();</span>
<span class="fc" id="L2000">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2005">					super.bench(blackhole);</span>
<span class="fc" id="L2006">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2015">			public static class ArrayUndirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2022">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, false, true,</span>
							false);
<span class="fc" id="L2024">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2029">					super.restoreGraph();</span>

<span class="fc" id="L2031">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2036">					super.bench(blackhole);</span>
<span class="fc" id="L2037">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2046">			public static class LinkedDirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2053">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, true, true,</span>
							false);
<span class="fc" id="L2055">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2060">					super.restoreGraph();</span>

<span class="fc" id="L2062">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2067">					super.bench(blackhole);</span>
<span class="fc" id="L2068">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2077">			public static class LinkedUndirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2084">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, false, true,</span>
							false);
<span class="fc" id="L2086">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2091">					super.restoreGraph();</span>

<span class="fc" id="L2093">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2098">					super.bench(blackhole);</span>
<span class="fc" id="L2099">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2108">			public static class LinkedPtrDirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2115">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, true, true,</span>
							false);
<span class="fc" id="L2117">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2122">					super.restoreGraph();</span>

<span class="fc" id="L2124">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2129">					super.bench(blackhole);</span>
<span class="fc" id="L2130">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2139">			public static class LinkedPtrUndirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2146">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, false,</span>
							true, false);
<span class="fc" id="L2148">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2153">					super.restoreGraph();</span>

<span class="fc" id="L2155">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2160">					super.bench(blackhole);</span>
<span class="fc" id="L2161">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2170">			public static class HashtableDirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2177">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, true, false,</span>
							false);
<span class="fc" id="L2179">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2184">					super.restoreGraph();</span>

<span class="fc" id="L2186">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2191">					super.bench(blackhole);</span>
<span class="fc" id="L2192">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2201">			public static class HashtableUndirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2208">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, false, false,</span>
							false);
<span class="fc" id="L2210">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2215">					super.restoreGraph();</span>

<span class="fc" id="L2217">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2222">					super.bench(blackhole);</span>
<span class="fc" id="L2223">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2232">			public static class HashtableMultiDirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2239">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;hashtable-multi&quot;)::newGraph, true,</span>
							false, false);
<span class="fc" id="L2241">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2246">					super.restoreGraph();</span>

<span class="fc" id="L2248">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2253">					super.bench(blackhole);</span>
<span class="fc" id="L2254">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2263">			public static class HashtableMultiUndirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2270">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;hashtable-multi&quot;)::newGraph, false,</span>
							false, false);
<span class="fc" id="L2272">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2277">					super.restoreGraph();</span>

<span class="fc" id="L2279">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2284">					super.bench(blackhole);</span>
<span class="fc" id="L2285">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2294">			public static class MatrixDirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2301">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, true, false, false);</span>
<span class="fc" id="L2302">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2307">					super.restoreGraph();</span>

<span class="fc" id="L2309">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2314">					super.bench(blackhole);</span>
<span class="fc" id="L2315">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2324">			public static class MatrixUndirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2331">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, false, false,</span>
							false);
<span class="fc" id="L2333">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2338">					super.restoreGraph();</span>

<span class="fc" id="L2340">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2345">					super.bench(blackhole);</span>
<span class="fc" id="L2346">				}</span>
			}

		}
	}

	static IntIterator circularIterator(IntIterable iterable) {
<span class="fc" id="L2353">		return new IntIterator() {</span>
<span class="fc" id="L2354">			IntIterator it = iterable.iterator();</span>

			@Override
			public boolean hasNext() {
<span class="nc" id="L2358">				return true;</span>
			}

			@Override
			public int nextInt() {
<span class="fc" id="L2363">				int res = it.nextInt();</span>
<span class="pc bpc" id="L2364" title="1 of 2 branches missed.">				if (!it.hasNext())</span>
<span class="nc" id="L2365">					it = iterable.iterator();</span>
<span class="fc" id="L2366">				return res;</span>
			}
		};
	}

	static LongIterator circularIterator(LongIterable iterable) {
<span class="fc" id="L2372">		return new LongIterator() {</span>
<span class="fc" id="L2373">			LongIterator it = iterable.iterator();</span>

			@Override
			public boolean hasNext() {
<span class="nc" id="L2377">				return true;</span>
			}

			@Override
			public long nextLong() {
<span class="fc" id="L2382">				long res = it.nextLong();</span>
<span class="pc bpc" id="L2383" title="1 of 2 branches missed.">				if (!it.hasNext())</span>
<span class="nc" id="L2384">					it = iterable.iterator();</span>
<span class="fc" id="L2385">				return res;</span>
			}
		};
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>