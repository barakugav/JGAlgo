<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GraphBench.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Benchmarks</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.bench.impls</a> &gt; <span class="el_source">GraphBench.java</span></div><h1>GraphBench.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.jgalgo.bench.impls;

import static com.jgalgo.internal.util.Range.range;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import java.util.function.Supplier;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Fork;
import org.openjdk.jmh.annotations.Level;
import org.openjdk.jmh.annotations.Measurement;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OperationsPerInvocation;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Param;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.annotations.Warmup;
import org.openjdk.jmh.infra.Blackhole;
import com.jgalgo.bench.util.BenchUtils;
import com.jgalgo.bench.util.TestUtils;
import com.jgalgo.graph.EdgeSet;
import com.jgalgo.graph.Graphs;
import com.jgalgo.graph.IEdgeIter;
import com.jgalgo.graph.IEdgeSet;
import com.jgalgo.graph.IndexGraph;
import com.jgalgo.graph.IndexGraphBuilder;
import com.jgalgo.graph.IndexGraphFactory;
import com.jgalgo.internal.util.IntPair;
import com.jgalgo.internal.util.Fastutil;
import it.unimi.dsi.fastutil.ints.IntIterable;
import it.unimi.dsi.fastutil.ints.IntIterator;
import it.unimi.dsi.fastutil.longs.LongImmutableList;
import it.unimi.dsi.fastutil.longs.LongIterable;
import it.unimi.dsi.fastutil.longs.LongIterator;
import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
import it.unimi.dsi.fastutil.longs.LongSet;

<span class="nc" id="L57">public class GraphBench {</span>

<span class="fc" id="L59">	public static class EdgesRead {</span>

		private IndexGraph g;
		private IntIterator queryVIter;
		private LongIterator queryUVIter;

		void setup(String args, Function&lt;IndexGraph, IndexGraph&gt; graphImplementation, boolean directed,
				boolean allowParallelEdges, boolean allowSelfEdges) {
<span class="fc" id="L67">			final long seed = 0x8c91b913bfe81bb7L;</span>
<span class="fc" id="L68">			final Random rand = new Random(seed);</span>
<span class="fc" id="L69">			Map&lt;String, String&gt; argsMap = BenchUtils.parseArgsStr(args);</span>
<span class="fc" id="L70">			final int n = Integer.parseInt(argsMap.get(&quot;|V|&quot;));</span>
<span class="fc" id="L71">			final int m = Integer.parseInt(argsMap.get(&quot;|E|&quot;));</span>

<span class="fc" id="L73">			g = IndexGraphFactory.newInstance(directed).allowSelfEdges().newGraph();</span>
<span class="fc" id="L74">			g.addVertices(range(n));</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">			LongSet existingEdges = allowParallelEdges ? null : new LongOpenHashSet();</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">			for (int e = 0; e &lt; m;) {</span>
<span class="fc" id="L77">				int u = Graphs.randVertex(g, rand), v = Graphs.randVertex(g, rand);</span>
<span class="fc bfc" id="L78" title="All 4 branches covered.">				if (!allowSelfEdges &amp;&amp; u == v)</span>
<span class="fc" id="L79">					continue;</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">				if (!allowParallelEdges) {</span>
<span class="fc" id="L81">					int u1 = u, v1 = v;</span>
<span class="fc bfc" id="L82" title="All 4 branches covered.">					if (!directed &amp;&amp; u1 &lt; v1) {</span>
<span class="fc" id="L83">						int tmp = u1;</span>
<span class="fc" id="L84">						u1 = v1;</span>
<span class="fc" id="L85">						v1 = tmp;</span>
					}
<span class="fc" id="L87">					long key = IntPair.of(u1, v1);</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">					if (!existingEdges.add(key))</span>
<span class="fc" id="L89">						continue;</span>
				}
<span class="fc" id="L91">				g.addEdge(u, v);</span>
<span class="fc" id="L92">				e++;</span>
<span class="fc" id="L93">			}</span>
<span class="fc" id="L94">			g = graphImplementation.apply(g);</span>

<span class="fc" id="L96">			int[] queryVertices = TestUtils.randArray(n * 16, 0, n, seed);</span>
<span class="fc" id="L97">			queryVIter = circularIterator(Fastutil.list(queryVertices));</span>

<span class="fc" id="L99">			int[] queryUVertices = TestUtils.randArray(n * 32, 0, n, seed);</span>
<span class="fc" id="L100">			long[] queryUVertices0 = new long[queryUVertices.length / 2];</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">			for (int q = 0; q &lt; queryUVertices0.length; q++) {</span>
				int u, v;
<span class="fc bfc" id="L103" title="All 2 branches covered.">				if (rand.nextBoolean()) {</span>
<span class="fc" id="L104">					u = queryUVertices[q * 2 + 0];</span>
<span class="fc" id="L105">					v = queryUVertices[q * 2 + 1];</span>
				} else {
<span class="fc" id="L107">					int e = Graphs.randEdge(g, rand);</span>
<span class="fc" id="L108">					u = g.edgeSource(e);</span>
<span class="fc" id="L109">					v = g.edgeTarget(e);</span>
<span class="fc bfc" id="L110" title="All 4 branches covered.">					if (!directed &amp;&amp; rand.nextBoolean()) {</span>
<span class="fc" id="L111">						int tmp = u;</span>
<span class="fc" id="L112">						u = v;</span>
<span class="fc" id="L113">						v = tmp;</span>
					}
				}
<span class="fc" id="L116">				queryUVertices0[q] = IntPair.of(u, v);</span>
			}
<span class="fc" id="L118">			queryUVIter = circularIterator(LongImmutableList.of(queryUVertices0));</span>
<span class="fc" id="L119">		}</span>

		void setup(String args, Supplier&lt;IndexGraph&gt; graphImplementation, boolean directed, boolean allowParallelEdges,
				boolean allowSelfEdges) {
<span class="fc" id="L123">			setup(args, g -&gt; {</span>
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">				assert g.isDirected() == directed;</span>
<span class="fc" id="L125">				IndexGraph g1 = graphImplementation.get();</span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">				assert g1.isDirected() == directed;</span>
<span class="fc" id="L127">				g1.addVertices(g.vertices());</span>
<span class="fc" id="L128">				g1.addEdges(EdgeSet.allOf(g));</span>
<span class="fc" id="L129">				return g1;</span>
			}, directed, allowParallelEdges, allowSelfEdges);
<span class="fc" id="L131">		}</span>

		private void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L134">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L135">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc" id="L136">			blackhole.consume(edgeSet);</span>
<span class="fc" id="L137">		}</span>

		private void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L140">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L141">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc" id="L142">			blackhole.consume(edgeSet.size());</span>
<span class="fc" id="L143">		}</span>

		private void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L146">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L147">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();)</span>
<span class="fc" id="L149">				blackhole.consume(eit.nextInt());</span>
<span class="fc" id="L150">		}</span>

		private void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L153">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L154">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();) {</span>
<span class="fc" id="L156">				eit.nextInt();</span>
<span class="fc" id="L157">				blackhole.consume(eit.sourceInt());</span>
			}
<span class="fc" id="L159">		}</span>

		private void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L162">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L163">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();) {</span>
<span class="fc" id="L165">				eit.nextInt();</span>
<span class="fc" id="L166">				blackhole.consume(eit.targetInt());</span>
			}
<span class="fc" id="L168">		}</span>

		private void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L171">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L172">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc" id="L173">			blackhole.consume(edgeSet);</span>
<span class="fc" id="L174">		}</span>

		private void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L177">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L178">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc" id="L179">			blackhole.consume(edgeSet.size());</span>
<span class="fc" id="L180">		}</span>

		private void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L183">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L184">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();)</span>
<span class="fc" id="L186">				blackhole.consume(eit.nextInt());</span>
<span class="fc" id="L187">		}</span>

		private void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L190">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L191">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();) {</span>
<span class="fc" id="L193">				eit.nextInt();</span>
<span class="fc" id="L194">				blackhole.consume(eit.sourceInt());</span>
			}
<span class="fc" id="L196">		}</span>

		private void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L199">			int v = queryVIter.nextInt();</span>
<span class="fc" id="L200">			IEdgeSet edgeSet = g.outEdges(v);</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">			for (IEdgeIter eit = edgeSet.iterator(); eit.hasNext();) {</span>
<span class="fc" id="L202">				eit.nextInt();</span>
<span class="fc" id="L203">				blackhole.consume(eit.targetInt());</span>
			}
<span class="fc" id="L205">		}</span>

		private void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L208">			long l = queryUVIter.nextLong();</span>
<span class="fc" id="L209">			int u = IntPair.first(l);</span>
<span class="fc" id="L210">			int v = IntPair.second(l);</span>
<span class="fc" id="L211">			blackhole.consume(g.getEdge(u, v));</span>
<span class="fc" id="L212">		}</span>

		private void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L215">			long l = queryUVIter.nextLong();</span>
<span class="fc" id="L216">			int u = IntPair.first(l);</span>
<span class="fc" id="L217">			int v = IntPair.second(l);</span>
<span class="fc" id="L218">			blackhole.consume(g.getEdges(u, v));</span>
<span class="fc" id="L219">		}</span>

		private void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L222">			long l = queryUVIter.nextLong();</span>
<span class="fc" id="L223">			int u = IntPair.first(l);</span>
<span class="fc" id="L224">			int v = IntPair.second(l);</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">			for (IEdgeIter eit = g.getEdges(u, v).iterator(); eit.hasNext();)</span>
<span class="fc" id="L226">				blackhole.consume(eit.nextInt());</span>
<span class="fc" id="L227">		}</span>

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L235">		public static class ArrayDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L242">				setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, true, true, false);</span>
<span class="fc" id="L243">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L247">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L248">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L252">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L253">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L257">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L258">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L262">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L263">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L267">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L268">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L272">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L273">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L277">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L278">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L282">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L283">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L287">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L288">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L292">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L293">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L297">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L298">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L302">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L303">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L307">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L308">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L317">		public static class ArrayUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L324">				setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, false, true, false);</span>
<span class="fc" id="L325">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L329">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L330">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L334">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L335">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L339">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L340">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L344">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L345">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L349">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L350">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L354">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L355">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L359">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L360">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L364">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L365">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L369">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L370">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L374">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L375">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L379">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L380">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L384">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L385">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L389">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L390">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L399">		public static class LinkedDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L406">				setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, true, true, false);</span>
<span class="fc" id="L407">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L411">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L412">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L416">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L417">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L421">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L422">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L426">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L427">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L431">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L432">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L436">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L437">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L441">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L442">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L446">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L447">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L451">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L452">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L456">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L457">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L461">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L462">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L466">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L467">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L471">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L472">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L481">		public static class LinkedUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L488">				setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, false, true,</span>
						false);
<span class="fc" id="L490">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L494">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L495">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L499">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L500">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L504">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L505">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L509">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L510">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L514">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L515">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L519">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L520">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L524">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L525">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L529">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L530">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L534">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L535">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L539">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L540">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L544">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L545">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L549">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L550">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L554">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L555">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L564">		public static class LinkedPtrDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L571">				setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, true, true,</span>
						false);
<span class="fc" id="L573">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L577">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L578">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L582">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L583">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L587">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L588">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L592">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L593">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L597">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L598">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L602">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L603">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L607">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L608">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L612">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L613">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L617">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L618">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L622">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L623">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L627">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L628">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L632">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L633">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L637">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L638">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L647">		public static class LinkedPtrUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L654">				setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, false, true,</span>
						false);
<span class="fc" id="L656">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L660">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L661">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L665">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L666">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L670">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L671">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L675">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L676">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L680">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L681">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L685">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L686">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L690">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L691">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L695">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L696">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L700">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L701">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L705">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L706">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L710">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L711">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L715">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L716">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L720">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L721">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L730">		public static class HashtableMultiDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L737">				setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;hashtable-multi&quot;)::newGraph, true, false,</span>
						false);
<span class="fc" id="L739">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L743">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L744">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L748">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L749">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L753">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L754">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L758">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L759">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L763">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L764">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L768">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L769">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L773">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L774">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L778">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L779">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L783">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L784">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L788">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L789">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L793">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L794">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L798">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L799">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L803">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L804">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L813">		public static class HashtableMultiUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L820">				setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;hashtable-multi&quot;)::newGraph, false, false,</span>
						false);
<span class="fc" id="L822">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L826">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L827">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L831">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L832">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L836">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L837">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L841">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L842">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L846">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L847">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L851">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L852">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L856">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L857">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L861">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L862">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L866">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L867">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L871">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L872">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L876">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L877">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L881">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L882">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L886">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L887">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L896">		public static class HashtableDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L903">				setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, true, false, false);</span>
<span class="fc" id="L904">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L908">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L909">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L913">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L914">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L918">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L919">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L923">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L924">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L928">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L929">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L933">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L934">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L938">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L939">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L943">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L944">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L948">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L949">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L953">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L954">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L958">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L959">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L963">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L964">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L968">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L969">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L978">		public static class HashtableUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L985">				setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, false, false,</span>
						false);
<span class="fc" id="L987">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L991">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L992">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L996">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L997">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1001">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L1002">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1006">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L1007">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1011">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L1012">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L1016">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L1017">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1021">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L1022">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1026">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L1027">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1031">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L1032">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1036">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L1037">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L1041">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L1042">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L1046">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L1047">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1051">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L1052">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L1061">		public static class MatrixDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L1068">				setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, true, false, false);</span>
<span class="fc" id="L1069">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L1073">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L1074">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1078">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L1079">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1083">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L1084">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1088">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L1089">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1093">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L1094">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L1098">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L1099">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1103">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L1104">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1108">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L1109">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1113">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L1114">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1118">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L1119">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L1123">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L1124">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L1128">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L1129">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1133">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L1134">			}</span>
		}

		@BenchmarkMode(Mode.AverageTime)
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L1143">		public static class MatrixUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L1150">				setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, false, false, false);</span>
<span class="fc" id="L1151">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L1155">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L1156">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1160">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L1161">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1165">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L1166">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1170">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L1171">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1175">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L1176">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L1180">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L1181">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1185">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L1186">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1190">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L1191">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1195">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L1196">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1200">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L1201">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L1205">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L1206">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L1210">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L1211">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1215">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L1216">			}</span>
		}

<span class="fc" id="L1219">		@BenchmarkMode(Mode.AverageTime)</span>
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L1225">		public static class CsrDirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L1232">				final boolean directed = true;</span>
<span class="fc" id="L1233">				final boolean allowParallelEdges = true;</span>
<span class="fc" id="L1234">				final boolean allowSelfEdges = true;</span>
<span class="fc" id="L1235">				setup(args, g -&gt; {</span>
<span class="pc bpc" id="L1236" title="1 of 2 branches missed.">					assert g.isDirected() == directed;</span>
<span class="fc" id="L1237">					IndexGraphBuilder g1 = IndexGraphBuilder.directed();</span>
<span class="fc" id="L1238">					g1.addVertices(g.vertices());</span>
<span class="fc" id="L1239">					g1.addEdges(EdgeSet.allOf(g));</span>
<span class="fc" id="L1240">					IndexGraph g1Graph = g1.build();</span>
<span class="pc bpc" id="L1241" title="1 of 2 branches missed.">					assert g1Graph.isDirected() == directed;</span>
<span class="fc" id="L1242">					return g1Graph;</span>
				}, directed, allowParallelEdges, allowSelfEdges);
<span class="fc" id="L1244">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L1248">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L1249">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1253">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L1254">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1258">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L1259">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1263">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L1264">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1268">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L1269">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L1273">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L1274">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1278">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L1279">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1283">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L1284">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1288">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L1289">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1293">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L1294">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L1298">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L1299">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L1303">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L1304">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1308">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L1309">			}</span>
		}

<span class="fc" id="L1312">		@BenchmarkMode(Mode.AverageTime)</span>
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L1318">		public static class CsrUndirected extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L1325">				final boolean directed = false;</span>
<span class="fc" id="L1326">				final boolean allowParallelEdges = true;</span>
<span class="fc" id="L1327">				final boolean allowSelfEdges = true;</span>
<span class="fc" id="L1328">				setup(args, g -&gt; {</span>
<span class="pc bpc" id="L1329" title="1 of 2 branches missed.">					assert g.isDirected() == directed;</span>
<span class="fc" id="L1330">					IndexGraphBuilder g1 = IndexGraphBuilder.undirected();</span>
<span class="fc" id="L1331">					g1.addVertices(g.vertices());</span>
<span class="fc" id="L1332">					g1.addEdges(EdgeSet.allOf(g));</span>
<span class="fc" id="L1333">					IndexGraph g1Graph = g1.build();</span>
<span class="pc bpc" id="L1334" title="1 of 2 branches missed.">					assert g1Graph.isDirected() == directed;</span>
<span class="fc" id="L1335">					return g1Graph;</span>
				}, directed, allowParallelEdges, allowSelfEdges);
<span class="fc" id="L1337">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L1341">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L1342">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1346">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L1347">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1351">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L1352">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1356">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L1357">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1361">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L1362">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L1366">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L1367">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1371">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L1372">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1376">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L1377">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1381">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L1382">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1386">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L1387">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L1391">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L1392">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L1396">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L1397">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1401">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L1402">			}</span>
		}

<span class="fc" id="L1405">		@BenchmarkMode(Mode.AverageTime)</span>
		@OutputTimeUnit(TimeUnit.NANOSECONDS)
		@Warmup(iterations = 2, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Measurement(iterations = 3, time = 100, timeUnit = TimeUnit.MILLISECONDS)
		@Fork(value = 1, warmups = 0)
		@State(Scope.Benchmark)
<span class="fc" id="L1411">		public static class CsrDirectedReindexed extends GraphBench.EdgesRead {</span>

			@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=13000 |E|=50000&quot; })
			public String args;

			@Setup(Level.Trial)
			public void setup() {
<span class="fc" id="L1418">				final boolean directed = true;</span>
<span class="fc" id="L1419">				final boolean allowParallelEdges = true;</span>
<span class="fc" id="L1420">				final boolean allowSelfEdges = true;</span>
<span class="fc" id="L1421">				setup(args, g -&gt; {</span>
<span class="pc bpc" id="L1422" title="1 of 2 branches missed.">					assert g.isDirected() == directed;</span>
<span class="fc" id="L1423">					IndexGraphBuilder g1 = IndexGraphBuilder.directed();</span>
<span class="fc" id="L1424">					g1.addVertices(g.vertices());</span>
<span class="fc" id="L1425">					g1.addEdges(EdgeSet.allOf(g));</span>
<span class="fc" id="L1426">					IndexGraph g1Graph = g1.reIndexAndBuild(true, true).graph;</span>
<span class="pc bpc" id="L1427" title="1 of 2 branches missed.">					assert g1Graph.isDirected() == directed;</span>
<span class="fc" id="L1428">					return g1Graph;</span>
				}, directed, allowParallelEdges, allowSelfEdges);
<span class="fc" id="L1430">			}</span>

			@Benchmark
			public void benchOutEdges(Blackhole blackhole) {
<span class="fc" id="L1434">				super.benchOutEdges(blackhole);</span>
<span class="fc" id="L1435">			}</span>

			@Benchmark
			public void benchOutEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1439">				super.benchOutEdgesSize(blackhole);</span>
<span class="fc" id="L1440">			}</span>

			@Benchmark
			public void benchOutEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1444">				super.benchOutEdgesIteration(blackhole);</span>
<span class="fc" id="L1445">			}</span>

			@Benchmark
			public void benchOutEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1449">				super.benchOutEdgesSource(blackhole);</span>
<span class="fc" id="L1450">			}</span>

			@Benchmark
			public void benchOutEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1454">				super.benchOutEdgesTarget(blackhole);</span>
<span class="fc" id="L1455">			}</span>

			@Benchmark
			public void benchInEdges(Blackhole blackhole) {
<span class="fc" id="L1459">				super.benchInEdges(blackhole);</span>
<span class="fc" id="L1460">			}</span>

			@Benchmark
			public void benchInEdgesSize(Blackhole blackhole) {
<span class="fc" id="L1464">				super.benchInEdgesSize(blackhole);</span>
<span class="fc" id="L1465">			}</span>

			@Benchmark
			public void benchInEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1469">				super.benchInEdgesIteration(blackhole);</span>
<span class="fc" id="L1470">			}</span>

			@Benchmark
			public void benchInEdgesSource(Blackhole blackhole) {
<span class="fc" id="L1474">				super.benchInEdgesSource(blackhole);</span>
<span class="fc" id="L1475">			}</span>

			@Benchmark
			public void benchInEdgesTarget(Blackhole blackhole) {
<span class="fc" id="L1479">				super.benchInEdgesTarget(blackhole);</span>
<span class="fc" id="L1480">			}</span>

			@Benchmark
			public void benchGetEdge(Blackhole blackhole) {
<span class="fc" id="L1484">				super.benchGetEdge(blackhole);</span>
<span class="fc" id="L1485">			}</span>

			@Benchmark
			public void benchGetEdges(Blackhole blackhole) {
<span class="fc" id="L1489">				super.benchGetEdges(blackhole);</span>
<span class="fc" id="L1490">			}</span>

			@Benchmark
			public void benchGetEdgesIteration(Blackhole blackhole) {
<span class="fc" id="L1494">				super.benchGetEdgesIteration(blackhole);</span>
<span class="fc" id="L1495">			}</span>
		}

	}

<span class="fc" id="L1500">	public static class Remove {</span>

		IndexGraph g;
		int n, m;
		Random rand;

		void setup(String args, Function&lt;IndexGraph, IndexGraph&gt; graphImplementation, boolean directed,
				boolean allowParallelEdges, boolean allowSelfEdges) {
<span class="fc" id="L1508">			final long seed = 0x850a14ff3dad400cL;</span>
<span class="fc" id="L1509">			rand = new Random(seed);</span>
<span class="fc" id="L1510">			Map&lt;String, String&gt; argsMap = BenchUtils.parseArgsStr(args);</span>
<span class="fc" id="L1511">			n = Integer.parseInt(argsMap.get(&quot;|V|&quot;));</span>
<span class="fc" id="L1512">			m = Integer.parseInt(argsMap.get(&quot;|E|&quot;));</span>

<span class="fc" id="L1514">			g = IndexGraphFactory</span>
<span class="fc" id="L1515">					.newInstance(directed)</span>
<span class="fc" id="L1516">					.allowSelfEdges(allowSelfEdges)</span>
<span class="fc" id="L1517">					.allowParallelEdges(allowParallelEdges)</span>
<span class="fc" id="L1518">					.newGraph();</span>
<span class="fc" id="L1519">			g.addVertices(range(n));</span>
<span class="fc bfc" id="L1520" title="All 2 branches covered.">			LongSet existingEdges = allowParallelEdges ? null : new LongOpenHashSet();</span>
<span class="fc bfc" id="L1521" title="All 2 branches covered.">			for (int e = 0; e &lt; m;) {</span>
<span class="fc" id="L1522">				int u = Graphs.randVertex(g, rand), v = Graphs.randVertex(g, rand);</span>
<span class="pc bpc" id="L1523" title="1 of 4 branches missed.">				if (!allowSelfEdges &amp;&amp; u == v)</span>
<span class="fc" id="L1524">					continue;</span>
<span class="fc bfc" id="L1525" title="All 2 branches covered.">				if (!allowParallelEdges) {</span>
<span class="fc" id="L1526">					int u1 = u, v1 = v;</span>
<span class="fc bfc" id="L1527" title="All 4 branches covered.">					if (!directed &amp;&amp; u1 &lt; v1) {</span>
<span class="fc" id="L1528">						int tmp = u1;</span>
<span class="fc" id="L1529">						u1 = v1;</span>
<span class="fc" id="L1530">						v1 = tmp;</span>
					}
<span class="fc" id="L1532">					long key = IntPair.of(u1, v1);</span>
<span class="fc bfc" id="L1533" title="All 2 branches covered.">					if (!existingEdges.add(key))</span>
<span class="fc" id="L1534">						continue;</span>
				}
<span class="fc" id="L1536">				g.addEdge(u, v);</span>
<span class="fc" id="L1537">				e++;</span>
<span class="fc" id="L1538">			}</span>
<span class="fc" id="L1539">			g = graphImplementation.apply(g);</span>
<span class="fc" id="L1540">		}</span>

		void setup(String args, Supplier&lt;IndexGraph&gt; graphImplementation, boolean directed, boolean allowParallelEdges,
				boolean allowSelfEdges) {
<span class="fc" id="L1544">			setup(args, g -&gt; {</span>
<span class="pc bpc" id="L1545" title="1 of 2 branches missed.">				assert g.isDirected() == directed;</span>
<span class="fc" id="L1546">				IndexGraph g1 = graphImplementation.get();</span>
<span class="pc bpc" id="L1547" title="1 of 2 branches missed.">				assert g1.isDirected() == directed;</span>
<span class="fc" id="L1548">				g1.addVertices(g.vertices());</span>
<span class="fc" id="L1549">				g1.addEdges(EdgeSet.allOf(g));</span>
<span class="fc" id="L1550">				return g1;</span>
			}, directed, allowParallelEdges, allowSelfEdges);
<span class="fc" id="L1552">		}</span>

		void restoreGraph() {
<span class="fc" id="L1555">			final boolean allowSelfEdges = g.isAllowSelfEdges();</span>
<span class="fc" id="L1556">			final boolean allowParallelEdges = g.isAllowParallelEdges();</span>
<span class="pc bpc" id="L1557" title="1 of 2 branches missed.">			while (g.vertices().size() &lt; n)</span>
<span class="nc" id="L1558">				g.addVertexInt();</span>
<span class="pc bpc" id="L1559" title="1 of 2 branches missed.">			while (g.edges().size() &lt; m) {</span>
<span class="nc" id="L1560">				int u = Graphs.randVertex(g, rand), v = Graphs.randVertex(g, rand);</span>
<span class="nc bnc" id="L1561" title="All 4 branches missed.">				if (!allowSelfEdges &amp;&amp; u == v)</span>
<span class="nc" id="L1562">					continue;</span>
<span class="nc bnc" id="L1563" title="All 4 branches missed.">				if (!allowParallelEdges &amp;&amp; g.containsEdge(u, v))</span>
<span class="nc" id="L1564">					continue;</span>
<span class="nc" id="L1565">				g.addEdge(u, v);</span>
<span class="nc" id="L1566">			}</span>
<span class="fc" id="L1567">		}</span>

<span class="fc" id="L1569">		public static class Edge extends Remove {</span>

			private IntIterator removeEIter;

			private static final int OperationsPerInvocation = 100;

			@Override
			void setup(String args, Function&lt;IndexGraph, IndexGraph&gt; graphImplementation, boolean directed,
					boolean allowParallelEdges, boolean allowSelfEdges) {
<span class="fc" id="L1578">				super.setup(args, graphImplementation, directed, allowParallelEdges, allowSelfEdges);</span>

<span class="pc bpc" id="L1580" title="1 of 2 branches missed.">				assert m &gt; OperationsPerInvocation;</span>
<span class="fc" id="L1581">				int[] removeEdges = TestUtils.randArray(m * 16, 0, m - OperationsPerInvocation, rand.nextLong());</span>
<span class="fc" id="L1582">				removeEIter = circularIterator(Fastutil.list(removeEdges));</span>
<span class="fc" id="L1583">			}</span>

			private void bench(Blackhole blackhole) {
<span class="fc bfc" id="L1586" title="All 2 branches covered.">				for (int o = 0; o &lt; OperationsPerInvocation; o++) {</span>
<span class="fc" id="L1587">					int e = removeEIter.nextInt();</span>
<span class="fc" id="L1588">					g.removeEdge(e);</span>
<span class="fc" id="L1589">					blackhole.consume(e);</span>
<span class="fc" id="L1590">					blackhole.consume(g);</span>
				}
<span class="fc" id="L1592">			}</span>

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1600">			public static class ArrayDirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1607">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, true, true, false);</span>
<span class="fc" id="L1608">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1613">					super.restoreGraph();</span>
<span class="fc" id="L1614">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1619">					super.bench(blackhole);</span>
<span class="fc" id="L1620">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1629">			public static class ArrayUndirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1636">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, false, true,</span>
							false);
<span class="fc" id="L1638">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1643">					super.restoreGraph();</span>
<span class="fc" id="L1644">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1649">					super.bench(blackhole);</span>
<span class="fc" id="L1650">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1659">			public static class LinkedDirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1666">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, true, true,</span>
							false);
<span class="fc" id="L1668">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1673">					super.restoreGraph();</span>
<span class="fc" id="L1674">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1679">					super.bench(blackhole);</span>
<span class="fc" id="L1680">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1689">			public static class LinkedUndirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1696">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, false, true,</span>
							false);
<span class="fc" id="L1698">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1703">					super.restoreGraph();</span>
<span class="fc" id="L1704">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1709">					super.bench(blackhole);</span>
<span class="fc" id="L1710">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1719">			public static class LinkedPtrDirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1726">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, true, true,</span>
							false);
<span class="fc" id="L1728">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1733">					super.restoreGraph();</span>
<span class="fc" id="L1734">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1739">					super.bench(blackhole);</span>
<span class="fc" id="L1740">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1749">			public static class LinkedPtrUndirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1756">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, false,</span>
							true, false);
<span class="fc" id="L1758">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1763">					super.restoreGraph();</span>
<span class="fc" id="L1764">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1769">					super.bench(blackhole);</span>
<span class="fc" id="L1770">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1779">			public static class HashtableDirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1786">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, true, false,</span>
							false);
<span class="fc" id="L1788">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1793">					super.restoreGraph();</span>
<span class="fc" id="L1794">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1799">					super.bench(blackhole);</span>
<span class="fc" id="L1800">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1809">			public static class HashtableUndirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1816">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, false, false,</span>
							false);
<span class="fc" id="L1818">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1823">					super.restoreGraph();</span>
<span class="fc" id="L1824">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1829">					super.bench(blackhole);</span>
<span class="fc" id="L1830">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1839">			public static class HashtableMultiDirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1846">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;hashtable-multi&quot;)::newGraph, true,</span>
							false, false);
<span class="fc" id="L1848">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1853">					super.restoreGraph();</span>
<span class="fc" id="L1854">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1859">					super.bench(blackhole);</span>
<span class="fc" id="L1860">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1869">			public static class HashtableMultiUndirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1876">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;hashtable-multi&quot;)::newGraph, false,</span>
							false, false);
<span class="fc" id="L1878">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1883">					super.restoreGraph();</span>
<span class="fc" id="L1884">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1889">					super.bench(blackhole);</span>
<span class="fc" id="L1890">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1899">			public static class MatrixDirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1906">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, true, false, false);</span>
<span class="fc" id="L1907">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1912">					super.restoreGraph();</span>
<span class="fc" id="L1913">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1918">					super.bench(blackhole);</span>
<span class="fc" id="L1919">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1928">			public static class MatrixUndirected extends GraphBench.Remove.Edge {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1935">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, false, false,</span>
							false);
<span class="fc" id="L1937">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1942">					super.restoreGraph();</span>
<span class="fc" id="L1943">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L1948">					super.bench(blackhole);</span>
<span class="fc" id="L1949">				}</span>
			}

		}

<span class="fc" id="L1954">		public static class Vertex extends Remove {</span>

			private IntIterator removeVIter;

			private static final int OperationsPerInvocation = 50;

			@Override
			void setup(String args, Function&lt;IndexGraph, IndexGraph&gt; graphImplementation, boolean directed,
					boolean allowParallelEdges, boolean allowSelfEdges) {
<span class="fc" id="L1963">				super.setup(args, graphImplementation, directed, allowParallelEdges, allowSelfEdges);</span>

<span class="pc bpc" id="L1965" title="1 of 2 branches missed.">				assert n &gt; OperationsPerInvocation;</span>
<span class="fc" id="L1966">				int[] removeVertices = TestUtils.randArray(n * 16, 0, n - OperationsPerInvocation, rand.nextLong());</span>
<span class="fc" id="L1967">				removeVIter = circularIterator(Fastutil.list(removeVertices));</span>
<span class="fc" id="L1968">			}</span>

			private void bench(Blackhole blackhole) {
<span class="fc bfc" id="L1971" title="All 2 branches covered.">				for (int o = 0; o &lt; OperationsPerInvocation; o++) {</span>
<span class="fc" id="L1972">					int v = removeVIter.nextInt();</span>
<span class="fc" id="L1973">					g.removeEdge(v);</span>
<span class="fc" id="L1974">					blackhole.consume(v);</span>
<span class="fc" id="L1975">					blackhole.consume(g);</span>
				}
<span class="fc" id="L1977">			}</span>

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L1985">			public static class ArrayDirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L1992">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, true, true, false);</span>
<span class="fc" id="L1993">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L1998">					super.restoreGraph();</span>
<span class="fc" id="L1999">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2004">					super.bench(blackhole);</span>
<span class="fc" id="L2005">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2014">			public static class ArrayUndirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2021">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;array&quot;)::newGraph, false, true,</span>
							false);
<span class="fc" id="L2023">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2028">					super.restoreGraph();</span>

<span class="fc" id="L2030">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2035">					super.bench(blackhole);</span>
<span class="fc" id="L2036">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2045">			public static class LinkedDirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2052">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, true, true,</span>
							false);
<span class="fc" id="L2054">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2059">					super.restoreGraph();</span>

<span class="fc" id="L2061">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2066">					super.bench(blackhole);</span>
<span class="fc" id="L2067">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2076">			public static class LinkedUndirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2083">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;linked-list&quot;)::newGraph, false, true,</span>
							false);
<span class="fc" id="L2085">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2090">					super.restoreGraph();</span>

<span class="fc" id="L2092">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2097">					super.bench(blackhole);</span>
<span class="fc" id="L2098">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2107">			public static class LinkedPtrDirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2114">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, true, true,</span>
							false);
<span class="fc" id="L2116">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2121">					super.restoreGraph();</span>

<span class="fc" id="L2123">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2128">					super.bench(blackhole);</span>
<span class="fc" id="L2129">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2138">			public static class LinkedPtrUndirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2145">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;linked-list-ptr&quot;)::newGraph, false,</span>
							true, false);
<span class="fc" id="L2147">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2152">					super.restoreGraph();</span>

<span class="fc" id="L2154">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2159">					super.bench(blackhole);</span>
<span class="fc" id="L2160">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2169">			public static class HashtableDirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2176">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, true, false,</span>
							false);
<span class="fc" id="L2178">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2183">					super.restoreGraph();</span>

<span class="fc" id="L2185">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2190">					super.bench(blackhole);</span>
<span class="fc" id="L2191">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2200">			public static class HashtableUndirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2207">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;hashtable&quot;)::newGraph, false, false,</span>
							false);
<span class="fc" id="L2209">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2214">					super.restoreGraph();</span>

<span class="fc" id="L2216">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2221">					super.bench(blackhole);</span>
<span class="fc" id="L2222">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2231">			public static class HashtableMultiDirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2238">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;hashtable-multi&quot;)::newGraph, true,</span>
							false, false);
<span class="fc" id="L2240">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2245">					super.restoreGraph();</span>

<span class="fc" id="L2247">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2252">					super.bench(blackhole);</span>
<span class="fc" id="L2253">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2262">			public static class HashtableMultiUndirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2269">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;hashtable-multi&quot;)::newGraph, false,</span>
							false, false);
<span class="fc" id="L2271">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2276">					super.restoreGraph();</span>

<span class="fc" id="L2278">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2283">					super.bench(blackhole);</span>
<span class="fc" id="L2284">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2293">			public static class MatrixDirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2300">					setup(args, IndexGraphFactory.directed().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, true, false, false);</span>
<span class="fc" id="L2301">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2306">					super.restoreGraph();</span>

<span class="fc" id="L2308">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Vertex.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2313">					super.bench(blackhole);</span>
<span class="fc" id="L2314">				}</span>
			}

			@BenchmarkMode(Mode.AverageTime)
			@OutputTimeUnit(TimeUnit.NANOSECONDS)
			@Warmup(iterations = 2, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Measurement(iterations = 3, time = 300, timeUnit = TimeUnit.MILLISECONDS)
			@Fork(value = 1, warmups = 0)
			@State(Scope.Benchmark)
<span class="fc" id="L2323">			public static class MatrixUndirected extends GraphBench.Remove.Vertex {</span>

				@Param({ &quot;|V|=100 |E|=300&quot;, &quot;|V|=100 |E|=3000&quot;, &quot;|V|=1300 |E|=50000&quot; })
				public String args;

				@Setup(Level.Trial)
				public void setup() {
<span class="fc" id="L2330">					setup(args, IndexGraphFactory.undirected().setOption(&quot;impl&quot;, &quot;matrix&quot;)::newGraph, false, false,</span>
							false);
<span class="fc" id="L2332">				}</span>

				@Override
				@Setup(Level.Invocation)
				public void restoreGraph() {
<span class="fc" id="L2337">					super.restoreGraph();</span>

<span class="fc" id="L2339">				}</span>

				@Benchmark
				@OperationsPerInvocation(GraphBench.Remove.Edge.OperationsPerInvocation)
				public void bench(Blackhole blackhole) {
<span class="fc" id="L2344">					super.bench(blackhole);</span>
<span class="fc" id="L2345">				}</span>
			}

		}
	}

	static IntIterator circularIterator(IntIterable iterable) {
<span class="fc" id="L2352">		return new IntIterator() {</span>
<span class="fc" id="L2353">			IntIterator it = iterable.iterator();</span>

			@Override
			public boolean hasNext() {
<span class="nc" id="L2357">				return true;</span>
			}

			@Override
			public int nextInt() {
<span class="fc" id="L2362">				int res = it.nextInt();</span>
<span class="pc bpc" id="L2363" title="1 of 2 branches missed.">				if (!it.hasNext())</span>
<span class="nc" id="L2364">					it = iterable.iterator();</span>
<span class="fc" id="L2365">				return res;</span>
			}
		};
	}

	static LongIterator circularIterator(LongIterable iterable) {
<span class="fc" id="L2371">		return new LongIterator() {</span>
<span class="fc" id="L2372">			LongIterator it = iterable.iterator();</span>

			@Override
			public boolean hasNext() {
<span class="nc" id="L2376">				return true;</span>
			}

			@Override
			public long nextLong() {
<span class="fc" id="L2381">				long res = it.nextLong();</span>
<span class="pc bpc" id="L2382" title="1 of 2 branches missed.">				if (!it.hasNext())</span>
<span class="nc" id="L2383">					it = iterable.iterator();</span>
<span class="fc" id="L2384">				return res;</span>
			}
		};
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>