<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GraphsTestUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JGAlgo - Benchmarks</a> &gt; <a href="index.source.html" class="el_package">com.jgalgo.bench.util</a> &gt; <span class="el_source">GraphsTestUtils.java</span></div><h1>GraphsTestUtils.java</h1><pre class="source lang-java linenums">/*-
 * Copyright 2023 Barak Ugav
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.jgalgo.bench.util;

import java.util.BitSet;
import java.util.Random;
import com.jgalgo.graph.Graph;
import com.jgalgo.graph.GraphFactory;
import com.jgalgo.graph.IndexGraphBuilder;
import com.jgalgo.graph.Weights;
import com.jgalgo.graph.WeightsDouble;
import com.jgalgo.graph.WeightsInt;
import it.unimi.dsi.fastutil.booleans.Boolean2ObjectFunction;

public class GraphsTestUtils extends TestUtils {

	private GraphsTestUtils() {}

	public static Boolean2ObjectFunction&lt;Graph&gt; defaultGraphImpl() {
<span class="fc" id="L34">		return direct -&gt; GraphFactory.newUndirected().setDirected(direct).newGraph();</span>
	}

	public static Graph randTree(int n, long seed) {
<span class="fc" id="L38">		return new RandomGraphBuilder(seed).n(n).m(n - 1).directed(false).selfEdges(false).cycles(false).connected(true)</span>
<span class="fc" id="L39">				.build();</span>
	}

	public static Graph randForest(int n, int m, long seed) {
<span class="nc" id="L43">		return new RandomGraphBuilder(seed).n(n).m(m).directed(false).selfEdges(false).cycles(false).connected(false)</span>
<span class="nc" id="L44">				.build();</span>
	}

	public static WeightsDouble assignRandWeights(Graph g, long seed) {
<span class="nc" id="L48">		return assignRandWeights(g, 1.0, 100.0, seed);</span>
	}

	public static WeightsDouble assignRandWeights(Graph g, double minWeight, double maxWeight, long seed) {
<span class="nc bnc" id="L52" title="All 2 branches missed.">		if (minWeight &gt;= maxWeight)</span>
<span class="nc" id="L53">			throw new IllegalArgumentException();</span>

<span class="nc" id="L55">		Random rand = new Random(seed);</span>
<span class="nc" id="L56">		WeightsDouble weight = g.addEdgesWeights(&quot;weight&quot;, double.class);</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">		for (int e : g.edges())</span>
<span class="nc" id="L58">			weight.set(e, nextDouble(rand, minWeight, maxWeight));</span>
<span class="nc" id="L59">		return weight;</span>
	}

	public static WeightsInt assignRandWeightsIntPos(Graph g, long seed) {
<span class="fc" id="L63">		int m = g.edges().size();</span>
<span class="fc" id="L64">		int minWeight = 1;</span>
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">		int maxWeight = m &lt; 50 ? 100 : m * 2 + 2;</span>
<span class="fc" id="L66">		return assignRandWeightsInt(g, minWeight, maxWeight, seed);</span>
	}

	public static WeightsInt assignRandWeightsIntNeg(Graph g, long seed) {
<span class="fc" id="L70">		int m = g.edges().size();</span>
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">		int maxWeight = m &lt; 50 ? 100 : m * 2 + 2;</span>
<span class="fc" id="L72">		return assignRandWeightsInt(g, -maxWeight / 8, maxWeight, seed);</span>
	}

	public static WeightsInt assignRandWeightsInt(Graph g, int minWeight, int maxWeight, long seed) {
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">		if (minWeight &gt;= maxWeight)</span>
<span class="nc" id="L77">			throw new IllegalArgumentException();</span>

<span class="fc" id="L79">		Random rand = new Random(seed);</span>
<span class="fc" id="L80">		WeightsInt weight = Weights.createExternalEdgesWeights(g, int.class);</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">		for (int e : g.edges())</span>
<span class="fc" id="L82">			weight.set(e, rand.nextInt(maxWeight - minWeight) + minWeight);</span>
<span class="fc" id="L83">		return weight;</span>
	}

	public static Graph randGraph(int n, int m, long seed) {
<span class="fc" id="L87">		return new RandomGraphBuilder(seed).n(n).m(m).directed(false).parallelEdges(false).selfEdges(false).cycles(true)</span>
<span class="fc" id="L88">				.connected(false).build();</span>
	}

	public static Graph randGraphBipartite(int sn, int tn, int m, long seed) {
<span class="fc" id="L92">		return new RandomGraphBuilder(seed).sn(sn).tn(tn).m(m).directed(false).bipartite(true).parallelEdges(false)</span>
<span class="fc" id="L93">				.selfEdges(false).cycles(true).connected(false).build();</span>
	}

	public static Graph randomGraphGnp(int n, boolean directed, long seed) {
<span class="fc" id="L97">		final double p = 0.1;</span>
<span class="fc" id="L98">		return randomGraphGnp(n, p, directed, seed);</span>
	}

	public static Graph randomGraphGnp(int n, double p, boolean directed, long seed) {
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">		if (n &lt; 0)</span>
<span class="nc" id="L103">			throw new IllegalArgumentException();</span>
<span class="pc bpc" id="L104" title="2 of 4 branches missed.">		if (!(0 &lt;= p &amp;&amp; p &lt;= 1))</span>
<span class="nc" id="L105">			throw new IllegalArgumentException();</span>

<span class="fc bfc" id="L107" title="All 2 branches covered.">		IndexGraphBuilder builder = directed ? IndexGraphBuilder.newDirected() : IndexGraphBuilder.newUndirected();</span>
<span class="fc" id="L108">		builder.expectedVerticesNum(n);</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">		for (int i = 0; i &lt; n; i++)</span>
<span class="fc" id="L110">			builder.addVertex();</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">		if (p &gt; 0) {</span>
<span class="fc" id="L112">			Random rand = new Random(seed);</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">			if (directed) {</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">				for (int u = 0; u &lt; n; u++)</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">					for (int v = 0; v &lt; n; v++)</span>
<span class="fc bfc" id="L116" title="All 4 branches covered.">						if (u != v &amp;&amp; rand.nextDouble() &lt;= p)</span>
<span class="fc" id="L117">							builder.addEdge(u, v);</span>
			} else {
<span class="fc bfc" id="L119" title="All 2 branches covered.">				for (int u = 0; u &lt; n; u++)</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">					for (int v = u + 1; v &lt; n; v++)</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">						if (rand.nextDouble() &lt;= p)</span>
<span class="fc" id="L122">							builder.addEdge(u, v);</span>
			}
		}

<span class="fc" id="L126">		return builder.reIndexAndBuild(true, true).graph();</span>
	}

	public static Graph randomGraphBarabasiAlbert(int n, boolean directed, long seed) {
<span class="fc" id="L130">		final int nInit = 20;</span>
<span class="fc" id="L131">		final int m = 10;</span>
<span class="fc" id="L132">		return randomGraphBarabasiAlbert(n, nInit, m, directed, seed);</span>
	}

	public static Graph randomGraphBarabasiAlbert(int n, int nInit, int m, boolean directed, long seed) {
<span class="pc bpc" id="L136" title="2 of 4 branches missed.">		if (nInit &lt;= 0 || nInit &gt; n)</span>
<span class="nc" id="L137">			throw new IllegalArgumentException();</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">		if (m &gt; nInit)</span>
<span class="nc" id="L139">			throw new IllegalArgumentException();</span>

<span class="fc" id="L141">		int[] endpoints = new int[(nInit * (nInit - 1) / 2 + (n - nInit) * m) * 2];</span>
<span class="fc" id="L142">		int edgeNum = 0;</span>

		/* start with a complete graph of size nInit */
<span class="fc bfc" id="L145" title="All 2 branches covered.">		for (int u = 0; u &lt; nInit; u++) {</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">			for (int v = u + 1; v &lt; nInit; v++) {</span>
<span class="fc" id="L147">				int e = edgeNum++;</span>
<span class="fc" id="L148">				endpoints[e * 2 + 0] = u;</span>
<span class="fc" id="L149">				endpoints[e * 2 + 1] = v;</span>
			}
		}

		/* add n-nInit vertices, each with m edges */
<span class="fc" id="L154">		Random rand = new Random(seed);</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">		for (int vNum = nInit; vNum &lt; n; vNum++) {</span>
<span class="fc" id="L156">			final int edgeNumAtStart = edgeNum;</span>
<span class="fc" id="L157">			final int u = vNum;</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">			for (int i = 0; i &lt; m; i++) {</span>
				/* by sampling from the current endpoints, we sample a vertex with prob of its degree */
<span class="fc" id="L160">				int v = endpoints[rand.nextInt(edgeNumAtStart * 2)];</span>
<span class="fc" id="L161">				int e = edgeNum++;</span>
<span class="fc" id="L162">				endpoints[e * 2 + 0] = u;</span>
<span class="fc" id="L163">				endpoints[e * 2 + 1] = v;</span>
			}
		}

<span class="fc bfc" id="L167" title="All 2 branches covered.">		IndexGraphBuilder builder = directed ? IndexGraphBuilder.newDirected() : IndexGraphBuilder.newUndirected();</span>
<span class="fc" id="L168">		builder.expectedVerticesNum(n);</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">		for (int i = 0; i &lt; n; i++)</span>
<span class="fc" id="L170">			builder.addVertex();</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">		for (int e = 0; e &lt; edgeNum; e++) {</span>
<span class="fc" id="L172">			int u = endpoints[e * 2 + 0];</span>
<span class="fc" id="L173">			int v = endpoints[e * 2 + 1];</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">			if (rand.nextBoolean()) {</span>
<span class="fc" id="L175">				int tmp = u;</span>
<span class="fc" id="L176">				u = v;</span>
<span class="fc" id="L177">				v = tmp;</span>
			}
<span class="fc" id="L179">			builder.addEdge(u, v);</span>
		}
<span class="fc" id="L181">		return builder.reIndexAndBuild(true, true).graph();</span>
	}

	public static Graph randomGraphRecursiveMatrix(int n, int m, boolean directed, long seed) {
<span class="fc bfc" id="L185" title="All 2 branches covered.">		if (directed) {</span>
<span class="fc" id="L186">			final double a = 0.57;</span>
<span class="fc" id="L187">			final double b = 0.21;</span>
<span class="fc" id="L188">			final double c = 0.17;</span>
<span class="fc" id="L189">			final double d = 0.05;</span>
<span class="fc" id="L190">			return randomGraphRecursiveMatrix(n, m, a, b, c, d, true, seed);</span>
		} else {
<span class="fc" id="L192">			final double a = 0.57;</span>
<span class="fc" id="L193">			final double b = 0.19;</span>
<span class="fc" id="L194">			final double c = 0.19;</span>
<span class="fc" id="L195">			final double d = 0.05;</span>
<span class="fc" id="L196">			return randomGraphRecursiveMatrix(n, m, a, b, c, d, false, seed);</span>
		}
	}

	public static Graph randomGraphRecursiveMatrix(int n, int m, double a, double b, double c, double d,
			boolean directed, long seed) {
<span class="pc bpc" id="L202" title="2 of 4 branches missed.">		if (n &lt;= 0 || m &lt; 0)</span>
<span class="nc" id="L203">			throw new IllegalArgumentException();</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">		if (m &gt; 0.75 * n * (n - 1))</span>
<span class="nc" id="L205">			throw new IllegalArgumentException(</span>
					&quot;too many edges for random sampling (max=&quot; + (int) (0.75 * n * (n - 1)) + &quot;)&quot;);
<span class="pc bpc" id="L207" title="4 of 8 branches missed.">		if (a &lt; 0 || b &lt; 0 || c &lt; 0 || d &lt; 0)</span>
<span class="nc" id="L208">			throw new IllegalArgumentException();</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">		if (a + b + c + d != 1)</span>
<span class="nc" id="L210">			throw new IllegalArgumentException();</span>

<span class="fc" id="L212">		final double p1 = a;</span>
<span class="fc" id="L213">		final double p2 = a + b;</span>
<span class="fc" id="L214">		final double p3 = a + b + c;</span>
<span class="fc" id="L215">		final double p4 = a + b + c + d;</span>

<span class="fc" id="L217">		final int depth = nextPowerOf2(n);</span>
<span class="fc" id="L218">		final int N = 1 &lt;&lt; depth;</span>
<span class="fc" id="L219">		BitSet edges = new BitSet(N * N);</span>

<span class="fc" id="L221">		Random rand = new Random(seed);</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">		for (int edgeNum = 0; edgeNum &lt; m;) {</span>
<span class="fc" id="L223">			int u = 0, v = 0;</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">			for (int s = depth; s &gt; 0; s--) {</span>
<span class="fc" id="L225">				double p = rand.nextDouble();</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">				if (p &lt; p1) {</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">				} else if (p &lt; p2) {</span>
<span class="fc" id="L228">					v += 1 &lt;&lt; (s - 1);</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">				} else if (p &lt; p3) {</span>
<span class="fc" id="L230">					u += 1 &lt;&lt; (s - 1);</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">				} else if (p &lt; p4) {</span>
<span class="fc" id="L232">					u += 1 &lt;&lt; (s - 1);</span>
<span class="fc" id="L233">					v += 1 &lt;&lt; (s - 1);</span>
				} else {
<span class="nc" id="L235">					throw new AssertionError();</span>
				}
			}
<span class="fc bfc" id="L238" title="All 2 branches covered.">			if (edges.get(u * N + v))</span>
<span class="fc" id="L239">				continue;</span>
<span class="fc" id="L240">			edges.set(u * N + v);</span>
<span class="fc" id="L241">			edgeNum++;</span>
<span class="fc" id="L242">		}</span>

<span class="fc bfc" id="L244" title="All 2 branches covered.">		IndexGraphBuilder builder = directed ? IndexGraphBuilder.newDirected() : IndexGraphBuilder.newUndirected();</span>
<span class="fc" id="L245">		builder.expectedVerticesNum(n);</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">		for (int i = 0; i &lt; n; i++)</span>
<span class="fc" id="L247">			builder.addVertex();</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">		if (directed) {</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">			for (int u = 0; u &lt; n; u++)</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">				for (int v = 0; v &lt; n; v++)</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">					if (edges.get(u * N + v))</span>
<span class="fc" id="L252">						builder.addEdge(u, v);</span>
		} else {
<span class="fc bfc" id="L254" title="All 2 branches covered.">			for (int u = 0; u &lt; n; u++)</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">				for (int v = u; v &lt; n; v++)</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">					if (edges.get(u * N + v))</span>
<span class="fc" id="L257">						builder.addEdge(u, v);</span>
		}
<span class="fc" id="L259">		return builder.reIndexAndBuild(true, true).graph();</span>
	}

	private static int nextPowerOf2(int x) {
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">		return x == 0 ? 0 : 32 - Integer.numberOfLeadingZeros(x - 1);</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>